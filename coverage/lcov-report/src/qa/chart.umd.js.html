
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for src/qa/chart.umd.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../prettify.css" />
    <link rel="stylesheet" href="../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../index.html">All files</a> / <a href="index.html">src/qa</a> chart.umd.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/5084</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/4585</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/1371</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/2</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >"object"==typeof exports&amp;&amp;"undefined"!=typeof module?module.exports=e():"function"==typeof define&amp;&amp;define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).Chart=e()}</span>(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(){"use strict";var t=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,<span class="fstat-no" title="function not covered" >ge</span>t Colors(){<span class="cstat-no" title="statement not covered" >return Jo}</span>,<span class="fstat-no" title="function not covered" >ge</span>t Decimation(){<span class="cstat-no" title="statement not covered" >return ta}</span>,<span class="fstat-no" title="function not covered" >ge</span>t Filler(){<span class="cstat-no" title="statement not covered" >return ba}</span>,<span class="fstat-no" title="function not covered" >ge</span>t Legend(){<span class="cstat-no" title="statement not covered" >return Ma}</span>,<span class="fstat-no" title="function not covered" >ge</span>t SubTitle(){<span class="cstat-no" title="statement not covered" >return Pa}</span>,<span class="fstat-no" title="function not covered" >ge</span>t Title(){<span class="cstat-no" title="statement not covered" >return ka}</span>,<span class="fstat-no" title="function not covered" >ge</span>t Tooltip(){<span class="cstat-no" title="statement not covered" >return Na}</span>});</span>function <span class="fstat-no" title="function not covered" >e(</span>){}const i=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >()</span>=&gt;{let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t++}</span></span>)();</span>function <span class="fstat-no" title="function not covered" >s(</span>t){<span class="cstat-no" title="statement not covered" >return null==t}</span>function <span class="fstat-no" title="function not covered" >n(</span>t){<span class="cstat-no" title="statement not covered" >if(Array.isArray&amp;&amp;Array.isArray(t))<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >Object.prototype.toString.call(t);<span class="cstat-no" title="statement not covered" ></span>return"[object"===e.slice(0,7)&amp;&amp;"Array]"===e.slice(-6)}</span>function <span class="fstat-no" title="function not covered" >o(</span>t){<span class="cstat-no" title="statement not covered" >return null!==t&amp;&amp;"[object Object]"===Object.prototype.toString.call(t)}</span>function <span class="fstat-no" title="function not covered" >a(</span>t){<span class="cstat-no" title="statement not covered" >return("number"==typeof t||t instanceof Number)&amp;&amp;isFinite(+t)}</span>function <span class="fstat-no" title="function not covered" >r(</span>t,e){<span class="cstat-no" title="statement not covered" >return a(t)?t:e}</span>function <span class="fstat-no" title="function not covered" >l(</span>t,e){<span class="cstat-no" title="statement not covered" >return void 0===t?e:t}</span>const h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >"string"==typeof t&amp;&amp;t.endsWith("%")?parseFloat(t)/100:+t/e,</span></span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >"string"==typeof t&amp;&amp;t.endsWith("%")?parseFloat(t)/100*e:+t;</span></span>function <span class="fstat-no" title="function not covered" >d(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;"function"==typeof t.call)<span class="cstat-no" title="statement not covered" >return t.apply(i,e)}</span></span>function <span class="fstat-no" title="function not covered" >u(</span>t,e,i,s){let a,r,l;<span class="cstat-no" title="statement not covered" >if(n(t))<span class="cstat-no" title="statement not covered" >if(r=t.length,s)<span class="cstat-no" title="statement not covered" >for(a=r-1;a&gt;=0;a--)<span class="cstat-no" title="statement not covered" >e.call(i,t[a],a);e</span></span>lse <span class="cstat-no" title="statement not covered" >for(a=0;a&lt;r;a++)<span class="cstat-no" title="statement not covered" >e.call(i,t[a],a);e</span></span></span>lse <span class="cstat-no" title="statement not covered" >if(o(t))<span class="cstat-no" title="statement not covered" >for(l=Object.keys(t),r=l.length,a=0;a&lt;r;a++)<span class="cstat-no" title="statement not covered" >e.call(i,t[l[a]],l[a])}</span></span></span></span>function <span class="fstat-no" title="function not covered" >f(</span>t,e){let i,s,n,o;<span class="cstat-no" title="statement not covered" >if(!t||!e||t.length!==e.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(i=0,s=t.length;i&lt;s;++i)<span class="cstat-no" title="statement not covered" >if(n=t[i],o=e[i],n.datasetIndex!==o.datasetIndex||n.index!==o.index)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>function <span class="fstat-no" title="function not covered" >g(</span>t){<span class="cstat-no" title="statement not covered" >if(n(t))<span class="cstat-no" title="statement not covered" >return t.map(g);<span class="cstat-no" title="statement not covered" >i</span></span>f(o(t)){const e=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>i=<span class="cstat-no" title="statement not covered" >Object.keys(t),</span>s=<span class="cstat-no" title="statement not covered" >i.length;</span>let n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;n&lt;s;++n)<span class="cstat-no" title="statement not covered" >e[i[n]]=g(t[i[n]]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >p(</span>t){<span class="cstat-no" title="statement not covered" >return-1===["__proto__","prototype","constructor"].indexOf(t)}</span>function <span class="fstat-no" title="function not covered" >m(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >if(!p(t))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >e[t],</span>a=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>o(n)&amp;&amp;o(a)?x(n,a,s):e[t]=g(a)}</span>function <span class="fstat-no" title="function not covered" >x(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >n(e)?e:[e],</span>a=<span class="cstat-no" title="statement not covered" >s.length;<span class="cstat-no" title="statement not covered" ></span>if(!o(t))<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >(i=i||{}).merger||m;</span>let l;<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;a;++e){<span class="cstat-no" title="statement not covered" >if(l=s[e],!o(l))<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >Object.keys(l);<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >n.length;</span>e&lt;s;++e)<span class="cstat-no" title="statement not covered" >r(n[e],t,l,i)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >b(</span>t,e){<span class="cstat-no" title="statement not covered" >return x(t,e,{merger:_})}</span>function <span class="fstat-no" title="function not covered" >_(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(!p(t))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >e[t],</span>n=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>o(s)&amp;&amp;o(n)?b(s,n):Object.prototype.hasOwnProperty.call(e,t)||(e[t]=g(n))}</span>const y=<span class="cstat-no" title="statement not covered" >{"":<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t,</span>x:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.x,</span>y:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.y}</span>;</span>function <span class="fstat-no" title="function not covered" >v(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.split("."),</span>i=<span class="cstat-no" title="statement not covered" >[];</span>let s=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(const t of e)<span class="cstat-no" title="statement not covered" >s+=t,s.endsWith("\\")?s=s.slice(0,-1)+".":(i.push(s),s="");<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >M(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >y[e]||(y[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >v(t);<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(const i of e){<span class="cstat-no" title="statement not covered" >if(""===i)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span></span>=t&amp;&amp;t[i]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>}</span>(e));<span class="cstat-no" title="statement not covered" ></span>return i(t)}</span>function <span class="fstat-no" title="function not covered" >w(</span>t){<span class="cstat-no" title="statement not covered" >return t.charAt(0).toUpperCase()+t.slice(1)}</span>const k=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >void 0!==t,</span></span>S=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"function"==typeof t,</span></span>P=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >if(t.size!==e.size)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(const i of t)<span class="cstat-no" title="statement not covered" >if(!e.has(i))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>;</span>function <span class="fstat-no" title="function not covered" >D(</span>t){<span class="cstat-no" title="statement not covered" >return"mouseup"===t.type||"click"===t.type||"contextmenu"===t.type}</span>const C=<span class="cstat-no" title="statement not covered" >Math.PI,</span>O=<span class="cstat-no" title="statement not covered" >2*C,</span>A=<span class="cstat-no" title="statement not covered" >O+C,</span>T=<span class="cstat-no" title="statement not covered" >Number.POSITIVE_INFINITY,</span>L=<span class="cstat-no" title="statement not covered" >C/180,</span>E=<span class="cstat-no" title="statement not covered" >C/2,</span>R=<span class="cstat-no" title="statement not covered" >C/4,</span>I=<span class="cstat-no" title="statement not covered" >2*C/3,</span>z=<span class="cstat-no" title="statement not covered" >Math.log10,</span>F=<span class="cstat-no" title="statement not covered" >Math.sign;</span>function <span class="fstat-no" title="function not covered" >V(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return Math.abs(t-e)&lt;i}</span>function <span class="fstat-no" title="function not covered" >B(</span>t){const e=<span class="cstat-no" title="statement not covered" >Math.round(t);<span class="cstat-no" title="statement not covered" ></span>t=V(t,e,t/1e3)?e:t;c</span>onst i=<span class="cstat-no" title="statement not covered" >Math.pow(10,Math.floor(z(t))),</span>s=<span class="cstat-no" title="statement not covered" >t/i;<span class="cstat-no" title="statement not covered" ></span>return(s&lt;=1?1:s&lt;=2?2:s&lt;=5?5:10)*i}</span>function <span class="fstat-no" title="function not covered" >W(</span>t){const e=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >Math.sqrt(t);</span>let s;<span class="cstat-no" title="statement not covered" >for(s=1;s&lt;i;s++)<span class="cstat-no" title="statement not covered" >t%s==0&amp;&amp;(e.push(s),e.push(t/s));<span class="cstat-no" title="statement not covered" >r</span></span>eturn i===(0|i)&amp;&amp;e.push(i),e.sort((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e)</span>).pop(),e}</span>function <span class="fstat-no" title="function not covered" >N(</span>t){<span class="cstat-no" title="statement not covered" >return!<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"symbol"==typeof t||"object"==typeof t&amp;&amp;null!==t&amp;&amp;!(Symbol.toPrimitive in t||"toString"in t||"valueOf"in t)}</span>(t)&amp;&amp;!isNaN(parseFloat(t))&amp;&amp;isFinite(t)}</span>function <span class="fstat-no" title="function not covered" >H(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >Math.round(t);<span class="cstat-no" title="statement not covered" ></span>return i-e&lt;=t&amp;&amp;i+e&gt;=t}</span>function <span class="fstat-no" title="function not covered" >j(</span>t,e,i){let s,n,o;<span class="cstat-no" title="statement not covered" >for(s=0,n=t.length;s&lt;n;s++)<span class="cstat-no" title="statement not covered" >o=t[s][i],isNaN(o)||(e.min=Math.min(e.min,o),e.max=Math.max(e.max,o))}</span></span>function <span class="fstat-no" title="function not covered" >$(</span>t){<span class="cstat-no" title="statement not covered" >return t*(C/180)}</span>function <span class="fstat-no" title="function not covered" >Y(</span>t){<span class="cstat-no" title="statement not covered" >return t*(180/C)}</span>function <span class="fstat-no" title="function not covered" >U(</span>t){<span class="cstat-no" title="statement not covered" >if(!a(t))<span class="cstat-no" title="statement not covered" >return;l</span></span>et e=<span class="cstat-no" title="statement not covered" >1,</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;Math.round(t*e)/e!==t;)<span class="cstat-no" title="statement not covered" >e*=10,i++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >X(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >e.x-t.x,</span>s=<span class="cstat-no" title="statement not covered" >e.y-t.y,</span>n=<span class="cstat-no" title="statement not covered" >Math.sqrt(i*i+s*s);</span>let o=<span class="cstat-no" title="statement not covered" >Math.atan2(s,i);<span class="cstat-no" title="statement not covered" ></span>return o&lt;-.5*C&amp;&amp;(o+=O),{angle:o,distance:n}}</span>function <span class="fstat-no" title="function not covered" >q(</span>t,e){<span class="cstat-no" title="statement not covered" >return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}</span>function <span class="fstat-no" title="function not covered" >K(</span>t,e){<span class="cstat-no" title="statement not covered" >return(t-e+A)%O-C}</span>function <span class="fstat-no" title="function not covered" >G(</span>t){<span class="cstat-no" title="statement not covered" >return(t%O+O)%O}</span>function <span class="fstat-no" title="function not covered" >J(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >G(t),</span>o=<span class="cstat-no" title="statement not covered" >G(e),</span>a=<span class="cstat-no" title="statement not covered" >G(i),</span>r=<span class="cstat-no" title="statement not covered" >G(o-n),</span>l=<span class="cstat-no" title="statement not covered" >G(a-n),</span>h=<span class="cstat-no" title="statement not covered" >G(n-o),</span>c=<span class="cstat-no" title="statement not covered" >G(n-a);<span class="cstat-no" title="statement not covered" ></span>return n===o||n===a||s&amp;&amp;o===a||r&gt;l&amp;&amp;h&lt;c}</span>function <span class="fstat-no" title="function not covered" >Z(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return Math.max(e,Math.min(i,t))}</span>function <span class="fstat-no" title="function not covered" >Q(</span>t){<span class="cstat-no" title="statement not covered" >return Z(t,-32768,32767)}</span>function <span class="fstat-no" title="function not covered" >tt(</span>t,e,i,s=<span class="branch-0 cbranch-no" title="branch not covered" >1e-6)</span>{<span class="cstat-no" title="statement not covered" >return t&gt;=Math.min(e,i)-s&amp;&amp;t&lt;=Math.max(e,i)+s}</span>function <span class="fstat-no" title="function not covered" >et(</span>t,e,i){<span class="cstat-no" title="statement not covered" >i=i||(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >t[i]&lt;e)</span>;l</span>et s,n=<span class="cstat-no" title="statement not covered" >t.length-1,</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;n-o&gt;1;)<span class="cstat-no" title="statement not covered" >s=o+n&gt;&gt;1,i(s)?o=s:n=s;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{lo:o,hi:n}}</span>const it=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >et(t,i,s?<span class="fstat-no" title="function not covered" >s=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >t[s][e];<span class="cstat-no" title="statement not covered" ></span>return n&lt;i||n===i&amp;&amp;t[s+1][e]===i}</span>:<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >t[s][e]&lt;i)</span>,</span></span>st=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >et(t,i,(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >t[s][e]&gt;=i)</span>);</span></span>function <span class="fstat-no" title="function not covered" >nt(</span>t,e,i){let s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>for(;s&lt;n&amp;&amp;t[s]&lt;e;)<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" >f</span></span>or(;n&gt;s&amp;&amp;t[n-1]&gt;i;)<span class="cstat-no" title="statement not covered" >n--;<span class="cstat-no" title="statement not covered" >r</span></span>eturn s&gt;0||n&lt;t.length?t.slice(s,n):t}</span>const ot=<span class="cstat-no" title="statement not covered" >["push","pop","shift","splice","unshift"];</span>function <span class="fstat-no" title="function not covered" >at(</span>t,e){<span class="cstat-no" title="statement not covered" >t._chartjs?t._chartjs.listeners.push(e):(Object.defineProperty(t,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[e]}}),ot.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >"_onData"+w(e),</span>s=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,e,{configurable:!0,enumerable:!1,<span class="fstat-no" title="function not covered" >va</span>lue(...e){const n=<span class="cstat-no" title="statement not covered" >s.apply(this,e);<span class="cstat-no" title="statement not covered" ></span>return t._chartjs.listeners.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >"function"==typeof t[i]&amp;&amp;t[i](...e)}</span>)),n}</span>})}</span>)))}</span>function <span class="fstat-no" title="function not covered" >rt(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t._chartjs;<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >i.listeners,</span>n=<span class="cstat-no" title="statement not covered" >s.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>-1!==n&amp;&amp;s.splice(n,1),s.length&gt;0||(ot.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >delete t[e]}</span>)),delete t._chartjs)}</span>function <span class="fstat-no" title="function not covered" >lt(</span>t){const e=<span class="cstat-no" title="statement not covered" >new Set(t);<span class="cstat-no" title="statement not covered" ></span>return e.size===t.length?t:Array.from(e)}</span>const ht=<span class="cstat-no" title="statement not covered" >"undefined"==typeof window?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t()}</span>:window.requestAnimationFrame;</span>function <span class="fstat-no" title="function not covered" >ct(</span>t,e){let i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(...n){<span class="cstat-no" title="statement not covered" >i=n,s||(s=!0,ht.call(window,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s=!1,t.apply(e,i)}</span>)))}</span>}</span>function <span class="fstat-no" title="function not covered" >dt(</span>t,e){let i;<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(...s){<span class="cstat-no" title="statement not covered" >return e?(clearTimeout(i),i=setTimeout(t,e,s)):t.apply(this,s),e}</span>}</span>const ut=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"start"===t?"left":"end"===t?"right":"center",</span></span>ft=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >"start"===t?e:"end"===t?i:(e+i)/2,</span></span>gt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >t===(s?"left":"right")?i:"center"===t?(e+i)/2:e;</span></span>function <span class="fstat-no" title="function not covered" >pt(</span>t,e,i){const n=<span class="cstat-no" title="statement not covered" >e.length;</span>let o=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>if(t._sorted){const{iScale:r,vScale:l,_parsed:h}=<span class="cstat-no" title="statement not covered" >t,</span>c=<span class="cstat-no" title="statement not covered" >t.dataset&amp;&amp;t.dataset.options?t.dataset.options.spanGaps:null,</span>d=<span class="cstat-no" title="statement not covered" >r.axis,</span>{min:u,max:f,minDefined:g,maxDefined:p}=<span class="cstat-no" title="statement not covered" >r.getUserBounds();<span class="cstat-no" title="statement not covered" ></span>if(g){<span class="cstat-no" title="statement not covered" >if(o=Math.min(it(h,d,u).lo,i?n:it(e,d,r.getPixelForValue(u)).lo),c){const t=<span class="cstat-no" title="statement not covered" >h.slice(0,o+1).reverse().findIndex((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!s(t[l.axis]))</span>);<span class="cstat-no" title="statement not covered" ></span>o-=Math.max(0,t)}<span class="cstat-no" title="statement not covered" ></span>o</span>=Z(o,0,n-1)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(p){let t=<span class="cstat-no" title="statement not covered" >Math.max(it(h,r.axis,f,!0).hi+1,i?0:it(e,d,r.getPixelForValue(f),!0).hi+1);<span class="cstat-no" title="statement not covered" ></span>if(c){const e=<span class="cstat-no" title="statement not covered" >h.slice(t-1).findIndex((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!s(t[l.axis]))</span>);<span class="cstat-no" title="statement not covered" ></span>t+=Math.max(0,e)}<span class="cstat-no" title="statement not covered" ></span>a</span>=Z(t,o,n)-o}</span>else <span class="cstat-no" title="statement not covered" >a=n-o}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{start:o,count:a}}</span>function <span class="fstat-no" title="function not covered" >mt(</span>t){const{xScale:e,yScale:i,_scaleRanges:s}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >{xmin:e.min,xmax:e.max,ymin:i.min,ymax:i.max};<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return t._scaleRanges=n,!0;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >s.xmin!==e.min||s.xmax!==e.max||s.ymin!==i.min||s.ymax!==i.max;<span class="cstat-no" title="statement not covered" ></span>return Object.assign(s,n),o}</span>class xt{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}<span class="fstat-no" title="function not covered" ></span>_n</span>otify(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.listeners[s],</span>o=<span class="cstat-no" title="statement not covered" >e.duration;<span class="cstat-no" title="statement not covered" ></span>n.forEach((<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >s({chart:t,initial:e.initial,numSteps:o,currentStep:Math.min(i-e.start,o)}))</span>)}<span class="fstat-no" title="function not covered" ></span>_r</span>efresh(){<span class="cstat-no" title="statement not covered" >this._request||(this._running=!0,this._request=ht.call(window,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._update(),this._request=null,this._running&amp;&amp;this._refresh()}</span>)))}<span class="fstat-no" title="function not covered" ></span>_u</span>pdate(t=<span class="branch-0 cbranch-no" title="branch not covered" >Date.now())</span>{let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>this._charts.forEach((<span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >if(!i.running||!i.items.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >i.items;</span>let o,a=<span class="cstat-no" title="statement not covered" >n.length-1,</span>r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(;a&gt;=0;--a)<span class="cstat-no" title="statement not covered" >o=n[a],o._active?(o._total&gt;i.duration&amp;&amp;(i.duration=o._total),o.tick(t),r=!0):(n[a]=n[n.length-1],n.pop());<span class="cstat-no" title="statement not covered" >r</span></span>&amp;&amp;(s.draw(),this._notify(s,i,t,"progress")),n.length||(i.running=!1,this._notify(s,i,t,"complete"),i.initial=!1),e+=n.length}</span>)),this._lastDate=t,0===e&amp;&amp;(this._running=!1)}<span class="fstat-no" title="function not covered" ></span>_g</span>etAnims(t){const e=<span class="cstat-no" title="statement not covered" >this._charts;</span>let i=<span class="cstat-no" title="statement not covered" >e.get(t);<span class="cstat-no" title="statement not covered" ></span>return i||(i={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},e.set(t,i)),i}<span class="fstat-no" title="function not covered" ></span>li</span>sten(t,e,i){<span class="cstat-no" title="statement not covered" >this._getAnims(t).listeners[e].push(i)}<span class="fstat-no" title="function not covered" ></span>ad</span>d(t,e){<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.length&amp;&amp;this._getAnims(t).items.push(...e)}<span class="fstat-no" title="function not covered" ></span>ha</span>s(t){<span class="cstat-no" title="statement not covered" >return this._getAnims(t).items.length&gt;0}<span class="fstat-no" title="function not covered" ></span>st</span>art(t){const e=<span class="cstat-no" title="statement not covered" >this._charts.get(t);<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.max(t,e._duration))</span>,0),this._refresh())}<span class="fstat-no" title="function not covered" ></span>ru</span>nning(t){<span class="cstat-no" title="statement not covered" >if(!this._running)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this._charts.get(t);<span class="cstat-no" title="statement not covered" ></span>return!!(e&amp;&amp;e.running&amp;&amp;e.items.length)}<span class="fstat-no" title="function not covered" ></span>st</span>op(t){const e=<span class="cstat-no" title="statement not covered" >this._charts.get(t);<span class="cstat-no" title="statement not covered" ></span>if(!e||!e.items.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >e.items;</span>let s=<span class="cstat-no" title="statement not covered" >i.length-1;<span class="cstat-no" title="statement not covered" ></span>for(;s&gt;=0;--s)<span class="cstat-no" title="statement not covered" >i[s].cancel();<span class="cstat-no" title="statement not covered" >e</span></span>.items=[],this._notify(t,e,Date.now(),"complete")}<span class="fstat-no" title="function not covered" ></span>re</span>move(t){<span class="cstat-no" title="statement not covered" >return this._charts.delete(t)}</span>}var bt=<span class="cstat-no" title="statement not covered" >new xt;</span></span>
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */function <span class="fstat-no" title="function not covered" >_t(</span>t){<span class="cstat-no" title="statement not covered" >return t+.5|0}</span>const yt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >Math.max(Math.min(t,i),e);</span></span>function <span class="fstat-no" title="function not covered" >vt(</span>t){<span class="cstat-no" title="statement not covered" >return yt(_t(2.55*t),0,255)}</span>function <span class="fstat-no" title="function not covered" >Mt(</span>t){<span class="cstat-no" title="statement not covered" >return yt(_t(255*t),0,255)}</span>function <span class="fstat-no" title="function not covered" >wt(</span>t){<span class="cstat-no" title="statement not covered" >return yt(_t(t/2.55)/100,0,1)}</span>function <span class="fstat-no" title="function not covered" >kt(</span>t){<span class="cstat-no" title="statement not covered" >return yt(_t(100*t),0,100)}</span>const St=<span class="cstat-no" title="statement not covered" >{0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},</span>Pt=<span class="cstat-no" title="statement not covered" >[..."0123456789ABCDEF"],</span>Dt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Pt[15&amp;t],</span></span>Ct=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Pt[(240&amp;t)&gt;&gt;4]+Pt[15&amp;t],</span></span>Ot=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(240&amp;t)&gt;&gt;4==(15&amp;t);</span></span>function <span class="fstat-no" title="function not covered" >At(</span>t){var e=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Ot(t.r)&amp;&amp;Ot(t.g)&amp;&amp;Ot(t.b)&amp;&amp;Ot(t.a))</span>(t)?Dt:Ct;<span class="cstat-no" title="statement not covered" ></span>return t?"#"+e(t.r)+e(t.g)+e(t.b)+(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t&lt;255?e(t):"")</span>(t.a,e):void 0}</span>const Tt=<span class="cstat-no" title="statement not covered" >/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;</span>function <span class="fstat-no" title="function not covered" >Lt(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >e*Math.min(i,1-i),</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,n=<span class="branch-0 cbranch-no" title="branch not covered" >(e+t/30)%12)</span>=&gt;<span class="cstat-no" title="statement not covered" >i-s*Math.max(Math.min(n-3,9-n,1),-1);<span class="cstat-no" title="statement not covered" ></span></span>return[n(0),n(8),n(4)]}</span>function <span class="fstat-no" title="function not covered" >Et(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(s</span>,n=<span class="branch-0 cbranch-no" title="branch not covered" >(s+t/60)%6)</span>=&gt;<span class="cstat-no" title="statement not covered" >i-i*e*Math.max(Math.min(n,4-n,1),0);<span class="cstat-no" title="statement not covered" ></span></span>return[s(5),s(3),s(1)]}</span>function <span class="fstat-no" title="function not covered" >Rt(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >Lt(t,1,.5);</span>let n;<span class="cstat-no" title="statement not covered" >for(e+i&gt;1&amp;&amp;(n=1/(e+i),e*=n,i*=n),n=0;n&lt;3;n++)<span class="cstat-no" title="statement not covered" >s[n]*=1-e-i,s[n]+=e;<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>function <span class="fstat-no" title="function not covered" >It(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.r/255,</span>i=<span class="cstat-no" title="statement not covered" >t.g/255,</span>s=<span class="cstat-no" title="statement not covered" >t.b/255,</span>n=<span class="cstat-no" title="statement not covered" >Math.max(e,i,s),</span>o=<span class="cstat-no" title="statement not covered" >Math.min(e,i,s),</span>a=<span class="cstat-no" title="statement not covered" >(n+o)/2;</span>let r,l,h;<span class="cstat-no" title="statement not covered" >return n!==o&amp;&amp;(h=n-o,l=a&gt;.5?h/(2-n-o):h/(n+o),r=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s,n){<span class="cstat-no" title="statement not covered" >return t===n?(e-i)/s+(e&lt;i?6:0):e===n?(i-t)/s+2:(t-e)/s+4}</span>(e,i,s,h,n),r=60*r+.5),[0|r,l||0,a]}</span>function <span class="fstat-no" title="function not covered" >zt(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return(Array.isArray(e)?t(e[0],e[1],e[2]):t(e,i,s)).map(Mt)}</span>function <span class="fstat-no" title="function not covered" >Ft(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return zt(Lt,t,e,i)}</span>function <span class="fstat-no" title="function not covered" >Vt(</span>t){<span class="cstat-no" title="statement not covered" >return(t%360+360)%360}</span>function <span class="fstat-no" title="function not covered" >Bt(</span>t){const e=<span class="cstat-no" title="statement not covered" >Tt.exec(t);</span>let i,s=<span class="cstat-no" title="statement not covered" >255;<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >e</span></span>[5]!==i&amp;&amp;(s=e[6]?vt(+e[5]):Mt(+e[5]));c</span>onst n=<span class="cstat-no" title="statement not covered" >Vt(+e[2]),</span>o=<span class="cstat-no" title="statement not covered" >+e[3]/100,</span>a=<span class="cstat-no" title="statement not covered" >+e[4]/100;<span class="cstat-no" title="statement not covered" ></span>return i="hwb"===e[1]?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return zt(Rt,t,e,i)}</span>(n,o,a):"hsv"===e[1]?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return zt(Et,t,e,i)}</span>(n,o,a):Ft(n,o,a),{r:i[0],g:i[1],b:i[2],a:s}}</span>const Wt=<span class="cstat-no" title="statement not covered" >{x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},</span>Nt=<span class="cstat-no" title="statement not covered" >{OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};</span>let Ht;function <span class="fstat-no" title="function not covered" >jt(</span>t){<span class="cstat-no" title="statement not covered" >Ht||(Ht=<span class="fstat-no" title="function not covered" >fu</span>nction(){const t=<span class="cstat-no" title="statement not covered" >{},</span>e=<span class="cstat-no" title="statement not covered" >Object.keys(Nt),</span>i=<span class="cstat-no" title="statement not covered" >Object.keys(Wt);</span>let s,n,o,a,r;<span class="cstat-no" title="statement not covered" >for(s=0;s&lt;e.length;s++){<span class="cstat-no" title="statement not covered" >for(a=r=e[s],n=0;n&lt;i.length;n++)<span class="cstat-no" title="statement not covered" >o=i[n],r=r.replace(o,Wt[o]);<span class="cstat-no" title="statement not covered" >o</span></span>=parseInt(Nt[a],16),t[r]=[o&gt;&gt;16&amp;255,o&gt;&gt;8&amp;255,255&amp;o]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>(),Ht.transparent=[0,0,0,0]);c</span>onst e=<span class="cstat-no" title="statement not covered" >Ht[t.toLowerCase()];<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;{r:e[0],g:e[1],b:e[2],a:4===e.length?e[3]:255}}</span>const $t=<span class="cstat-no" title="statement not covered" >/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;</span>const Yt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&lt;=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055,</span></span>Ut=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&lt;=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4);</span></span>function <span class="fstat-no" title="function not covered" >Xt(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(t){let s=<span class="cstat-no" title="statement not covered" >It(t);<span class="cstat-no" title="statement not covered" ></span>s[e]=Math.max(0,Math.min(s[e]+s[e]*i,0===e?360:1)),s=Ft(s),t.r=s[0],t.g=s[1],t.b=s[2]}</span>}</span>function <span class="fstat-no" title="function not covered" >qt(</span>t,e){<span class="cstat-no" title="statement not covered" >return t?Object.assign(e||{},t):t}</span>function <span class="fstat-no" title="function not covered" >Kt(</span>t){var e=<span class="cstat-no" title="statement not covered" >{r:0,g:0,b:0,a:255};<span class="cstat-no" title="statement not covered" ></span>return Array.isArray(t)?t.length&gt;=3&amp;&amp;(e={r:t[0],g:t[1],b:t[2],a:255},t.length&gt;3&amp;&amp;(e.a=Mt(t[3]))):(e=qt(t,{r:0,g:0,b:0,a:1})).a=Mt(e.a),e}</span>function <span class="fstat-no" title="function not covered" >Gt(</span>t){<span class="cstat-no" title="statement not covered" >return"r"===t.charAt(0)?<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >$t.exec(t);</span>let i,s,n,o=<span class="cstat-no" title="statement not covered" >255;<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >if(e[7]!==i){const t=<span class="cstat-no" title="statement not covered" >+e[7];<span class="cstat-no" title="statement not covered" ></span>o=e[8]?vt(t):yt(255*t,0,255)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i=+e[1],s=+e[3],n=+e[5],i=255&amp;(e[2]?vt(i):yt(i,0,255)),s=255&amp;(e[4]?vt(s):yt(s,0,255)),n=255&amp;(e[6]?vt(n):yt(n,0,255)),{r:i,g:s,b:n,a:o}}</span>}</span>(t):Bt(t)}</span>class Jt{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >if(t instanceof Jt)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >typeof t;</span>let i;var s,n,o;<span class="cstat-no" title="statement not covered" >"object"===e?i=Kt(t):"string"===e&amp;&amp;(o=(s=t).length,"#"===s[0]&amp;&amp;(4===o||5===o?n={r:255&amp;17*St[s[1]],g:255&amp;17*St[s[2]],b:255&amp;17*St[s[3]],a:5===o?17*St[s[4]]:255}:7!==o&amp;&amp;9!==o||(n={r:St[s[1]]&lt;&lt;4|St[s[2]],g:St[s[3]]&lt;&lt;4|St[s[4]],b:St[s[5]]&lt;&lt;4|St[s[6]],a:9===o?St[s[7]]&lt;&lt;4|St[s[8]]:255})),i=n||jt(t)||Gt(t)),this._rgb=i,this._valid=!!i}<span class="fstat-no" title="function not covered" ></span>ge</span>t valid(){<span class="cstat-no" title="statement not covered" >return this._valid}<span class="fstat-no" title="function not covered" ></span>ge</span>t rgb(){var t=<span class="cstat-no" title="statement not covered" >qt(this._rgb);<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(t.a=wt(t.a)),t}<span class="fstat-no" title="function not covered" ></span>se</span>t rgb(t){<span class="cstat-no" title="statement not covered" >this._rgb=Kt(t)}<span class="fstat-no" title="function not covered" ></span>rg</span>bString(){<span class="cstat-no" title="statement not covered" >return this._valid?(t=this._rgb)&amp;&amp;(t.a&lt;255?`rgba(${t.r}, ${t.g}, ${t.b}, ${wt(t.a)})`:`rgb(${t.r}, ${t.g}, ${t.b})`):void 0;v</span>ar t}<span class="fstat-no" title="function not covered" >he</span>xString(){<span class="cstat-no" title="statement not covered" >return this._valid?At(this._rgb):void 0}<span class="fstat-no" title="function not covered" ></span>hs</span>lString(){<span class="cstat-no" title="statement not covered" >return this._valid?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >It(t),</span>i=<span class="cstat-no" title="statement not covered" >e[0],</span>s=<span class="cstat-no" title="statement not covered" >kt(e[1]),</span>n=<span class="cstat-no" title="statement not covered" >kt(e[2]);<span class="cstat-no" title="statement not covered" ></span>return t.a&lt;255?`hsla(${i}, ${s}%, ${n}%, ${wt(t.a)})`:`hsl(${i}, ${s}%, ${n}%)`}</span>(this._rgb):void 0}<span class="fstat-no" title="function not covered" ></span>mi</span>x(t,e){<span class="cstat-no" title="statement not covered" >if(t){const i=<span class="cstat-no" title="statement not covered" >this.rgb,</span>s=<span class="cstat-no" title="statement not covered" >t.rgb;</span>let n;const o=<span class="cstat-no" title="statement not covered" >e===n?.5:e,</span>a=<span class="cstat-no" title="statement not covered" >2*o-1,</span>r=<span class="cstat-no" title="statement not covered" >i.a-s.a,</span>l=<span class="cstat-no" title="statement not covered" >((a*r==-1?a:(a+r)/(1+a*r))+1)/2;<span class="cstat-no" title="statement not covered" ></span>n=1-l,i.r=255&amp;l*i.r+n*s.r+.5,i.g=255&amp;l*i.g+n*s.g+.5,i.b=255&amp;l*i.b+n*s.b+.5,i.a=o*i.a+(1-o)*s.a,this.rgb=i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}<span class="fstat-no" title="function not covered" ></span>in</span>terpolate(t,e){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;(this._rgb=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >Ut(wt(t.r)),</span>n=<span class="cstat-no" title="statement not covered" >Ut(wt(t.g)),</span>o=<span class="cstat-no" title="statement not covered" >Ut(wt(t.b));<span class="cstat-no" title="statement not covered" ></span>return{r:Mt(Yt(s+i*(Ut(wt(e.r))-s))),g:Mt(Yt(n+i*(Ut(wt(e.g))-n))),b:Mt(Yt(o+i*(Ut(wt(e.b))-o))),a:t.a+i*(e.a-t.a)}}</span>(this._rgb,t._rgb,e)),this}<span class="fstat-no" title="function not covered" ></span>cl</span>one(){<span class="cstat-no" title="statement not covered" >return new Jt(this.rgb)}<span class="fstat-no" title="function not covered" ></span>al</span>pha(t){<span class="cstat-no" title="statement not covered" >return this._rgb.a=Mt(t),this}<span class="fstat-no" title="function not covered" ></span>cl</span>earer(t){<span class="cstat-no" title="statement not covered" >return this._rgb.a*=1-t,this}<span class="fstat-no" title="function not covered" ></span>gr</span>eyscale(){const t=<span class="cstat-no" title="statement not covered" >this._rgb,</span>e=<span class="cstat-no" title="statement not covered" >_t(.3*t.r+.59*t.g+.11*t.b);<span class="cstat-no" title="statement not covered" ></span>return t.r=t.g=t.b=e,this}<span class="fstat-no" title="function not covered" ></span>op</span>aquer(t){<span class="cstat-no" title="statement not covered" >return this._rgb.a*=1+t,this}<span class="fstat-no" title="function not covered" ></span>ne</span>gate(){const t=<span class="cstat-no" title="statement not covered" >this._rgb;<span class="cstat-no" title="statement not covered" ></span>return t.r=255-t.r,t.g=255-t.g,t.b=255-t.b,this}<span class="fstat-no" title="function not covered" ></span>li</span>ghten(t){<span class="cstat-no" title="statement not covered" >return Xt(this._rgb,2,t),this}<span class="fstat-no" title="function not covered" ></span>da</span>rken(t){<span class="cstat-no" title="statement not covered" >return Xt(this._rgb,2,-t),this}<span class="fstat-no" title="function not covered" ></span>sa</span>turate(t){<span class="cstat-no" title="statement not covered" >return Xt(this._rgb,1,t),this}<span class="fstat-no" title="function not covered" ></span>de</span>saturate(t){<span class="cstat-no" title="statement not covered" >return Xt(this._rgb,1,-t),this}<span class="fstat-no" title="function not covered" ></span>ro</span>tate(t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >It(t);<span class="cstat-no" title="statement not covered" ></span>i[0]=Vt(i[0]+e),i=Ft(i),t.r=i[0],t.g=i[1],t.b=i[2]}</span>(this._rgb,t),this}</span>}function <span class="fstat-no" title="function not covered" >Zt(</span>t){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;"object"==typeof t){const e=<span class="cstat-no" title="statement not covered" >t.toString();<span class="cstat-no" title="statement not covered" ></span>return"[object CanvasPattern]"===e||"[object CanvasGradient]"===e}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >Qt(</span>t){<span class="cstat-no" title="statement not covered" >return Zt(t)?t:new Jt(t)}</span>function <span class="fstat-no" title="function not covered" >te(</span>t){<span class="cstat-no" title="statement not covered" >return Zt(t)?t:new Jt(t).saturate(.5).darken(.1).hexString()}</span>const ee=<span class="cstat-no" title="statement not covered" >["x","y","borderWidth","radius","tension"],</span>ie=<span class="cstat-no" title="statement not covered" >["color","borderColor","backgroundColor"];</span>const se=<span class="cstat-no" title="statement not covered" >new Map;</span>function <span class="fstat-no" title="function not covered" >ne(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >e=e||{};c</span>onst i=<span class="cstat-no" title="statement not covered" >t+JSON.stringify(e);</span>let s=<span class="cstat-no" title="statement not covered" >se.get(i);<span class="cstat-no" title="statement not covered" ></span>return s||(s=new Intl.NumberFormat(t,e),se.set(i,s)),s}</span>(e,i).format(t)}</span>const oe=<span class="cstat-no" title="statement not covered" >{values:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >n(t)?t:""+t,<span class="fstat-no" title="function not covered" ></span>nu</span>meric(t,e,i){<span class="cstat-no" title="statement not covered" >if(0===t)<span class="cstat-no" title="statement not covered" >return"0";c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.chart.options.locale;</span>let n,o=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(i.length&gt;1){const e=<span class="cstat-no" title="statement not covered" >Math.max(Math.abs(i[0].value),Math.abs(i[i.length-1].value));<span class="cstat-no" title="statement not covered" ></span>(e&lt;1e-4||e&gt;1e15)&amp;&amp;(n="scientific"),o=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i=<span class="cstat-no" title="statement not covered" >e.length&gt;3?e[2].value-e[1].value:e[1].value-e[0].value;<span class="cstat-no" title="statement not covered" ></span>Math.abs(i)&gt;=1&amp;&amp;t!==Math.floor(t)&amp;&amp;(i=t-Math.floor(t));<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>(t,i)}</span>c</span>onst a=<span class="cstat-no" title="statement not covered" >z(Math.abs(o)),</span>r=<span class="cstat-no" title="statement not covered" >isNaN(a)?1:Math.max(Math.min(-1*Math.floor(a),20),0),</span>l=<span class="cstat-no" title="statement not covered" >{notation:n,minimumFractionDigits:r,maximumFractionDigits:r};<span class="cstat-no" title="statement not covered" ></span>return Object.assign(l,this.options.ticks.format),ne(t,s,l)}</span>,<span class="fstat-no" title="function not covered" >lo</span>garithmic(t,e,i){<span class="cstat-no" title="statement not covered" >if(0===t)<span class="cstat-no" title="statement not covered" >return"0";c</span></span>onst s=<span class="cstat-no" title="statement not covered" >i[e].significand||t/Math.pow(10,Math.floor(z(t)));<span class="cstat-no" title="statement not covered" ></span>return[1,2,3,5,10,15].includes(s)||e&gt;.8*i.length?oe.numeric.call(this,t,e,i):""}</span>};</span>var ae=<span class="cstat-no" title="statement not covered" >{formatters:oe};</span>const re=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>le=<span class="cstat-no" title="statement not covered" >Object.create(null);</span>function <span class="fstat-no" title="function not covered" >he(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >e.split(".");<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >i.length;</span>e&lt;s;++e){const s=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>t=t[s]||(t[s]=Object.create(null))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >ce(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return"string"==typeof e?x(he(t,e),i):x(he(t,""),e)}</span>class de{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.chart.platform.getDevicePixelRatio(),</span>this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >te(e.backgroundColor),</span>this.hoverBorderColor=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >te(e.borderColor),</span>this.hoverColor=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >te(e.color),</span>this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t),this.apply(e)}<span class="fstat-no" title="function not covered" ></span>se</span>t(t,e){<span class="cstat-no" title="statement not covered" >return ce(this,t,e)}<span class="fstat-no" title="function not covered" ></span>ge</span>t(t){<span class="cstat-no" title="statement not covered" >return he(this,t)}<span class="fstat-no" title="function not covered" ></span>de</span>scribe(t,e){<span class="cstat-no" title="statement not covered" >return ce(le,t,e)}<span class="fstat-no" title="function not covered" ></span>ov</span>erride(t,e){<span class="cstat-no" title="statement not covered" >return ce(re,t,e)}<span class="fstat-no" title="function not covered" ></span>ro</span>ute(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >he(this,t),</span>a=<span class="cstat-no" title="statement not covered" >he(this,i),</span>r=<span class="cstat-no" title="statement not covered" >"_"+e;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperties(n,{[r]:{value:n[e],writable:!0},[e]:{enumerable:!0,<span class="fstat-no" title="function not covered" >ge</span>t(){const t=<span class="cstat-no" title="statement not covered" >this[r],</span>e=<span class="cstat-no" title="statement not covered" >a[s];<span class="cstat-no" title="statement not covered" ></span>return o(t)?Object.assign({},e,t):l(t,e)}</span>,<span class="fstat-no" title="function not covered" >se</span>t(t){<span class="cstat-no" title="statement not covered" >this[r]=t}</span>}})}<span class="fstat-no" title="function not covered" ></span>ap</span>ply(t){<span class="cstat-no" title="statement not covered" >t.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t(this))</span>)}</span>}var ue=<span class="cstat-no" title="statement not covered" >new de({_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.startsWith("on"),</span>_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"events"!==t,</span>hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}},[<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),t.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"onProgress"!==t&amp;&amp;"onComplete"!==t&amp;&amp;"fn"!==t}</span>),t.set("animations",{colors:{type:"color",properties:ie},numbers:{type:"number",properties:ee}}),t.describe("animations",{_fallback:"animation"}),t.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0|t}</span>}}})}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",clip:!0,grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.lineWidth,</span>tickColor:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.color,</span>offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:ae.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),t.route("scale.ticks","color","","color"),t.route("scale.grid","color","","borderColor"),t.route("scale.border","color","","borderColor"),t.route("scale.title","color","","color"),t.describe("scale",{_fallback:!1,_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.startsWith("before")&amp;&amp;!t.startsWith("after")&amp;&amp;"callback"!==t&amp;&amp;"parser"!==t,</span>_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"borderDash"!==t&amp;&amp;"tickBorderDash"!==t&amp;&amp;"dash"!==t}</span>),t.describe("scales",{_fallback:"scale"}),t.describe("scale.ticks",{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"backdropPadding"!==t&amp;&amp;"callback"!==t,</span>_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"backdropPadding"!==t}</span>)}</span>]);</span>function <span class="fstat-no" title="function not covered" >fe(</span>){<span class="cstat-no" title="statement not covered" >return"undefined"!=typeof window&amp;&amp;"undefined"!=typeof document}</span>function <span class="fstat-no" title="function not covered" >ge(</span>t){let e=<span class="cstat-no" title="statement not covered" >t.parentNode;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;"[object ShadowRoot]"===e.toString()&amp;&amp;(e=e.host),e}</span>function <span class="fstat-no" title="function not covered" >pe(</span>t,e,i){let s;<span class="cstat-no" title="statement not covered" >return"string"==typeof t?(s=parseInt(t,10),-1!==t.indexOf("%")&amp;&amp;(s=s/100*e.parentNode[i])):s=t,s}</span>const me=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.ownerDocument.defaultView.getComputedStyle(t,null);</span></span>function <span class="fstat-no" title="function not covered" >xe(</span>t,e){<span class="cstat-no" title="statement not covered" >return me(t).getPropertyValue(e)}</span>const be=<span class="cstat-no" title="statement not covered" >["top","right","bottom","left"];</span>function <span class="fstat-no" title="function not covered" >_e(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>i=i?"-"+i:"";<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;4;n++){const o=<span class="cstat-no" title="statement not covered" >be[n];<span class="cstat-no" title="statement not covered" ></span>s[o]=parseFloat(t[e+"-"+o+i])||0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.width=s.left+s.right,s.height=s.top+s.bottom,s}</span>const ye=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >(t&gt;0||e&gt;0)&amp;&amp;(!i||!i.shadowRoot);</span></span>function <span class="fstat-no" title="function not covered" >ve(</span>t,e){<span class="cstat-no" title="statement not covered" >if("native"in t)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst{canvas:i,currentDevicePixelRatio:s}=<span class="cstat-no" title="statement not covered" >e,</span>n=<span class="cstat-no" title="statement not covered" >me(i),</span>o=<span class="cstat-no" title="statement not covered" >"border-box"===n.boxSizing,</span>a=<span class="cstat-no" title="statement not covered" >_e(n,"padding"),</span>r=<span class="cstat-no" title="statement not covered" >_e(n,"border","width"),</span>{x:l,y:h,box:c}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >t.touches,</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.length?i[0]:t,</span>{offsetX:n,offsetY:o}=<span class="cstat-no" title="statement not covered" >s;</span>let a,r,l=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(ye(n,o,t.target))<span class="cstat-no" title="statement not covered" >a=n,r=o;e</span>lse{const t=<span class="cstat-no" title="statement not covered" >e.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>a=s.clientX-t.left,r=s.clientY-t.top,l=!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{x:a,y:r,box:l}}</span>(t,i),</span>d=<span class="cstat-no" title="statement not covered" >a.left+(c&amp;&amp;r.left),</span>u=<span class="cstat-no" title="statement not covered" >a.top+(c&amp;&amp;r.top);</span>let{width:f,height:g}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return o&amp;&amp;(f-=a.width+r.width,g-=a.height+r.height),{x:Math.round((l-d)/f*i.width/s),y:Math.round((h-u)/g*i.height/s)}}</span>const Me=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.round(10*t)/10;</span></span>function <span class="fstat-no" title="function not covered" >we(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >me(t),</span>o=<span class="cstat-no" title="statement not covered" >_e(n,"margin"),</span>a=<span class="cstat-no" title="statement not covered" >pe(n.maxWidth,t,"clientWidth")||T,</span>r=<span class="cstat-no" title="statement not covered" >pe(n.maxHeight,t,"clientHeight")||T,</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let s,n;<span class="cstat-no" title="statement not covered" >if(void 0===e||void 0===i){const o=<span class="cstat-no" title="statement not covered" >t&amp;&amp;ge(t);<span class="cstat-no" title="statement not covered" ></span>if(o){const t=<span class="cstat-no" title="statement not covered" >o.getBoundingClientRect(),</span>a=<span class="cstat-no" title="statement not covered" >me(o),</span>r=<span class="cstat-no" title="statement not covered" >_e(a,"border","width"),</span>l=<span class="cstat-no" title="statement not covered" >_e(a,"padding");<span class="cstat-no" title="statement not covered" ></span>e=t.width-l.width-r.width,i=t.height-l.height-r.height,s=pe(a.maxWidth,o,"clientWidth"),n=pe(a.maxHeight,o,"clientHeight")}</span>else <span class="cstat-no" title="statement not covered" >e=t.clientWidth,i=t.clientHeight}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{width:e,height:i,maxWidth:s||T,maxHeight:n||T}}</span>(t,e,i);</span>let{width:h,height:c}=<span class="cstat-no" title="statement not covered" >l;<span class="cstat-no" title="statement not covered" ></span>if("content-box"===n.boxSizing){const t=<span class="cstat-no" title="statement not covered" >_e(n,"border","width"),</span>e=<span class="cstat-no" title="statement not covered" >_e(n,"padding");<span class="cstat-no" title="statement not covered" ></span>h-=e.width+t.width,c-=e.height+t.height}<span class="cstat-no" title="statement not covered" ></span>h</span>=Math.max(0,h-o.width),c=Math.max(0,s?h/s:c-o.height),h=Me(Math.min(h,a,l.maxWidth)),c=Me(Math.min(c,r,l.maxHeight)),h&amp;&amp;!c&amp;&amp;(c=Me(h/2));<span class="cstat-no" title="statement not covered" >r</span>eturn(void 0!==e||void 0!==i)&amp;&amp;s&amp;&amp;l.height&amp;&amp;c&gt;l.height&amp;&amp;(c=l.height,h=Me(Math.floor(c*s))),{width:h,height:c}}</span>function <span class="fstat-no" title="function not covered" >ke(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >e||1,</span>n=<span class="cstat-no" title="statement not covered" >Math.floor(t.height*s),</span>o=<span class="cstat-no" title="statement not covered" >Math.floor(t.width*s);<span class="cstat-no" title="statement not covered" ></span>t.height=Math.floor(t.height),t.width=Math.floor(t.width);c</span>onst a=<span class="cstat-no" title="statement not covered" >t.canvas;<span class="cstat-no" title="statement not covered" ></span>return a.style&amp;&amp;(i||!a.style.height&amp;&amp;!a.style.width)&amp;&amp;(a.style.height=`${t.height}px`,a.style.width=`${t.width}px`),(t.currentDevicePixelRatio!==s||a.height!==n||a.width!==o)&amp;&amp;(t.currentDevicePixelRatio=s,a.height=n,a.width=o,t.ctx.setTransform(s,0,0,s,0,0),!0)}</span>const Se=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){let t=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>try{const e=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >ge</span>t passive(){<span class="cstat-no" title="statement not covered" >return t=!0,!1}</span>};<span class="cstat-no" title="statement not covered" ></span>fe()&amp;&amp;(window.addEventListener("test",null,e),window.removeEventListener("test",null,e))}</span>catch(t){}<span class="cstat-no" title="statement not covered" >r</span>eturn t}</span>();</span>function <span class="fstat-no" title="function not covered" >Pe(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >xe(t,e),</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.match(/^(\d+)(\.\d+)?px$/);<span class="cstat-no" title="statement not covered" ></span>return s?+s[1]:void 0}</span>function <span class="fstat-no" title="function not covered" >De(</span>t){<span class="cstat-no" title="statement not covered" >return!t||s(t.size)||s(t.family)?null:(t.style?t.style+" ":"")+(t.weight?t.weight+" ":"")+t.size+"px "+t.family}</span>function <span class="fstat-no" title="function not covered" >Ce(</span>t,e,i,s,n){let o=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>return o||(o=e[n]=t.measureText(n).width,i.push(n)),o&gt;s&amp;&amp;(s=o),s}</span>function <span class="fstat-no" title="function not covered" >Oe(</span>t,e,i,s){let o=<span class="cstat-no" title="statement not covered" >(s=s||{}).data=s.data||{},</span>a=<span class="cstat-no" title="statement not covered" >s.garbageCollect=s.garbageCollect||[];<span class="cstat-no" title="statement not covered" ></span>s.font!==e&amp;&amp;(o=s.data={},a=s.garbageCollect=[],s.font=e),t.save(),t.font=e;l</span>et r=<span class="cstat-no" title="statement not covered" >0;</span>const l=<span class="cstat-no" title="statement not covered" >i.length;</span>let h,c,d,u,f;<span class="cstat-no" title="statement not covered" >for(h=0;h&lt;l;h++)<span class="cstat-no" title="statement not covered" >if(u=i[h],null==u||n(u)){<span class="cstat-no" title="statement not covered" >if(n(u))<span class="cstat-no" title="statement not covered" >for(c=0,d=u.length;c&lt;d;c++)<span class="cstat-no" title="statement not covered" >f=u[c],null==f||n(f)||(r=Ce(t,o,a,r,f))}</span></span></span>else <span class="cstat-no" title="statement not covered" >r=Ce(t,o,a,r,u);<span class="cstat-no" title="statement not covered" >t</span></span></span>.restore();c</span>onst g=<span class="cstat-no" title="statement not covered" >a.length/2;<span class="cstat-no" title="statement not covered" ></span>if(g&gt;i.length){<span class="cstat-no" title="statement not covered" >for(h=0;h&lt;g;h++)<span class="cstat-no" title="statement not covered" >delete o[a[h]];<span class="cstat-no" title="statement not covered" >a</span></span>.splice(0,g)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Ae(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.currentDevicePixelRatio,</span>n=<span class="cstat-no" title="statement not covered" >0!==i?Math.max(i/2,.5):0;<span class="cstat-no" title="statement not covered" ></span>return Math.round((e-n)*s)/s+n}</span>function <span class="fstat-no" title="function not covered" >Te(</span>t,e){<span class="cstat-no" title="statement not covered" >(e||t)&amp;&amp;((e=e||t.getContext("2d")).save(),e.resetTransform(),e.clearRect(0,0,t.width,t.height),e.restore())}</span>function <span class="fstat-no" title="function not covered" >Le(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >Ee(t,e,i,s,null)}</span>function <span class="fstat-no" title="function not covered" >Ee(</span>t,e,i,s,n){let o,a,r,l,h,c,d,u;const f=<span class="cstat-no" title="statement not covered" >e.pointStyle,</span>g=<span class="cstat-no" title="statement not covered" >e.rotation,</span>p=<span class="cstat-no" title="statement not covered" >e.radius;</span>let m=<span class="cstat-no" title="statement not covered" >(g||0)*L;<span class="cstat-no" title="statement not covered" ></span>if(f&amp;&amp;"object"==typeof f&amp;&amp;(o=f.toString(),"[object HTMLImageElement]"===o||"[object HTMLCanvasElement]"===o))<span class="cstat-no" title="statement not covered" >return t.save(),t.translate(i,s),t.rotate(m),t.drawImage(f,-f.width/2,-f.height/2,f.width,f.height),void t.restore();<span class="cstat-no" title="statement not covered" >i</span></span>f(!(isNaN(p)||p&lt;=0)){<span class="cstat-no" title="statement not covered" >switch(t.beginPath(),f){default:<span class="cstat-no" title="statement not covered" >n?t.ellipse(i,s,n/2,p,0,0,O):t.arc(i,s,p,0,O),t.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"triangle":<span class="cstat-no" title="statement not covered" >c=n?n/2:p,t.moveTo(i+Math.sin(m)*c,s-Math.cos(m)*p),m+=I,t.lineTo(i+Math.sin(m)*c,s-Math.cos(m)*p),m+=I,t.lineTo(i+Math.sin(m)*c,s-Math.cos(m)*p),t.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rectRounded":<span class="cstat-no" title="statement not covered" >h=.516*p,l=p-h,a=Math.cos(m+R)*l,d=Math.cos(m+R)*(n?n/2-h:l),r=Math.sin(m+R)*l,u=Math.sin(m+R)*(n?n/2-h:l),t.arc(i-d,s-r,h,m-C,m-E),t.arc(i+u,s-a,h,m-E,m),t.arc(i+d,s+r,h,m,m+E),t.arc(i-u,s+a,h,m+E,m+C),t.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rect":<span class="cstat-no" title="statement not covered" >if(!g){<span class="cstat-no" title="statement not covered" >l=Math.SQRT1_2*p,c=n?n/2:l,t.rect(i-c,s-l,2*c,2*l);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>m</span>+=R;c</span>ase"rectRot":<span class="cstat-no" title="statement not covered" >d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+u,s-a),t.lineTo(i+d,s+r),t.lineTo(i-u,s+a),t.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"crossRot":<span class="cstat-no" title="statement not covered" >m+=R;c</span>ase"cross":<span class="cstat-no" title="statement not covered" >d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+d,s+r),t.moveTo(i+u,s-a),t.lineTo(i-u,s+a);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"star":<span class="cstat-no" title="statement not covered" >d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+d,s+r),t.moveTo(i+u,s-a),t.lineTo(i-u,s+a),m+=R,d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+d,s+r),t.moveTo(i+u,s-a),t.lineTo(i-u,s+a);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"line":<span class="cstat-no" title="statement not covered" >a=n?n/2:Math.cos(m)*p,r=Math.sin(m)*p,t.moveTo(i-a,s-r),t.lineTo(i+a,s+r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"dash":<span class="cstat-no" title="statement not covered" >t.moveTo(i,s),t.lineTo(i+Math.cos(m)*(n?n/2:p),s+Math.sin(m)*p);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase!1:<span class="cstat-no" title="statement not covered" >t.closePath()}<span class="cstat-no" title="statement not covered" ></span>t</span>.fill(),e.borderWidth&gt;0&amp;&amp;t.stroke()}</span>}</span>function <span class="fstat-no" title="function not covered" >Re(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return i=i||.5,!e||t&amp;&amp;t.x&gt;e.left-i&amp;&amp;t.x&lt;e.right+i&amp;&amp;t.y&gt;e.top-i&amp;&amp;t.y&lt;e.bottom+i}</span>function <span class="fstat-no" title="function not covered" >Ie(</span>t,e){<span class="cstat-no" title="statement not covered" >t.save(),t.beginPath(),t.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),t.clip()}</span>function <span class="fstat-no" title="function not covered" >ze(</span>t){<span class="cstat-no" title="statement not covered" >t.restore()}</span>function <span class="fstat-no" title="function not covered" >Fe(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return t.lineTo(i.x,i.y);<span class="cstat-no" title="statement not covered" >i</span></span>f("middle"===n){const s=<span class="cstat-no" title="statement not covered" >(e.x+i.x)/2;<span class="cstat-no" title="statement not covered" ></span>t.lineTo(s,e.y),t.lineTo(s,i.y)}</span>else<span class="cstat-no" title="statement not covered" >"after"===n!=!!s?t.lineTo(e.x,i.y):t.lineTo(i.x,e.y);<span class="cstat-no" title="statement not covered" >t</span></span>.lineTo(i.x,i.y)}</span>function <span class="fstat-no" title="function not covered" >Ve(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return t.lineTo(i.x,i.y);<span class="cstat-no" title="statement not covered" >t</span></span>.bezierCurveTo(s?e.cp1x:e.cp2x,s?e.cp1y:e.cp2y,s?i.cp2x:i.cp1x,s?i.cp2y:i.cp1y,i.x,i.y)}</span>function <span class="fstat-no" title="function not covered" >Be(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >if(n.strikethrough||n.underline){const o=<span class="cstat-no" title="statement not covered" >t.measureText(s),</span>a=<span class="cstat-no" title="statement not covered" >e-o.actualBoundingBoxLeft,</span>r=<span class="cstat-no" title="statement not covered" >e+o.actualBoundingBoxRight,</span>l=<span class="cstat-no" title="statement not covered" >i-o.actualBoundingBoxAscent,</span>h=<span class="cstat-no" title="statement not covered" >i+o.actualBoundingBoxDescent,</span>c=<span class="cstat-no" title="statement not covered" >n.strikethrough?(l+h)/2:h;<span class="cstat-no" title="statement not covered" ></span>t.strokeStyle=t.fillStyle,t.beginPath(),t.lineWidth=n.decorationWidth||2,t.moveTo(a,c),t.lineTo(r,c),t.stroke()}</span>}</span>function <span class="fstat-no" title="function not covered" >We(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.fillStyle;<span class="cstat-no" title="statement not covered" ></span>t.fillStyle=e.color,t.fillRect(e.left,e.top,e.width,e.height),t.fillStyle=i}</span>function <span class="fstat-no" title="function not covered" >Ne(</span>t,e,i,o,a,r=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const l=<span class="cstat-no" title="statement not covered" >n(e)?e:[e],</span>h=<span class="cstat-no" title="statement not covered" >r.strokeWidth&gt;0&amp;&amp;""!==r.strokeColor;</span>let c,d;<span class="cstat-no" title="statement not covered" >for(t.save(),t.font=a.string,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >e.translation&amp;&amp;t.translate(e.translation[0],e.translation[1]),s(e.rotation)||t.rotate(e.rotation),e.color&amp;&amp;(t.fillStyle=e.color),e.textAlign&amp;&amp;(t.textAlign=e.textAlign),e.textBaseline&amp;&amp;(t.textBaseline=e.textBaseline)}</span>(t,r),c=0;c&lt;l.length;++c)<span class="cstat-no" title="statement not covered" >d=l[c],r.backdrop&amp;&amp;We(t,r.backdrop),h&amp;&amp;(r.strokeColor&amp;&amp;(t.strokeStyle=r.strokeColor),s(r.strokeWidth)||(t.lineWidth=r.strokeWidth),t.strokeText(d,i,o,r.maxWidth)),t.fillText(d,i,o,r.maxWidth),Be(t,i,o,d,r),o+=Number(a.lineHeight);<span class="cstat-no" title="statement not covered" >t</span></span>.restore()}</span>function <span class="fstat-no" title="function not covered" >He(</span>t,e){const{x:i,y:s,w:n,h:o,radius:a}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>t.arc(i+a.topLeft,s+a.topLeft,a.topLeft,1.5*C,C,!0),t.lineTo(i,s+o-a.bottomLeft),t.arc(i+a.bottomLeft,s+o-a.bottomLeft,a.bottomLeft,C,E,!0),t.lineTo(i+n-a.bottomRight,s+o),t.arc(i+n-a.bottomRight,s+o-a.bottomRight,a.bottomRight,E,0,!0),t.lineTo(i+n,s+a.topRight),t.arc(i+n-a.topRight,s+a.topRight,a.topRight,0,-E,!0),t.lineTo(i+a.topLeft,s)}</span>function <span class="fstat-no" title="function not covered" >je(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >[""],</span>i,s,n=(<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t[0])</span></span>){const o=<span class="cstat-no" title="statement not covered" >i||t;<span class="cstat-no" title="statement not covered" ></span>void 0===s&amp;&amp;(s=ti("_fallback",t));c</span>onst a=<span class="cstat-no" title="statement not covered" >{[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:t,_rootScopes:o,_fallback:s,_getTarget:n,override:<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >je([i,...t],e,o,s)}</span>;<span class="cstat-no" title="statement not covered" ></span>return new Proxy(a,{deleteProperty:<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;(<span class="cstat-no" title="statement not covered" >delete e[i],delete e._keys,delete t[0][i],!0)</span>,get:<span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >qe(i,s,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n;<span class="cstat-no" title="statement not covered" >for(const o of e)<span class="cstat-no" title="statement not covered" >if(n=ti(Ue(o,t),i),void 0!==n)<span class="cstat-no" title="statement not covered" >return Xe(t,n)?Ze(i,s,t,n):n}</span></span></span>(s,e,t,i))</span>),</span>getOwnPropertyDescriptor:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Reflect.getOwnPropertyDescriptor(t._scopes[0],e),</span>getPrototypeOf:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Reflect.getPrototypeOf(t[0]),</span>has:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >ei(t).includes(e),</span>ownKeys:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >ei(t),<span class="fstat-no" title="function not covered" ></span>se</span>t(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t._storage||(t._storage=n());<span class="cstat-no" title="statement not covered" ></span>return t[e]=s[e]=i,delete t._keys,!0}</span>})}</span>function <span class="fstat-no" title="function not covered" >$e(</span>t,e,i,s){const a=<span class="cstat-no" title="statement not covered" >{_cacheable:!1,_proxy:t,_context:e,_subProxy:i,_stack:new Set,_descriptors:Ye(t,s),setContext:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >$e(t,e,i,s),</span>override:<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >$e(t.override(n),e,i,s)}</span>;<span class="cstat-no" title="statement not covered" ></span>return new Proxy(a,{deleteProperty:<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;(<span class="cstat-no" title="statement not covered" >delete e[i],delete t[i],!0)</span>,get:<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >qe(t,e,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{_proxy:s,_context:a,_subProxy:r,_descriptors:l}=<span class="cstat-no" title="statement not covered" >t;</span>let h=<span class="cstat-no" title="statement not covered" >s[e];<span class="cstat-no" title="statement not covered" ></span>S(h)&amp;&amp;l.isScriptable(e)&amp;&amp;(h=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{_proxy:n,_context:o,_subProxy:a,_stack:r}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(r.has(t))<span class="cstat-no" title="statement not covered" >throw new Error("Recursion detected: "+Array.from(r).join("-&gt;")+"-&gt;"+t);<span class="cstat-no" title="statement not covered" >r</span></span>.add(t);l</span>et l=<span class="cstat-no" title="statement not covered" >e(o,a||s);<span class="cstat-no" title="statement not covered" ></span>r.delete(t),Xe(t,l)&amp;&amp;(l=Ze(n._scopes,n,t,l));<span class="cstat-no" title="statement not covered" >r</span>eturn l}</span>(e,h,t,i));<span class="cstat-no" title="statement not covered" >n</span>(h)&amp;&amp;h.length&amp;&amp;(h=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{_proxy:n,_context:a,_subProxy:r,_descriptors:l}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==a.index&amp;&amp;s(t))<span class="cstat-no" title="statement not covered" >return e[a.index%e.length];<span class="cstat-no" title="statement not covered" >i</span></span>f(o(e[0])){const i=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >n._scopes.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t!==i)</span>);<span class="cstat-no" title="statement not covered" ></span>e=[];<span class="cstat-no" title="statement not covered" >f</span>or(const o of i){const i=<span class="cstat-no" title="statement not covered" >Ze(s,n,t,o);<span class="cstat-no" title="statement not covered" ></span>e.push($e(i,a,r&amp;&amp;r[t],l))}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>(e,h,t,l.isIndexable));<span class="cstat-no" title="statement not covered" >X</span>e(e,h)&amp;&amp;(h=$e(h,a,r&amp;&amp;r[e],l));<span class="cstat-no" title="statement not covered" >r</span>eturn h}</span>(t,e,i))</span>),</span>getOwnPropertyDescriptor:<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >e._descriptors.allKeys?Reflect.has(t,i)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(t,i),</span>getPrototypeOf:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Reflect.getPrototypeOf(t),</span>has:<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >Reflect.has(t,i),</span>ownKeys:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Reflect.ownKeys(t),</span>set:<span class="fstat-no" title="function not covered" >(e</span>,i,s)=&gt;(<span class="cstat-no" title="statement not covered" >t[i]=s,delete e[i],!0)</span>})}</span>function <span class="fstat-no" title="function not covered" >Ye(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >{scriptable:!0,indexable:!0})</span>{const{_scriptable:i=<span class="branch-0 cbranch-no" title="branch not covered" >e.scriptable,</span>_indexable:s=<span class="branch-0 cbranch-no" title="branch not covered" >e.indexable,</span>_allKeys:n=<span class="branch-0 cbranch-no" title="branch not covered" >e.allKeys}</span>=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return{allKeys:n,scriptable:i,indexable:s,isScriptable:S(i)?i:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i,</span>isIndexable:S(s)?s:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s}</span>}</span>const Ue=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t?t+w(e):e,</span></span>Xe=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >o(e)&amp;&amp;"adapters"!==t&amp;&amp;(null===Object.getPrototypeOf(e)||e.constructor===Object);</span></span>function <span class="fstat-no" title="function not covered" >qe(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(Object.prototype.hasOwnProperty.call(t,e)||"constructor"===e)<span class="cstat-no" title="statement not covered" >return t[e];c</span></span>onst s=<span class="cstat-no" title="statement not covered" >i();<span class="cstat-no" title="statement not covered" ></span>return t[e]=s,s}</span>function <span class="fstat-no" title="function not covered" >Ke(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return S(t)?t(e,i):t}</span>const Ge=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >!0===t?e:"string"==typeof t?M(e,t):void 0;</span></span>function <span class="fstat-no" title="function not covered" >Je(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >for(const o of e){const e=<span class="cstat-no" title="statement not covered" >Ge(i,o);<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >t.add(e);c</span>onst o=<span class="cstat-no" title="statement not covered" >Ke(e._fallback,i,n);<span class="cstat-no" title="statement not covered" ></span>if(void 0!==o&amp;&amp;o!==i&amp;&amp;o!==s)<span class="cstat-no" title="statement not covered" >return o}</span></span>else <span class="cstat-no" title="statement not covered" >if(!1===e&amp;&amp;void 0!==s&amp;&amp;i!==s)<span class="cstat-no" title="statement not covered" >return null}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >Ze(</span>t,e,i,s){const a=<span class="cstat-no" title="statement not covered" >e._rootScopes,</span>r=<span class="cstat-no" title="statement not covered" >Ke(e._fallback,i,s),</span>l=<span class="cstat-no" title="statement not covered" >[...t,...a],</span>h=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>h.add(s);l</span>et c=<span class="cstat-no" title="statement not covered" >Qe(h,l,i,r||i,s);<span class="cstat-no" title="statement not covered" ></span>return null!==c&amp;&amp;((void 0===r||r===i||(c=Qe(h,l,r,c,s),null!==c))&amp;&amp;je(Array.from(h),[""],a,r,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t._getTarget();<span class="cstat-no" title="statement not covered" ></span>e in s||(s[e]={});c</span>onst a=<span class="cstat-no" title="statement not covered" >s[e];<span class="cstat-no" title="statement not covered" ></span>if(n(a)&amp;&amp;o(i))<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >r</span></span>eturn a||{}}</span>(e,i,s))</span>))}</span>function <span class="fstat-no" title="function not covered" >Qe(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >for(;i;)<span class="cstat-no" title="statement not covered" >i=Je(t,e,i,s,n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >ti(</span>t,e){<span class="cstat-no" title="statement not covered" >for(const i of e){<span class="cstat-no" title="statement not covered" >if(!i)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>if(void 0!==e)<span class="cstat-no" title="statement not covered" >return e}</span></span>}</span>function <span class="fstat-no" title="function not covered" >ei(</span>t){let e=<span class="cstat-no" title="statement not covered" >t._keys;<span class="cstat-no" title="statement not covered" ></span>return e||(e=t._keys=<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>for(const i of t)<span class="cstat-no" title="statement not covered" >for(const t of Object.keys(i).filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.startsWith("_"))</span>))<span class="cstat-no" title="statement not covered" >e.add(t);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn Array.from(e)}</span>(t._scopes)),e}</span>function <span class="fstat-no" title="function not covered" >ii(</span>t,e,i,s){const{iScale:n}=<span class="cstat-no" title="statement not covered" >t,</span>{key:o=<span class="branch-0 cbranch-no" title="branch not covered" >"r"}</span>=<span class="cstat-no" title="statement not covered" >this._parsing,</span>a=<span class="cstat-no" title="statement not covered" >new Array(s);</span>let r,l,h,c;<span class="cstat-no" title="statement not covered" >for(r=0,l=s;r&lt;l;++r)<span class="cstat-no" title="statement not covered" >h=r+i,c=e[h],a[r]={r:n.parse(M(c,o),h)};<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>const si=<span class="cstat-no" title="statement not covered" >Number.EPSILON||1e-14,</span>ni=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e&lt;t.length&amp;&amp;!t[e].skip&amp;&amp;t[e],</span></span>oi=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"x"===t?"y":"x";</span></span>function <span class="fstat-no" title="function not covered" >ai(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.skip?e:t,</span>o=<span class="cstat-no" title="statement not covered" >e,</span>a=<span class="cstat-no" title="statement not covered" >i.skip?e:i,</span>r=<span class="cstat-no" title="statement not covered" >q(o,n),</span>l=<span class="cstat-no" title="statement not covered" >q(a,o);</span>let h=<span class="cstat-no" title="statement not covered" >r/(r+l),</span>c=<span class="cstat-no" title="statement not covered" >l/(r+l);<span class="cstat-no" title="statement not covered" ></span>h=isNaN(h)?0:h,c=isNaN(c)?0:c;c</span>onst d=<span class="cstat-no" title="statement not covered" >s*h,</span>u=<span class="cstat-no" title="statement not covered" >s*c;<span class="cstat-no" title="statement not covered" ></span>return{previous:{x:o.x-d*(a.x-n.x),y:o.y-d*(a.y-n.y)},next:{x:o.x+u*(a.x-n.x),y:o.y+u*(a.y-n.y)}}}</span>function <span class="fstat-no" title="function not covered" >ri(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >"x")</span>{const i=<span class="cstat-no" title="statement not covered" >oi(e),</span>s=<span class="cstat-no" title="statement not covered" >t.length,</span>n=<span class="cstat-no" title="statement not covered" >Array(s).fill(0),</span>o=<span class="cstat-no" title="statement not covered" >Array(s);</span>let a,r,l,h=<span class="cstat-no" title="statement not covered" >ni(t,0);<span class="cstat-no" title="statement not covered" ></span>for(a=0;a&lt;s;++a)<span class="cstat-no" title="statement not covered" >if(r=l,l=h,h=ni(t,a+1),l){<span class="cstat-no" title="statement not covered" >if(h){const t=<span class="cstat-no" title="statement not covered" >h[e]-l[e];<span class="cstat-no" title="statement not covered" ></span>n[a]=0!==t?(h[i]-l[i])/t:0}<span class="cstat-no" title="statement not covered" ></span>o</span>[a]=r?h?F(n[a-1])!==F(n[a])?0:(n[a-1]+n[a])/2:n[a-1]:n[a]}<span class="cstat-no" title="statement not covered" ></span>!<span class="fstat-no" title="function not covered" ></span></span>fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.length;</span>let n,o,a,r,l,h=<span class="cstat-no" title="statement not covered" >ni(t,0);<span class="cstat-no" title="statement not covered" ></span>for(let c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;s-1;++c)<span class="cstat-no" title="statement not covered" >l=h,h=ni(t,c+1),l&amp;&amp;h&amp;&amp;(V(e[c],0,si)?i[c]=i[c+1]=0:(n=i[c]/e[c],o=i[c+1]/e[c],r=Math.pow(n,2)+Math.pow(o,2),r&lt;=9||(a=3/Math.sqrt(r),i[c]=n*a*e[c],i[c+1]=o*a*e[c])))}</span></span>(t,n,o),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >"x")</span>{const s=<span class="cstat-no" title="statement not covered" >oi(i),</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>let o,a,r,l=<span class="cstat-no" title="statement not covered" >ni(t,0);<span class="cstat-no" title="statement not covered" ></span>for(let h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;n;++h){<span class="cstat-no" title="statement not covered" >if(a=r,r=l,l=ni(t,h+1),!r)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >r[i],</span>c=<span class="cstat-no" title="statement not covered" >r[s];<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;(o=(n-a[i])/3,r[`cp1${i}`]=n-o,r[`cp1${s}`]=c-o*e[h]),l&amp;&amp;(o=(l[i]-n)/3,r[`cp2${i}`]=n+o,r[`cp2${s}`]=c+o*e[h])}</span>}</span>(t,o,e)}</span>function <span class="fstat-no" title="function not covered" >li(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return Math.max(Math.min(t,i),e)}</span>function <span class="fstat-no" title="function not covered" >hi(</span>t,e,i,s,n){let o,a,r,l;<span class="cstat-no" title="statement not covered" >if(e.spanGaps&amp;&amp;(t=t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.skip)</span>)),"monotone"===e.cubicInterpolationMode)<span class="cstat-no" title="statement not covered" >ri(t,n);e</span>lse{let i=<span class="cstat-no" title="statement not covered" >s?t[t.length-1]:t[0];<span class="cstat-no" title="statement not covered" ></span>for(o=0,a=t.length;o&lt;a;++o)<span class="cstat-no" title="statement not covered" >r=t[o],l=ai(i,r,t[Math.min(o+1,a-(s?0:1))%a],e.tension),r.cp1x=l.previous.x,r.cp1y=l.previous.y,r.cp2x=l.next.x,r.cp2y=l.next.y,i=r}<span class="cstat-no" title="statement not covered" ></span></span>e</span>.capBezierPoints&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i,s,n,o,a,r=<span class="cstat-no" title="statement not covered" >Re(t[0],e);<span class="cstat-no" title="statement not covered" ></span>for(i=0,s=t.length;i&lt;s;++i)<span class="cstat-no" title="statement not covered" >a=o,o=r,r=i&lt;s-1&amp;&amp;Re(t[i+1],e),o&amp;&amp;(n=t[i],a&amp;&amp;(n.cp1x=li(n.cp1x,e.left,e.right),n.cp1y=li(n.cp1y,e.top,e.bottom)),r&amp;&amp;(n.cp2x=li(n.cp2x,e.left,e.right),n.cp2y=li(n.cp2y,e.top,e.bottom)))}</span></span>(t,i)}</span>const ci=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0===t||1===t,</span></span>di=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >-Math.pow(2,10*(t-=1))*Math.sin((t-e)*O/i),</span></span>ui=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >Math.pow(2,-10*t)*Math.sin((t-e)*O/i)+1,</span></span>fi=<span class="cstat-no" title="statement not covered" >{linear:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t,</span>easeInQuad:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t*t,</span>easeOutQuad:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >-t*(t-2),</span>easeInOutQuad:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t/=.5)&lt;1?.5*t*t:-.5*(--t*(t-2)-1),</span>easeInCubic:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t*t*t,</span>easeOutCubic:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t-=1)*t*t+1,</span>easeInOutCubic:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t/=.5)&lt;1?.5*t*t*t:.5*((t-=2)*t*t+2),</span>easeInQuart:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t*t*t*t,</span>easeOutQuart:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >-((t-=1)*t*t*t-1),</span>easeInOutQuart:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t/=.5)&lt;1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2),</span>easeInQuint:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t*t*t*t*t,</span>easeOutQuint:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t-=1)*t*t*t*t+1,</span>easeInOutQuint:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t/=.5)&lt;1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2),</span>easeInSine:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >1-Math.cos(t*E),</span>easeOutSine:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.sin(t*E),</span>easeInOutSine:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >-.5*(Math.cos(C*t)-1),</span>easeInExpo:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0===t?0:Math.pow(2,10*(t-1)),</span>easeOutExpo:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >1===t?1:1-Math.pow(2,-10*t),</span>easeInOutExpo:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >ci(t)?t:t&lt;.5?.5*Math.pow(2,10*(2*t-1)):.5*(2-Math.pow(2,-10*(2*t-1))),</span>easeInCirc:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&gt;=1?t:-(Math.sqrt(1-t*t)-1),</span>easeOutCirc:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.sqrt(1-(t-=1)*t),</span>easeInOutCirc:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t/=.5)&lt;1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1),</span>easeInElastic:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >ci(t)?t:di(t,.075,.3),</span>easeOutElastic:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >ci(t)?t:ui(t,.075,.3),<span class="fstat-no" title="function not covered" ></span>ea</span>seInOutElastic(t){const e=<span class="cstat-no" title="statement not covered" >.1125;<span class="cstat-no" title="statement not covered" ></span>return ci(t)?t:t&lt;.5?.5*di(2*t,e,.45):.5+.5*ui(2*t-1,e,.45)}</span>,<span class="fstat-no" title="function not covered" >ea</span>seInBack(t){const e=<span class="cstat-no" title="statement not covered" >1.70158;<span class="cstat-no" title="statement not covered" ></span>return t*t*((e+1)*t-e)}</span>,<span class="fstat-no" title="function not covered" >ea</span>seOutBack(t){const e=<span class="cstat-no" title="statement not covered" >1.70158;<span class="cstat-no" title="statement not covered" ></span>return(t-=1)*t*((e+1)*t+e)+1}</span>,<span class="fstat-no" title="function not covered" >ea</span>seInOutBack(t){let e=<span class="cstat-no" title="statement not covered" >1.70158;<span class="cstat-no" title="statement not covered" ></span>return(t/=.5)&lt;1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)}</span>,easeInBounce:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >1-fi.easeOutBounce(1-t),<span class="fstat-no" title="function not covered" ></span>ea</span>seOutBounce(t){const e=<span class="cstat-no" title="statement not covered" >7.5625,</span>i=<span class="cstat-no" title="statement not covered" >2.75;<span class="cstat-no" title="statement not covered" ></span>return t&lt;1/i?e*t*t:t&lt;2/i?e*(t-=1.5/i)*t+.75:t&lt;2.5/i?e*(t-=2.25/i)*t+.9375:e*(t-=2.625/i)*t+.984375}</span>,easeInOutBounce:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&lt;.5?.5*fi.easeInBounce(2*t):.5*fi.easeOutBounce(2*t-1)+.5}</span>;</span>function <span class="fstat-no" title="function not covered" >gi(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return{x:t.x+i*(e.x-t.x),y:t.y+i*(e.y-t.y)}}</span>function <span class="fstat-no" title="function not covered" >pi(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return{x:t.x+i*(e.x-t.x),y:"middle"===s?i&lt;.5?t.y:e.y:"after"===s?i&lt;1?t.y:e.y:i&gt;0?e.y:t.y}}</span>function <span class="fstat-no" title="function not covered" >mi(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >{x:t.cp2x,y:t.cp2y},</span>o=<span class="cstat-no" title="statement not covered" >{x:e.cp1x,y:e.cp1y},</span>a=<span class="cstat-no" title="statement not covered" >gi(t,n,i),</span>r=<span class="cstat-no" title="statement not covered" >gi(n,o,i),</span>l=<span class="cstat-no" title="statement not covered" >gi(o,e,i),</span>h=<span class="cstat-no" title="statement not covered" >gi(a,r,i),</span>c=<span class="cstat-no" title="statement not covered" >gi(r,l,i);<span class="cstat-no" title="statement not covered" ></span>return gi(h,c,i)}</span>const xi=<span class="cstat-no" title="statement not covered" >/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,</span>bi=<span class="cstat-no" title="statement not covered" >/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;</span>function <span class="fstat-no" title="function not covered" >_i(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >(""+t).match(xi);<span class="cstat-no" title="statement not covered" ></span>if(!i||"normal"===i[1])<span class="cstat-no" title="statement not covered" >return 1.2*e;<span class="cstat-no" title="statement not covered" >s</span></span>witch(t=+i[2],i[3]){case"px":<span class="cstat-no" title="statement not covered" >return t;c</span>ase"%":<span class="cstat-no" title="statement not covered" >t/=100}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e*t}</span>const yi=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >+t||0;</span></span>function <span class="fstat-no" title="function not covered" >vi(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >{},</span>s=<span class="cstat-no" title="statement not covered" >o(e),</span>n=<span class="cstat-no" title="statement not covered" >s?Object.keys(e):e,</span>a=<span class="cstat-no" title="statement not covered" >o(t)?s?<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >l(t[i],t[e[i]]):<span class="fstat-no" title="function not covered" ></span>e=</span>&gt;<span class="cstat-no" title="statement not covered" >t[e]:<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span></span>for(const t of n)<span class="cstat-no" title="statement not covered" >i[t]=yi(a(t));<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >Mi(</span>t){<span class="cstat-no" title="statement not covered" >return vi(t,{top:"y",right:"x",bottom:"y",left:"x"})}</span>function <span class="fstat-no" title="function not covered" >wi(</span>t){<span class="cstat-no" title="statement not covered" >return vi(t,["topLeft","topRight","bottomLeft","bottomRight"])}</span>function <span class="fstat-no" title="function not covered" >ki(</span>t){const e=<span class="cstat-no" title="statement not covered" >Mi(t);<span class="cstat-no" title="statement not covered" ></span>return e.width=e.left+e.right,e.height=e.top+e.bottom,e}</span>function <span class="fstat-no" title="function not covered" >Si(</span>t,e){<span class="cstat-no" title="statement not covered" >t=t||{},e=e||ue.font;l</span>et i=<span class="cstat-no" title="statement not covered" >l(t.size,e.size);<span class="cstat-no" title="statement not covered" ></span>"string"==typeof i&amp;&amp;(i=parseInt(i,10));l</span>et s=<span class="cstat-no" title="statement not covered" >l(t.style,e.style);<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;!(""+s).match(bi)&amp;&amp;(console.warn('Invalid font style specified: "'+s+'"'),s=void 0);c</span>onst n=<span class="cstat-no" title="statement not covered" >{family:l(t.family,e.family),lineHeight:_i(l(t.lineHeight,e.lineHeight),i),size:i,style:s,weight:l(t.weight,e.weight),string:""};<span class="cstat-no" title="statement not covered" ></span>return n.string=De(n),n}</span>function <span class="fstat-no" title="function not covered" >Pi(</span>t,e,i,s){let o,a,r,l=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>for(o=0,a=t.length;o&lt;a;++o)<span class="cstat-no" title="statement not covered" >if(r=t[o],void 0!==r&amp;&amp;(void 0!==e&amp;&amp;"function"==typeof r&amp;&amp;(r=r(e),l=!1),void 0!==i&amp;&amp;n(r)&amp;&amp;(r=r[i%r.length],l=!1),void 0!==r))<span class="cstat-no" title="statement not covered" >return s&amp;&amp;!l&amp;&amp;(s.cacheable=!1),r}</span></span></span>function <span class="fstat-no" title="function not covered" >Di(</span>t,e,i){const{min:s,max:n}=<span class="cstat-no" title="statement not covered" >t,</span>o=<span class="cstat-no" title="statement not covered" >c(e,(n-s)/2),</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >i&amp;&amp;0===t?0:t+e;<span class="cstat-no" title="statement not covered" ></span></span>return{min:a(s,-Math.abs(o)),max:a(n,o)}}</span>function <span class="fstat-no" title="function not covered" >Ci(</span>t,e){<span class="cstat-no" title="statement not covered" >return Object.assign(Object.create(t),e)}</span>function <span class="fstat-no" title="function not covered" >Oi(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return t?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return{x:<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >t+t+e-i,<span class="fstat-no" title="function not covered" ></span>se</span>tWidth(t){<span class="cstat-no" title="statement not covered" >e=t}</span>,textAlign:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"center"===t?t:"right"===t?"left":"right",</span>xPlus:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e,</span>leftForLtr:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e}</span>}</span>(e,i):{x:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t,<span class="fstat-no" title="function not covered" ></span>se</span>tWidth(t){},textAlign:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t,</span>xPlus:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t+e,</span>leftForLtr:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t}</span>}</span>function <span class="fstat-no" title="function not covered" >Ai(</span>t,e){let i,s;<span class="cstat-no" title="statement not covered" >"ltr"!==e&amp;&amp;"rtl"!==e||(i=t.canvas.style,s=[i.getPropertyValue("direction"),i.getPropertyPriority("direction")],i.setProperty("direction",e,"important"),t.prevTextDirection=s)}</span>function <span class="fstat-no" title="function not covered" >Ti(</span>t,e){<span class="cstat-no" title="statement not covered" >void 0!==e&amp;&amp;(delete t.prevTextDirection,t.canvas.style.setProperty("direction",e[0],e[1]))}</span>function <span class="fstat-no" title="function not covered" >Li(</span>t){<span class="cstat-no" title="statement not covered" >return"angle"===t?{between:J,compare:K,normalize:G}:{between:tt,compare:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e,</span>normalize:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t}</span>}</span>function <span class="fstat-no" title="function not covered" >Ei(</span>{start:t,end:e,count:i,loop:s,style:n}){<span class="cstat-no" title="statement not covered" >return{start:t%i,end:e%i,loop:s&amp;&amp;(e-t+1)%i==0,style:n}}</span>function <span class="fstat-no" title="function not covered" >Ri(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(!i)<span class="cstat-no" title="statement not covered" >return[t];c</span></span>onst{property:s,start:n,end:o}=<span class="cstat-no" title="statement not covered" >i,</span>a=<span class="cstat-no" title="statement not covered" >e.length,</span>{compare:r,between:l,normalize:h}=<span class="cstat-no" title="statement not covered" >Li(s),</span>{start:c,end:d,loop:u,style:f}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{property:s,start:n,end:o}=<span class="cstat-no" title="statement not covered" >i,</span>{between:a,normalize:r}=<span class="cstat-no" title="statement not covered" >Li(s),</span>l=<span class="cstat-no" title="statement not covered" >e.length;</span>let h,c,{start:d,end:u,loop:f}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(f){<span class="cstat-no" title="statement not covered" >for(d+=l,u+=l,h=0,c=l;h&lt;c&amp;&amp;a(r(e[d%l][s]),n,o);++h)<span class="cstat-no" title="statement not covered" >d--,u--;<span class="cstat-no" title="statement not covered" >d</span></span>%=l,u%=l}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn u&lt;d&amp;&amp;(u+=l),{start:d,end:u,loop:f,style:t.style}}</span>(t,e,i),</span>g=<span class="cstat-no" title="statement not covered" >[];</span>let p,m,x,b=<span class="cstat-no" title="statement not covered" >!1,</span>_=<span class="cstat-no" title="statement not covered" >null;</span>const y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >b||l(n,x,p)&amp;&amp;0!==r(n,x),</span></span>v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!b||0===r(o,p)||l(o,x,p);<span class="cstat-no" title="statement not covered" ></span></span>for(let t=<span class="cstat-no" title="statement not covered" >c,</span>i=<span class="cstat-no" title="statement not covered" >c;</span>t&lt;=d;++t)<span class="cstat-no" title="statement not covered" >m=e[t%a],m.skip||(p=h(m[s]),p!==x&amp;&amp;(b=l(p,n,o),null===_&amp;&amp;y()&amp;&amp;(_=0===r(p,n)?t:i),null!==_&amp;&amp;v()&amp;&amp;(g.push(Ei({start:_,end:t,loop:u,count:a,style:f})),_=null),i=t,x=p));<span class="cstat-no" title="statement not covered" >r</span></span>eturn null!==_&amp;&amp;g.push(Ei({start:_,end:d,loop:u,count:a,style:f})),g}</span>function <span class="fstat-no" title="function not covered" >Ii(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >t.segments;<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;s.length;n++){const o=<span class="cstat-no" title="statement not covered" >Ri(s[n],t.points,e);<span class="cstat-no" title="statement not covered" ></span>o.length&amp;&amp;i.push(...o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>function <span class="fstat-no" title="function not covered" >zi(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.points,</span>s=<span class="cstat-no" title="statement not covered" >t.options.spanGaps,</span>n=<span class="cstat-no" title="statement not covered" >i.length;<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return[];c</span></span>onst o=<span class="cstat-no" title="statement not covered" >!!t._loop,</span>{start:a,end:r}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >e-1;<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;!s)<span class="cstat-no" title="statement not covered" >for(;n&lt;e&amp;&amp;!t[n].skip;)<span class="cstat-no" title="statement not covered" >n++;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(;n&lt;e&amp;&amp;t[n].skip;)<span class="cstat-no" title="statement not covered" >n++;<span class="cstat-no" title="statement not covered" >f</span></span>or(n%=e,i&amp;&amp;(o+=n);o&gt;n&amp;&amp;t[o%e].skip;)<span class="cstat-no" title="statement not covered" >o--;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o%=e,{start:n,end:o}}</span>(i,n,o,s);<span class="cstat-no" title="statement not covered" ></span>if(!0===s)<span class="cstat-no" title="statement not covered" >return Fi(t,[{start:a,end:r,loop:o}],i,e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn Fi(t,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.length,</span>o=<span class="cstat-no" title="statement not covered" >[];</span>let a,r=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>for(a=e+1;a&lt;=i;++a){const i=<span class="cstat-no" title="statement not covered" >t[a%n];<span class="cstat-no" title="statement not covered" ></span>i.skip||i.stop?l.skip||(s=!1,o.push({start:e%n,end:(a-1)%n,loop:s}),e=r=i.stop?a:null):(r=a,l.skip&amp;&amp;(e=a)),l=i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null!==r&amp;&amp;o.push({start:e%n,end:r%n,loop:s}),o}</span>(i,a,r&lt;a?r+n:r,!!t._fullLoop&amp;&amp;0===a&amp;&amp;r===n-1),i,e)}</span>function <span class="fstat-no" title="function not covered" >Fi(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return s&amp;&amp;s.setContext&amp;&amp;i?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t._chart.getContext(),</span>o=<span class="cstat-no" title="statement not covered" >Vi(t.options),</span>{_datasetIndex:a,options:{spanGaps:r}}=<span class="cstat-no" title="statement not covered" >t,</span>l=<span class="cstat-no" title="statement not covered" >i.length,</span>h=<span class="cstat-no" title="statement not covered" >[];</span>let c=<span class="cstat-no" title="statement not covered" >o,</span>d=<span class="cstat-no" title="statement not covered" >e[0].start,</span>u=<span class="cstat-no" title="statement not covered" >d;</span>function <span class="fstat-no" title="function not covered" >f(</span>t,e,s,n){const o=<span class="cstat-no" title="statement not covered" >r?-1:1;<span class="cstat-no" title="statement not covered" ></span>if(t!==e){<span class="cstat-no" title="statement not covered" >for(t+=l;i[t%l].skip;)<span class="cstat-no" title="statement not covered" >t-=o;<span class="cstat-no" title="statement not covered" >f</span></span>or(;i[e%l].skip;)<span class="cstat-no" title="statement not covered" >e+=o;<span class="cstat-no" title="statement not covered" >t</span></span>%l!=e%l&amp;&amp;(h.push({start:t%l,end:e%l,loop:s,style:n}),c=n,d=e%l)}</span>}<span class="cstat-no" title="statement not covered" ></span>for(const t of e){<span class="cstat-no" title="statement not covered" >d=r?d:t.start;l</span>et e,o=<span class="cstat-no" title="statement not covered" >i[d%l];<span class="cstat-no" title="statement not covered" ></span>for(u=d+1;u&lt;=t.end;u++){const r=<span class="cstat-no" title="statement not covered" >i[u%l];<span class="cstat-no" title="statement not covered" ></span>e=Vi(s.setContext(Ci(n,{type:"segment",p0:o,p1:r,p0DataIndex:(u-1)%l,p1DataIndex:u%l,datasetIndex:a}))),Bi(e,c)&amp;&amp;f(d,u-1,t.loop,c),o=r,c=e}<span class="cstat-no" title="statement not covered" ></span>d</span>&lt;u-1&amp;&amp;f(d,u-1,t.loop,c)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn h}</span>(t,e,i,s):e}</span>function <span class="fstat-no" title="function not covered" >Vi(</span>t){<span class="cstat-no" title="statement not covered" >return{backgroundColor:t.backgroundColor,borderCapStyle:t.borderCapStyle,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderJoinStyle:t.borderJoinStyle,borderWidth:t.borderWidth,borderColor:t.borderColor}}</span>function <span class="fstat-no" title="function not covered" >Bi(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return Zt(e)?(i.includes(e)||i.push(e),i.indexOf(e)):e}</span>;<span class="cstat-no" title="statement not covered" ></span>return JSON.stringify(t,s)!==JSON.stringify(e,s)}</span>function <span class="fstat-no" title="function not covered" >Wi(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return t.options.clip?t[i]:e[i]}</span>function <span class="fstat-no" title="function not covered" >Ni(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >e._clip;<span class="cstat-no" title="statement not covered" ></span>if(i.disabled)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{xScale:i,yScale:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;s?{left:Wi(i,e,"left"),right:Wi(i,e,"right"),top:Wi(s,e,"top"),bottom:Wi(s,e,"bottom")}:e}</span>(e,t.chartArea);<span class="cstat-no" title="statement not covered" ></span>return{left:!1===i.left?0:s.left-(!0===i.left?0:i.left),right:!1===i.right?t.width:s.right+(!0===i.right?0:i.right),top:!1===i.top?0:s.top-(!0===i.top?0:i.top),bottom:!1===i.bottom?t.height:s.bottom+(!0===i.bottom?0:i.bottom)}}</span>var Hi=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,HALF_PI:E,INFINITY:T,PI:C,PITAU:A,QUARTER_PI:R,RAD_PER_DEG:L,TAU:O,TWO_THIRDS_PI:I,_addGrace:Di,_alignPixel:Ae,_alignStartEnd:ft,_angleBetween:J,_angleDiff:K,_arrayUnique:lt,_attachContext:$e,_bezierCurveTo:Ve,_bezierInterpolation:mi,_boundSegment:Ri,_boundSegments:Ii,_capitalize:w,_computeSegments:zi,_createResolver:je,_decimalPlaces:U,_deprecated:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){<span class="cstat-no" title="statement not covered" >void 0!==e&amp;&amp;console.warn(t+': "'+i+'" is deprecated. Please use "'+s+'" instead')}</span>,_descriptors:Ye,_elementsEqual:f,_factorize:W,_filterBetween:nt,_getParentNode:ge,_getStartAndCountOfVisiblePoints:pt,_int16Range:Q,_isBetween:tt,_isClickEvent:D,_isDomSupported:fe,_isPointInArea:Re,_limitValue:Z,_longestText:Oe,_lookup:et,_lookupByKey:it,_measureText:Ce,_merger:m,_mergerIf:_,_normalizeAngle:G,_parseObjectDataRadialScale:ii,_pointInLine:gi,_readValueToProps:vi,_rlookupByKey:st,_scaleRangesChanged:mt,_setMinAndMaxByKey:j,_splitKey:v,_steppedInterpolation:pi,_steppedLineTo:Fe,_textX:gt,_toLeftRightCenter:ut,_updateBezierControlPoints:hi,addRoundedRectPath:He,almostEquals:V,almostWhole:H,callback:d,clearCanvas:Te,clipArea:Ie,clone:g,color:Qt,createContext:Ci,debounce:dt,defined:k,distanceBetweenPoints:q,drawPoint:Le,drawPointLegend:Ee,each:u,easingEffects:fi,finiteOrDefault:r,fontString:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return e+" "+t+"px "+i}</span>,formatNumber:ne,getAngleFromPoint:X,getDatasetClipArea:Ni,getHoverColor:te,getMaximumSize:we,getRelativePosition:ve,getRtlAdapter:Oi,getStyle:xe,isArray:n,isFinite:a,isFunction:S,isNullOrUndef:s,isNumber:N,isObject:o,isPatternOrGradient:Zt,listenArrayEvents:at,log10:z,merge:x,mergeIf:b,niceNum:B,noop:e,overrideTextDirection:Ai,readUsedSize:Pe,renderText:Ne,requestAnimFrame:ht,resolve:Pi,resolveObjectKey:M,restoreTextDirection:Ti,retinaScale:ke,setsEqual:P,sign:F,splineCurve:ai,splineCurveMonotone:ri,supportsEventListenerOptions:Se,throttled:ct,toDegrees:Y,toDimension:c,toFont:Si,toFontString:De,toLineHeight:_i,toPadding:ki,toPercentage:h,toRadians:$,toTRBL:Mi,toTRBLCorners:wi,uid:i,unclipArea:ze,unlistenArrayEvents:rt,valueOrDefault:l});</span>function <span class="fstat-no" title="function not covered" >ji(</span>t,e,i,n){const{controller:o,data:a,_sorted:r}=<span class="cstat-no" title="statement not covered" >t,</span>l=<span class="cstat-no" title="statement not covered" >o._cachedMeta.iScale,</span>h=<span class="cstat-no" title="statement not covered" >t.dataset&amp;&amp;t.dataset.options?t.dataset.options.spanGaps:null;<span class="cstat-no" title="statement not covered" ></span>if(l&amp;&amp;e===l.axis&amp;&amp;"r"!==e&amp;&amp;r&amp;&amp;a.length){const r=<span class="cstat-no" title="statement not covered" >l._reversePixels?st:it;<span class="cstat-no" title="statement not covered" ></span>if(!n){const n=<span class="cstat-no" title="statement not covered" >r(a,e,i);<span class="cstat-no" title="statement not covered" ></span>if(h){const{vScale:e}=<span class="cstat-no" title="statement not covered" >o._cachedMeta,</span>{_parsed:i}=<span class="cstat-no" title="statement not covered" >t,</span>a=<span class="cstat-no" title="statement not covered" >i.slice(0,n.lo+1).reverse().findIndex((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!s(t[e.axis]))</span>);<span class="cstat-no" title="statement not covered" ></span>n.lo-=Math.max(0,a);c</span>onst r=<span class="cstat-no" title="statement not covered" >i.slice(n.hi).findIndex((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!s(t[e.axis]))</span>);<span class="cstat-no" title="statement not covered" ></span>n.hi+=Math.max(0,r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o._sharedOptions){const t=<span class="cstat-no" title="statement not covered" >a[0],</span>s=<span class="cstat-no" title="statement not covered" >"function"==typeof t.getRange&amp;&amp;t.getRange(e);<span class="cstat-no" title="statement not covered" ></span>if(s){const t=<span class="cstat-no" title="statement not covered" >r(a,e,i-s),</span>n=<span class="cstat-no" title="statement not covered" >r(a,e,i+s);<span class="cstat-no" title="statement not covered" ></span>return{lo:t.lo,hi:n.hi}}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{lo:0,hi:a.length-1}}</span>function <span class="fstat-no" title="function not covered" >$i(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >t.getSortedVisibleDatasetMetas(),</span>a=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >o.length;</span>t&lt;i;++t){const{index:i,data:r}=<span class="cstat-no" title="statement not covered" >o[t],</span>{lo:l,hi:h}=<span class="cstat-no" title="statement not covered" >ji(o[t],e,a,n);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >l;</span>t&lt;=h;++t){const e=<span class="cstat-no" title="statement not covered" >r[t];<span class="cstat-no" title="statement not covered" ></span>e.skip||s(e,i,t)}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >Yi(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(!n&amp;&amp;!t.isPointInArea(e))<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >r</span></span>eturn $i(t,i,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(i,a,r){<span class="cstat-no" title="statement not covered" >(n||Re(i,t.chartArea,0))&amp;&amp;i.inRange(e.x,e.y,s)&amp;&amp;o.push({element:i,datasetIndex:a,index:r})}</span>),!0),o}</span>function <span class="fstat-no" title="function not covered" >Ui(</span>t,e,i,s,n,o){let a=<span class="cstat-no" title="statement not covered" >[];</span>const r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >-1!==t.indexOf("x"),</span>i=<span class="cstat-no" title="statement not covered" >-1!==t.indexOf("y");<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,s){const n=<span class="cstat-no" title="statement not covered" >e?Math.abs(t.x-s.x):0,</span>o=<span class="cstat-no" title="statement not covered" >i?Math.abs(t.y-s.y):0;<span class="cstat-no" title="statement not covered" ></span>return Math.sqrt(Math.pow(n,2)+Math.pow(o,2))}</span>}</span>(i);</span>let l=<span class="cstat-no" title="statement not covered" >Number.POSITIVE_INFINITY;<span class="cstat-no" title="statement not covered" ></span>return $i(t,i,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(i,h,c){const d=<span class="cstat-no" title="statement not covered" >i.inRange(e.x,e.y,n);<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;!d)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst u=<span class="cstat-no" title="statement not covered" >i.getCenterPoint(n);<span class="cstat-no" title="statement not covered" ></span>if(!(!!o||t.isPointInArea(u))&amp;&amp;!d)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst f=<span class="cstat-no" title="statement not covered" >r(e,u);<span class="cstat-no" title="statement not covered" ></span>f&lt;l?(a=[{element:i,datasetIndex:h,index:c}],l=f):f===l&amp;&amp;a.push({element:i,datasetIndex:h,index:c})}</span>)),a}</span>function <span class="fstat-no" title="function not covered" >Xi(</span>t,e,i,s,n,o){<span class="cstat-no" title="statement not covered" >return o||t.isPointInArea(e)?"r"!==i||s?Ui(t,e,i,s,n,o):<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return $i(t,i,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,o){const{startAngle:a,endAngle:r}=<span class="cstat-no" title="statement not covered" >t.getProps(["startAngle","endAngle"],s),</span>{angle:l}=<span class="cstat-no" title="statement not covered" >X(t,{x:e.x,y:e.y});<span class="cstat-no" title="statement not covered" ></span>J(l,a,r)&amp;&amp;n.push({element:t,datasetIndex:i,index:o})}</span>)),n}</span>(t,e,i,n):[]}</span>function <span class="fstat-no" title="function not covered" >qi(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >"x"===i?"inXRange":"inYRange";</span>let r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return $i(t,i,e,(<span class="fstat-no" title="function not covered" >(t</span>,s,l)=&gt;{<span class="cstat-no" title="statement not covered" >t[a]&amp;&amp;t[a](e[i],n)&amp;&amp;(o.push({element:t,datasetIndex:s,index:l}),r=r||t.inRange(e.x,e.y,n))}</span>)),s&amp;&amp;!r?[]:o}</span>var Ki=<span class="cstat-no" title="statement not covered" >{evaluateInteractionItems:$i,modes:{<span class="fstat-no" title="function not covered" >in</span>dex(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >ve(e,t),</span>o=<span class="cstat-no" title="statement not covered" >i.axis||"x",</span>a=<span class="cstat-no" title="statement not covered" >i.includeInvisible||!1,</span>r=<span class="cstat-no" title="statement not covered" >i.intersect?Yi(t,n,o,s,a):Xi(t,n,o,!1,s,a),</span>l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return r.length?(t.getSortedVisibleDatasetMetas().forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >r[0].index,</span>i=<span class="cstat-no" title="statement not covered" >t.data[e];<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;!i.skip&amp;&amp;l.push({element:i,datasetIndex:t.index,index:e})}</span>)),l):[]}</span>,<span class="fstat-no" title="function not covered" >da</span>taset(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >ve(e,t),</span>o=<span class="cstat-no" title="statement not covered" >i.axis||"xy",</span>a=<span class="cstat-no" title="statement not covered" >i.includeInvisible||!1;</span>let r=<span class="cstat-no" title="statement not covered" >i.intersect?Yi(t,n,o,s,a):Xi(t,n,o,!1,s,a);<span class="cstat-no" title="statement not covered" ></span>if(r.length&gt;0){const e=<span class="cstat-no" title="statement not covered" >r[0].datasetIndex,</span>i=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(e).data;<span class="cstat-no" title="statement not covered" ></span>r=[];<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;i.length;++t)<span class="cstat-no" title="statement not covered" >r.push({element:i[t],datasetIndex:e,index:t})}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn r}</span>,point:<span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >Yi(t,ve(e,t),i.axis||"xy",s,i.includeInvisible||!1),<span class="fstat-no" title="function not covered" ></span>ne</span>arest(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >ve(e,t),</span>o=<span class="cstat-no" title="statement not covered" >i.axis||"xy",</span>a=<span class="cstat-no" title="statement not covered" >i.includeInvisible||!1;<span class="cstat-no" title="statement not covered" ></span>return Xi(t,n,o,i.intersect,s,a)}</span>,x:<span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >qi(t,ve(e,t),"x",i.intersect,s),</span>y:<span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >qi(t,ve(e,t),"y",i.intersect,s)}</span>};</span>const Gi=<span class="cstat-no" title="statement not covered" >["left","top","right","bottom"];</span>function <span class="fstat-no" title="function not covered" >Ji(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.pos===e)</span>)}</span>function <span class="fstat-no" title="function not covered" >Zi(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >-1===Gi.indexOf(t.pos)&amp;&amp;t.box.axis===e)</span>)}</span>function <span class="fstat-no" title="function not covered" >Qi(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.sort((<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;{const s=<span class="cstat-no" title="statement not covered" >e?i:t,</span>n=<span class="cstat-no" title="statement not covered" >e?t:i;<span class="cstat-no" title="statement not covered" ></span>return s.weight===n.weight?s.index-n.index:s.weight-n.weight}</span>))}</span>function <span class="fstat-no" title="function not covered" >ts(</span>t,e){const i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const i of t){const{stack:t,pos:s,stackWeight:n}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(!t||!Gi.includes(s))<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >e[t]||(e[t]={count:0,placed:0,weight:0,size:0});<span class="cstat-no" title="statement not covered" ></span>o.count++,o.weight+=n}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>(t),</span>{vBoxMaxWidth:s,hBoxMaxHeight:n}=<span class="cstat-no" title="statement not covered" >e;</span>let o,a,r;<span class="cstat-no" title="statement not covered" >for(o=0,a=t.length;o&lt;a;++o){<span class="cstat-no" title="statement not covered" >r=t[o];c</span>onst{fullSize:a}=<span class="cstat-no" title="statement not covered" >r.box,</span>l=<span class="cstat-no" title="statement not covered" >i[r.stack],</span>h=<span class="cstat-no" title="statement not covered" >l&amp;&amp;r.stackWeight/l.weight;<span class="cstat-no" title="statement not covered" ></span>r.horizontal?(r.width=h?h*s:a&amp;&amp;e.availableWidth,r.height=n):(r.width=s,r.height=h?h*n:a&amp;&amp;e.availableHeight)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>function <span class="fstat-no" title="function not covered" >es(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return Math.max(t[i],e[i])+Math.max(t[s],e[s])}</span>function <span class="fstat-no" title="function not covered" >is(</span>t,e){<span class="cstat-no" title="statement not covered" >t.top=Math.max(t.top,e.top),t.left=Math.max(t.left,e.left),t.bottom=Math.max(t.bottom,e.bottom),t.right=Math.max(t.right,e.right)}</span>function <span class="fstat-no" title="function not covered" >ss(</span>t,e,i,s){const{pos:n,box:a}=<span class="cstat-no" title="statement not covered" >i,</span>r=<span class="cstat-no" title="statement not covered" >t.maxPadding;<span class="cstat-no" title="statement not covered" ></span>if(!o(n)){<span class="cstat-no" title="statement not covered" >i.size&amp;&amp;(t[n]-=i.size);c</span>onst e=<span class="cstat-no" title="statement not covered" >s[i.stack]||{size:0,count:1};<span class="cstat-no" title="statement not covered" ></span>e.size=Math.max(e.size,i.horizontal?a.height:a.width),i.size=e.size/e.count,t[n]+=i.size}<span class="cstat-no" title="statement not covered" ></span>a</span>.getPadding&amp;&amp;is(r,a.getPadding());c</span>onst l=<span class="cstat-no" title="statement not covered" >Math.max(0,e.outerWidth-es(r,t,"left","right")),</span>h=<span class="cstat-no" title="statement not covered" >Math.max(0,e.outerHeight-es(r,t,"top","bottom")),</span>c=<span class="cstat-no" title="statement not covered" >l!==t.w,</span>d=<span class="cstat-no" title="statement not covered" >h!==t.h;<span class="cstat-no" title="statement not covered" ></span>return t.w=l,t.h=h,i.horizontal?{same:c,other:d}:{same:d,other:c}}</span>function <span class="fstat-no" title="function not covered" >ns(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >e.maxPadding;</span>function <span class="fstat-no" title="function not covered" >s(</span>t){const s=<span class="cstat-no" title="statement not covered" >{left:0,top:0,right:0,bottom:0};<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >s[t]=Math.max(e[t],i[t])}</span>)),s}<span class="cstat-no" title="statement not covered" ></span>return s(t?["left","right"]:["top","bottom"])}</span>function <span class="fstat-no" title="function not covered" >os(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >[];</span>let o,a,r,l,h,c;<span class="cstat-no" title="statement not covered" >for(o=0,a=t.length,h=0;o&lt;a;++o){<span class="cstat-no" title="statement not covered" >r=t[o],l=r.box,l.update(r.width||e.w,r.height||e.h,ns(r.horizontal,e));c</span>onst{same:a,other:d}=<span class="cstat-no" title="statement not covered" >ss(e,i,r,s);<span class="cstat-no" title="statement not covered" ></span>h|=a&amp;&amp;n.length,c=c||d,l.fullSize||n.push(r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn h&amp;&amp;os(n,e,i,s)||c}</span>function <span class="fstat-no" title="function not covered" >as(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >t.top=i,t.left=e,t.right=e+s,t.bottom=i+n,t.width=s,t.height=n}</span>function <span class="fstat-no" title="function not covered" >rs(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >i.padding;</span>let{x:o,y:a}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>for(const r of t){const t=<span class="cstat-no" title="statement not covered" >r.box,</span>l=<span class="cstat-no" title="statement not covered" >s[r.stack]||{count:1,placed:0,weight:1},</span>h=<span class="cstat-no" title="statement not covered" >r.stackWeight/l.weight||1;<span class="cstat-no" title="statement not covered" ></span>if(r.horizontal){const s=<span class="cstat-no" title="statement not covered" >e.w*h,</span>o=<span class="cstat-no" title="statement not covered" >l.size||t.height;<span class="cstat-no" title="statement not covered" ></span>k(l.start)&amp;&amp;(a=l.start),t.fullSize?as(t,n.left,a,i.outerWidth-n.right-n.left,o):as(t,e.left+l.placed,a,s,o),l.start=a,l.placed+=s,a=t.bottom}</span>else{const s=<span class="cstat-no" title="statement not covered" >e.h*h,</span>a=<span class="cstat-no" title="statement not covered" >l.size||t.width;<span class="cstat-no" title="statement not covered" ></span>k(l.start)&amp;&amp;(o=l.start),t.fullSize?as(t,o,n.top,a,i.outerHeight-n.bottom-n.top):as(t,o,e.top+l.placed,a,s),l.start=o,l.placed+=s,o=t.right}</span>}<span class="cstat-no" title="statement not covered" ></span>e</span>.x=o,e.y=a}</span>var ls=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >ad</span>dBox(t,e){<span class="cstat-no" title="statement not covered" >t.boxes||(t.boxes=[]),e.fullSize=e.fullSize||!1,e.position=e.position||"top",e.weight=e.weight||0,e._layers=e._layers||<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[{z:0,<span class="fstat-no" title="function not covered" >dr</span>aw(t){<span class="cstat-no" title="statement not covered" >e.draw(t)}</span>}]}</span>,t.boxes.push(e)}</span>,<span class="fstat-no" title="function not covered" >re</span>moveBox(t,e){const i=<span class="cstat-no" title="statement not covered" >t.boxes?t.boxes.indexOf(e):-1;<span class="cstat-no" title="statement not covered" ></span>-1!==i&amp;&amp;t.boxes.splice(i,1)}</span>,<span class="fstat-no" title="function not covered" >co</span>nfigure(t,e,i){<span class="cstat-no" title="statement not covered" >e.fullSize=i.fullSize,e.position=i.position,e.weight=i.weight}</span>,<span class="fstat-no" title="function not covered" >up</span>date(t,e,i,s){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >ki(t.options.layout.padding),</span>o=<span class="cstat-no" title="statement not covered" >Math.max(e-n.width,0),</span>a=<span class="cstat-no" title="statement not covered" >Math.max(i-n.height,0),</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >[];</span>let i,s,n,o,a,r;<span class="cstat-no" title="statement not covered" >for(i=0,s=(t||[]).length;i&lt;s;++i)<span class="cstat-no" title="statement not covered" >n=t[i],({position:o,options:{stack:a,stackWeight:r=<span class="branch-0 cbranch-no" title="branch not covered" >1}</span>}=n),e.push({index:i,box:n,pos:o,horizontal:n.isHorizontal(),weight:n.weight,stack:a&amp;&amp;o+a,stackWeight:r});<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>(t),</span>i=<span class="cstat-no" title="statement not covered" >Qi(e.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.box.fullSize)</span>),!0),</span>s=<span class="cstat-no" title="statement not covered" >Qi(Ji(e,"left"),!0),</span>n=<span class="cstat-no" title="statement not covered" >Qi(Ji(e,"right")),</span>o=<span class="cstat-no" title="statement not covered" >Qi(Ji(e,"top"),!0),</span>a=<span class="cstat-no" title="statement not covered" >Qi(Ji(e,"bottom")),</span>r=<span class="cstat-no" title="statement not covered" >Zi(e,"x"),</span>l=<span class="cstat-no" title="statement not covered" >Zi(e,"y");<span class="cstat-no" title="statement not covered" ></span>return{fullSize:i,leftAndTop:s.concat(o),rightAndBottom:n.concat(l).concat(a).concat(r),chartArea:Ji(e,"chartArea"),vertical:s.concat(n).concat(l),horizontal:o.concat(a).concat(r)}}</span>(t.boxes),</span>l=<span class="cstat-no" title="statement not covered" >r.vertical,</span>h=<span class="cstat-no" title="statement not covered" >r.horizontal;<span class="cstat-no" title="statement not covered" ></span>u(t.boxes,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >"function"==typeof t.beforeLayout&amp;&amp;t.beforeLayout()}</span>));c</span>onst c=<span class="cstat-no" title="statement not covered" >l.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.box.options&amp;&amp;!1===e.box.options.display?t:t+1)</span>,0)||1,</span>d=<span class="cstat-no" title="statement not covered" >Object.freeze({outerWidth:e,outerHeight:i,padding:n,availableWidth:o,availableHeight:a,vBoxMaxWidth:o/2/c,hBoxMaxHeight:a/2}),</span>f=<span class="cstat-no" title="statement not covered" >Object.assign({},n);<span class="cstat-no" title="statement not covered" ></span>is(f,ki(s));c</span>onst g=<span class="cstat-no" title="statement not covered" >Object.assign({maxPadding:f,w:o,h:a,x:n.left,y:n.top},n),</span>p=<span class="cstat-no" title="statement not covered" >ts(l.concat(h),d);<span class="cstat-no" title="statement not covered" ></span>os(r.fullSize,g,d,p),os(l,g,d,p),os(h,g,d,p)&amp;&amp;os(l,g,d,p),<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.maxPadding;</span>function <span class="fstat-no" title="function not covered" >i(</span>i){const s=<span class="cstat-no" title="statement not covered" >Math.max(e[i]-t[i],0);<span class="cstat-no" title="statement not covered" ></span>return t[i]+=s,s}<span class="cstat-no" title="statement not covered" ></span>t.y+=i("top"),t.x+=i("left"),i("right"),i("bottom")}</span>(g),rs(r.leftAndTop,g,d,p),g.x+=g.w,g.y+=g.h,rs(r.rightAndBottom,g,d,p),t.chartArea={left:g.left,top:g.top,right:g.left+g.w,bottom:g.top+g.h,height:g.h,width:g.w},u(r.chartArea,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >e.box;<span class="cstat-no" title="statement not covered" ></span>Object.assign(i,t.chartArea),i.update(g.w,g.h,{left:0,top:0,right:0,bottom:0})}</span>))}</span>};</span>class hs{<span class="fstat-no" title="function not covered" >ac</span>quireContext(t,e){}<span class="fstat-no" title="function not covered" >re</span>leaseContext(t){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>ad</span>dEventListener(t,e,i){}<span class="fstat-no" title="function not covered" >re</span>moveEventListener(t,e,i){}<span class="fstat-no" title="function not covered" >ge</span>tDevicePixelRatio(){<span class="cstat-no" title="statement not covered" >return 1}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaximumSize(t,e,i,s){<span class="cstat-no" title="statement not covered" >return e=Math.max(0,e||t.width),i=i||t.height,{width:e,height:Math.max(0,s?Math.floor(e/s):i)}}<span class="fstat-no" title="function not covered" ></span>is</span>Attached(t){<span class="cstat-no" title="statement not covered" >return!0}<span class="fstat-no" title="function not covered" ></span>up</span>dateConfig(t){}}class cs extends hs{<span class="fstat-no" title="function not covered" >ac</span>quireContext(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;t.getContext&amp;&amp;t.getContext("2d")||null}<span class="fstat-no" title="function not covered" ></span>up</span>dateConfig(t){<span class="cstat-no" title="statement not covered" >t.options.animation=!1}</span>}const ds=<span class="cstat-no" title="statement not covered" >"$chartjs",</span>us=<span class="cstat-no" title="statement not covered" >{touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},</span>fs=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >null===t||""===t;</span></span>const gs=<span class="cstat-no" title="statement not covered" >!!Se&amp;&amp;{passive:!0};</span>function <span class="fstat-no" title="function not covered" >ps(</span>t,e,i){<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.canvas&amp;&amp;t.canvas.removeEventListener(e,i,gs)}</span>function <span class="fstat-no" title="function not covered" >ms(</span>t,e){<span class="cstat-no" title="statement not covered" >for(const i of t)<span class="cstat-no" title="statement not covered" >if(i===e||i.contains(e))<span class="cstat-no" title="statement not covered" >return!0}</span></span></span>function <span class="fstat-no" title="function not covered" >xs(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.canvas,</span>n=<span class="cstat-no" title="statement not covered" >new MutationObserver((<span class="fstat-no" title="function not covered" >t=</span>&gt;{let e=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(const i of t)<span class="cstat-no" title="statement not covered" >e=e||ms(i.addedNodes,s),e=e&amp;&amp;!ms(i.removedNodes,s);<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;i()}</span>));<span class="cstat-no" title="statement not covered" ></span>return n.observe(document,{childList:!0,subtree:!0}),n}</span>function <span class="fstat-no" title="function not covered" >bs(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.canvas,</span>n=<span class="cstat-no" title="statement not covered" >new MutationObserver((<span class="fstat-no" title="function not covered" >t=</span>&gt;{let e=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(const i of t)<span class="cstat-no" title="statement not covered" >e=e||ms(i.removedNodes,s),e=e&amp;&amp;!ms(i.addedNodes,s);<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;i()}</span>));<span class="cstat-no" title="statement not covered" ></span>return n.observe(document,{childList:!0,subtree:!0}),n}</span>const _s=<span class="cstat-no" title="statement not covered" >new Map;</span>let ys=<span class="cstat-no" title="statement not covered" >0;</span>function <span class="fstat-no" title="function not covered" >vs(</span>){const t=<span class="cstat-no" title="statement not covered" >window.devicePixelRatio;<span class="cstat-no" title="statement not covered" ></span>t!==ys&amp;&amp;(ys=t,_s.forEach((<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >i.currentDevicePixelRatio!==t&amp;&amp;e()}</span>)))}</span>function <span class="fstat-no" title="function not covered" >Ms(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.canvas,</span>n=<span class="cstat-no" title="statement not covered" >s&amp;&amp;ge(s);<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >ct((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const s=<span class="cstat-no" title="statement not covered" >n.clientWidth;<span class="cstat-no" title="statement not covered" ></span>i(t,e),s&lt;n.clientWidth&amp;&amp;i()}</span>),window),</span>a=<span class="cstat-no" title="statement not covered" >new ResizeObserver((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t[0],</span>i=<span class="cstat-no" title="statement not covered" >e.contentRect.width,</span>s=<span class="cstat-no" title="statement not covered" >e.contentRect.height;<span class="cstat-no" title="statement not covered" ></span>0===i&amp;&amp;0===s||o(i,s)}</span>));<span class="cstat-no" title="statement not covered" ></span>return a.observe(n),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >_s.size||window.addEventListener("resize",vs),_s.set(t,e)}</span>(t,o),a}</span>function <span class="fstat-no" title="function not covered" >ws(</span>t,e,i){<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.disconnect(),"resize"===e&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >_s.delete(t),_s.size||window.removeEventListener("resize",vs)}</span>(t)}</span>function <span class="fstat-no" title="function not covered" >ks(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.canvas,</span>n=<span class="cstat-no" title="statement not covered" >ct((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >null!==t.ctx&amp;&amp;i(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >us[t.type]||t.type,</span>{x:s,y:n}=<span class="cstat-no" title="statement not covered" >ve(t,e);<span class="cstat-no" title="statement not covered" ></span>return{type:i,chart:e,native:t,x:void 0!==s?s:null,y:void 0!==n?n:null}}</span>(e,t))}</span>),t);<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.addEventListener(e,i,gs)}</span>(s,e,n),n}</span>class Ss extends hs{<span class="fstat-no" title="function not covered" >ac</span>quireContext(t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.getContext&amp;&amp;t.getContext("2d");<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;i.canvas===t?(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >t.style,</span>s=<span class="cstat-no" title="statement not covered" >t.getAttribute("height"),</span>n=<span class="cstat-no" title="statement not covered" >t.getAttribute("width");<span class="cstat-no" title="statement not covered" ></span>if(t[ds]={initial:{height:s,width:n,style:{display:i.display,height:i.height,width:i.width}}},i.display=i.display||"block",i.boxSizing=i.boxSizing||"border-box",fs(n)){const e=<span class="cstat-no" title="statement not covered" >Pe(t,"width");<span class="cstat-no" title="statement not covered" ></span>void 0!==e&amp;&amp;(t.width=e)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(fs(s))<span class="cstat-no" title="statement not covered" >if(""===t.style.height)<span class="cstat-no" title="statement not covered" >t.height=t.width/(e||2);e</span>lse{const e=<span class="cstat-no" title="statement not covered" >Pe(t,"height");<span class="cstat-no" title="statement not covered" ></span>void 0!==e&amp;&amp;(t.height=e)}</span>}</span></span>(t,e),i):null}<span class="fstat-no" title="function not covered" ></span>re</span>leaseContext(t){const e=<span class="cstat-no" title="statement not covered" >t.canvas;<span class="cstat-no" title="statement not covered" ></span>if(!e[ds])<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >e[ds].initial;<span class="cstat-no" title="statement not covered" ></span>["height","width"].forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>s(n)?e.removeAttribute(t):e.setAttribute(t,n)}</span>));c</span>onst n=<span class="cstat-no" title="statement not covered" >i.style||{};<span class="cstat-no" title="statement not covered" ></span>return Object.keys(n).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.style[t]=n[t]}</span>)),e.width=e.width,delete e[ds],!0}<span class="fstat-no" title="function not covered" ></span>ad</span>dEventListener(t,e,i){<span class="cstat-no" title="statement not covered" >this.removeEventListener(t,e);c</span>onst s=<span class="cstat-no" title="statement not covered" >t.$proxies||(t.$proxies={}),</span>n=<span class="cstat-no" title="statement not covered" >{attach:xs,detach:bs,resize:Ms}[e]||ks;<span class="cstat-no" title="statement not covered" ></span>s[e]=n(t,e,i)}<span class="fstat-no" title="function not covered" ></span>re</span>moveEventListener(t,e){const i=<span class="cstat-no" title="statement not covered" >t.$proxies||(t.$proxies={}),</span>s=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >(</span></span>{attach:ws,detach:ws,resize:ws}[e]||ps)(t,e,s),i[e]=void 0}<span class="fstat-no" title="function not covered" ></span>ge</span>tDevicePixelRatio(){<span class="cstat-no" title="statement not covered" >return window.devicePixelRatio}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaximumSize(t,e,i,s){<span class="cstat-no" title="statement not covered" >return we(t,e,i,s)}<span class="fstat-no" title="function not covered" ></span>is</span>Attached(t){const e=<span class="cstat-no" title="statement not covered" >t&amp;&amp;ge(t);<span class="cstat-no" title="statement not covered" ></span>return!(!e||!e.isConnected)}</span>}function <span class="fstat-no" title="function not covered" >Ps(</span>t){<span class="cstat-no" title="statement not covered" >return!fe()||"undefined"!=typeof OffscreenCanvas&amp;&amp;t instanceof OffscreenCanvas?cs:Ss}</span>var Ds=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,BasePlatform:hs,BasicPlatform:cs,DomPlatform:Ss,_detectPlatform:Ps});</span>const Cs=<span class="cstat-no" title="statement not covered" >"transparent",</span>Os=<span class="cstat-no" title="statement not covered" >{boolean:<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >i&gt;.5?e:t,<span class="fstat-no" title="function not covered" ></span>co</span>lor(t,e,i){const s=<span class="cstat-no" title="statement not covered" >Qt(t||Cs),</span>n=<span class="cstat-no" title="statement not covered" >s.valid&amp;&amp;Qt(e||Cs);<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;n.valid?n.mix(s,i).hexString():e}</span>,number:<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >t+(e-t)*i}</span>;</span>class As{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e[i];<span class="cstat-no" title="statement not covered" ></span>s=Pi([t.to,s,n,t.from]);c</span>onst o=<span class="cstat-no" title="statement not covered" >Pi([t.from,n,s]);<span class="cstat-no" title="statement not covered" ></span>this._active=!0,this._fn=t.fn||Os[t.type||typeof o],this._easing=fi[t.easing]||fi.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=i,this._from=o,this._to=s,this._promises=void 0}<span class="fstat-no" title="function not covered" ></span>ac</span>tive(){<span class="cstat-no" title="statement not covered" >return this._active}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e,i){<span class="cstat-no" title="statement not covered" >if(this._active){<span class="cstat-no" title="statement not covered" >this._notify(!1);c</span>onst s=<span class="cstat-no" title="statement not covered" >this._target[this._prop],</span>n=<span class="cstat-no" title="statement not covered" >i-this._start,</span>o=<span class="cstat-no" title="statement not covered" >this._duration-n;<span class="cstat-no" title="statement not covered" ></span>this._start=i,this._duration=Math.floor(Math.max(o,t.duration)),this._total+=n,this._loop=!!t.loop,this._to=Pi([t.to,e,s,t.from]),this._from=Pi([t.from,s,e])}</span>}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(){<span class="cstat-no" title="statement not covered" >this._active&amp;&amp;(this.tick(Date.now()),this._active=!1,this._notify(!1))}<span class="fstat-no" title="function not covered" ></span>ti</span>ck(t){const e=<span class="cstat-no" title="statement not covered" >t-this._start,</span>i=<span class="cstat-no" title="statement not covered" >this._duration,</span>s=<span class="cstat-no" title="statement not covered" >this._prop,</span>n=<span class="cstat-no" title="statement not covered" >this._from,</span>o=<span class="cstat-no" title="statement not covered" >this._loop,</span>a=<span class="cstat-no" title="statement not covered" >this._to;</span>let r;<span class="cstat-no" title="statement not covered" >if(this._active=n!==a&amp;&amp;(o||e&lt;i),!this._active)<span class="cstat-no" title="statement not covered" >return this._target[s]=a,void this._notify(!0);<span class="cstat-no" title="statement not covered" >e</span></span>&lt;0?this._target[s]=n:(r=e/i%2,r=o&amp;&amp;r&gt;1?2-r:r,r=this._easing(Math.min(1,Math.max(0,r))),this._target[s]=this._fn(n,a,r))}<span class="fstat-no" title="function not covered" ></span>wa</span>it(){const t=<span class="cstat-no" title="statement not covered" >this._promises||(this._promises=[]);<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >t.push({res:e,rej:i})}</span>))}<span class="fstat-no" title="function not covered" ></span>_n</span>otify(t){const e=<span class="cstat-no" title="statement not covered" >t?"res":"rej",</span>i=<span class="cstat-no" title="statement not covered" >this._promises||[];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;i.length;t++)<span class="cstat-no" title="statement not covered" >i[t][e]()}</span></span>}class Ts{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this._chart=t,this._properties=new Map,this.configure(e)}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(t){<span class="cstat-no" title="statement not covered" >if(!o(t))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >Object.keys(ue.animation),</span>i=<span class="cstat-no" title="statement not covered" >this._properties;<span class="cstat-no" title="statement not covered" ></span>Object.getOwnPropertyNames(t).forEach((<span class="fstat-no" title="function not covered" >s=</span>&gt;{const a=<span class="cstat-no" title="statement not covered" >t[s];<span class="cstat-no" title="statement not covered" ></span>if(!o(a))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const t of e)<span class="cstat-no" title="statement not covered" >r[t]=a[t];<span class="cstat-no" title="statement not covered" >(</span></span>n(a.properties)&amp;&amp;a.properties||[s]).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t!==s&amp;&amp;i.has(t)||i.set(t,r)}</span>))}</span>))}<span class="fstat-no" title="function not covered" ></span>_a</span>nimateOptions(t,e){const i=<span class="cstat-no" title="statement not covered" >e.options,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et i=<span class="cstat-no" title="statement not covered" >t.options;<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return void(t.options=e);<span class="cstat-no" title="statement not covered" >i</span></span>.$shared&amp;&amp;(t.options=i=Object.assign({},i,{$shared:!1,$animations:{}}));<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>(t,i);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return[];c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this._createAnimations(s,i);<span class="cstat-no" title="statement not covered" ></span>return i.$shared&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(e);<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;s.length;e++){const n=<span class="cstat-no" title="statement not covered" >t[s[e]];<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;n.active()&amp;&amp;i.push(n.wait())}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Promise.all(i)}</span>(t.options.$animations,i).then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.options=i}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{})),n}<span class="fstat-no" title="function not covered" ></span>_c</span>reateAnimations(t,e){const i=<span class="cstat-no" title="statement not covered" >this._properties,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >t.$animations||(t.$animations={}),</span>o=<span class="cstat-no" title="statement not covered" >Object.keys(e),</span>a=<span class="cstat-no" title="statement not covered" >Date.now();</span>let r;<span class="cstat-no" title="statement not covered" >for(r=o.length-1;r&gt;=0;--r){const l=<span class="cstat-no" title="statement not covered" >o[r];<span class="cstat-no" title="statement not covered" ></span>if("$"===l.charAt(0))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f("options"===l){<span class="cstat-no" title="statement not covered" >s.push(...this._animateOptions(t,e));<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst h=<span class="cstat-no" title="statement not covered" >e[l];</span>let c=<span class="cstat-no" title="statement not covered" >n[l];</span>const d=<span class="cstat-no" title="statement not covered" >i.get(l);<span class="cstat-no" title="statement not covered" ></span>if(c){<span class="cstat-no" title="statement not covered" >if(d&amp;&amp;c.active()){<span class="cstat-no" title="statement not covered" >c.update(d,h,a);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>c</span>.cancel()}<span class="cstat-no" title="statement not covered" ></span>d</span>&amp;&amp;d.duration?(n[l]=c=new As(d,t,l,h),s.push(c)):t[l]=h}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e){<span class="cstat-no" title="statement not covered" >if(0===this._properties.size)<span class="cstat-no" title="statement not covered" >return void Object.assign(t,e);c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this._createAnimations(t,e);<span class="cstat-no" title="statement not covered" ></span>return i.length?(bt.add(this._chart,i),!0):void 0}</span>}function <span class="fstat-no" title="function not covered" >Ls(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.options||{},</span>s=<span class="cstat-no" title="statement not covered" >i.reverse,</span>n=<span class="cstat-no" title="statement not covered" >void 0===i.min?e:0,</span>o=<span class="cstat-no" title="statement not covered" >void 0===i.max?e:0;<span class="cstat-no" title="statement not covered" ></span>return{start:s?o:n,end:s?n:o}}</span>function <span class="fstat-no" title="function not covered" >Es(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >t._getSortedDatasetMetas(e);</span>let n,o;<span class="cstat-no" title="statement not covered" >for(n=0,o=s.length;n&lt;o;++n)<span class="cstat-no" title="statement not covered" >i.push(s[n].index);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >Rs(</span>t,e,i,s=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const n=<span class="cstat-no" title="statement not covered" >t.keys,</span>o=<span class="cstat-no" title="statement not covered" >"single"===s.mode;</span>let r,l,h,c;<span class="cstat-no" title="statement not covered" >if(null===e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et d=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(r=0,l=n.length;r&lt;l;++r){<span class="cstat-no" title="statement not covered" >if(h=+n[r],h===i){<span class="cstat-no" title="statement not covered" >if(d=!0,s.all)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}<span class="cstat-no" title="statement not covered" ></span>c</span>=t.values[h],a(c)&amp;&amp;(o||0===e||F(e)===F(c))&amp;&amp;(e+=c)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn d||s.all?e:0}</span>function <span class="fstat-no" title="function not covered" >Is(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.options.stacked;<span class="cstat-no" title="statement not covered" ></span>return i||void 0===i&amp;&amp;void 0!==e.stack}</span>function <span class="fstat-no" title="function not covered" >zs(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t[e]||(t[e]={});<span class="cstat-no" title="statement not covered" ></span>return s[i]||(s[i]={})}</span>function <span class="fstat-no" title="function not covered" >Fs(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >for(const n of e.getMatchingVisibleMetas(s).reverse()){const e=<span class="cstat-no" title="statement not covered" >t[n.index];<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;e&gt;0||!i&amp;&amp;e&lt;0)<span class="cstat-no" title="statement not covered" >return n.index}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn null}</span>function <span class="fstat-no" title="function not covered" >Vs(</span>t,e){const{chart:i,_cachedMeta:s}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >i._stacks||(i._stacks={}),</span>{iScale:o,vScale:a,index:r}=<span class="cstat-no" title="statement not covered" >s,</span>l=<span class="cstat-no" title="statement not covered" >o.axis,</span>h=<span class="cstat-no" title="statement not covered" >a.axis,</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return`${t.id}.${e.id}.${i.stack||i.type}`}</span>(o,a,s),</span>d=<span class="cstat-no" title="statement not covered" >e.length;</span>let u;<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;d;++t){const i=<span class="cstat-no" title="statement not covered" >e[t],</span>{[l]:o,[h]:d}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>u=(i._stacks||(i._stacks={}))[h]=zs(n,c,o),u[r]=d,u._top=Fs(u,a,!0,s.type),u._bottom=Fs(u,a,!1,s.type);<span class="cstat-no" title="statement not covered" >(</span>u._visualValues||(u._visualValues={}))[r]=d}</span>}</span>function <span class="fstat-no" title="function not covered" >Bs(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.scales;<span class="cstat-no" title="statement not covered" ></span>return Object.keys(i).filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >i[t].axis===e)</span>).shift()}</span>function <span class="fstat-no" title="function not covered" >Ws(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.controller.index,</span>s=<span class="cstat-no" title="statement not covered" >t.vScale&amp;&amp;t.vScale.axis;<span class="cstat-no" title="statement not covered" ></span>if(s){<span class="cstat-no" title="statement not covered" >e=e||t._parsed;<span class="cstat-no" title="statement not covered" >f</span>or(const t of e){const e=<span class="cstat-no" title="statement not covered" >t._stacks;<span class="cstat-no" title="statement not covered" ></span>if(!e||void 0===e[s]||void 0===e[s][i])<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >d</span></span>elete e[s][i],void 0!==e[s]._visualValues&amp;&amp;void 0!==e[s]._visualValues[i]&amp;&amp;delete e[s]._visualValues[i]}</span>}</span>}</span>const Ns=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"reset"===t||"none"===t,</span></span>Hs=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e?t:Object.assign({},t);</span></span>class js{static defaults=<span class="cstat-no" title="statement not covered" >{};</span>static datasetElementType=<span class="cstat-no" title="statement not covered" >null;</span>static dataElementType=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this.chart=t,this._ctx=t.ctx,this.index=e,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}<span class="fstat-no" title="function not covered" ></span>in</span>itialize(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this.configure(),this.linkScales(),t._stacked=Is(t.vScale,t),this.addElements(),this.options.fill&amp;&amp;!this.chart.isPluginEnabled("filler")&amp;&amp;console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")}<span class="fstat-no" title="function not covered" ></span>up</span>dateIndex(t){<span class="cstat-no" title="statement not covered" >this.index!==t&amp;&amp;Ws(this._cachedMeta),this.index=t}<span class="fstat-no" title="function not covered" ></span>li</span>nkScales(){const t=<span class="cstat-no" title="statement not covered" >this.chart,</span>e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.getDataset(),</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >"x"===t?e:"r"===t?s:i,</span></span>n=<span class="cstat-no" title="statement not covered" >e.xAxisID=l(i.xAxisID,Bs(t,"x")),</span>o=<span class="cstat-no" title="statement not covered" >e.yAxisID=l(i.yAxisID,Bs(t,"y")),</span>a=<span class="cstat-no" title="statement not covered" >e.rAxisID=l(i.rAxisID,Bs(t,"r")),</span>r=<span class="cstat-no" title="statement not covered" >e.indexAxis,</span>h=<span class="cstat-no" title="statement not covered" >e.iAxisID=s(r,n,o,a),</span>c=<span class="cstat-no" title="statement not covered" >e.vAxisID=s(r,o,n,a);<span class="cstat-no" title="statement not covered" ></span>e.xScale=this.getScaleForId(n),e.yScale=this.getScaleForId(o),e.rScale=this.getScaleForId(a),e.iScale=this.getScaleForId(h),e.vScale=this.getScaleForId(c)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDataset(){<span class="cstat-no" title="statement not covered" >return this.chart.data.datasets[this.index]}<span class="fstat-no" title="function not covered" ></span>ge</span>tMeta(){<span class="cstat-no" title="statement not covered" >return this.chart.getDatasetMeta(this.index)}<span class="fstat-no" title="function not covered" ></span>ge</span>tScaleForId(t){<span class="cstat-no" title="statement not covered" >return this.chart.scales[t]}<span class="fstat-no" title="function not covered" ></span>_g</span>etOtherScale(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>return t===e.iScale?e.vScale:e.iScale}<span class="fstat-no" title="function not covered" ></span>re</span>set(){<span class="cstat-no" title="statement not covered" >this._update("reset")}<span class="fstat-no" title="function not covered" ></span>_d</span>estroy(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this._data&amp;&amp;rt(this._data,this),t._stacked&amp;&amp;Ws(t)}<span class="fstat-no" title="function not covered" ></span>_d</span>ataCheck(){const t=<span class="cstat-no" title="statement not covered" >this.getDataset(),</span>e=<span class="cstat-no" title="statement not covered" >t.data||(t.data=[]),</span>i=<span class="cstat-no" title="statement not covered" >this._data;<span class="cstat-no" title="statement not covered" ></span>if(o(e)){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this._data=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{iScale:i,vScale:s}=<span class="cstat-no" title="statement not covered" >e,</span>n=<span class="cstat-no" title="statement not covered" >"x"===i.axis?"x":"y",</span>o=<span class="cstat-no" title="statement not covered" >"x"===s.axis?"x":"y",</span>a=<span class="cstat-no" title="statement not covered" >Object.keys(t),</span>r=<span class="cstat-no" title="statement not covered" >new Array(a.length);</span>let l,h,c;<span class="cstat-no" title="statement not covered" >for(l=0,h=a.length;l&lt;h;++l)<span class="cstat-no" title="statement not covered" >c=a[l],r[l]={[n]:c,[o]:t[c]};<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>(e,t)}</span>else <span class="cstat-no" title="statement not covered" >if(i!==e){<span class="cstat-no" title="statement not covered" >if(i){<span class="cstat-no" title="statement not covered" >rt(i,this);c</span>onst t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>Ws(t),t._parsed=[]}<span class="cstat-no" title="statement not covered" ></span>e</span>&amp;&amp;Object.isExtensible(e)&amp;&amp;at(e,this),this._syncList=[],this._data=e}</span>}<span class="fstat-no" title="function not covered" ></span></span>ad</span>dElements(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this._dataCheck(),this.datasetElementType&amp;&amp;(t.dataset=new this.datasetElementType)}<span class="fstat-no" title="function not covered" ></span>bu</span>ildOrUpdateElements(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.getDataset();</span>let s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>this._dataCheck();c</span>onst n=<span class="cstat-no" title="statement not covered" >e._stacked;<span class="cstat-no" title="statement not covered" ></span>e._stacked=Is(e.vScale,e),e.stack!==i.stack&amp;&amp;(s=!0,Ws(e),e.stack=i.stack),this._resyncElements(t),(s||n!==e._stacked)&amp;&amp;(Vs(this,e._parsed),e._stacked=Is(e.vScale,e))}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){const t=<span class="cstat-no" title="statement not covered" >this.chart.config,</span>e=<span class="cstat-no" title="statement not covered" >t.datasetScopeKeys(this._type),</span>i=<span class="cstat-no" title="statement not covered" >t.getOptionScopes(this.getDataset(),e,!0);<span class="cstat-no" title="statement not covered" ></span>this.options=t.createResolver(i,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){const{_cachedMeta:i,_data:s}=<span class="cstat-no" title="statement not covered" >this,</span>{iScale:a,_stacked:r}=<span class="cstat-no" title="statement not covered" >i,</span>l=<span class="cstat-no" title="statement not covered" >a.axis;</span>let h,c,d,u=<span class="cstat-no" title="statement not covered" >0===t&amp;&amp;e===s.length||i._sorted,</span>f=<span class="cstat-no" title="statement not covered" >t&gt;0&amp;&amp;i._parsed[t-1];<span class="cstat-no" title="statement not covered" ></span>if(!1===this._parsing)<span class="cstat-no" title="statement not covered" >i._parsed=s,i._sorted=!0,d=s;e</span>lse{<span class="cstat-no" title="statement not covered" >d=n(s[t])?this.parseArrayData(i,s,t,e):o(s[t])?this.parseObjectData(i,s,t,e):this.parsePrimitiveData(i,s,t,e);c</span>onst a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null===c[l]||f&amp;&amp;c[l]&lt;f[l];<span class="cstat-no" title="statement not covered" ></span></span>for(h=0;h&lt;e;++h)<span class="cstat-no" title="statement not covered" >i._parsed[h+t]=c=d[h],u&amp;&amp;(a()&amp;&amp;(u=!1),f=c);<span class="cstat-no" title="statement not covered" >i</span></span>._sorted=u}<span class="cstat-no" title="statement not covered" ></span>r</span>&amp;&amp;Vs(this,d)}<span class="fstat-no" title="function not covered" ></span>pa</span>rsePrimitiveData(t,e,i,s){const{iScale:n,vScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>a=<span class="cstat-no" title="statement not covered" >n.axis,</span>r=<span class="cstat-no" title="statement not covered" >o.axis,</span>l=<span class="cstat-no" title="statement not covered" >n.getLabels(),</span>h=<span class="cstat-no" title="statement not covered" >n===o,</span>c=<span class="cstat-no" title="statement not covered" >new Array(s);</span>let d,u,f;<span class="cstat-no" title="statement not covered" >for(d=0,u=s;d&lt;u;++d)<span class="cstat-no" title="statement not covered" >f=d+i,c[d]={[a]:h||n.parse(l[f],f),[r]:o.parse(e[f],f)};<span class="cstat-no" title="statement not covered" >r</span></span>eturn c}<span class="fstat-no" title="function not covered" ></span>pa</span>rseArrayData(t,e,i,s){const{xScale:n,yScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>a=<span class="cstat-no" title="statement not covered" >new Array(s);</span>let r,l,h,c;<span class="cstat-no" title="statement not covered" >for(r=0,l=s;r&lt;l;++r)<span class="cstat-no" title="statement not covered" >h=r+i,c=e[h],a[r]={x:n.parse(c[0],h),y:o.parse(c[1],h)};<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}<span class="fstat-no" title="function not covered" ></span>pa</span>rseObjectData(t,e,i,s){const{xScale:n,yScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>{xAxisKey:a=<span class="branch-0 cbranch-no" title="branch not covered" >"x",</span>yAxisKey:r=<span class="branch-0 cbranch-no" title="branch not covered" >"y"}</span>=<span class="cstat-no" title="statement not covered" >this._parsing,</span>l=<span class="cstat-no" title="statement not covered" >new Array(s);</span>let h,c,d,u;<span class="cstat-no" title="statement not covered" >for(h=0,c=s;h&lt;c;++h)<span class="cstat-no" title="statement not covered" >d=h+i,u=e[d],l[h]={x:n.parse(M(u,a),d),y:o.parse(M(u,r),d)};<span class="cstat-no" title="statement not covered" >r</span></span>eturn l}<span class="fstat-no" title="function not covered" ></span>ge</span>tParsed(t){<span class="cstat-no" title="statement not covered" >return this._cachedMeta._parsed[t]}<span class="fstat-no" title="function not covered" ></span>ge</span>tDataElement(t){<span class="cstat-no" title="statement not covered" >return this._cachedMeta.data[t]}<span class="fstat-no" title="function not covered" ></span>ap</span>plyStack(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.chart,</span>n=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>o=<span class="cstat-no" title="statement not covered" >e[t.axis];<span class="cstat-no" title="statement not covered" ></span>return Rs({keys:Es(s,!0),values:e._stacks[t.axis]._visualValues},o,n.index,{mode:i})}<span class="fstat-no" title="function not covered" ></span>up</span>dateRangeFromParsed(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >i[e.axis];</span>let o=<span class="cstat-no" title="statement not covered" >null===n?NaN:n;</span>const a=<span class="cstat-no" title="statement not covered" >s&amp;&amp;i._stacks[e.axis];<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;a&amp;&amp;(s.values=a,o=Rs(s,n,this._cachedMeta.index)),t.min=Math.min(t.min,o),t.max=Math.max(t.max,o)}<span class="fstat-no" title="function not covered" ></span>ge</span>tMinMax(t,e){const i=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>s=<span class="cstat-no" title="statement not covered" >i._parsed,</span>n=<span class="cstat-no" title="statement not covered" >i._sorted&amp;&amp;t===i.iScale,</span>o=<span class="cstat-no" title="statement not covered" >s.length,</span>r=<span class="cstat-no" title="statement not covered" >this._getOtherScale(t),</span>l=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >t&amp;&amp;!e.hidden&amp;&amp;e._stacked&amp;&amp;{keys:Es(i,!0),values:null})</span>(e,i,this.chart),</span>h=<span class="cstat-no" title="statement not covered" >{min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},</span>{min:c,max:d}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const{min:e,max:i,minDefined:s,maxDefined:n}=<span class="cstat-no" title="statement not covered" >t.getUserBounds();<span class="cstat-no" title="statement not covered" ></span>return{min:s?e:Number.NEGATIVE_INFINITY,max:n?i:Number.POSITIVE_INFINITY}}</span>(r);</span>let u,f;function <span class="fstat-no" title="function not covered" >g(</span>){<span class="cstat-no" title="statement not covered" >f=s[u];c</span>onst e=<span class="cstat-no" title="statement not covered" >f[r.axis];<span class="cstat-no" title="statement not covered" ></span>return!a(f[t.axis])||c&gt;e||d&lt;e}<span class="cstat-no" title="statement not covered" ></span>for(u=0;u&lt;o&amp;&amp;(g()||(this.updateRangeFromParsed(h,t,f,l),!n));++u);<span class="cstat-no" title="statement not covered" >i</span>f(n)<span class="cstat-no" title="statement not covered" >for(u=o-1;u&gt;=0;--u)<span class="cstat-no" title="statement not covered" >if(!g()){<span class="cstat-no" title="statement not covered" >this.updateRangeFromParsed(h,t,f,l);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn h}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllParsedValues(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta._parsed,</span>i=<span class="cstat-no" title="statement not covered" >[];</span>let s,n,o;<span class="cstat-no" title="statement not covered" >for(s=0,n=e.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >o=e[s][t.axis],a(o)&amp;&amp;i.push(o);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >e.iScale,</span>s=<span class="cstat-no" title="statement not covered" >e.vScale,</span>n=<span class="cstat-no" title="statement not covered" >this.getParsed(t);<span class="cstat-no" title="statement not covered" ></span>return{label:i?""+i.getLabelForValue(n[i.axis]):"",value:s?""+s.getLabelForValue(n[s.axis]):""}}<span class="fstat-no" title="function not covered" ></span>_u</span>pdate(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this.update(t||"default"),e._clip=<span class="fstat-no" title="function not covered" >fu</span>nction(t){let e,i,s,n;<span class="cstat-no" title="statement not covered" >return o(t)?(e=t.top,i=t.right,s=t.bottom,n=t.left):e=i=s=n=t,{top:e,right:i,bottom:s,left:n,disabled:!1===t}}</span>(l(this.options.clip,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >if(!1===i)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >Ls(t,i),</span>n=<span class="cstat-no" title="statement not covered" >Ls(e,i);<span class="cstat-no" title="statement not covered" ></span>return{top:n.end,right:s.end,bottom:n.start,left:s.start}}</span>(e.xScale,e.yScale,this.getMaxOverflow())))}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){}<span class="fstat-no" title="function not covered" >dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this._ctx,</span>e=<span class="cstat-no" title="statement not covered" >this.chart,</span>i=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>s=<span class="cstat-no" title="statement not covered" >i.data||[],</span>n=<span class="cstat-no" title="statement not covered" >e.chartArea,</span>o=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >this._drawStart||0,</span>r=<span class="cstat-no" title="statement not covered" >this._drawCount||s.length-a,</span>l=<span class="cstat-no" title="statement not covered" >this.options.drawActiveElementsOnTop;</span>let h;<span class="cstat-no" title="statement not covered" >for(i.dataset&amp;&amp;i.dataset.draw(t,n,a,r),h=a;h&lt;a+r;++h){const e=<span class="cstat-no" title="statement not covered" >s[h];<span class="cstat-no" title="statement not covered" ></span>e.hidden||(e.active&amp;&amp;l?o.push(e):e.draw(t,n))}<span class="cstat-no" title="statement not covered" ></span>f</span>or(h=0;h&lt;o.length;++h)<span class="cstat-no" title="statement not covered" >o[h].draw(t,n)}<span class="fstat-no" title="function not covered" ></span></span>ge</span>tStyle(t,e){const i=<span class="cstat-no" title="statement not covered" >e?"active":"default";<span class="cstat-no" title="statement not covered" ></span>return void 0===t&amp;&amp;this._cachedMeta.dataset?this.resolveDatasetElementOptions(i):this.resolveDataElementOptions(t||0,i)}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.getDataset();</span>let n;<span class="cstat-no" title="statement not covered" >if(t&gt;=0&amp;&amp;t&lt;this._cachedMeta.data.length){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta.data[t];<span class="cstat-no" title="statement not covered" ></span>n=e.$context||(e.$context=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return Ci(t,{active:!1,dataIndex:e,parsed:void 0,raw:void 0,element:i,index:e,mode:"default",type:"data"})}</span>(this.getContext(),t,e)),n.parsed=this.getParsed(t),n.raw=s.data[t],n.index=n.dataIndex=t}</span>else <span class="cstat-no" title="statement not covered" >n=this.$context||(this.$context=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return Ci(t,{active:!1,dataset:void 0,datasetIndex:e,index:e,mode:"default",type:"dataset"})}</span>(this.chart.getContext(),this.index)),n.dataset=s,n.index=n.datasetIndex=this.index;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.active=!!e,n.mode=i,n}<span class="fstat-no" title="function not covered" ></span>re</span>solveDatasetElementOptions(t){<span class="cstat-no" title="statement not covered" >return this._resolveElementOptions(this.datasetElementType.id,t)}<span class="fstat-no" title="function not covered" ></span>re</span>solveDataElementOptions(t,e){<span class="cstat-no" title="statement not covered" >return this._resolveElementOptions(this.dataElementType.id,e,t)}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveElementOptions(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >"default",</span>i){const s=<span class="cstat-no" title="statement not covered" >"active"===e,</span>n=<span class="cstat-no" title="statement not covered" >this._cachedDataOpts,</span>o=<span class="cstat-no" title="statement not covered" >t+"-"+e,</span>a=<span class="cstat-no" title="statement not covered" >n[o],</span>r=<span class="cstat-no" title="statement not covered" >this.enableOptionSharing&amp;&amp;k(i);<span class="cstat-no" title="statement not covered" ></span>if(a)<span class="cstat-no" title="statement not covered" >return Hs(a,r);c</span></span>onst l=<span class="cstat-no" title="statement not covered" >this.chart.config,</span>h=<span class="cstat-no" title="statement not covered" >l.datasetElementScopeKeys(this._type,t),</span>c=<span class="cstat-no" title="statement not covered" >s?[`${t}Hover`,"hover",t,""]:[t,""],</span>d=<span class="cstat-no" title="statement not covered" >l.getOptionScopes(this.getDataset(),h),</span>u=<span class="cstat-no" title="statement not covered" >Object.keys(ue.elements[t]),</span>f=<span class="cstat-no" title="statement not covered" >l.resolveNamedOptions(d,u,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.getContext(i,s,e))</span>,c);<span class="cstat-no" title="statement not covered" ></span>return f.$shared&amp;&amp;(f.$shared=r,n[o]=Object.freeze(Hs(f,r))),f}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveAnimations(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.chart,</span>n=<span class="cstat-no" title="statement not covered" >this._cachedDataOpts,</span>o=<span class="cstat-no" title="statement not covered" >`animation-${e}`,</span>a=<span class="cstat-no" title="statement not covered" >n[o];<span class="cstat-no" title="statement not covered" ></span>if(a)<span class="cstat-no" title="statement not covered" >return a;l</span></span>et r;<span class="cstat-no" title="statement not covered" >if(!1!==s.options.animation){const s=<span class="cstat-no" title="statement not covered" >this.chart.config,</span>n=<span class="cstat-no" title="statement not covered" >s.datasetAnimationScopeKeys(this._type,e),</span>o=<span class="cstat-no" title="statement not covered" >s.getOptionScopes(this.getDataset(),n);<span class="cstat-no" title="statement not covered" ></span>r=s.createResolver(o,this.getContext(t,i,e))}</span>c</span>onst l=<span class="cstat-no" title="statement not covered" >new Ts(s,r&amp;&amp;r.animations);<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;r._cacheable&amp;&amp;(n[o]=Object.freeze(l)),l}<span class="fstat-no" title="function not covered" ></span>ge</span>tSharedOptions(t){<span class="cstat-no" title="statement not covered" >if(t.$shared)<span class="cstat-no" title="statement not covered" >return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}<span class="fstat-no" title="function not covered" ></span></span>in</span>cludeOptions(t,e){<span class="cstat-no" title="statement not covered" >return!e||Ns(t)||this.chart._animationsDisabled}<span class="fstat-no" title="function not covered" ></span>_g</span>etSharedOptions(t,e){const i=<span class="cstat-no" title="statement not covered" >this.resolveDataElementOptions(t,e),</span>s=<span class="cstat-no" title="statement not covered" >this._sharedOptions,</span>n=<span class="cstat-no" title="statement not covered" >this.getSharedOptions(i),</span>o=<span class="cstat-no" title="statement not covered" >this.includeOptions(e,n)||n!==s;<span class="cstat-no" title="statement not covered" ></span>return this.updateSharedOptions(n,e,i),{sharedOptions:n,includeOptions:o}}<span class="fstat-no" title="function not covered" ></span>up</span>dateElement(t,e,i,s){<span class="cstat-no" title="statement not covered" >Ns(s)?Object.assign(t,i):this._resolveAnimations(e,s).update(t,i)}<span class="fstat-no" title="function not covered" ></span>up</span>dateSharedOptions(t,e,i){<span class="cstat-no" title="statement not covered" >t&amp;&amp;!Ns(e)&amp;&amp;this._resolveAnimations(void 0,e).update(t,i)}<span class="fstat-no" title="function not covered" ></span>_s</span>etStyle(t,e,i,s){<span class="cstat-no" title="statement not covered" >t.active=s;c</span>onst n=<span class="cstat-no" title="statement not covered" >this.getStyle(e,s);<span class="cstat-no" title="statement not covered" ></span>this._resolveAnimations(e,i,s).update(t,{options:!s&amp;&amp;this.getSharedOptions(n)||n})}<span class="fstat-no" title="function not covered" ></span>re</span>moveHoverStyle(t,e,i){<span class="cstat-no" title="statement not covered" >this._setStyle(t,i,"active",!1)}<span class="fstat-no" title="function not covered" ></span>se</span>tHoverStyle(t,e,i){<span class="cstat-no" title="statement not covered" >this._setStyle(t,i,"active",!0)}<span class="fstat-no" title="function not covered" ></span>_r</span>emoveDatasetHoverStyle(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta.dataset;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;this._setStyle(t,void 0,"active",!1)}<span class="fstat-no" title="function not covered" ></span>_s</span>etDatasetHoverStyle(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta.dataset;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;this._setStyle(t,void 0,"active",!0)}<span class="fstat-no" title="function not covered" ></span>_r</span>esyncElements(t){const e=<span class="cstat-no" title="statement not covered" >this._data,</span>i=<span class="cstat-no" title="statement not covered" >this._cachedMeta.data;<span class="cstat-no" title="statement not covered" ></span>for(const[t,e,i]of this._syncList)<span class="cstat-no" title="statement not covered" >this[t](e,i);<span class="cstat-no" title="statement not covered" >t</span></span>his._syncList=[];c</span>onst s=<span class="cstat-no" title="statement not covered" >i.length,</span>n=<span class="cstat-no" title="statement not covered" >e.length,</span>o=<span class="cstat-no" title="statement not covered" >Math.min(n,s);<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;this.parse(0,o),n&gt;s?this._insertElements(s,n-s,t):n&lt;s&amp;&amp;this._removeElements(n,s-n)}<span class="fstat-no" title="function not covered" ></span>_i</span>nsertElements(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{const s=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>n=<span class="cstat-no" title="statement not covered" >s.data,</span>o=<span class="cstat-no" title="statement not covered" >t+e;</span>let a;const r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(t.length+=e,a=t.length-1;a&gt;=o;a--)<span class="cstat-no" title="statement not covered" >t[a]=t[a-e]}</span></span>;<span class="cstat-no" title="statement not covered" ></span>for(r(n),a=t;a&lt;o;++a)<span class="cstat-no" title="statement not covered" >n[a]=new this.dataElementType;<span class="cstat-no" title="statement not covered" >t</span></span>his._parsing&amp;&amp;r(s._parsed),this.parse(t,e),i&amp;&amp;this.updateElements(n,t,e,"reset")}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){}<span class="fstat-no" title="function not covered" >_r</span>emoveElements(t,e){const i=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>if(this._parsing){const s=<span class="cstat-no" title="statement not covered" >i._parsed.splice(t,e);<span class="cstat-no" title="statement not covered" ></span>i._stacked&amp;&amp;Ws(i,s)}<span class="cstat-no" title="statement not covered" ></span>i</span>.data.splice(t,e)}<span class="fstat-no" title="function not covered" ></span>_s</span>ync(t){<span class="cstat-no" title="statement not covered" >if(this._parsing)<span class="cstat-no" title="statement not covered" >this._syncList.push(t);e</span>lse{const[e,i,s]=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>this[e](i,s)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.chart._dataChanges.push([this.index,...t])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataPush(){const t=<span class="cstat-no" title="statement not covered" >arguments.length;<span class="cstat-no" title="statement not covered" ></span>this._sync(["_insertElements",this.getDataset().data.length-t,t])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataPop(){<span class="cstat-no" title="statement not covered" >this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataShift(){<span class="cstat-no" title="statement not covered" >this._sync(["_removeElements",0,1])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataSplice(t,e){<span class="cstat-no" title="statement not covered" >e&amp;&amp;this._sync(["_removeElements",t,e]);c</span>onst i=<span class="cstat-no" title="statement not covered" >arguments.length-2;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;this._sync(["_insertElements",t,i])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataUnshift(){<span class="cstat-no" title="statement not covered" >this._sync(["_insertElements",0,arguments.length])}</span>}class $s{static defaults=<span class="cstat-no" title="statement not covered" >{};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >void 0;</span>x;y;active=<span class="cstat-no" title="statement not covered" >!1;</span>options;$animations;<span class="fstat-no" title="function not covered" >to</span>oltipPosition(t){const{x:e,y:i}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],t);<span class="cstat-no" title="statement not covered" ></span>return{x:e,y:i}}<span class="fstat-no" title="function not covered" ></span>ha</span>sValue(){<span class="cstat-no" title="statement not covered" >return N(this.x)&amp;&amp;N(this.y)}<span class="fstat-no" title="function not covered" ></span>ge</span>tProps(t,e){const i=<span class="cstat-no" title="statement not covered" >this.$animations;<span class="cstat-no" title="statement not covered" ></span>if(!e||!i)<span class="cstat-no" title="statement not covered" >return this;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >s[t]=i[t]&amp;&amp;i[t].active()?i[t]._to:this[t]}</span>)),s}</span>}function <span class="fstat-no" title="function not covered" >Ys(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.options.ticks,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.options.offset,</span>i=<span class="cstat-no" title="statement not covered" >t._tickSize(),</span>s=<span class="cstat-no" title="statement not covered" >t._length/i+(e?0:1),</span>n=<span class="cstat-no" title="statement not covered" >t._maxLength/i;<span class="cstat-no" title="statement not covered" ></span>return Math.floor(Math.min(s,n))}</span>(t),</span>o=<span class="cstat-no" title="statement not covered" >Math.min(i.maxTicksLimit||n,n),</span>a=<span class="cstat-no" title="statement not covered" >i.major.enabled?<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >[];</span>let i,s;<span class="cstat-no" title="statement not covered" >for(i=0,s=t.length;i&lt;s;i++)<span class="cstat-no" title="statement not covered" >t[i].major&amp;&amp;e.push(i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>(e):[],</span>r=<span class="cstat-no" title="statement not covered" >a.length,</span>l=<span class="cstat-no" title="statement not covered" >a[0],</span>h=<span class="cstat-no" title="statement not covered" >a[r-1],</span>c=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(r&gt;o)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n,o=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >i[0];<span class="cstat-no" title="statement not covered" ></span>for(s=Math.ceil(s),n=0;n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >n===a&amp;&amp;(e.push(t[n]),o++,a=i[o*s])}</span></span>(e,c,a,r/o),c;c</span></span>onst d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.length;</span>let i,s;<span class="cstat-no" title="statement not covered" >if(e&lt;2)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(s=t[0],i=1;i&lt;e;++i)<span class="cstat-no" title="statement not covered" >if(t[i]-t[i-1]!==s)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn s}</span>(t),</span>n=<span class="cstat-no" title="statement not covered" >e.length/i;<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return Math.max(n,1);c</span></span>onst o=<span class="cstat-no" title="statement not covered" >W(s);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >o.length-1;</span>t&lt;e;t++){const e=<span class="cstat-no" title="statement not covered" >o[t];<span class="cstat-no" title="statement not covered" ></span>if(e&gt;n)<span class="cstat-no" title="statement not covered" >return e}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn Math.max(n,1)}</span>(a,e,o);<span class="cstat-no" title="statement not covered" ></span>if(r&gt;0){let t,i;const n=<span class="cstat-no" title="statement not covered" >r&gt;1?Math.round((h-l)/(r-1)):null;<span class="cstat-no" title="statement not covered" ></span>for(Us(e,c,d,s(n)?0:l-n,l),t=0,i=r-1;t&lt;i;t++)<span class="cstat-no" title="statement not covered" >Us(e,c,d,a[t],a[t+1]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn Us(e,c,d,h,s(n)?e.length:h+n),c}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Us(e,c,d),c}</span>function <span class="fstat-no" title="function not covered" >Us(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >l(s,0),</span>a=<span class="cstat-no" title="statement not covered" >Math.min(l(n,t.length),t.length);</span>let r,h,c,d=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(i=Math.ceil(i),n&amp;&amp;(r=n-s,i=r/Math.floor(r/i)),c=o;c&lt;0;)<span class="cstat-no" title="statement not covered" >d++,c=Math.round(o+d*i);<span class="cstat-no" title="statement not covered" >f</span></span>or(h=Math.max(o,0);h&lt;a;h++)<span class="cstat-no" title="statement not covered" >h===c&amp;&amp;(e.push(t[h]),d++,c=Math.round(o+d*i))}</span></span>const Xs=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >"top"===e||"left"===e?t[e]+i:t[e]-i,</span></span>qs=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.min(e||t,t);</span></span>function <span class="fstat-no" title="function not covered" >Ks(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >t.length/e,</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>let o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;o&lt;n;o+=s)<span class="cstat-no" title="statement not covered" >i.push(t[Math.floor(o)]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >Gs(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.ticks.length,</span>n=<span class="cstat-no" title="statement not covered" >Math.min(e,s-1),</span>o=<span class="cstat-no" title="statement not covered" >t._startPixel,</span>a=<span class="cstat-no" title="statement not covered" >t._endPixel,</span>r=<span class="cstat-no" title="statement not covered" >1e-6;</span>let l,h=<span class="cstat-no" title="statement not covered" >t.getPixelForTick(n);<span class="cstat-no" title="statement not covered" ></span>if(!(i&amp;&amp;(l=1===s?Math.max(h-o,a-h):0===e?(t.getPixelForTick(1)-h)/2:(h-t.getPixelForTick(n-1))/2,h+=n&lt;e?l:-l,h&lt;o-r||h&gt;a+r)))<span class="cstat-no" title="statement not covered" >return h}</span></span>function <span class="fstat-no" title="function not covered" >Js(</span>t){<span class="cstat-no" title="statement not covered" >return t.drawTicks?t.tickLength:0}</span>function <span class="fstat-no" title="function not covered" >Zs(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!t.display)<span class="cstat-no" title="statement not covered" >return 0;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >Si(t.font,e),</span>s=<span class="cstat-no" title="statement not covered" >ki(t.padding);<span class="cstat-no" title="statement not covered" ></span>return(n(t.text)?t.text.length:1)*i.lineHeight+s.height}</span>function <span class="fstat-no" title="function not covered" >Qs(</span>t,e,i){let s=<span class="cstat-no" title="statement not covered" >ut(t);<span class="cstat-no" title="statement not covered" ></span>return(i&amp;&amp;"right"!==e||!i&amp;&amp;"right"===e)&amp;&amp;(s=(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"left"===t?"right":"right"===t?"left":t)</span>(s)),s}</span>class tn extends $s{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}<span class="fstat-no" title="function not covered" ></span>in</span>it(t){<span class="cstat-no" title="statement not covered" >this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){<span class="cstat-no" title="statement not covered" >return t}<span class="fstat-no" title="function not covered" ></span>ge</span>tUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:i,_suggestedMax:s}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t=r(t,Number.POSITIVE_INFINITY),e=r(e,Number.NEGATIVE_INFINITY),i=r(i,Number.POSITIVE_INFINITY),s=r(s,Number.NEGATIVE_INFINITY),{min:r(t,i),max:r(e,s),minDefined:a(t),maxDefined:a(e)}}<span class="fstat-no" title="function not covered" ></span>ge</span>tMinMax(t){let e,{min:i,max:s,minDefined:n,maxDefined:o}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;o)<span class="cstat-no" title="statement not covered" >return{min:i,max:s};c</span></span>onst a=<span class="cstat-no" title="statement not covered" >this.getMatchingVisibleMetas();<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >a.length;</span>r&lt;l;++r)<span class="cstat-no" title="statement not covered" >e=a[r].controller.getMinMax(this,t),n||(i=Math.min(i,e.min)),o||(s=Math.max(s,e.max));<span class="cstat-no" title="statement not covered" >r</span></span>eturn i=o&amp;&amp;i&gt;s?s:i,s=n&amp;&amp;i&gt;s?i:s,{min:r(i,r(s,i)),max:r(s,r(i,s))}}<span class="fstat-no" title="function not covered" ></span>ge</span>tPadding(){<span class="cstat-no" title="statement not covered" >return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}<span class="fstat-no" title="function not covered" ></span>ge</span>tTicks(){<span class="cstat-no" title="statement not covered" >return this.ticks}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabels(){const t=<span class="cstat-no" title="statement not covered" >this.chart.data;<span class="cstat-no" title="statement not covered" ></span>return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelItems(t=<span class="branch-0 cbranch-no" title="branch not covered" >this.chart.chartArea)</span>{<span class="cstat-no" title="statement not covered" >return this._labelItems||(this._labelItems=this._computeLabelItems(t))}<span class="fstat-no" title="function not covered" ></span>be</span>foreLayout(){<span class="cstat-no" title="statement not covered" >this._cache={},this._dataLimitsCached=!1}<span class="fstat-no" title="function not covered" ></span>be</span>foreUpdate(){<span class="cstat-no" title="statement not covered" >d(this.options.beforeUpdate,[this])}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e,i){const{beginAtZero:s,grace:n,ticks:o}=<span class="cstat-no" title="statement not covered" >this.options,</span>a=<span class="cstat-no" title="statement not covered" >o.sampleSize;<span class="cstat-no" title="statement not covered" ></span>this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=i=Object.assign({left:0,right:0,top:0,bottom:0},i),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+i.left+i.right:this.height+i.top+i.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=Di(this,n,s),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();c</span>onst r=<span class="cstat-no" title="statement not covered" >a&lt;this.ticks.length;<span class="cstat-no" title="statement not covered" ></span>this._convertTicksToLabels(r?Ks(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),o.display&amp;&amp;(o.autoSkip||"auto"===o.source)&amp;&amp;(this.ticks=Ys(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),r&amp;&amp;this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){let t,e,i=<span class="cstat-no" title="statement not covered" >this.options.reverse;<span class="cstat-no" title="statement not covered" ></span>this.isHorizontal()?(t=this.left,e=this.right):(t=this.top,e=this.bottom,i=!i),this._startPixel=t,this._endPixel=e,this._reversePixels=i,this._length=e-t,this._alignToPixels=this.options.alignToPixels}<span class="fstat-no" title="function not covered" ></span>af</span>terUpdate(){<span class="cstat-no" title="statement not covered" >d(this.options.afterUpdate,[this])}<span class="fstat-no" title="function not covered" ></span>be</span>foreSetDimensions(){<span class="cstat-no" title="statement not covered" >d(this.options.beforeSetDimensions,[this])}<span class="fstat-no" title="function not covered" ></span>se</span>tDimensions(){<span class="cstat-no" title="statement not covered" >this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}<span class="fstat-no" title="function not covered" ></span>af</span>terSetDimensions(){<span class="cstat-no" title="statement not covered" >d(this.options.afterSetDimensions,[this])}<span class="fstat-no" title="function not covered" ></span>_c</span>allHooks(t){<span class="cstat-no" title="statement not covered" >this.chart.notifyPlugins(t,this.getContext()),d(this.options[t],[this])}<span class="fstat-no" title="function not covered" ></span>be</span>foreDataLimits(){<span class="cstat-no" title="statement not covered" >this._callHooks("beforeDataLimits")}<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){}<span class="fstat-no" title="function not covered" >af</span>terDataLimits(){<span class="cstat-no" title="statement not covered" >this._callHooks("afterDataLimits")}<span class="fstat-no" title="function not covered" ></span>be</span>foreBuildTicks(){<span class="cstat-no" title="statement not covered" >this._callHooks("beforeBuildTicks")}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){<span class="cstat-no" title="statement not covered" >return[]}<span class="fstat-no" title="function not covered" ></span>af</span>terBuildTicks(){<span class="cstat-no" title="statement not covered" >this._callHooks("afterBuildTicks")}<span class="fstat-no" title="function not covered" ></span>be</span>foreTickToLabelConversion(){<span class="cstat-no" title="statement not covered" >d(this.options.beforeTickToLabelConversion,[this])}<span class="fstat-no" title="function not covered" ></span>ge</span>nerateTickLabels(t){const e=<span class="cstat-no" title="statement not covered" >this.options.ticks;</span>let i,s,n;<span class="cstat-no" title="statement not covered" >for(i=0,s=t.length;i&lt;s;i++)<span class="cstat-no" title="statement not covered" >n=t[i],n.label=d(e.callback,[n.value,i,t],this)}<span class="fstat-no" title="function not covered" ></span></span>af</span>terTickToLabelConversion(){<span class="cstat-no" title="statement not covered" >d(this.options.afterTickToLabelConversion,[this])}<span class="fstat-no" title="function not covered" ></span>be</span>foreCalculateLabelRotation(){<span class="cstat-no" title="statement not covered" >d(this.options.beforeCalculateLabelRotation,[this])}<span class="fstat-no" title="function not covered" ></span>ca</span>lculateLabelRotation(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.ticks,</span>i=<span class="cstat-no" title="statement not covered" >qs(this.ticks.length,t.ticks.maxTicksLimit),</span>s=<span class="cstat-no" title="statement not covered" >e.minRotation||0,</span>n=<span class="cstat-no" title="statement not covered" >e.maxRotation;</span>let o,a,r,l=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if(!this._isVisible()||!e.display||s&gt;=n||i&lt;=1||!this.isHorizontal())<span class="cstat-no" title="statement not covered" >return void(this.labelRotation=s);c</span></span>onst h=<span class="cstat-no" title="statement not covered" >this._getLabelSizes(),</span>c=<span class="cstat-no" title="statement not covered" >h.widest.width,</span>d=<span class="cstat-no" title="statement not covered" >h.highest.height,</span>u=<span class="cstat-no" title="statement not covered" >Z(this.chart.width-c,0,this.maxWidth);<span class="cstat-no" title="statement not covered" ></span>o=t.offset?this.maxWidth/i:u/(i-1),c+6&gt;o&amp;&amp;(o=u/(i-(t.offset?.5:1)),a=this.maxHeight-Js(t.grid)-e.padding-Zs(t.title,this.chart.options.font),r=Math.sqrt(c*c+d*d),l=Y(Math.min(Math.asin(Z((h.highest.height+6)/o,-1,1)),Math.asin(Z(a/r,-1,1))-Math.asin(Z(d/r,-1,1)))),l=Math.max(s,Math.min(n,l))),this.labelRotation=l}<span class="fstat-no" title="function not covered" ></span>af</span>terCalculateLabelRotation(){<span class="cstat-no" title="statement not covered" >d(this.options.afterCalculateLabelRotation,[this])}<span class="fstat-no" title="function not covered" ></span>af</span>terAutoSkip(){}<span class="fstat-no" title="function not covered" >be</span>foreFit(){<span class="cstat-no" title="statement not covered" >d(this.options.beforeFit,[this])}<span class="fstat-no" title="function not covered" ></span>fi</span>t(){const t=<span class="cstat-no" title="statement not covered" >{width:0,height:0},</span>{chart:e,options:{ticks:i,title:s,grid:n}}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >this._isVisible(),</span>a=<span class="cstat-no" title="statement not covered" >this.isHorizontal();<span class="cstat-no" title="statement not covered" ></span>if(o){const o=<span class="cstat-no" title="statement not covered" >Zs(s,e.options.font);<span class="cstat-no" title="statement not covered" ></span>if(a?(t.width=this.maxWidth,t.height=Js(n)+o):(t.height=this.maxHeight,t.width=Js(n)+o),i.display&amp;&amp;this.ticks.length){const{first:e,last:s,widest:n,highest:o}=<span class="cstat-no" title="statement not covered" >this._getLabelSizes(),</span>r=<span class="cstat-no" title="statement not covered" >2*i.padding,</span>l=<span class="cstat-no" title="statement not covered" >$(this.labelRotation),</span>h=<span class="cstat-no" title="statement not covered" >Math.cos(l),</span>c=<span class="cstat-no" title="statement not covered" >Math.sin(l);<span class="cstat-no" title="statement not covered" ></span>if(a){const e=<span class="cstat-no" title="statement not covered" >i.mirror?0:c*n.width+h*o.height;<span class="cstat-no" title="statement not covered" ></span>t.height=Math.min(this.maxHeight,t.height+e+r)}</span>else{const e=<span class="cstat-no" title="statement not covered" >i.mirror?0:h*n.width+c*o.height;<span class="cstat-no" title="statement not covered" ></span>t.width=Math.min(this.maxWidth,t.width+e+r)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._calculatePadding(e,s,c,h)}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his._handleMargins(),a?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}<span class="fstat-no" title="function not covered" ></span>_c</span>alculatePadding(t,e,i,s){const{ticks:{align:n,padding:o},position:a}=<span class="cstat-no" title="statement not covered" >this.options,</span>r=<span class="cstat-no" title="statement not covered" >0!==this.labelRotation,</span>l=<span class="cstat-no" title="statement not covered" >"top"!==a&amp;&amp;"x"===this.axis;<span class="cstat-no" title="statement not covered" ></span>if(this.isHorizontal()){const a=<span class="cstat-no" title="statement not covered" >this.getPixelForTick(0)-this.left,</span>h=<span class="cstat-no" title="statement not covered" >this.right-this.getPixelForTick(this.ticks.length-1);</span>let c=<span class="cstat-no" title="statement not covered" >0,</span>d=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>r?l?(c=s*t.width,d=i*e.height):(c=i*t.height,d=s*e.width):"start"===n?d=e.width:"end"===n?c=t.width:"inner"!==n&amp;&amp;(c=t.width/2,d=e.width/2),this.paddingLeft=Math.max((c-a+o)*this.width/(this.width-a),0),this.paddingRight=Math.max((d-h+o)*this.width/(this.width-h),0)}</span>else{let i=<span class="cstat-no" title="statement not covered" >e.height/2,</span>s=<span class="cstat-no" title="statement not covered" >t.height/2;<span class="cstat-no" title="statement not covered" ></span>"start"===n?(i=0,s=t.height):"end"===n&amp;&amp;(i=e.height,s=0),this.paddingTop=i+o,this.paddingBottom=s+o}</span>}<span class="fstat-no" title="function not covered" ></span>_h</span>andleMargins(){<span class="cstat-no" title="statement not covered" >this._margins&amp;&amp;(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}<span class="fstat-no" title="function not covered" ></span>af</span>terFit(){<span class="cstat-no" title="statement not covered" >d(this.options.afterFit,[this])}<span class="fstat-no" title="function not covered" ></span>is</span>Horizontal(){const{axis:t,position:e}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>return"top"===e||"bottom"===e||"x"===t}<span class="fstat-no" title="function not covered" ></span>is</span>FullSize(){<span class="cstat-no" title="statement not covered" >return this.options.fullSize}<span class="fstat-no" title="function not covered" ></span>_c</span>onvertTicksToLabels(t){let e,i;<span class="cstat-no" title="statement not covered" >for(this.beforeTickToLabelConversion(),this.generateTickLabels(t),e=0,i=t.length;e&lt;i;e++)<span class="cstat-no" title="statement not covered" >s(t[e].label)&amp;&amp;(t.splice(e,1),i--,e--);<span class="cstat-no" title="statement not covered" >t</span></span>his.afterTickToLabelConversion()}<span class="fstat-no" title="function not covered" ></span>_g</span>etLabelSizes(){let t=<span class="cstat-no" title="statement not covered" >this._labelSizes;<span class="cstat-no" title="statement not covered" ></span>if(!t){const e=<span class="cstat-no" title="statement not covered" >this.options.ticks.sampleSize;</span>let i=<span class="cstat-no" title="statement not covered" >this.ticks;<span class="cstat-no" title="statement not covered" ></span>e&lt;i.length&amp;&amp;(i=Ks(i,e)),this._labelSizes=t=this._computeLabelSizes(i,i.length,this.options.ticks.maxTicksLimit)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeLabelSizes(t,e,i){const{ctx:o,_longestTextCache:a}=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >[],</span>l=<span class="cstat-no" title="statement not covered" >[],</span>h=<span class="cstat-no" title="statement not covered" >Math.floor(e/qs(e,i));</span>let c,d,f,g,p,m,x,b,_,y,v,M=<span class="cstat-no" title="statement not covered" >0,</span>w=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(c=0;c&lt;e;c+=h){<span class="cstat-no" title="statement not covered" >if(g=t[c].label,p=this._resolveTickFontOptions(c),o.font=m=p.string,x=a[m]=a[m]||{data:{},gc:[]},b=p.lineHeight,_=y=0,s(g)||n(g)){<span class="cstat-no" title="statement not covered" >if(n(g))<span class="cstat-no" title="statement not covered" >for(d=0,f=g.length;d&lt;f;++d)<span class="cstat-no" title="statement not covered" >v=g[d],s(v)||n(v)||(_=Ce(o,x.data,x.gc,_,v),y+=b)}</span></span></span>else <span class="cstat-no" title="statement not covered" >_=Ce(o,x.data,x.gc,_,g),y=b;<span class="cstat-no" title="statement not covered" >r</span></span>.push(_),l.push(y),M=Math.max(_,M),w=Math.max(y,w)}<span class="cstat-no" title="statement not covered" ></span>!<span class="fstat-no" title="function not covered" ></span>fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >u(t,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >t.gc,</span>s=<span class="cstat-no" title="statement not covered" >i.length/2;</span>let n;<span class="cstat-no" title="statement not covered" >if(s&gt;e){<span class="cstat-no" title="statement not covered" >for(n=0;n&lt;s;++n)<span class="cstat-no" title="statement not covered" >delete t.data[i[n]];<span class="cstat-no" title="statement not covered" >i</span></span>.splice(0,s)}</span>}</span>))}</span>(a,e);c</span>onst k=<span class="cstat-no" title="statement not covered" >r.indexOf(M),</span>S=<span class="cstat-no" title="statement not covered" >l.indexOf(w),</span>P=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{width:r[t]||0,height:l[t]||0})</span>;<span class="cstat-no" title="statement not covered" ></span>return{first:P(0),last:P(e-1),widest:P(k),highest:P(S),widths:r,heights:l}}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){<span class="cstat-no" title="statement not covered" >return t}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t,e){<span class="cstat-no" title="statement not covered" >return NaN}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){}<span class="fstat-no" title="function not covered" >ge</span>tPixelForTick(t){const e=<span class="cstat-no" title="statement not covered" >this.ticks;<span class="cstat-no" title="statement not covered" ></span>return t&lt;0||t&gt;e.length-1?null:this.getPixelForValue(e[t].value)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForDecimal(t){<span class="cstat-no" title="statement not covered" >this._reversePixels&amp;&amp;(t=1-t);c</span>onst e=<span class="cstat-no" title="statement not covered" >this._startPixel+t*this._length;<span class="cstat-no" title="statement not covered" ></span>return Q(this._alignToPixels?Ae(this.chart,e,0):e)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDecimalForPixel(t){const e=<span class="cstat-no" title="statement not covered" >(t-this._startPixel)/this._length;<span class="cstat-no" title="statement not covered" ></span>return this._reversePixels?1-e:e}<span class="fstat-no" title="function not covered" ></span>ge</span>tBasePixel(){<span class="cstat-no" title="statement not covered" >return this.getPixelForValue(this.getBaseValue())}<span class="fstat-no" title="function not covered" ></span>ge</span>tBaseValue(){const{min:t,max:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t&lt;0&amp;&amp;e&lt;0?e:t&gt;0&amp;&amp;e&gt;0?t:0}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(t){const e=<span class="cstat-no" title="statement not covered" >this.ticks||[];<span class="cstat-no" title="statement not covered" ></span>if(t&gt;=0&amp;&amp;t&lt;e.length){const i=<span class="cstat-no" title="statement not covered" >e[t];<span class="cstat-no" title="statement not covered" ></span>return i.$context||(i.$context=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return Ci(t,{tick:i,index:e,type:"tick"})}</span>(this.getContext(),t,i))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.$context||(this.$context=Ci(this.chart.getContext(),{scale:this,type:"scale"}))}<span class="fstat-no" title="function not covered" ></span>_t</span>ickSize(){const t=<span class="cstat-no" title="statement not covered" >this.options.ticks,</span>e=<span class="cstat-no" title="statement not covered" >$(this.labelRotation),</span>i=<span class="cstat-no" title="statement not covered" >Math.abs(Math.cos(e)),</span>s=<span class="cstat-no" title="statement not covered" >Math.abs(Math.sin(e)),</span>n=<span class="cstat-no" title="statement not covered" >this._getLabelSizes(),</span>o=<span class="cstat-no" title="statement not covered" >t.autoSkipPadding||0,</span>a=<span class="cstat-no" title="statement not covered" >n?n.widest.width+o:0,</span>r=<span class="cstat-no" title="statement not covered" >n?n.highest.height+o:0;<span class="cstat-no" title="statement not covered" ></span>return this.isHorizontal()?r*i&gt;a*s?a/i:r/s:r*s&lt;a*i?r/i:a/s}<span class="fstat-no" title="function not covered" ></span>_i</span>sVisible(){const t=<span class="cstat-no" title="statement not covered" >this.options.display;<span class="cstat-no" title="statement not covered" ></span>return"auto"!==t?!!t:this.getMatchingVisibleMetas().length&gt;0}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeGridLineItems(t){const e=<span class="cstat-no" title="statement not covered" >this.axis,</span>i=<span class="cstat-no" title="statement not covered" >this.chart,</span>s=<span class="cstat-no" title="statement not covered" >this.options,</span>{grid:n,position:a,border:r}=<span class="cstat-no" title="statement not covered" >s,</span>h=<span class="cstat-no" title="statement not covered" >n.offset,</span>c=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>d=<span class="cstat-no" title="statement not covered" >this.ticks.length+(h?1:0),</span>u=<span class="cstat-no" title="statement not covered" >Js(n),</span>f=<span class="cstat-no" title="statement not covered" >[],</span>g=<span class="cstat-no" title="statement not covered" >r.setContext(this.getContext()),</span>p=<span class="cstat-no" title="statement not covered" >g.display?g.width:0,</span>m=<span class="cstat-no" title="statement not covered" >p/2,</span>x=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Ae(i,t,p)}</span>;</span>let b,_,y,v,M,w,k,S,P,D,C,O;<span class="cstat-no" title="statement not covered" >if("top"===a)<span class="cstat-no" title="statement not covered" >b=x(this.bottom),w=this.bottom-u,S=b-m,D=x(t.top)+m,O=t.bottom;e</span>lse <span class="cstat-no" title="statement not covered" >if("bottom"===a)<span class="cstat-no" title="statement not covered" >b=x(this.top),D=t.top,O=x(t.bottom)-m,w=b+m,S=this.top+u;e</span>lse <span class="cstat-no" title="statement not covered" >if("left"===a)<span class="cstat-no" title="statement not covered" >b=x(this.right),M=this.right-u,k=b-m,P=x(t.left)+m,C=t.right;e</span>lse <span class="cstat-no" title="statement not covered" >if("right"===a)<span class="cstat-no" title="statement not covered" >b=x(this.left),P=t.left,C=x(t.right)-m,M=b+m,k=this.left+u;e</span>lse <span class="cstat-no" title="statement not covered" >if("x"===e){<span class="cstat-no" title="statement not covered" >if("center"===a)<span class="cstat-no" title="statement not covered" >b=x((t.top+t.bottom)/2+.5);e</span>lse <span class="cstat-no" title="statement not covered" >if(o(a)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(a)[0],</span>e=<span class="cstat-no" title="statement not covered" >a[t];<span class="cstat-no" title="statement not covered" ></span>b=x(this.chart.scales[t].getPixelForValue(e))}<span class="cstat-no" title="statement not covered" ></span>D</span></span>=t.top,O=t.bottom,w=b+m,S=w+u}</span>else <span class="cstat-no" title="statement not covered" >if("y"===e){<span class="cstat-no" title="statement not covered" >if("center"===a)<span class="cstat-no" title="statement not covered" >b=x((t.left+t.right)/2);e</span>lse <span class="cstat-no" title="statement not covered" >if(o(a)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(a)[0],</span>e=<span class="cstat-no" title="statement not covered" >a[t];<span class="cstat-no" title="statement not covered" ></span>b=x(this.chart.scales[t].getPixelForValue(e))}<span class="cstat-no" title="statement not covered" ></span>M</span></span>=b-m,k=M-u,P=t.left,C=t.right}</span>c</span></span></span></span></span></span>onst A=<span class="cstat-no" title="statement not covered" >l(s.ticks.maxTicksLimit,d),</span>T=<span class="cstat-no" title="statement not covered" >Math.max(1,Math.ceil(d/A));<span class="cstat-no" title="statement not covered" ></span>for(_=0;_&lt;d;_+=T){const t=<span class="cstat-no" title="statement not covered" >this.getContext(_),</span>e=<span class="cstat-no" title="statement not covered" >n.setContext(t),</span>s=<span class="cstat-no" title="statement not covered" >r.setContext(t),</span>o=<span class="cstat-no" title="statement not covered" >e.lineWidth,</span>a=<span class="cstat-no" title="statement not covered" >e.color,</span>l=<span class="cstat-no" title="statement not covered" >s.dash||[],</span>d=<span class="cstat-no" title="statement not covered" >s.dashOffset,</span>u=<span class="cstat-no" title="statement not covered" >e.tickWidth,</span>g=<span class="cstat-no" title="statement not covered" >e.tickColor,</span>p=<span class="cstat-no" title="statement not covered" >e.tickBorderDash||[],</span>m=<span class="cstat-no" title="statement not covered" >e.tickBorderDashOffset;<span class="cstat-no" title="statement not covered" ></span>y=Gs(this,_,h),void 0!==y&amp;&amp;(v=Ae(i,y,o),c?M=k=P=C=v:w=S=D=O=v,f.push({tx1:M,ty1:w,tx2:k,ty2:S,x1:P,y1:D,x2:C,y2:O,width:o,color:a,borderDash:l,borderDashOffset:d,tickWidth:u,tickColor:g,tickBorderDash:p,tickBorderDashOffset:m}))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._ticksLength=d,this._borderValue=b,f}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeLabelItems(t){const e=<span class="cstat-no" title="statement not covered" >this.axis,</span>i=<span class="cstat-no" title="statement not covered" >this.options,</span>{position:s,ticks:a}=<span class="cstat-no" title="statement not covered" >i,</span>r=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>l=<span class="cstat-no" title="statement not covered" >this.ticks,</span>{align:h,crossAlign:c,padding:d,mirror:u}=<span class="cstat-no" title="statement not covered" >a,</span>f=<span class="cstat-no" title="statement not covered" >Js(i.grid),</span>g=<span class="cstat-no" title="statement not covered" >f+d,</span>p=<span class="cstat-no" title="statement not covered" >u?-d:g,</span>m=<span class="cstat-no" title="statement not covered" >-$(this.labelRotation),</span>x=<span class="cstat-no" title="statement not covered" >[];</span>let b,_,y,v,M,w,k,S,P,D,C,O,A=<span class="cstat-no" title="statement not covered" >"middle";<span class="cstat-no" title="statement not covered" ></span>if("top"===s)<span class="cstat-no" title="statement not covered" >w=this.bottom-p,k=this._getXAxisLabelAlignment();e</span>lse <span class="cstat-no" title="statement not covered" >if("bottom"===s)<span class="cstat-no" title="statement not covered" >w=this.top+p,k=this._getXAxisLabelAlignment();e</span>lse <span class="cstat-no" title="statement not covered" >if("left"===s){const t=<span class="cstat-no" title="statement not covered" >this._getYAxisLabelAlignment(f);<span class="cstat-no" title="statement not covered" ></span>k=t.textAlign,M=t.x}</span>else <span class="cstat-no" title="statement not covered" >if("right"===s){const t=<span class="cstat-no" title="statement not covered" >this._getYAxisLabelAlignment(f);<span class="cstat-no" title="statement not covered" ></span>k=t.textAlign,M=t.x}</span>else <span class="cstat-no" title="statement not covered" >if("x"===e){<span class="cstat-no" title="statement not covered" >if("center"===s)<span class="cstat-no" title="statement not covered" >w=(t.top+t.bottom)/2+g;e</span>lse <span class="cstat-no" title="statement not covered" >if(o(s)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(s)[0],</span>e=<span class="cstat-no" title="statement not covered" >s[t];<span class="cstat-no" title="statement not covered" ></span>w=this.chart.scales[t].getPixelForValue(e)+g}<span class="cstat-no" title="statement not covered" ></span>k</span></span>=this._getXAxisLabelAlignment()}</span>else <span class="cstat-no" title="statement not covered" >if("y"===e){<span class="cstat-no" title="statement not covered" >if("center"===s)<span class="cstat-no" title="statement not covered" >M=(t.left+t.right)/2-g;e</span>lse <span class="cstat-no" title="statement not covered" >if(o(s)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(s)[0],</span>e=<span class="cstat-no" title="statement not covered" >s[t];<span class="cstat-no" title="statement not covered" ></span>M=this.chart.scales[t].getPixelForValue(e)}<span class="cstat-no" title="statement not covered" ></span>k</span></span>=this._getYAxisLabelAlignment(f).textAlign}<span class="cstat-no" title="statement not covered" ></span>"</span></span></span></span></span></span>y"===e&amp;&amp;("start"===h?A="top":"end"===h&amp;&amp;(A="bottom"));c</span>onst T=<span class="cstat-no" title="statement not covered" >this._getLabelSizes();<span class="cstat-no" title="statement not covered" ></span>for(b=0,_=l.length;b&lt;_;++b){<span class="cstat-no" title="statement not covered" >y=l[b],v=y.label;c</span>onst t=<span class="cstat-no" title="statement not covered" >a.setContext(this.getContext(b));<span class="cstat-no" title="statement not covered" ></span>S=this.getPixelForTick(b)+a.labelOffset,P=this._resolveTickFontOptions(b),D=P.lineHeight,C=n(v)?v.length:1;c</span>onst e=<span class="cstat-no" title="statement not covered" >C/2,</span>i=<span class="cstat-no" title="statement not covered" >t.color,</span>o=<span class="cstat-no" title="statement not covered" >t.textStrokeColor,</span>h=<span class="cstat-no" title="statement not covered" >t.textStrokeWidth;</span>let d,f=<span class="cstat-no" title="statement not covered" >k;<span class="cstat-no" title="statement not covered" ></span>if(r?(M=S,"inner"===k&amp;&amp;(f=b===_-1?this.options.reverse?"left":"right":0===b?this.options.reverse?"right":"left":"center"),O="top"===s?"near"===c||0!==m?-C*D+D/2:"center"===c?-T.highest.height/2-e*D+D:-T.highest.height+D/2:"near"===c||0!==m?D/2:"center"===c?T.highest.height/2-e*D:T.highest.height-C*D,u&amp;&amp;(O*=-1),0===m||t.showLabelBackdrop||(M+=D/2*Math.sin(m))):(w=S,O=(1-C)*D/2),t.showLabelBackdrop){const e=<span class="cstat-no" title="statement not covered" >ki(t.backdropPadding),</span>i=<span class="cstat-no" title="statement not covered" >T.heights[b],</span>s=<span class="cstat-no" title="statement not covered" >T.widths[b];</span>let n=<span class="cstat-no" title="statement not covered" >O-e.top,</span>o=<span class="cstat-no" title="statement not covered" >0-e.left;<span class="cstat-no" title="statement not covered" ></span>switch(A){case"middle":<span class="cstat-no" title="statement not covered" >n-=i/2;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"bottom":<span class="cstat-no" title="statement not covered" >n-=i}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(k){case"center":<span class="cstat-no" title="statement not covered" >o-=s/2;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"right":<span class="cstat-no" title="statement not covered" >o-=s;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"inner":<span class="cstat-no" title="statement not covered" >b===_-1?o-=s:b&gt;0&amp;&amp;(o-=s/2)}<span class="cstat-no" title="statement not covered" ></span>d</span>={left:o,top:n,width:s+e.width,height:i+e.height,color:t.backdropColor}}<span class="cstat-no" title="statement not covered" ></span>x</span>.push({label:v,font:P,textOffset:O,options:{rotation:m,color:i,strokeColor:o,strokeWidth:h,textAlign:f,textBaseline:A,translation:[M,w],backdrop:d}})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn x}<span class="fstat-no" title="function not covered" ></span>_g</span>etXAxisLabelAlignment(){const{position:t,ticks:e}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(-$(this.labelRotation))<span class="cstat-no" title="statement not covered" >return"top"===t?"left":"right";l</span></span>et i=<span class="cstat-no" title="statement not covered" >"center";<span class="cstat-no" title="statement not covered" ></span>return"start"===e.align?i="left":"end"===e.align?i="right":"inner"===e.align&amp;&amp;(i="inner"),i}<span class="fstat-no" title="function not covered" ></span>_g</span>etYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:i,mirror:s,padding:n}}=<span class="cstat-no" title="statement not covered" >this.options,</span>o=<span class="cstat-no" title="statement not covered" >t+n,</span>a=<span class="cstat-no" title="statement not covered" >this._getLabelSizes().widest.width;</span>let r,l;<span class="cstat-no" title="statement not covered" >return"left"===e?s?(l=this.right+n,"near"===i?r="left":"center"===i?(r="center",l+=a/2):(r="right",l+=a)):(l=this.right-o,"near"===i?r="right":"center"===i?(r="center",l-=a/2):(r="left",l=this.left)):"right"===e?s?(l=this.left+n,"near"===i?r="right":"center"===i?(r="center",l-=a/2):(r="left",l-=a)):(l=this.left+o,"near"===i?r="left":"center"===i?(r="center",l+=a/2):(r="right",l=this.right)):r="right",{textAlign:r,x:l}}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeLabelArea(){<span class="cstat-no" title="statement not covered" >if(this.options.ticks.mirror)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.chart,</span>e=<span class="cstat-no" title="statement not covered" >this.options.position;<span class="cstat-no" title="statement not covered" ></span>return"left"===e||"right"===e?{top:0,left:this.left,bottom:t.height,right:this.right}:"top"===e||"bottom"===e?{top:this.top,left:0,bottom:this.bottom,right:t.width}:void 0}<span class="fstat-no" title="function not covered" ></span>dr</span>awBackground(){const{ctx:t,options:{backgroundColor:e},left:i,top:s,width:n,height:o}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(t.save(),t.fillStyle=e,t.fillRect(i,s,n,o),t.restore())}<span class="fstat-no" title="function not covered" ></span>ge</span>tLineWidthForValue(t){const e=<span class="cstat-no" title="statement not covered" >this.options.grid;<span class="cstat-no" title="statement not covered" ></span>if(!this._isVisible()||!e.display)<span class="cstat-no" title="statement not covered" >return 0;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.ticks.findIndex((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.value===t)</span>);<span class="cstat-no" title="statement not covered" ></span>if(i&gt;=0){<span class="cstat-no" title="statement not covered" >return e.setContext(this.getContext(i)).lineWidth}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn 0}<span class="fstat-no" title="function not covered" ></span>dr</span>awGrid(t){const e=<span class="cstat-no" title="statement not covered" >this.options.grid,</span>i=<span class="cstat-no" title="statement not covered" >this.ctx,</span>s=<span class="cstat-no" title="statement not covered" >this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));</span>let n,o;const a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >s.width&amp;&amp;s.color&amp;&amp;(i.save(),i.lineWidth=s.width,i.strokeStyle=s.color,i.setLineDash(s.borderDash||[]),i.lineDashOffset=s.borderDashOffset,i.beginPath(),i.moveTo(t.x,t.y),i.lineTo(e.x,e.y),i.stroke(),i.restore())}</span>;<span class="cstat-no" title="statement not covered" ></span>if(e.display)<span class="cstat-no" title="statement not covered" >for(n=0,o=s.length;n&lt;o;++n){const t=<span class="cstat-no" title="statement not covered" >s[n];<span class="cstat-no" title="statement not covered" ></span>e.drawOnChartArea&amp;&amp;a({x:t.x1,y:t.y1},{x:t.x2,y:t.y2},t),e.drawTicks&amp;&amp;a({x:t.tx1,y:t.ty1},{x:t.tx2,y:t.ty2},{color:t.tickColor,width:t.tickWidth,borderDash:t.tickBorderDash,borderDashOffset:t.tickBorderDashOffset})}</span>}<span class="fstat-no" title="function not covered" ></span></span>dr</span>awBorder(){const{chart:t,ctx:e,options:{border:i,grid:s}}=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >i.setContext(this.getContext()),</span>o=<span class="cstat-no" title="statement not covered" >i.display?n.width:0;<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >s.setContext(this.getContext(0)).lineWidth,</span>r=<span class="cstat-no" title="statement not covered" >this._borderValue;</span>let l,h,c,d;<span class="cstat-no" title="statement not covered" >this.isHorizontal()?(l=Ae(t,this.left,o)-o/2,h=Ae(t,this.right,a)+a/2,c=d=r):(c=Ae(t,this.top,o)-o/2,d=Ae(t,this.bottom,a)+a/2,l=h=r),e.save(),e.lineWidth=n.width,e.strokeStyle=n.color,e.beginPath(),e.moveTo(l,c),e.lineTo(h,d),e.stroke(),e.restore()}<span class="fstat-no" title="function not covered" ></span>dr</span>awLabels(t){<span class="cstat-no" title="statement not covered" >if(!this.options.ticks.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>i=<span class="cstat-no" title="statement not covered" >this._computeLabelArea();<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;Ie(e,i);c</span>onst s=<span class="cstat-no" title="statement not covered" >this.getLabelItems(t);<span class="cstat-no" title="statement not covered" ></span>for(const t of s){const i=<span class="cstat-no" title="statement not covered" >t.options,</span>s=<span class="cstat-no" title="statement not covered" >t.font;<span class="cstat-no" title="statement not covered" ></span>Ne(e,t.label,0,t.textOffset,s,i)}<span class="cstat-no" title="statement not covered" ></span>i</span>&amp;&amp;ze(e)}<span class="fstat-no" title="function not covered" ></span>dr</span>awTitle(){const{ctx:t,options:{position:e,title:i,reverse:s}}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!i.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >Si(i.font),</span>r=<span class="cstat-no" title="statement not covered" >ki(i.padding),</span>l=<span class="cstat-no" title="statement not covered" >i.align;</span>let h=<span class="cstat-no" title="statement not covered" >a.lineHeight/2;<span class="cstat-no" title="statement not covered" ></span>"bottom"===e||"center"===e||o(e)?(h+=r.bottom,n(i.text)&amp;&amp;(h+=a.lineHeight*(i.text.length-1))):h+=r.top;c</span>onst{titleX:c,titleY:d,maxWidth:u,rotation:f}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{top:n,left:a,bottom:r,right:l,chart:h}=<span class="cstat-no" title="statement not covered" >t,</span>{chartArea:c,scales:d}=<span class="cstat-no" title="statement not covered" >h;</span>let u,f,g,p=<span class="cstat-no" title="statement not covered" >0;</span>const m=<span class="cstat-no" title="statement not covered" >r-n,</span>x=<span class="cstat-no" title="statement not covered" >l-a;<span class="cstat-no" title="statement not covered" ></span>if(t.isHorizontal()){<span class="cstat-no" title="statement not covered" >if(f=ft(s,a,l),o(i)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(i)[0],</span>s=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>g=d[t].getPixelForValue(s)+m-e}</span>else <span class="cstat-no" title="statement not covered" >g="center"===i?(c.bottom+c.top)/2+m-e:Xs(t,i,e);<span class="cstat-no" title="statement not covered" >u</span></span>=l-a}</span>else{<span class="cstat-no" title="statement not covered" >if(o(i)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(i)[0],</span>s=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>f=d[t].getPixelForValue(s)-x+e}</span>else <span class="cstat-no" title="statement not covered" >f="center"===i?(c.left+c.right)/2-x+e:Xs(t,i,e);<span class="cstat-no" title="statement not covered" >g</span></span>=ft(s,r,n),p="left"===i?-E:E}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{titleX:f,titleY:g,maxWidth:u,rotation:p}}</span>(this,h,e,l);<span class="cstat-no" title="statement not covered" ></span>Ne(t,i.text,0,0,a,{color:i.color,maxWidth:u,rotation:f,textAlign:Qs(l,e,s),textBaseline:"middle",translation:[c,d]})}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){<span class="cstat-no" title="statement not covered" >this._isVisible()&amp;&amp;(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}<span class="fstat-no" title="function not covered" ></span>_l</span>ayers(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.ticks&amp;&amp;t.ticks.z||0,</span>i=<span class="cstat-no" title="statement not covered" >l(t.grid&amp;&amp;t.grid.z,-1),</span>s=<span class="cstat-no" title="statement not covered" >l(t.border&amp;&amp;t.border.z,0);<span class="cstat-no" title="statement not covered" ></span>return this._isVisible()&amp;&amp;this.draw===tn.prototype.draw?[{z:i,draw:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.drawBackground(),this.drawGrid(t),this.drawTitle()}</span>},{z:s,draw:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.drawBorder()}</span>},{z:e,draw:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.drawLabels(t)}</span>}]:[{z:e,draw:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.draw(t)}</span>}]}<span class="fstat-no" title="function not covered" ></span>ge</span>tMatchingVisibleMetas(t){const e=<span class="cstat-no" title="statement not covered" >this.chart.getSortedVisibleDatasetMetas(),</span>i=<span class="cstat-no" title="statement not covered" >this.axis+"AxisID",</span>s=<span class="cstat-no" title="statement not covered" >[];</span>let n,o;<span class="cstat-no" title="statement not covered" >for(n=0,o=e.length;n&lt;o;++n){const o=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>o[i]!==this.id||t&amp;&amp;o.type!==t||s.push(o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveTickFontOptions(t){<span class="cstat-no" title="statement not covered" >return Si(this.options.ticks.setContext(this.getContext(t)).font)}<span class="fstat-no" title="function not covered" ></span>_m</span>axDigits(){const t=<span class="cstat-no" title="statement not covered" >this._resolveTickFontOptions(0).lineHeight;<span class="cstat-no" title="statement not covered" ></span>return(this.isHorizontal()?this.width:this.height)/t}</span>}class en{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i){<span class="cstat-no" title="statement not covered" >this.type=t,this.scope=e,this.override=i,this.items=Object.create(null)}<span class="fstat-no" title="function not covered" ></span>is</span>ForType(t){<span class="cstat-no" title="statement not covered" >return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}<span class="fstat-no" title="function not covered" ></span>re</span>gister(t){const e=<span class="cstat-no" title="statement not covered" >Object.getPrototypeOf(t);</span>let i;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"id"in t&amp;&amp;"defaults"in t}</span>)(e)&amp;&amp;(i=this.register(e));c</span>onst s=<span class="cstat-no" title="statement not covered" >this.items,</span>n=<span class="cstat-no" title="statement not covered" >t.id,</span>o=<span class="cstat-no" title="statement not covered" >this.scope+"."+n;<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >throw new Error("class does not have id: "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n in s||(s[n]=t,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >x(Object.create(null),[i?ue.get(i):{},ue.get(e),t.defaults]);<span class="cstat-no" title="statement not covered" ></span>ue.set(e,s),t.defaultRoutes&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >Object.keys(e).forEach((<span class="fstat-no" title="function not covered" >i=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >i.split("."),</span>n=<span class="cstat-no" title="statement not covered" >s.pop(),</span>o=<span class="cstat-no" title="statement not covered" >[t].concat(s).join("."),</span>a=<span class="cstat-no" title="statement not covered" >e[i].split("."),</span>r=<span class="cstat-no" title="statement not covered" >a.pop(),</span>l=<span class="cstat-no" title="statement not covered" >a.join(".");<span class="cstat-no" title="statement not covered" ></span>ue.route(o,n,l,r)}</span>))}</span>(e,t.defaultRoutes);<span class="cstat-no" title="statement not covered" >t</span>.descriptors&amp;&amp;ue.describe(e,t.descriptors)}</span>(t,o,i),this.override&amp;&amp;ue.override(t.id,t.overrides)),o}<span class="fstat-no" title="function not covered" ></span>ge</span>t(t){<span class="cstat-no" title="statement not covered" >return this.items[t]}<span class="fstat-no" title="function not covered" ></span>un</span>register(t){const e=<span class="cstat-no" title="statement not covered" >this.items,</span>i=<span class="cstat-no" title="statement not covered" >t.id,</span>s=<span class="cstat-no" title="statement not covered" >this.scope;<span class="cstat-no" title="statement not covered" ></span>i in e&amp;&amp;delete e[i],s&amp;&amp;i in ue[s]&amp;&amp;(delete ue[s][i],this.override&amp;&amp;delete re[i])}</span>}class sn{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.controllers=new en(js,"datasets",!0),this.elements=new en($s,"elements"),this.plugins=new en(Object,"plugins"),this.scales=new en(tn,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}<span class="fstat-no" title="function not covered" ></span>ad</span>d(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t)}<span class="fstat-no" title="function not covered" ></span>re</span>move(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dControllers(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.controllers)}<span class="fstat-no" title="function not covered" ></span>ad</span>dElements(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.elements)}<span class="fstat-no" title="function not covered" ></span>ad</span>dPlugins(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.plugins)}<span class="fstat-no" title="function not covered" ></span>ad</span>dScales(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.scales)}<span class="fstat-no" title="function not covered" ></span>ge</span>tController(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.controllers,"controller")}<span class="fstat-no" title="function not covered" ></span>ge</span>tElement(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.elements,"element")}<span class="fstat-no" title="function not covered" ></span>ge</span>tPlugin(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.plugins,"plugin")}<span class="fstat-no" title="function not covered" ></span>ge</span>tScale(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.scales,"scale")}<span class="fstat-no" title="function not covered" ></span>re</span>moveControllers(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.controllers)}<span class="fstat-no" title="function not covered" ></span>re</span>moveElements(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.elements)}<span class="fstat-no" title="function not covered" ></span>re</span>movePlugins(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.plugins)}<span class="fstat-no" title="function not covered" ></span>re</span>moveScales(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.scales)}<span class="fstat-no" title="function not covered" ></span>_e</span>ach(t,e,i){<span class="cstat-no" title="statement not covered" >[...e].forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >i||this._getRegistryForType(e);<span class="cstat-no" title="statement not covered" ></span>i||s.isForType(e)||s===this.plugins&amp;&amp;e.id?this._exec(t,s,e):u(e,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >i||this._getRegistryForType(e);<span class="cstat-no" title="statement not covered" ></span>this._exec(t,s,e)}</span>))}</span>))}<span class="fstat-no" title="function not covered" ></span>_e</span>xec(t,e,i){const s=<span class="cstat-no" title="statement not covered" >w(t);<span class="cstat-no" title="statement not covered" ></span>d(i["before"+s],[],i),e[t](i),d(i["after"+s],[],i)}<span class="fstat-no" title="function not covered" ></span>_g</span>etRegistryForType(t){<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this._typedRegistries.length;e++){const i=<span class="cstat-no" title="statement not covered" >this._typedRegistries[e];<span class="cstat-no" title="statement not covered" ></span>if(i.isForType(t))<span class="cstat-no" title="statement not covered" >return i}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn this.plugins}<span class="fstat-no" title="function not covered" ></span>_g</span>et(t,e,i){const s=<span class="cstat-no" title="statement not covered" >e.get(t);<span class="cstat-no" title="statement not covered" ></span>if(void 0===s)<span class="cstat-no" title="statement not covered" >throw new Error('"'+t+'" is not a registered '+i+".");<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>}var nn=<span class="cstat-no" title="statement not covered" >new sn;</span>class on{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._init=[]}<span class="fstat-no" title="function not covered" ></span>no</span>tify(t,e,i,s){<span class="cstat-no" title="statement not covered" >"beforeInit"===e&amp;&amp;(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,"install"));c</span>onst n=<span class="cstat-no" title="statement not covered" >s?this._descriptors(t).filter(s):this._descriptors(t),</span>o=<span class="cstat-no" title="statement not covered" >this._notify(n,t,e,i);<span class="cstat-no" title="statement not covered" ></span>return"afterDestroy"===e&amp;&amp;(this._notify(n,t,"stop"),this._notify(this._init,t,"uninstall")),o}<span class="fstat-no" title="function not covered" ></span>_n</span>otify(t,e,i,s){<span class="cstat-no" title="statement not covered" >s=s||{};<span class="cstat-no" title="statement not covered" >f</span>or(const n of t){const t=<span class="cstat-no" title="statement not covered" >n.plugin;<span class="cstat-no" title="statement not covered" ></span>if(!1===d(t[i],[e,s,n.options],t)&amp;&amp;s.cancelable)<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!0}<span class="fstat-no" title="function not covered" ></span>in</span>validate(){<span class="cstat-no" title="statement not covered" >s(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}<span class="fstat-no" title="function not covered" ></span>_d</span>escriptors(t){<span class="cstat-no" title="statement not covered" >if(this._cache)<span class="cstat-no" title="statement not covered" >return this._cache;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this._cache=this._createDescriptors(t);<span class="cstat-no" title="statement not covered" ></span>return this._notifyStateChanges(t),e}<span class="fstat-no" title="function not covered" ></span>_c</span>reateDescriptors(t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.config,</span>s=<span class="cstat-no" title="statement not covered" >l(i.options&amp;&amp;i.options.plugins,{}),</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >{},</span>i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(nn.plugins.items);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;s.length;t++)<span class="cstat-no" title="statement not covered" >i.push(nn.getPlugin(s[t]));c</span></span>onst n=<span class="cstat-no" title="statement not covered" >t.plugins||[];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;n.length;t++){const s=<span class="cstat-no" title="statement not covered" >n[t];<span class="cstat-no" title="statement not covered" ></span>-1===i.indexOf(s)&amp;&amp;(i.push(s),e[s.id]=!0)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{plugins:i,localIds:e}}</span>(i);<span class="cstat-no" title="statement not covered" ></span>return!1!==s||e?<span class="fstat-no" title="function not covered" >fu</span>nction(t,{plugins:e,localIds:i},s,n){const o=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >t.getContext();<span class="cstat-no" title="statement not covered" ></span>for(const r of e){const e=<span class="cstat-no" title="statement not covered" >r.id,</span>l=<span class="cstat-no" title="statement not covered" >an(s[e],n);<span class="cstat-no" title="statement not covered" ></span>null!==l&amp;&amp;o.push({plugin:r,options:rn(t.config,{plugin:r,local:i[e]},l,a)})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}</span>(t,n,s,e):[]}<span class="fstat-no" title="function not covered" ></span>_n</span>otifyStateChanges(t){const e=<span class="cstat-no" title="statement not covered" >this._oldCache||[],</span>i=<span class="cstat-no" title="statement not covered" >this._cache,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!e.some((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.plugin.id===e.plugin.id)</span>))</span>);<span class="cstat-no" title="statement not covered" ></span></span>this._notify(s(e,i),t,"stop"),this._notify(s(i,e),t,"start")}</span>}function <span class="fstat-no" title="function not covered" >an(</span>t,e){<span class="cstat-no" title="statement not covered" >return e||!1!==t?!0===t?{}:t:null}</span>function <span class="fstat-no" title="function not covered" >rn(</span>t,{plugin:e,local:i},s,n){const o=<span class="cstat-no" title="statement not covered" >t.pluginScopeKeys(e),</span>a=<span class="cstat-no" title="statement not covered" >t.getOptionScopes(s,o);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;e.defaults&amp;&amp;a.push(e.defaults),t.createResolver(a,n,[""],{scriptable:!1,indexable:!1,allKeys:!0})}</span>function <span class="fstat-no" title="function not covered" >ln(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >ue.datasets[t]||{};<span class="cstat-no" title="statement not covered" ></span>return((e.datasets||{})[t]||{}).indexAxis||e.indexAxis||i.indexAxis||"x"}</span>function <span class="fstat-no" title="function not covered" >hn(</span>t){<span class="cstat-no" title="statement not covered" >if("x"===t||"y"===t||"r"===t)<span class="cstat-no" title="statement not covered" >return t}</span></span>function <span class="fstat-no" title="function not covered" >cn(</span>t,...e){<span class="cstat-no" title="statement not covered" >if(hn(t))<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >f</span></span>or(const s of e){const e=<span class="cstat-no" title="statement not covered" >s.axis||("top"===(i=s.position)||"bottom"===i?"x":"left"===i||"right"===i?"y":void 0)||t.length&gt;1&amp;&amp;hn(t[0].toLowerCase());<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return e}</span></span>v</span>ar i;<span class="cstat-no" title="statement not covered" >throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`)}</span>function <span class="fstat-no" title="function not covered" >dn(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(i[e+"AxisID"]===t)<span class="cstat-no" title="statement not covered" >return{axis:e}}</span></span>function <span class="fstat-no" title="function not covered" >un(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >re[t.type]||{scales:{}},</span>s=<span class="cstat-no" title="statement not covered" >e.scales||{},</span>n=<span class="cstat-no" title="statement not covered" >ln(t.type,e),</span>a=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>return Object.keys(s).forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const r=<span class="cstat-no" title="statement not covered" >s[e];<span class="cstat-no" title="statement not covered" ></span>if(!o(r))<span class="cstat-no" title="statement not covered" >return console.error(`Invalid scale configuration for scale: ${e}`);<span class="cstat-no" title="statement not covered" >i</span></span>f(r._proxy)<span class="cstat-no" title="statement not covered" >return console.warn(`Ignoring resolver passed as options for scale: ${e}`);c</span></span>onst l=<span class="cstat-no" title="statement not covered" >cn(e,r,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(e.data&amp;&amp;e.data.datasets){const i=<span class="cstat-no" title="statement not covered" >e.data.datasets.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.xAxisID===t||e.yAxisID===t)</span>);<span class="cstat-no" title="statement not covered" ></span>if(i.length)<span class="cstat-no" title="statement not covered" >return dn(t,"x",i[0])||dn(t,"y",i[0])}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{}}</span>(e,t),ue.scales[r.type]),</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t===e?"_index_":"_value_"}</span>(l,n),</span>c=<span class="cstat-no" title="statement not covered" >i.scales||{};<span class="cstat-no" title="statement not covered" ></span>a[e]=b(Object.create(null),[{axis:l},r,c[l],c[h]])}</span>)),t.data.datasets.forEach((<span class="fstat-no" title="function not covered" >i=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >i.type||t.type,</span>o=<span class="cstat-no" title="statement not covered" >i.indexAxis||ln(n,e),</span>r=<span class="cstat-no" title="statement not covered" >(re[n]||{}).scales||{};<span class="cstat-no" title="statement not covered" ></span>Object.keys(r).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return"_index_"===t?i=e:"_value_"===t&amp;&amp;(i="x"===e?"y":"x"),i}</span>(t,o),</span>n=<span class="cstat-no" title="statement not covered" >i[e+"AxisID"]||e;<span class="cstat-no" title="statement not covered" ></span>a[n]=a[n]||Object.create(null),b(a[n],[{axis:e},s[n],r[t]])}</span>))}</span>)),Object.keys(a).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >a[t];<span class="cstat-no" title="statement not covered" ></span>b(e,[ue.scales[e.type],ue.scale])}</span>)),a}</span>function <span class="fstat-no" title="function not covered" >fn(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.options||(t.options={});<span class="cstat-no" title="statement not covered" ></span>e.plugins=l(e.plugins,{}),e.scales=un(t,e)}</span>function <span class="fstat-no" title="function not covered" >gn(</span>t){<span class="cstat-no" title="statement not covered" >return(t=t||{}).datasets=t.datasets||[],t.labels=t.labels||[],t}</span>const pn=<span class="cstat-no" title="statement not covered" >new Map,</span>mn=<span class="cstat-no" title="statement not covered" >new Set;</span>function <span class="fstat-no" title="function not covered" >xn(</span>t,e){let i=<span class="cstat-no" title="statement not covered" >pn.get(t);<span class="cstat-no" title="statement not covered" ></span>return i||(i=e(),pn.set(t,i),mn.add(i)),i}</span>const bn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{const s=<span class="cstat-no" title="statement not covered" >M(e,i);<span class="cstat-no" title="statement not covered" ></span>void 0!==s&amp;&amp;t.add(s)}</span>;</span>class _n{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this._config=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return(t=t||{}).data=gn(t.data),fn(t),t}</span>(t),this._scopeCache=new Map,this._resolverCache=new Map}<span class="fstat-no" title="function not covered" ></span>ge</span>t platform(){<span class="cstat-no" title="statement not covered" >return this._config.platform}<span class="fstat-no" title="function not covered" ></span>ge</span>t type(){<span class="cstat-no" title="statement not covered" >return this._config.type}<span class="fstat-no" title="function not covered" ></span>se</span>t type(t){<span class="cstat-no" title="statement not covered" >this._config.type=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t data(){<span class="cstat-no" title="statement not covered" >return this._config.data}<span class="fstat-no" title="function not covered" ></span>se</span>t data(t){<span class="cstat-no" title="statement not covered" >this._config.data=gn(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>t options(){<span class="cstat-no" title="statement not covered" >return this._config.options}<span class="fstat-no" title="function not covered" ></span>se</span>t options(t){<span class="cstat-no" title="statement not covered" >this._config.options=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t plugins(){<span class="cstat-no" title="statement not covered" >return this._config.plugins}<span class="fstat-no" title="function not covered" ></span>up</span>date(){const t=<span class="cstat-no" title="statement not covered" >this._config;<span class="cstat-no" title="statement not covered" ></span>this.clearCache(),fn(t)}<span class="fstat-no" title="function not covered" ></span>cl</span>earCache(){<span class="cstat-no" title="statement not covered" >this._scopeCache.clear(),this._resolverCache.clear()}<span class="fstat-no" title="function not covered" ></span>da</span>tasetScopeKeys(t){<span class="cstat-no" title="statement not covered" >return xn(t,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`datasets.${t}`,""]])</span>)}<span class="fstat-no" title="function not covered" ></span>da</span>tasetAnimationScopeKeys(t,e){<span class="cstat-no" title="statement not covered" >return xn(`${t}.transition.${e}`,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,""]])</span>)}<span class="fstat-no" title="function not covered" ></span>da</span>tasetElementScopeKeys(t,e){<span class="cstat-no" title="statement not covered" >return xn(`${t}-${e}`,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,""]])</span>)}<span class="fstat-no" title="function not covered" ></span>pl</span>uginScopeKeys(t){const e=<span class="cstat-no" title="statement not covered" >t.id;<span class="cstat-no" title="statement not covered" ></span>return xn(`${this.type}-plugin-${e}`,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`plugins.${e}`,...t.additionalOptionScopes||[]]])</span>)}<span class="fstat-no" title="function not covered" ></span>_c</span>achedScopes(t,e){const i=<span class="cstat-no" title="statement not covered" >this._scopeCache;</span>let s=<span class="cstat-no" title="statement not covered" >i.get(t);<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;!e||(s=new Map,i.set(t,s)),s}<span class="fstat-no" title="function not covered" ></span>ge</span>tOptionScopes(t,e,i){const{options:s,type:n}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >this._cachedScopes(t,i),</span>a=<span class="cstat-no" title="statement not covered" >o.get(e);<span class="cstat-no" title="statement not covered" ></span>if(a)<span class="cstat-no" title="statement not covered" >return a;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>e.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >t&amp;&amp;(r.add(t),e.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >bn(r,t,e))</span>)),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >bn(r,s,t))</span>),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >bn(r,re[n]||{},t))</span>),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >bn(r,ue,t))</span>),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >bn(r,le,t))</span>)}</span>));c</span>onst l=<span class="cstat-no" title="statement not covered" >Array.from(r);<span class="cstat-no" title="statement not covered" ></span>return 0===l.length&amp;&amp;l.push(Object.create(null)),mn.has(e)&amp;&amp;o.set(e,l),l}<span class="fstat-no" title="function not covered" ></span>ch</span>artOptionScopes(){const{options:t,type:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return[t,re[e]||{},ue.datasets[e]||{},{type:e},ue,le]}<span class="fstat-no" title="function not covered" ></span>re</span>solveNamedOptions(t,e,i,s=<span class="branch-0 cbranch-no" title="branch not covered" >[""])</span>{const o=<span class="cstat-no" title="statement not covered" >{$shared:!0},</span>{resolver:a,subPrefixes:r}=<span class="cstat-no" title="statement not covered" >yn(this._resolverCache,t,s);</span>let l=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>if(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{isScriptable:i,isIndexable:s}=<span class="cstat-no" title="statement not covered" >Ye(t);<span class="cstat-no" title="statement not covered" ></span>for(const o of e){const e=<span class="cstat-no" title="statement not covered" >i(o),</span>a=<span class="cstat-no" title="statement not covered" >s(o),</span>r=<span class="cstat-no" title="statement not covered" >(a||e)&amp;&amp;t[o];<span class="cstat-no" title="statement not covered" ></span>if(e&amp;&amp;(S(r)||vn(r))||a&amp;&amp;n(r))<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>(a,e)){<span class="cstat-no" title="statement not covered" >o.$shared=!1;<span class="cstat-no" title="statement not covered" >l</span>=$e(a,i=S(i)?i():i,this.createResolver(t,i,r))}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const t of e)<span class="cstat-no" title="statement not covered" >o[t]=l[t];<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}<span class="fstat-no" title="function not covered" ></span>cr</span>eateResolver(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >[""],</span>s){const{resolver:n}=<span class="cstat-no" title="statement not covered" >yn(this._resolverCache,t,i);<span class="cstat-no" title="statement not covered" ></span>return o(e)?$e(n,e,void 0,s):n}</span>}function <span class="fstat-no" title="function not covered" >yn(</span>t,e,i){let s=<span class="cstat-no" title="statement not covered" >t.get(e);<span class="cstat-no" title="statement not covered" ></span>s||(s=new Map,t.set(e,s));c</span>onst n=<span class="cstat-no" title="statement not covered" >i.join();</span>let o=<span class="cstat-no" title="statement not covered" >s.get(n);<span class="cstat-no" title="statement not covered" ></span>if(!o){<span class="cstat-no" title="statement not covered" >o={resolver:je(e,i),subPrefixes:i.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.toLowerCase().includes("hover"))</span>)},s.set(n,o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}</span>const vn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >o(t)&amp;&amp;Object.getOwnPropertyNames(t).some((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >S(t[e]))</span>);</span></span>const Mn=<span class="cstat-no" title="statement not covered" >["top","bottom","left","right","chartArea"];</span>function <span class="fstat-no" title="function not covered" >wn(</span>t,e){<span class="cstat-no" title="statement not covered" >return"top"===t||"bottom"===t||-1===Mn.indexOf(t)&amp;&amp;"x"===e}</span>function <span class="fstat-no" title="function not covered" >kn(</span>t,e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(i,s){<span class="cstat-no" title="statement not covered" >return i[t]===s[t]?i[e]-s[e]:i[t]-s[t]}</span>}</span>function <span class="fstat-no" title="function not covered" >Sn(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.chart,</span>i=<span class="cstat-no" title="statement not covered" >e.options.animation;<span class="cstat-no" title="statement not covered" ></span>e.notifyPlugins("afterRender"),d(i&amp;&amp;i.onComplete,[t],e)}</span>function <span class="fstat-no" title="function not covered" >Pn(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.chart,</span>i=<span class="cstat-no" title="statement not covered" >e.options.animation;<span class="cstat-no" title="statement not covered" ></span>d(i&amp;&amp;i.onProgress,[t],e)}</span>function <span class="fstat-no" title="function not covered" >Dn(</span>t){<span class="cstat-no" title="statement not covered" >return fe()&amp;&amp;"string"==typeof t?t=document.getElementById(t):t&amp;&amp;t.length&amp;&amp;(t=t[0]),t&amp;&amp;t.canvas&amp;&amp;(t=t.canvas),t}</span>const Cn=<span class="cstat-no" title="statement not covered" >{},</span>On=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >Dn(t);<span class="cstat-no" title="statement not covered" ></span>return Object.values(Cn).filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.canvas===e)</span>).pop()}</span>;</span>function <span class="fstat-no" title="function not covered" >An(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >Object.keys(t);<span class="cstat-no" title="statement not covered" ></span>for(const n of s){const s=<span class="cstat-no" title="statement not covered" >+n;<span class="cstat-no" title="statement not covered" ></span>if(s&gt;=e){const o=<span class="cstat-no" title="statement not covered" >t[n];<span class="cstat-no" title="statement not covered" ></span>delete t[n],(i&gt;0||s&gt;e)&amp;&amp;(t[s+i]=o)}</span>}</span>}</span>class Tn{static defaults=<span class="cstat-no" title="statement not covered" >ue;</span>static instances=<span class="cstat-no" title="statement not covered" >Cn;</span>static overrides=<span class="cstat-no" title="statement not covered" >re;</span>static registry=<span class="cstat-no" title="statement not covered" >nn;</span>static version=<span class="cstat-no" title="statement not covered" >"4.5.0";</span>static getChart=<span class="cstat-no" title="statement not covered" >On;<span class="fstat-no" title="function not covered" ></span>st</span>atic register(...t){<span class="cstat-no" title="statement not covered" >nn.add(...t),Ln()}<span class="fstat-no" title="function not covered" ></span>st</span>atic unregister(...t){<span class="cstat-no" title="statement not covered" >nn.remove(...t),Ln()}<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e){const s=<span class="cstat-no" title="statement not covered" >this.config=new _n(e),</span>n=<span class="cstat-no" title="statement not covered" >Dn(t),</span>o=<span class="cstat-no" title="statement not covered" >On(n);<span class="cstat-no" title="statement not covered" ></span>if(o)<span class="cstat-no" title="statement not covered" >throw new Error("Canvas is already in use. Chart with ID '"+o.id+"' must be destroyed before the canvas with ID '"+o.canvas.id+"' can be reused.");c</span></span>onst a=<span class="cstat-no" title="statement not covered" >s.createResolver(s.chartOptionScopes(),this.getContext());<span class="cstat-no" title="statement not covered" ></span>this.platform=new(s.platform||Ps(n)),this.platform.updateConfig(s);c</span>onst r=<span class="cstat-no" title="statement not covered" >this.platform.acquireContext(n,a.aspectRatio),</span>l=<span class="cstat-no" title="statement not covered" >r&amp;&amp;r.canvas,</span>h=<span class="cstat-no" title="statement not covered" >l&amp;&amp;l.height,</span>c=<span class="cstat-no" title="statement not covered" >l&amp;&amp;l.width;<span class="cstat-no" title="statement not covered" ></span>this.id=i(),this.ctx=r,this.canvas=l,this.width=c,this.height=h,this._options=a,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new on,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=dt((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.update(t))</span>,a.resizeDelay||0),this._dataChanges=[],Cn[this.id]=this,r&amp;&amp;l?(bt.listen(this,"complete",Sn),bt.listen(this,"progress",Pn),this._initialize(),this.attached&amp;&amp;this.update()):console.error("Failed to create chart: can't acquire context from the given item")}<span class="fstat-no" title="function not covered" ></span>ge</span>t aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:i,height:n,_aspectRatio:o}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return s(t)?e&amp;&amp;o?o:n?i/n:null:t}<span class="fstat-no" title="function not covered" ></span>ge</span>t data(){<span class="cstat-no" title="statement not covered" >return this.config.data}<span class="fstat-no" title="function not covered" ></span>se</span>t data(t){<span class="cstat-no" title="statement not covered" >this.config.data=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t options(){<span class="cstat-no" title="statement not covered" >return this._options}<span class="fstat-no" title="function not covered" ></span>se</span>t options(t){<span class="cstat-no" title="statement not covered" >this.config.options=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t registry(){<span class="cstat-no" title="statement not covered" >return nn}<span class="fstat-no" title="function not covered" ></span>_i</span>nitialize(){<span class="cstat-no" title="statement not covered" >return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():ke(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}<span class="fstat-no" title="function not covered" ></span>cl</span>ear(){<span class="cstat-no" title="statement not covered" >return Te(this.canvas,this.ctx),this}<span class="fstat-no" title="function not covered" ></span>st</span>op(){<span class="cstat-no" title="statement not covered" >return bt.stop(this),this}<span class="fstat-no" title="function not covered" ></span>re</span>size(t,e){<span class="cstat-no" title="statement not covered" >bt.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}<span class="fstat-no" title="function not covered" ></span>_r</span>esize(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options,</span>s=<span class="cstat-no" title="statement not covered" >this.canvas,</span>n=<span class="cstat-no" title="statement not covered" >i.maintainAspectRatio&amp;&amp;this.aspectRatio,</span>o=<span class="cstat-no" title="statement not covered" >this.platform.getMaximumSize(s,t,e,n),</span>a=<span class="cstat-no" title="statement not covered" >i.devicePixelRatio||this.platform.getDevicePixelRatio(),</span>r=<span class="cstat-no" title="statement not covered" >this.width?"resize":"attach";<span class="cstat-no" title="statement not covered" ></span>this.width=o.width,this.height=o.height,this._aspectRatio=this.aspectRatio,ke(this,a,!0)&amp;&amp;(this.notifyPlugins("resize",{size:o}),d(i.onResize,[this,o],this),this.attached&amp;&amp;this._doResize(r)&amp;&amp;this.render())}<span class="fstat-no" title="function not covered" ></span>en</span>sureScalesHaveIDs(){<span class="cstat-no" title="statement not covered" >u(this.options.scales||{},(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >t.id=e}</span>))}<span class="fstat-no" title="function not covered" ></span>bu</span>ildOrUpdateScales(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.scales,</span>i=<span class="cstat-no" title="statement not covered" >this.scales,</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(i).reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;(<span class="cstat-no" title="statement not covered" >t[e]=!1,t)</span>),{});</span>let n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(n=n.concat(Object.keys(e).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >e[t],</span>s=<span class="cstat-no" title="statement not covered" >cn(t,i),</span>n=<span class="cstat-no" title="statement not covered" >"r"===s,</span>o=<span class="cstat-no" title="statement not covered" >"x"===s;<span class="cstat-no" title="statement not covered" ></span>return{options:i,dposition:n?"chartArea":o?"bottom":"left",dtype:n?"radialLinear":o?"category":"linear"}}</span>)))),u(n,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >e.options,</span>o=<span class="cstat-no" title="statement not covered" >n.id,</span>a=<span class="cstat-no" title="statement not covered" >cn(o,n),</span>r=<span class="cstat-no" title="statement not covered" >l(n.type,e.dtype);<span class="cstat-no" title="statement not covered" ></span>void 0!==n.position&amp;&amp;wn(n.position,a)===wn(e.dposition)||(n.position=e.dposition),s[o]=!0;l</span>et h=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(o in i&amp;&amp;i[o].type===r)<span class="cstat-no" title="statement not covered" >h=i[o];e</span>lse{<span class="cstat-no" title="statement not covered" >h=new(nn.getScale(r))({id:o,type:r,ctx:this.ctx,chart:this}),i[h.id]=h}<span class="cstat-no" title="statement not covered" ></span>h</span>.init(n,t)}</span>)),u(s,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >t||delete i[e]}</span>)),u(i,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >ls.configure(this,t,t.options),ls.addBox(this,t)}</span>))}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateMetasets(){const t=<span class="cstat-no" title="statement not covered" >this._metasets,</span>e=<span class="cstat-no" title="statement not covered" >this.data.datasets.length,</span>i=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>if(t.sort((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.index-e.index)</span>),i&gt;e){<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >e;</span>t&lt;i;++t)<span class="cstat-no" title="statement not covered" >this._destroyDatasetMeta(t);<span class="cstat-no" title="statement not covered" >t</span></span>.splice(e,i-e)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._sortedMetasets=t.slice(0).sort(kn("order","index"))}<span class="fstat-no" title="function not covered" ></span>_r</span>emoveUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t.length&gt;e.length&amp;&amp;delete this._stacks,t.forEach((<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >0===e.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e===t._dataset)</span>).length&amp;&amp;this._destroyDatasetMeta(i)}</span>))}<span class="fstat-no" title="function not covered" ></span>bu</span>ildOrUpdateControllers(){const t=<span class="cstat-no" title="statement not covered" >[],</span>e=<span class="cstat-no" title="statement not covered" >this.data.datasets;</span>let i,s;<span class="cstat-no" title="statement not covered" >for(this._removeUnreferencedMetasets(),i=0,s=e.length;i&lt;s;i++){const s=<span class="cstat-no" title="statement not covered" >e[i];</span>let n=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(i);</span>const o=<span class="cstat-no" title="statement not covered" >s.type||this.config.type;<span class="cstat-no" title="statement not covered" ></span>if(n.type&amp;&amp;n.type!==o&amp;&amp;(this._destroyDatasetMeta(i),n=this.getDatasetMeta(i)),n.type=o,n.indexAxis=s.indexAxis||ln(o,this.options),n.order=s.order||0,n.index=i,n.label=""+s.label,n.visible=this.isDatasetVisible(i),n.controller)<span class="cstat-no" title="statement not covered" >n.controller.updateIndex(i),n.controller.linkScales();e</span>lse{const e=<span class="cstat-no" title="statement not covered" >nn.getController(o),</span>{datasetElementType:s,dataElementType:a}=<span class="cstat-no" title="statement not covered" >ue.datasets[o];<span class="cstat-no" title="statement not covered" ></span>Object.assign(e,{dataElementType:nn.getElement(a),datasetElementType:s&amp;&amp;nn.getElement(s)}),n.controller=new e(this,i),t.push(n.controller)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._updateMetasets(),t}<span class="fstat-no" title="function not covered" ></span>_r</span>esetElements(){<span class="cstat-no" title="statement not covered" >u(this.data.datasets,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(e).controller.reset()}</span>),this)}<span class="fstat-no" title="function not covered" ></span>re</span>set(){<span class="cstat-no" title="statement not covered" >this._resetElements(),this.notifyPlugins("reset")}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this.config;<span class="cstat-no" title="statement not covered" ></span>e.update();c</span>onst i=<span class="cstat-no" title="statement not covered" >this._options=e.createResolver(e.chartOptionScopes(),this.getContext()),</span>s=<span class="cstat-no" title="statement not covered" >this._animationsDisabled=!i.animation;<span class="cstat-no" title="statement not covered" ></span>if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),!1===this.notifyPlugins("beforeUpdate",{mode:t,cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this.buildOrUpdateControllers();<span class="cstat-no" title="statement not covered" ></span>this.notifyPlugins("beforeElementsUpdate");l</span>et o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >this.data.datasets.length;</span>t&lt;e;t++){const{controller:e}=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t),</span>i=<span class="cstat-no" title="statement not covered" >!s&amp;&amp;-1===n.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>e.buildOrUpdateElements(i),o=Math.max(+e.getMaxOverflow(),o)}<span class="cstat-no" title="statement not covered" ></span>o</span>=this._minPadding=i.layout.autoPadding?o:0,this._updateLayout(o),s||u(n,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.reset()}</span>)),this._updateDatasets(t),this.notifyPlugins("afterUpdate",{mode:t}),this._layers.sort(kn("z","_idx"));c</span>onst{_active:a,_lastEvent:r}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>r?this._eventHandler(r,!0):a.length&amp;&amp;this._updateHoverStyles(a,a,!0),this.render()}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateScales(){<span class="cstat-no" title="statement not covered" >u(this.scales,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >ls.removeBox(this,t)}</span>)),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}<span class="fstat-no" title="function not covered" ></span>_c</span>heckEventBindings(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >new Set(Object.keys(this._listeners)),</span>i=<span class="cstat-no" title="statement not covered" >new Set(t.events);<span class="cstat-no" title="statement not covered" ></span>P(e,i)&amp;&amp;!!this._responsiveListeners===t.responsive||(this.unbindEvents(),this.bindEvents())}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateHiddenIndices(){const{_hiddenIndices:t}=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this._getUniformDataChanges()||[];<span class="cstat-no" title="statement not covered" ></span>for(const{method:i,start:s,count:n}of e){<span class="cstat-no" title="statement not covered" >An(t,s,"_removeElements"===i?-n:n)}</span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etUniformDataChanges(){const t=<span class="cstat-no" title="statement not covered" >this._dataChanges;<span class="cstat-no" title="statement not covered" ></span>if(!t||!t.length)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his._dataChanges=[];c</span>onst e=<span class="cstat-no" title="statement not covered" >this.data.datasets.length,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >new Set(t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t[0]===e)</span>).map((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e+","+t.splice(1).join(","))</span>)),</span></span>s=<span class="cstat-no" title="statement not covered" >i(0);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >1;</span>t&lt;e;t++)<span class="cstat-no" title="statement not covered" >if(!P(s,i(t)))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn Array.from(s).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.split(","))</span>).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{method:t[1],start:+t[2],count:+t[3]})</span>))}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateLayout(t){<span class="cstat-no" title="statement not covered" >if(!1===this.notifyPlugins("beforeLayout",{cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >l</span></span>s.update(this,this.width,this.height,t);c</span>onst e=<span class="cstat-no" title="statement not covered" >this.chartArea,</span>i=<span class="cstat-no" title="statement not covered" >e.width&lt;=0||e.height&lt;=0;<span class="cstat-no" title="statement not covered" ></span>this._layers=[],u(this.boxes,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >i&amp;&amp;"chartArea"===t.position||(t.configure&amp;&amp;t.configure(),this._layers.push(...t._layers()))}</span>),this),this._layers.forEach((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >t._idx=e}</span>)),this.notifyPlugins("afterLayout")}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateDatasets(t){<span class="cstat-no" title="statement not covered" >if(!1!==this.notifyPlugins("beforeDatasetsUpdate",{mode:t,cancelable:!0})){<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >this.data.datasets.length;</span>t&lt;e;++t)<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t).controller.configure();<span class="cstat-no" title="statement not covered" >f</span></span>or(let e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >this.data.datasets.length;</span>e&lt;i;++e)<span class="cstat-no" title="statement not covered" >this._updateDataset(e,S(t)?t({datasetIndex:e}):t);<span class="cstat-no" title="statement not covered" >t</span></span>his.notifyPlugins("afterDatasetsUpdate",{mode:t})}</span>}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateDataset(t,e){const i=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t),</span>s=<span class="cstat-no" title="statement not covered" >{meta:i,index:t,mode:e,cancelable:!0};<span class="cstat-no" title="statement not covered" ></span>!1!==this.notifyPlugins("beforeDatasetUpdate",s)&amp;&amp;(i.controller._update(e),s.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",s))}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >!1!==this.notifyPlugins("beforeRender",{cancelable:!0})&amp;&amp;(bt.has(this)?this.attached&amp;&amp;!bt.running(this)&amp;&amp;bt.start(this):(this.draw(),Sn({chart:this})))}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){let t;<span class="cstat-no" title="statement not covered" >if(this._resizeBeforeDraw){const{width:t,height:e}=<span class="cstat-no" title="statement not covered" >this._resizeBeforeDraw;<span class="cstat-no" title="statement not covered" ></span>this._resizeBeforeDraw=null,this._resize(t,e)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.clear(),this.width&lt;=0||this.height&lt;=0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!1===this.notifyPlugins("beforeDraw",{cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this._layers;<span class="cstat-no" title="statement not covered" ></span>for(t=0;t&lt;e.length&amp;&amp;e[t].z&lt;=0;++t)<span class="cstat-no" title="statement not covered" >e[t].draw(this.chartArea);<span class="cstat-no" title="statement not covered" >f</span></span>or(this._drawDatasets();t&lt;e.length;++t)<span class="cstat-no" title="statement not covered" >e[t].draw(this.chartArea);<span class="cstat-no" title="statement not covered" >t</span></span>his.notifyPlugins("afterDraw")}<span class="fstat-no" title="function not covered" ></span>_g</span>etSortedDatasetMetas(t){const e=<span class="cstat-no" title="statement not covered" >this._sortedMetasets,</span>i=<span class="cstat-no" title="statement not covered" >[];</span>let s,n;<span class="cstat-no" title="statement not covered" >for(s=0,n=e.length;s&lt;n;++s){const n=<span class="cstat-no" title="statement not covered" >e[s];<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;!n.visible||i.push(n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>ge</span>tSortedVisibleDatasetMetas(){<span class="cstat-no" title="statement not covered" >return this._getSortedDatasetMetas(!0)}<span class="fstat-no" title="function not covered" ></span>_d</span>rawDatasets(){<span class="cstat-no" title="statement not covered" >if(!1===this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.getSortedVisibleDatasetMetas();<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >t.length-1;</span>e&gt;=0;--e)<span class="cstat-no" title="statement not covered" >this._drawDataset(t[e]);<span class="cstat-no" title="statement not covered" >t</span></span>his.notifyPlugins("afterDatasetsDraw")}<span class="fstat-no" title="function not covered" ></span>_d</span>rawDataset(t){const e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>i=<span class="cstat-no" title="statement not covered" >{meta:t,index:t.index,cancelable:!0},</span>s=<span class="cstat-no" title="statement not covered" >Ni(this,t);<span class="cstat-no" title="statement not covered" ></span>!1!==this.notifyPlugins("beforeDatasetDraw",i)&amp;&amp;(s&amp;&amp;Ie(e,s),t.controller.draw(),s&amp;&amp;ze(e),i.cancelable=!1,this.notifyPlugins("afterDatasetDraw",i))}<span class="fstat-no" title="function not covered" ></span>is</span>PointInArea(t){<span class="cstat-no" title="statement not covered" >return Re(t,this.chartArea,this._minPadding)}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsAtEventForMode(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >Ki.modes[e];<span class="cstat-no" title="statement not covered" ></span>return"function"==typeof n?n(this,t,i,s):[]}<span class="fstat-no" title="function not covered" ></span>ge</span>tDatasetMeta(t){const e=<span class="cstat-no" title="statement not covered" >this.data.datasets[t],</span>i=<span class="cstat-no" title="statement not covered" >this._metasets;</span>let s=<span class="cstat-no" title="statement not covered" >i.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&amp;&amp;t._dataset===e)</span>).pop();<span class="cstat-no" title="statement not covered" ></span>return s||(s={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&amp;&amp;e.order||0,index:t,_dataset:e,_parsed:[],_sorted:!1},i.push(s)),s}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(){<span class="cstat-no" title="statement not covered" >return this.$context||(this.$context=Ci(null,{chart:this,type:"chart"}))}<span class="fstat-no" title="function not covered" ></span>ge</span>tVisibleDatasetCount(){<span class="cstat-no" title="statement not covered" >return this.getSortedVisibleDatasetMetas().length}<span class="fstat-no" title="function not covered" ></span>is</span>DatasetVisible(t){const e=<span class="cstat-no" title="statement not covered" >this.data.datasets[t];<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t);<span class="cstat-no" title="statement not covered" ></span>return"boolean"==typeof i.hidden?!i.hidden:!e.hidden}<span class="fstat-no" title="function not covered" ></span>se</span>tDatasetVisibility(t,e){<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t).hidden=!e}<span class="fstat-no" title="function not covered" ></span>to</span>ggleDataVisibility(t){<span class="cstat-no" title="statement not covered" >this._hiddenIndices[t]=!this._hiddenIndices[t]}<span class="fstat-no" title="function not covered" ></span>ge</span>tDataVisibility(t){<span class="cstat-no" title="statement not covered" >return!this._hiddenIndices[t]}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateVisibility(t,e,i){const s=<span class="cstat-no" title="statement not covered" >i?"show":"hide",</span>n=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t),</span>o=<span class="cstat-no" title="statement not covered" >n.controller._resolveAnimations(void 0,s);<span class="cstat-no" title="statement not covered" ></span>k(e)?(n.data[e].hidden=!i,this.update()):(this.setDatasetVisibility(t,i),o.update(n,{visible:i}),this.update((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.datasetIndex===t?s:void 0)</span>))}<span class="fstat-no" title="function not covered" ></span>hi</span>de(t,e){<span class="cstat-no" title="statement not covered" >this._updateVisibility(t,e,!1)}<span class="fstat-no" title="function not covered" ></span>sh</span>ow(t,e){<span class="cstat-no" title="statement not covered" >this._updateVisibility(t,e,!0)}<span class="fstat-no" title="function not covered" ></span>_d</span>estroyDatasetMeta(t){const e=<span class="cstat-no" title="statement not covered" >this._metasets[t];<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e.controller&amp;&amp;e.controller._destroy(),delete this._metasets[t]}<span class="fstat-no" title="function not covered" ></span>_s</span>top(){let t,e;<span class="cstat-no" title="statement not covered" >for(this.stop(),bt.remove(this),t=0,e=this.data.datasets.length;t&lt;e;++t)<span class="cstat-no" title="statement not covered" >this._destroyDatasetMeta(t)}<span class="fstat-no" title="function not covered" ></span></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.notifyPlugins("beforeDestroy");c</span>onst{canvas:t,ctx:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._stop(),this.config.clearCache(),t&amp;&amp;(this.unbindEvents(),Te(t,e),this.platform.releaseContext(e),this.canvas=null,this.ctx=null),delete Cn[this.id],this.notifyPlugins("afterDestroy")}<span class="fstat-no" title="function not covered" ></span>to</span>Base64Image(...t){<span class="cstat-no" title="statement not covered" >return this.canvas.toDataURL(...t)}<span class="fstat-no" title="function not covered" ></span>bi</span>ndEvents(){<span class="cstat-no" title="statement not covered" >this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}<span class="fstat-no" title="function not covered" ></span>bi</span>ndUserEvents(){const t=<span class="cstat-no" title="statement not covered" >this._listeners,</span>e=<span class="cstat-no" title="statement not covered" >this.platform,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >e.addEventListener(this,i,s),t[i]=s}</span>,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >t.offsetX=e,t.offsetY=i,this._eventHandler(t)}</span>;<span class="cstat-no" title="statement not covered" ></span>u(this.options.events,(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >i(t,s))</span>)}<span class="fstat-no" title="function not covered" ></span>bi</span>ndResponsiveEvents(){<span class="cstat-no" title="statement not covered" >this._responsiveListeners||(this._responsiveListeners={});c</span>onst t=<span class="cstat-no" title="statement not covered" >this._responsiveListeners,</span>e=<span class="cstat-no" title="statement not covered" >this.platform,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >e.addEventListener(this,i,s),t[i]=s}</span>,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >t[i]&amp;&amp;(e.removeEventListener(this,i,s),delete t[i])}</span>,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.canvas&amp;&amp;this.resize(t,e)}</span>;</span>let o;const a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s("attach",a),this.attached=!0,this.resize(),i("resize",n),i("detach",o)}</span>;<span class="cstat-no" title="statement not covered" ></span>o=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.attached=!1,s("resize",n),this._stop(),this._resize(0,0),i("attach",a)}</span>,e.isAttached(this.canvas)?a():o()}<span class="fstat-no" title="function not covered" ></span>un</span>bindEvents(){<span class="cstat-no" title="statement not covered" >u(this._listeners,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.platform.removeEventListener(this,e,t)}</span>)),this._listeners={},u(this._responsiveListeners,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.platform.removeEventListener(this,e,t)}</span>)),this._responsiveListeners=void 0}<span class="fstat-no" title="function not covered" ></span>up</span>dateHoverStyle(t,e,i){const s=<span class="cstat-no" title="statement not covered" >i?"set":"remove";</span>let n,o,a,r;<span class="cstat-no" title="statement not covered" >for("dataset"===e&amp;&amp;(n=this.getDatasetMeta(t[0].datasetIndex),n.controller["_"+s+"DatasetHoverStyle"]()),a=0,r=t.length;a&lt;r;++a){<span class="cstat-no" title="statement not covered" >o=t[a];c</span>onst e=<span class="cstat-no" title="statement not covered" >o&amp;&amp;this.getDatasetMeta(o.datasetIndex).controller;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e[s+"HoverStyle"](o.element,o.datasetIndex,o.index)}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tActiveElements(){<span class="cstat-no" title="statement not covered" >return this._active||[]}<span class="fstat-no" title="function not covered" ></span>se</span>tActiveElements(t){const e=<span class="cstat-no" title="statement not covered" >this._active||[],</span>i=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >({</span>datasetIndex:t,index:e})=&gt;{const i=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >throw new Error("No dataset found at index "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{datasetIndex:t,element:i.data[e],index:e}}</span>));<span class="cstat-no" title="statement not covered" ></span>!f(i,e)&amp;&amp;(this._active=i,this._lastEvent=null,this._updateHoverStyles(i,e))}<span class="fstat-no" title="function not covered" ></span>no</span>tifyPlugins(t,e,i){<span class="cstat-no" title="statement not covered" >return this._plugins.notify(this,t,e,i)}<span class="fstat-no" title="function not covered" ></span>is</span>PluginEnabled(t){<span class="cstat-no" title="statement not covered" >return 1===this._plugins._cache.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.plugin.id===t)</span>).length}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateHoverStyles(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.options.hover,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!e.some((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.datasetIndex===e.datasetIndex&amp;&amp;t.index===e.index)</span>))</span>),</span></span>o=<span class="cstat-no" title="statement not covered" >n(e,t),</span>a=<span class="cstat-no" title="statement not covered" >i?t:n(t,e);<span class="cstat-no" title="statement not covered" ></span>o.length&amp;&amp;this.updateHoverStyle(o,s.mode,!1),a.length&amp;&amp;s.mode&amp;&amp;this.updateHoverStyle(a,s.mode,!0)}<span class="fstat-no" title="function not covered" ></span>_e</span>ventHandler(t,e){const i=<span class="cstat-no" title="statement not covered" >{event:t,replay:e,cancelable:!0,inChartArea:this.isPointInArea(t)},</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >(e.options.events||this.options.events).includes(t.native.type);<span class="cstat-no" title="statement not covered" ></span></span>if(!1===this.notifyPlugins("beforeEvent",i,s))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this._handleEvent(t,e,i.inChartArea);<span class="cstat-no" title="statement not covered" ></span>return i.cancelable=!1,this.notifyPlugins("afterEvent",i,s),(n||i.changed)&amp;&amp;this.render(),this}<span class="fstat-no" title="function not covered" ></span>_h</span>andleEvent(t,e,i){const{_active:s=<span class="branch-0 cbranch-no" title="branch not covered" >[],</span>options:n}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >e,</span>a=<span class="cstat-no" title="statement not covered" >this._getActiveElements(t,s,i,o),</span>r=<span class="cstat-no" title="statement not covered" >D(t),</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){<span class="cstat-no" title="statement not covered" >return i&amp;&amp;"mouseout"!==t.type?s?e:t:null}</span>(t,this._lastEvent,i,r);<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(this._lastEvent=null,d(n.onHover,[t,a,this],this),r&amp;&amp;d(n.onClick,[t,a,this],this));c</span>onst h=<span class="cstat-no" title="statement not covered" >!f(a,s);<span class="cstat-no" title="statement not covered" ></span>return(h||e)&amp;&amp;(this._active=a,this._updateHoverStyles(a,s,e)),this._lastEvent=l,h}<span class="fstat-no" title="function not covered" ></span>_g</span>etActiveElements(t,e,i,s){<span class="cstat-no" title="statement not covered" >if("mouseout"===t.type)<span class="cstat-no" title="statement not covered" >return[];<span class="cstat-no" title="statement not covered" >i</span></span>f(!i)<span class="cstat-no" title="statement not covered" >return e;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this.options.hover;<span class="cstat-no" title="statement not covered" ></span>return this.getElementsAtEventForMode(t,n.mode,n,s)}</span>}function <span class="fstat-no" title="function not covered" >Ln(</span>){<span class="cstat-no" title="statement not covered" >return u(Tn.instances,(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t._plugins.invalidate())</span>)}</span>function <span class="fstat-no" title="function not covered" >En(</span>){<span class="cstat-no" title="statement not covered" >throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}</span>class Rn{<span class="fstat-no" title="function not covered" >st</span>atic override(t){<span class="cstat-no" title="statement not covered" >Object.assign(Rn.prototype,t)}</span>options;<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.options=t||{}}<span class="fstat-no" title="function not covered" ></span>in</span>it(){}<span class="fstat-no" title="function not covered" >fo</span>rmats(){<span class="cstat-no" title="statement not covered" >return En()}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(){<span class="cstat-no" title="statement not covered" >return En()}<span class="fstat-no" title="function not covered" ></span>fo</span>rmat(){<span class="cstat-no" title="statement not covered" >return En()}<span class="fstat-no" title="function not covered" ></span>ad</span>d(){<span class="cstat-no" title="statement not covered" >return En()}<span class="fstat-no" title="function not covered" ></span>di</span>ff(){<span class="cstat-no" title="statement not covered" >return En()}<span class="fstat-no" title="function not covered" ></span>st</span>artOf(){<span class="cstat-no" title="statement not covered" >return En()}<span class="fstat-no" title="function not covered" ></span>en</span>dOf(){<span class="cstat-no" title="statement not covered" >return En()}</span>}var In=<span class="cstat-no" title="statement not covered" >{_date:Rn};</span>function <span class="fstat-no" title="function not covered" >zn(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.iScale,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!t._cache.$bar){const i=<span class="cstat-no" title="statement not covered" >t.getMatchingVisibleMetas(e);</span>let s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >i.length;</span>e&lt;n;e++)<span class="cstat-no" title="statement not covered" >s=s.concat(i[e].controller.getAllParsedValues(t));<span class="cstat-no" title="statement not covered" >t</span></span>._cache.$bar=lt(s.sort((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e)</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t._cache.$bar}</span>(e,t.type);</span>let s,n,o,a,r=<span class="cstat-no" title="statement not covered" >e._length;</span>const l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >32767!==o&amp;&amp;-32768!==o&amp;&amp;(k(a)&amp;&amp;(r=Math.min(r,Math.abs(o-a)||r)),a=o)}</span>;<span class="cstat-no" title="statement not covered" ></span>for(s=0,n=i.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >o=e.getPixelForValue(i[s]),l();<span class="cstat-no" title="statement not covered" >f</span></span>or(a=void 0,s=0,n=e.ticks.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >o=e.getPixelForTick(s),l();<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Fn(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return n(t)?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >i.parse(t[0],s),</span>o=<span class="cstat-no" title="statement not covered" >i.parse(t[1],s),</span>a=<span class="cstat-no" title="statement not covered" >Math.min(n,o),</span>r=<span class="cstat-no" title="statement not covered" >Math.max(n,o);</span>let l=<span class="cstat-no" title="statement not covered" >a,</span>h=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>Math.abs(a)&gt;Math.abs(r)&amp;&amp;(l=r,h=a),e[i.axis]=h,e._custom={barStart:l,barEnd:h,start:n,end:o,min:a,max:r}}</span>(t,e,i,s):e[i.axis]=i.parse(t,s),e}</span>function <span class="fstat-no" title="function not covered" >Vn(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.iScale,</span>o=<span class="cstat-no" title="statement not covered" >t.vScale,</span>a=<span class="cstat-no" title="statement not covered" >n.getLabels(),</span>r=<span class="cstat-no" title="statement not covered" >n===o,</span>l=<span class="cstat-no" title="statement not covered" >[];</span>let h,c,d,u;<span class="cstat-no" title="statement not covered" >for(h=i,c=i+s;h&lt;c;++h)<span class="cstat-no" title="statement not covered" >u=e[h],d={},d[n.axis]=r||n.parse(a[h],h),l.push(Fn(u,d,o,h));<span class="cstat-no" title="statement not covered" >r</span></span>eturn l}</span>function <span class="fstat-no" title="function not covered" >Bn(</span>t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;void 0!==t.barStart&amp;&amp;void 0!==t.barEnd}</span>function <span class="fstat-no" title="function not covered" >Wn(</span>t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >e.borderSkipped;</span>const o=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return void(t.borderSkipped=o);<span class="cstat-no" title="statement not covered" >i</span></span>f(!0===n)<span class="cstat-no" title="statement not covered" >return void(t.borderSkipped={top:!0,right:!0,bottom:!0,left:!0});c</span></span>onst{start:a,end:r,reverse:l,top:h,bottom:c}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){let e,i,s,n,o;<span class="cstat-no" title="statement not covered" >return t.horizontal?(e=t.base&gt;t.x,i="left",s="right"):(e=t.base&lt;t.y,i="bottom",s="top"),e?(n="end",o="start"):(n="start",o="end"),{start:i,end:s,reverse:e,top:n,bottom:o}}</span>(t);<span class="cstat-no" title="statement not covered" ></span>"middle"===n&amp;&amp;i&amp;&amp;(t.enableBorderRadius=!0,(i._top||0)===s?n=h:(i._bottom||0)===s?n=c:(o[Nn(c,a,r,l)]=!0,n=h)),o[Nn(n,a,r,l)]=!0,t.borderSkipped=o}</span>function <span class="fstat-no" title="function not covered" >Nn(</span>t,e,i,s){var n,o,a;<span class="cstat-no" title="statement not covered" >return s?(a=i,t=Hn(t=(n=t)===(o=e)?a:n===a?o:n,i,e)):t=Hn(t,e,i),t}</span>function <span class="fstat-no" title="function not covered" >Hn(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return"start"===t?e:"end"===t?i:t}</span>function <span class="fstat-no" title="function not covered" >jn(</span>t,{inflateAmount:e},i){<span class="cstat-no" title="statement not covered" >t.inflateAmount="auto"===e?1===i?.33:0:e}</span>class $n extends js{static id=<span class="cstat-no" title="statement not covered" >"doughnut";</span>static defaults=<span class="cstat-no" title="statement not covered" >{datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"};</span>static descriptors=<span class="cstat-no" title="statement not covered" >{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"spacing"!==t,</span>_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"spacing"!==t&amp;&amp;!t.startsWith("borderDash")&amp;&amp;!t.startsWith("hoverBorderDash")}</span>;</span>static overrides=<span class="cstat-no" title="statement not covered" >{aspectRatio:1,plugins:{legend:{labels:{<span class="fstat-no" title="function not covered" >ge</span>nerateLabels(t){const e=<span class="cstat-no" title="statement not covered" >t.data;<span class="cstat-no" title="statement not covered" ></span>if(e.labels.length&amp;&amp;e.datasets.length){const{labels:{pointStyle:i,color:s}}=<span class="cstat-no" title="statement not covered" >t.legend.options;<span class="cstat-no" title="statement not covered" ></span>return e.labels.map((<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{const o=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(0).controller.getStyle(n);<span class="cstat-no" title="statement not covered" ></span>return{text:e,fillStyle:o.backgroundColor,strokeStyle:o.borderColor,fontColor:s,lineWidth:o.borderWidth,pointStyle:i,hidden:!t.getDataVisibility(n),index:n}}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn[]}</span>},<span class="fstat-no" title="function not covered" >on</span>Click(t,e,i){<span class="cstat-no" title="statement not covered" >i.chart.toggleDataVisibility(e.index),i.chart.update()}</span>}}};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(t,e),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}<span class="fstat-no" title="function not covered" ></span>li</span>nkScales(){}<span class="fstat-no" title="function not covered" >pa</span>rse(t,e){const i=<span class="cstat-no" title="statement not covered" >this.getDataset().data,</span>s=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>if(!1===this._parsing)<span class="cstat-no" title="statement not covered" >s._parsed=i;e</span>lse{let n,a,r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >+i[t];<span class="cstat-no" title="statement not covered" ></span></span>if(o(i[t])){const{key:t=<span class="branch-0 cbranch-no" title="branch not covered" >"value"}</span>=<span class="cstat-no" title="statement not covered" >this._parsing;<span class="cstat-no" title="statement not covered" ></span>r=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >+M(i[e],t)}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(n=t,a=t+e;n&lt;a;++n)<span class="cstat-no" title="statement not covered" >s._parsed[n]=r(n)}</span></span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etRotation(){<span class="cstat-no" title="statement not covered" >return $(this.options.rotation-90)}<span class="fstat-no" title="function not covered" ></span>_g</span>etCircumference(){<span class="cstat-no" title="statement not covered" >return $(this.options.circumference)}<span class="fstat-no" title="function not covered" ></span>_g</span>etRotationExtents(){let t=<span class="cstat-no" title="statement not covered" >O,</span>e=<span class="cstat-no" title="statement not covered" >-O;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;this.chart.data.datasets.length;++i)<span class="cstat-no" title="statement not covered" >if(this.chart.isDatasetVisible(i)&amp;&amp;this.chart.getDatasetMeta(i).type===this._type){const s=<span class="cstat-no" title="statement not covered" >this.chart.getDatasetMeta(i).controller,</span>n=<span class="cstat-no" title="statement not covered" >s._getRotation(),</span>o=<span class="cstat-no" title="statement not covered" >s._getCircumference();<span class="cstat-no" title="statement not covered" ></span>t=Math.min(t,n),e=Math.max(e,n+o)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn{rotation:t,circumference:e-t}}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this.chart,</span>{chartArea:i}=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>n=<span class="cstat-no" title="statement not covered" >s.data,</span>o=<span class="cstat-no" title="statement not covered" >this.getMaxBorderWidth()+this.getMaxOffset(n)+this.options.spacing,</span>a=<span class="cstat-no" title="statement not covered" >Math.max((Math.min(i.width,i.height)-o)/2,0),</span>r=<span class="cstat-no" title="statement not covered" >Math.min(h(this.options.cutout,a),1),</span>l=<span class="cstat-no" title="statement not covered" >this._getRingWeight(this.index),</span>{circumference:d,rotation:u}=<span class="cstat-no" title="statement not covered" >this._getRotationExtents(),</span>{ratioX:f,ratioY:g,offsetX:p,offsetY:m}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let s=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >1,</span>o=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(e&lt;O){const r=<span class="cstat-no" title="statement not covered" >t,</span>l=<span class="cstat-no" title="statement not covered" >r+e,</span>h=<span class="cstat-no" title="statement not covered" >Math.cos(r),</span>c=<span class="cstat-no" title="statement not covered" >Math.sin(r),</span>d=<span class="cstat-no" title="statement not covered" >Math.cos(l),</span>u=<span class="cstat-no" title="statement not covered" >Math.sin(l),</span>f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;<span class="cstat-no" title="statement not covered" >J(t,r,l,!0)?1:Math.max(e,e*i,s,s*i),</span></span>g=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;<span class="cstat-no" title="statement not covered" >J(t,r,l,!0)?-1:Math.min(e,e*i,s,s*i),</span></span>p=<span class="cstat-no" title="statement not covered" >f(0,h,d),</span>m=<span class="cstat-no" title="statement not covered" >f(E,c,u),</span>x=<span class="cstat-no" title="statement not covered" >g(C,h,d),</span>b=<span class="cstat-no" title="statement not covered" >g(C+E,c,u);<span class="cstat-no" title="statement not covered" ></span>s=(p-x)/2,n=(m-b)/2,o=-(p+x)/2,a=-(m+b)/2}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{ratioX:s,ratioY:n,offsetX:o,offsetY:a}}</span>(u,d,r),</span>x=<span class="cstat-no" title="statement not covered" >(i.width-o)/f,</span>b=<span class="cstat-no" title="statement not covered" >(i.height-o)/g,</span>_=<span class="cstat-no" title="statement not covered" >Math.max(Math.min(x,b)/2,0),</span>y=<span class="cstat-no" title="statement not covered" >c(this.options.radius,_),</span>v=<span class="cstat-no" title="statement not covered" >(y-Math.max(y*r,0))/this._getVisibleDatasetWeightTotal();<span class="cstat-no" title="statement not covered" ></span>this.offsetX=p*y,this.offsetY=m*y,s.total=this.calculateTotal(),this.outerRadius=y-v*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-v*l,0),this.updateElements(n,0,n.length,t)}<span class="fstat-no" title="function not covered" ></span>_c</span>ircumference(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options,</span>s=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>n=<span class="cstat-no" title="statement not covered" >this._getCircumference();<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;i.animation.animateRotate||!this.chart.getDataVisibility(t)||null===s._parsed[t]||s.data[t].hidden?0:this.calculateCircumference(s._parsed[t]*n/O)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >"reset"===s,</span>o=<span class="cstat-no" title="statement not covered" >this.chart,</span>a=<span class="cstat-no" title="statement not covered" >o.chartArea,</span>r=<span class="cstat-no" title="statement not covered" >o.options.animation,</span>l=<span class="cstat-no" title="statement not covered" >(a.left+a.right)/2,</span>h=<span class="cstat-no" title="statement not covered" >(a.top+a.bottom)/2,</span>c=<span class="cstat-no" title="statement not covered" >n&amp;&amp;r.animateScale,</span>d=<span class="cstat-no" title="statement not covered" >c?0:this.innerRadius,</span>u=<span class="cstat-no" title="statement not covered" >c?0:this.outerRadius,</span>{sharedOptions:f,includeOptions:g}=<span class="cstat-no" title="statement not covered" >this._getSharedOptions(e,s);</span>let p,m=<span class="cstat-no" title="statement not covered" >this._getRotation();<span class="cstat-no" title="statement not covered" ></span>for(p=0;p&lt;e;++p)<span class="cstat-no" title="statement not covered" >m+=this._circumference(p,n);<span class="cstat-no" title="statement not covered" >f</span></span>or(p=e;p&lt;e+i;++p){const e=<span class="cstat-no" title="statement not covered" >this._circumference(p,n),</span>i=<span class="cstat-no" title="statement not covered" >t[p],</span>o=<span class="cstat-no" title="statement not covered" >{x:l+this.offsetX,y:h+this.offsetY,startAngle:m,endAngle:m+e,circumference:e,outerRadius:u,innerRadius:d};<span class="cstat-no" title="statement not covered" ></span>g&amp;&amp;(o.options=f||this.resolveDataElementOptions(p,i.active?"active":s)),m+=e,this.updateElement(i,p,o,s)}</span>}<span class="fstat-no" title="function not covered" ></span>ca</span>lculateTotal(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >t.data;</span>let i,s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(i=0;i&lt;e.length;i++){const n=<span class="cstat-no" title="statement not covered" >t._parsed[i];<span class="cstat-no" title="statement not covered" ></span>null===n||isNaN(n)||!this.chart.getDataVisibility(i)||e[i].hidden||(s+=Math.abs(n))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>ca</span>lculateCircumference(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta.total;<span class="cstat-no" title="statement not covered" ></span>return e&gt;0&amp;&amp;!isNaN(t)?O*(Math.abs(t)/e):0}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.chart,</span>s=<span class="cstat-no" title="statement not covered" >i.data.labels||[],</span>n=<span class="cstat-no" title="statement not covered" >ne(e._parsed[t],i.options.locale);<span class="cstat-no" title="statement not covered" ></span>return{label:s[t]||"",value:n}}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxBorderWidth(t){let e=<span class="cstat-no" title="statement not covered" >0;</span>const i=<span class="cstat-no" title="statement not covered" >this.chart;</span>let s,n,o,a,r;<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >for(s=0,n=i.data.datasets.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >if(i.isDatasetVisible(s)){<span class="cstat-no" title="statement not covered" >o=i.getDatasetMeta(s),t=o.data,a=o.controller;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span></span></span>f(!t)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >f</span></span>or(s=0,n=t.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >r=a.resolveDataElementOptions(s),"inner"!==r.borderAlign&amp;&amp;(e=Math.max(e,r.borderWidth||0,r.hoverBorderWidth||0));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOffset(t){let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>i&lt;s;++i){const t=<span class="cstat-no" title="statement not covered" >this.resolveDataElementOptions(i);<span class="cstat-no" title="statement not covered" ></span>e=Math.max(e,t.offset||0,t.hoverOffset||0)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>_g</span>etRingWeightOffset(t){let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t;++i)<span class="cstat-no" title="statement not covered" >this.chart.isDatasetVisible(i)&amp;&amp;(e+=this._getRingWeight(i));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>_g</span>etRingWeight(t){<span class="cstat-no" title="statement not covered" >return Math.max(l(this.chart.data.datasets[t].weight,1),0)}<span class="fstat-no" title="function not covered" ></span>_g</span>etVisibleDatasetWeightTotal(){<span class="cstat-no" title="statement not covered" >return this._getRingWeightOffset(this.chart.data.datasets.length)||1}</span>}class Yn extends js{static id=<span class="cstat-no" title="statement not covered" >"polarArea";</span>static defaults=<span class="cstat-no" title="statement not covered" >{dataElementType:"arc",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0};</span>static overrides=<span class="cstat-no" title="statement not covered" >{aspectRatio:1,plugins:{legend:{labels:{<span class="fstat-no" title="function not covered" >ge</span>nerateLabels(t){const e=<span class="cstat-no" title="statement not covered" >t.data;<span class="cstat-no" title="statement not covered" ></span>if(e.labels.length&amp;&amp;e.datasets.length){const{labels:{pointStyle:i,color:s}}=<span class="cstat-no" title="statement not covered" >t.legend.options;<span class="cstat-no" title="statement not covered" ></span>return e.labels.map((<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{const o=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(0).controller.getStyle(n);<span class="cstat-no" title="statement not covered" ></span>return{text:e,fillStyle:o.backgroundColor,strokeStyle:o.borderColor,fontColor:s,lineWidth:o.borderWidth,pointStyle:i,hidden:!t.getDataVisibility(n),index:n}}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn[]}</span>},<span class="fstat-no" title="function not covered" >on</span>Click(t,e,i){<span class="cstat-no" title="statement not covered" >i.chart.toggleDataVisibility(e.index),i.chart.update()}</span>}},scales:{r:{type:"radialLinear",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(t,e),this.innerRadius=void 0,this.outerRadius=void 0}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.chart,</span>s=<span class="cstat-no" title="statement not covered" >i.data.labels||[],</span>n=<span class="cstat-no" title="statement not covered" >ne(e._parsed[t].r,i.options.locale);<span class="cstat-no" title="statement not covered" ></span>return{label:s[t]||"",value:n}}<span class="fstat-no" title="function not covered" ></span>pa</span>rseObjectData(t,e,i,s){<span class="cstat-no" title="statement not covered" >return ii.bind(this)(t,e,i,s)}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta.data;<span class="cstat-no" title="statement not covered" ></span>this._updateRadius(),this.updateElements(e,0,e.length,t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tMinMax(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >{min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};<span class="cstat-no" title="statement not covered" ></span>return t.data.forEach((<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;{const s=<span class="cstat-no" title="statement not covered" >this.getParsed(i).r;<span class="cstat-no" title="statement not covered" ></span>!isNaN(s)&amp;&amp;this.chart.getDataVisibility(i)&amp;&amp;(s&lt;e.min&amp;&amp;(e.min=s),s&gt;e.max&amp;&amp;(e.max=s))}</span>)),e}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateRadius(){const t=<span class="cstat-no" title="statement not covered" >this.chart,</span>e=<span class="cstat-no" title="statement not covered" >t.chartArea,</span>i=<span class="cstat-no" title="statement not covered" >t.options,</span>s=<span class="cstat-no" title="statement not covered" >Math.min(e.right-e.left,e.bottom-e.top),</span>n=<span class="cstat-no" title="statement not covered" >Math.max(s/2,0),</span>o=<span class="cstat-no" title="statement not covered" >(n-Math.max(i.cutoutPercentage?n/100*i.cutoutPercentage:1,0))/t.getVisibleDatasetCount();<span class="cstat-no" title="statement not covered" ></span>this.outerRadius=n-o*this.index,this.innerRadius=this.outerRadius-o}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >"reset"===s,</span>o=<span class="cstat-no" title="statement not covered" >this.chart,</span>a=<span class="cstat-no" title="statement not covered" >o.options.animation,</span>r=<span class="cstat-no" title="statement not covered" >this._cachedMeta.rScale,</span>l=<span class="cstat-no" title="statement not covered" >r.xCenter,</span>h=<span class="cstat-no" title="statement not covered" >r.yCenter,</span>c=<span class="cstat-no" title="statement not covered" >r.getIndexAngle(0)-.5*C;</span>let d,u=<span class="cstat-no" title="statement not covered" >c;</span>const f=<span class="cstat-no" title="statement not covered" >360/this.countVisibleElements();<span class="cstat-no" title="statement not covered" ></span>for(d=0;d&lt;e;++d)<span class="cstat-no" title="statement not covered" >u+=this._computeAngle(d,s,f);<span class="cstat-no" title="statement not covered" >f</span></span>or(d=e;d&lt;e+i;d++){const e=<span class="cstat-no" title="statement not covered" >t[d];</span>let i=<span class="cstat-no" title="statement not covered" >u,</span>g=<span class="cstat-no" title="statement not covered" >u+this._computeAngle(d,s,f),</span>p=<span class="cstat-no" title="statement not covered" >o.getDataVisibility(d)?r.getDistanceFromCenterForValue(this.getParsed(d).r):0;<span class="cstat-no" title="statement not covered" ></span>u=g,n&amp;&amp;(a.animateScale&amp;&amp;(p=0),a.animateRotate&amp;&amp;(i=g=c));c</span>onst m=<span class="cstat-no" title="statement not covered" >{x:l,y:h,innerRadius:0,outerRadius:p,startAngle:i,endAngle:g,options:this.resolveDataElementOptions(d,e.active?"active":s)};<span class="cstat-no" title="statement not covered" ></span>this.updateElement(e,d,m,s)}</span>}<span class="fstat-no" title="function not covered" ></span>co</span>untVisibleElements(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;</span>let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return t.data.forEach((<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >!isNaN(this.getParsed(i).r)&amp;&amp;this.chart.getDataVisibility(i)&amp;&amp;e++}</span>)),e}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeAngle(t,e,i){<span class="cstat-no" title="statement not covered" >return this.chart.getDataVisibility(t)?$(this.resolveDataElementOptions(t,e).angle||i):0}</span>}var Un=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,BarController:class extends js{static id=<span class="cstat-no" title="statement not covered" >"bar";</span>static defaults=<span class="cstat-no" title="statement not covered" >{datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}};</span>static overrides=<span class="cstat-no" title="statement not covered" >{scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}};<span class="fstat-no" title="function not covered" ></span>pa</span>rsePrimitiveData(t,e,i,s){<span class="cstat-no" title="statement not covered" >return Vn(t,e,i,s)}<span class="fstat-no" title="function not covered" ></span>pa</span>rseArrayData(t,e,i,s){<span class="cstat-no" title="statement not covered" >return Vn(t,e,i,s)}<span class="fstat-no" title="function not covered" ></span>pa</span>rseObjectData(t,e,i,s){const{iScale:n,vScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>{xAxisKey:a=<span class="branch-0 cbranch-no" title="branch not covered" >"x",</span>yAxisKey:r=<span class="branch-0 cbranch-no" title="branch not covered" >"y"}</span>=<span class="cstat-no" title="statement not covered" >this._parsing,</span>l=<span class="cstat-no" title="statement not covered" >"x"===n.axis?a:r,</span>h=<span class="cstat-no" title="statement not covered" >"x"===o.axis?a:r,</span>c=<span class="cstat-no" title="statement not covered" >[];</span>let d,u,f,g;<span class="cstat-no" title="statement not covered" >for(d=i,u=i+s;d&lt;u;++d)<span class="cstat-no" title="statement not covered" >g=e[d],f={},f[n.axis]=n.parse(M(g,l),d),c.push(Fn(M(g,h),f,o,d));<span class="cstat-no" title="statement not covered" >r</span></span>eturn c}<span class="fstat-no" title="function not covered" ></span>up</span>dateRangeFromParsed(t,e,i,s){<span class="cstat-no" title="statement not covered" >super.updateRangeFromParsed(t,e,i,s);c</span>onst n=<span class="cstat-no" title="statement not covered" >i._custom;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;e===this._cachedMeta.vScale&amp;&amp;(t.min=Math.min(t.min,n.min),t.max=Math.max(t.max,n.max))}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){<span class="cstat-no" title="statement not covered" >return 0}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{iScale:i,vScale:s}=<span class="cstat-no" title="statement not covered" >e,</span>n=<span class="cstat-no" title="statement not covered" >this.getParsed(t),</span>o=<span class="cstat-no" title="statement not covered" >n._custom,</span>a=<span class="cstat-no" title="statement not covered" >Bn(o)?"["+o.start+", "+o.end+"]":""+s.getLabelForValue(n[s.axis]);<span class="cstat-no" title="statement not covered" ></span>return{label:""+i.getLabelForValue(n[i.axis]),value:a}}<span class="fstat-no" title="function not covered" ></span>in</span>itialize(){<span class="cstat-no" title="statement not covered" >this.enableOptionSharing=!0,super.initialize();<span class="cstat-no" title="statement not covered" >t</span>his._cachedMeta.stack=this.getDataset().stack}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this.updateElements(e.data,0,e.data.length,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,n){const o=<span class="cstat-no" title="statement not covered" >"reset"===n,</span>{index:a,_cachedMeta:{vScale:r}}=<span class="cstat-no" title="statement not covered" >this,</span>l=<span class="cstat-no" title="statement not covered" >r.getBasePixel(),</span>h=<span class="cstat-no" title="statement not covered" >r.isHorizontal(),</span>c=<span class="cstat-no" title="statement not covered" >this._getRuler(),</span>{sharedOptions:d,includeOptions:u}=<span class="cstat-no" title="statement not covered" >this._getSharedOptions(e,n);<span class="cstat-no" title="statement not covered" ></span>for(let f=<span class="cstat-no" title="statement not covered" >e;</span>f&lt;e+i;f++){const e=<span class="cstat-no" title="statement not covered" >this.getParsed(f),</span>i=<span class="cstat-no" title="statement not covered" >o||s(e[r.axis])?{base:l,head:l}:this._calculateBarValuePixels(f),</span>g=<span class="cstat-no" title="statement not covered" >this._calculateBarIndexPixels(f,c),</span>p=<span class="cstat-no" title="statement not covered" >(e._stacks||{})[r.axis],</span>m=<span class="cstat-no" title="statement not covered" >{horizontal:h,base:i.base,enableBorderRadius:!p||Bn(e._custom)||a===p._top||a===p._bottom,x:h?i.head:g.center,y:h?g.center:i.head,height:h?g.size:Math.abs(i.size),width:h?Math.abs(i.size):g.size};<span class="cstat-no" title="statement not covered" ></span>u&amp;&amp;(m.options=d||this.resolveDataElementOptions(f,t[f].active?"active":n));c</span>onst x=<span class="cstat-no" title="statement not covered" >m.options||t[f].options;<span class="cstat-no" title="statement not covered" ></span>Wn(m,x,p,a),jn(m,x,c.ratio),this.updateElement(t[f],f,m,n)}</span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etStacks(t,e){const{iScale:i}=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>n=<span class="cstat-no" title="statement not covered" >i.getMatchingVisibleMetas(this._type).filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.controller.options.grouped)</span>),</span>o=<span class="cstat-no" title="statement not covered" >i.options.stacked,</span>a=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >this._cachedMeta.controller.getParsed(e),</span>l=<span class="cstat-no" title="statement not covered" >r&amp;&amp;r[i.axis],</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t._parsed.find((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t[i.axis]===l)</span>),</span>n=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e[t.vScale.axis];<span class="cstat-no" title="statement not covered" ></span>if(s(n)||isNaN(n))<span class="cstat-no" title="statement not covered" >return!0}</span></span>;<span class="cstat-no" title="statement not covered" ></span>for(const i of n)<span class="cstat-no" title="statement not covered" >if((void 0===e||!h(i))&amp;&amp;((!1===o||-1===a.indexOf(i.stack)||void 0===o&amp;&amp;void 0===i.stack)&amp;&amp;a.push(i.stack),i.index===t))<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn a.length||a.push(void 0),a}<span class="fstat-no" title="function not covered" ></span>_g</span>etStackCount(t){<span class="cstat-no" title="statement not covered" >return this._getStacks(void 0,t).length}<span class="fstat-no" title="function not covered" ></span>_g</span>etAxisCount(){<span class="cstat-no" title="statement not covered" >return this._getAxis().length}<span class="fstat-no" title="function not covered" ></span>ge</span>tFirstScaleIdForIndexAxis(){const t=<span class="cstat-no" title="statement not covered" >this.chart.scales,</span>e=<span class="cstat-no" title="statement not covered" >this.chart.options.indexAxis;<span class="cstat-no" title="statement not covered" ></span>return Object.keys(t).filter((<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >t[i].axis===e)</span>).shift()}<span class="fstat-no" title="function not covered" ></span>_g</span>etAxis(){const t=<span class="cstat-no" title="statement not covered" >{},</span>e=<span class="cstat-no" title="statement not covered" >this.getFirstScaleIdForIndexAxis();<span class="cstat-no" title="statement not covered" ></span>for(const i of this.chart.data.datasets)<span class="cstat-no" title="statement not covered" >t[l("x"===this.chart.options.indexAxis?i.xAxisID:i.yAxisID,e)]=!0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn Object.keys(t)}<span class="fstat-no" title="function not covered" ></span>_g</span>etStackIndex(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this._getStacks(t,i),</span>n=<span class="cstat-no" title="statement not covered" >void 0!==e?s.indexOf(e):-1;<span class="cstat-no" title="statement not covered" ></span>return-1===n?s.length-1:n}<span class="fstat-no" title="function not covered" ></span>_g</span>etRuler(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >e.iScale,</span>s=<span class="cstat-no" title="statement not covered" >[];</span>let n,o;<span class="cstat-no" title="statement not covered" >for(n=0,o=e.data.length;n&lt;o;++n)<span class="cstat-no" title="statement not covered" >s.push(i.getPixelForValue(this.getParsed(n)[i.axis],n));c</span></span>onst a=<span class="cstat-no" title="statement not covered" >t.barThickness;<span class="cstat-no" title="statement not covered" ></span>return{min:a||zn(e),pixels:s,start:i._startPixel,end:i._endPixel,stackCount:this._getStackCount(),scale:i,grouped:t.grouped,ratio:a?1:t.categoryPercentage*t.barPercentage}}<span class="fstat-no" title="function not covered" ></span>_c</span>alculateBarValuePixels(t){const{_cachedMeta:{vScale:e,_stacked:i,index:n},options:{base:o,minBarLength:a}}=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >o||0,</span>l=<span class="cstat-no" title="statement not covered" >this.getParsed(t),</span>h=<span class="cstat-no" title="statement not covered" >l._custom,</span>c=<span class="cstat-no" title="statement not covered" >Bn(h);</span>let d,u,f=<span class="cstat-no" title="statement not covered" >l[e.axis],</span>g=<span class="cstat-no" title="statement not covered" >0,</span>p=<span class="cstat-no" title="statement not covered" >i?this.applyStack(e,l,i):f;<span class="cstat-no" title="statement not covered" ></span>p!==f&amp;&amp;(g=p-f,p=f),c&amp;&amp;(f=h.barStart,p=h.barEnd-h.barStart,0!==f&amp;&amp;F(f)!==F(h.barEnd)&amp;&amp;(g=0),g+=f);c</span>onst m=<span class="cstat-no" title="statement not covered" >s(o)||c?g:o;</span>let x=<span class="cstat-no" title="statement not covered" >e.getPixelForValue(m);<span class="cstat-no" title="statement not covered" ></span>if(d=this.chart.getDataVisibility(t)?e.getPixelForValue(g+p):x,u=d-x,Math.abs(u)&lt;a){<span class="cstat-no" title="statement not covered" >u=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return 0!==t?F(t):(e.isHorizontal()?1:-1)*(e.min&gt;=i?1:-1)}</span>(u,e,r)*a,f===r&amp;&amp;(x-=u/2);c</span>onst t=<span class="cstat-no" title="statement not covered" >e.getPixelForDecimal(0),</span>s=<span class="cstat-no" title="statement not covered" >e.getPixelForDecimal(1),</span>o=<span class="cstat-no" title="statement not covered" >Math.min(t,s),</span>h=<span class="cstat-no" title="statement not covered" >Math.max(t,s);<span class="cstat-no" title="statement not covered" ></span>x=Math.max(Math.min(x,h),o),d=x+u,i&amp;&amp;!c&amp;&amp;(l._stacks[e.axis]._visualValues[n]=e.getValueForPixel(d)-e.getValueForPixel(x))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(x===e.getPixelForValue(r)){const t=<span class="cstat-no" title="statement not covered" >F(u)*e.getLineWidthForValue(r)/2;<span class="cstat-no" title="statement not covered" ></span>x+=t,u-=t}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{size:u,base:x,head:d,center:d+u/2}}<span class="fstat-no" title="function not covered" ></span>_c</span>alculateBarIndexPixels(t,e){const i=<span class="cstat-no" title="statement not covered" >e.scale,</span>n=<span class="cstat-no" title="statement not covered" >this.options,</span>o=<span class="cstat-no" title="statement not covered" >n.skipNull,</span>a=<span class="cstat-no" title="statement not covered" >l(n.maxBarThickness,1/0);</span>let r,h;const c=<span class="cstat-no" title="statement not covered" >this._getAxisCount();<span class="cstat-no" title="statement not covered" ></span>if(e.grouped){const i=<span class="cstat-no" title="statement not covered" >o?this._getStackCount(t):e.stackCount,</span>d=<span class="cstat-no" title="statement not covered" >"flex"===n.barThickness?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.pixels,</span>o=<span class="cstat-no" title="statement not covered" >n[t];</span>let a=<span class="cstat-no" title="statement not covered" >t&gt;0?n[t-1]:null,</span>r=<span class="cstat-no" title="statement not covered" >t&lt;n.length-1?n[t+1]:null;</span>const l=<span class="cstat-no" title="statement not covered" >i.categoryPercentage;<span class="cstat-no" title="statement not covered" ></span>null===a&amp;&amp;(a=o-(null===r?e.end-e.start:r-o)),null===r&amp;&amp;(r=o+o-a);c</span>onst h=<span class="cstat-no" title="statement not covered" >o-(o-Math.min(a,r))/2*l;<span class="cstat-no" title="statement not covered" ></span>return{chunk:Math.abs(r-a)/2*l/s,ratio:i.barPercentage,start:h}}</span>(t,e,n,i*c):<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,n){const o=<span class="cstat-no" title="statement not covered" >i.barThickness;</span>let a,r;<span class="cstat-no" title="statement not covered" >return s(o)?(a=e.min*i.categoryPercentage,r=i.barPercentage):(a=o*n,r=1),{chunk:a/n,ratio:r,start:e.pixels[t]-a/2}}</span>(t,e,n,i*c),</span>u=<span class="cstat-no" title="statement not covered" >"x"===this.chart.options.indexAxis?this.getDataset().xAxisID:this.getDataset().yAxisID,</span>f=<span class="cstat-no" title="statement not covered" >this._getAxis().indexOf(l(u,this.getFirstScaleIdForIndexAxis())),</span>g=<span class="cstat-no" title="statement not covered" >this._getStackIndex(this.index,this._cachedMeta.stack,o?t:void 0)+f;<span class="cstat-no" title="statement not covered" ></span>r=d.start+d.chunk*g+d.chunk/2,h=Math.min(a,d.chunk*d.ratio)}</span>else <span class="cstat-no" title="statement not covered" >r=i.getPixelForValue(this.getParsed(t)[i.axis],t),h=Math.min(a,e.min*e.ratio);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{base:r-h/2,head:r+h/2,center:r,size:h}}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >t.vScale,</span>i=<span class="cstat-no" title="statement not covered" >t.data,</span>s=<span class="cstat-no" title="statement not covered" >i.length;</span>let n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;n&lt;s;++n)<span class="cstat-no" title="statement not covered" >null===this.getParsed(n)[e.axis]||i[n].hidden||i[n].draw(this._ctx)}</span></span>},BubbleController:class extends js{static id=<span class="cstat-no" title="statement not covered" >"bubble";</span>static defaults=<span class="cstat-no" title="statement not covered" >{datasetElementType:!1,dataElementType:"point",animations:{numbers:{type:"number",properties:["x","y","borderWidth","radius"]}}};</span>static overrides=<span class="cstat-no" title="statement not covered" >{scales:{x:{type:"linear"},y:{type:"linear"}}};<span class="fstat-no" title="function not covered" ></span>in</span>itialize(){<span class="cstat-no" title="statement not covered" >this.enableOptionSharing=!0,super.initialize()}<span class="fstat-no" title="function not covered" ></span>pa</span>rsePrimitiveData(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >super.parsePrimitiveData(t,e,i,s);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;n.length;t++)<span class="cstat-no" title="statement not covered" >n[t]._custom=this.resolveDataElementOptions(t+i).radius;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>pa</span>rseArrayData(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >super.parseArrayData(t,e,i,s);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;n.length;t++){const s=<span class="cstat-no" title="statement not covered" >e[i+t];<span class="cstat-no" title="statement not covered" ></span>n[t]._custom=l(s[2],this.resolveDataElementOptions(t+i).radius)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>pa</span>rseObjectData(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >super.parseObjectData(t,e,i,s);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;n.length;t++){const s=<span class="cstat-no" title="statement not covered" >e[i+t];<span class="cstat-no" title="statement not covered" ></span>n[t]._custom=l(s&amp;&amp;s.r&amp;&amp;+s.r,this.resolveDataElementOptions(t+i).radius)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta.data;</span>let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >t.length-1;</span>i&gt;=0;--i)<span class="cstat-no" title="statement not covered" >e=Math.max(e,t[i].size(this.resolveDataElementOptions(i))/2);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e&gt;0&amp;&amp;e}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.chart.data.labels||[],</span>{xScale:s,yScale:n}=<span class="cstat-no" title="statement not covered" >e,</span>o=<span class="cstat-no" title="statement not covered" >this.getParsed(t),</span>a=<span class="cstat-no" title="statement not covered" >s.getLabelForValue(o.x),</span>r=<span class="cstat-no" title="statement not covered" >n.getLabelForValue(o.y),</span>l=<span class="cstat-no" title="statement not covered" >o._custom;<span class="cstat-no" title="statement not covered" ></span>return{label:i[t]||"",value:"("+a+", "+r+(l?", "+l:"")+")"}}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta.data;<span class="cstat-no" title="statement not covered" ></span>this.updateElements(e,0,e.length,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >"reset"===s,</span>{iScale:o,vScale:a}=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{sharedOptions:r,includeOptions:l}=<span class="cstat-no" title="statement not covered" >this._getSharedOptions(e,s),</span>h=<span class="cstat-no" title="statement not covered" >o.axis,</span>c=<span class="cstat-no" title="statement not covered" >a.axis;<span class="cstat-no" title="statement not covered" ></span>for(let d=<span class="cstat-no" title="statement not covered" >e;</span>d&lt;e+i;d++){const e=<span class="cstat-no" title="statement not covered" >t[d],</span>i=<span class="cstat-no" title="statement not covered" >!n&amp;&amp;this.getParsed(d),</span>u=<span class="cstat-no" title="statement not covered" >{},</span>f=<span class="cstat-no" title="statement not covered" >u[h]=n?o.getPixelForDecimal(.5):o.getPixelForValue(i[h]),</span>g=<span class="cstat-no" title="statement not covered" >u[c]=n?a.getBasePixel():a.getPixelForValue(i[c]);<span class="cstat-no" title="statement not covered" ></span>u.skip=isNaN(f)||isNaN(g),l&amp;&amp;(u.options=r||this.resolveDataElementOptions(d,e.active?"active":s),n&amp;&amp;(u.options.radius=0)),this.updateElement(e,d,u,s)}</span>}<span class="fstat-no" title="function not covered" ></span>re</span>solveDataElementOptions(t,e){const i=<span class="cstat-no" title="statement not covered" >this.getParsed(t);</span>let s=<span class="cstat-no" title="statement not covered" >super.resolveDataElementOptions(t,e);<span class="cstat-no" title="statement not covered" ></span>s.$shared&amp;&amp;(s=Object.assign({},s,{$shared:!1}));c</span>onst n=<span class="cstat-no" title="statement not covered" >s.radius;<span class="cstat-no" title="statement not covered" ></span>return"active"!==e&amp;&amp;(s.radius=0),s.radius+=l(i&amp;&amp;i._custom,n),s}</span>},DoughnutController:$n,LineController:class extends js{static id=<span class="cstat-no" title="statement not covered" >"line";</span>static defaults=<span class="cstat-no" title="statement not covered" >{datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1};</span>static overrides=<span class="cstat-no" title="statement not covered" >{scales:{_index_:{type:"category"},_value_:{type:"linear"}}};<span class="fstat-no" title="function not covered" ></span>in</span>itialize(){<span class="cstat-no" title="statement not covered" >this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{dataset:i,data:s=<span class="branch-0 cbranch-no" title="branch not covered" >[],</span>_dataset:n}=<span class="cstat-no" title="statement not covered" >e,</span>o=<span class="cstat-no" title="statement not covered" >this.chart._animationsDisabled;</span>let{start:a,count:r}=<span class="cstat-no" title="statement not covered" >pt(e,s,o);<span class="cstat-no" title="statement not covered" ></span>this._drawStart=a,this._drawCount=r,mt(e)&amp;&amp;(a=0,r=s.length),i._chart=this.chart,i._datasetIndex=this.index,i._decimated=!!n._decimated,i.points=s;c</span>onst l=<span class="cstat-no" title="statement not covered" >this.resolveDatasetElementOptions(t);<span class="cstat-no" title="statement not covered" ></span>this.options.showLine||(l.borderWidth=0),l.segment=this.options.segment,this.updateElement(i,void 0,{animated:!o,options:l},t),this.updateElements(s,a,r,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,n){const o=<span class="cstat-no" title="statement not covered" >"reset"===n,</span>{iScale:a,vScale:r,_stacked:l,_dataset:h}=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{sharedOptions:c,includeOptions:d}=<span class="cstat-no" title="statement not covered" >this._getSharedOptions(e,n),</span>u=<span class="cstat-no" title="statement not covered" >a.axis,</span>f=<span class="cstat-no" title="statement not covered" >r.axis,</span>{spanGaps:g,segment:p}=<span class="cstat-no" title="statement not covered" >this.options,</span>m=<span class="cstat-no" title="statement not covered" >N(g)?g:Number.POSITIVE_INFINITY,</span>x=<span class="cstat-no" title="statement not covered" >this.chart._animationsDisabled||o||"none"===n,</span>b=<span class="cstat-no" title="statement not covered" >e+i,</span>_=<span class="cstat-no" title="statement not covered" >t.length;</span>let y=<span class="cstat-no" title="statement not covered" >e&gt;0&amp;&amp;this.getParsed(e-1);<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;_;++i){const g=<span class="cstat-no" title="statement not covered" >t[i],</span>_=<span class="cstat-no" title="statement not covered" >x?g:{};<span class="cstat-no" title="statement not covered" ></span>if(i&lt;e||i&gt;=b){<span class="cstat-no" title="statement not covered" >_.skip=!0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst v=<span class="cstat-no" title="statement not covered" >this.getParsed(i),</span>M=<span class="cstat-no" title="statement not covered" >s(v[f]),</span>w=<span class="cstat-no" title="statement not covered" >_[u]=a.getPixelForValue(v[u],i),</span>k=<span class="cstat-no" title="statement not covered" >_[f]=o||M?r.getBasePixel():r.getPixelForValue(l?this.applyStack(r,v,l):v[f],i);<span class="cstat-no" title="statement not covered" ></span>_.skip=isNaN(w)||isNaN(k)||M,_.stop=i&gt;0&amp;&amp;Math.abs(v[u]-y[u])&gt;m,p&amp;&amp;(_.parsed=v,_.raw=h.data[i]),d&amp;&amp;(_.options=c||this.resolveDataElementOptions(i,g.active?"active":n)),x||this.updateElement(g,i,_,n),y=v}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >t.dataset,</span>i=<span class="cstat-no" title="statement not covered" >e.options&amp;&amp;e.options.borderWidth||0,</span>s=<span class="cstat-no" title="statement not covered" >t.data||[];<span class="cstat-no" title="statement not covered" ></span>if(!s.length)<span class="cstat-no" title="statement not covered" >return i;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >s[0].size(this.resolveDataElementOptions(0)),</span>o=<span class="cstat-no" title="statement not covered" >s[s.length-1].size(this.resolveDataElementOptions(s.length-1));<span class="cstat-no" title="statement not covered" ></span>return Math.max(i,n,o)/2}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>t.dataset.updateControlPoints(this.chart.chartArea,t.iScale.axis),super.draw()}</span>},PieController:class extends $n{static id=<span class="cstat-no" title="statement not covered" >"pie";</span>static defaults=<span class="cstat-no" title="statement not covered" >{cutout:0,rotation:0,circumference:360,radius:"100%"}}</span>,PolarAreaController:Yn,RadarController:class extends js{static id=<span class="cstat-no" title="statement not covered" >"radar";</span>static defaults=<span class="cstat-no" title="statement not covered" >{datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:!0,elements:{line:{fill:"start"}}};</span>static overrides=<span class="cstat-no" title="statement not covered" >{aspectRatio:1,scales:{r:{type:"radialLinear"}}};<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta.vScale,</span>i=<span class="cstat-no" title="statement not covered" >this.getParsed(t);<span class="cstat-no" title="statement not covered" ></span>return{label:e.getLabels()[t],value:""+e.getLabelForValue(i[e.axis])}}<span class="fstat-no" title="function not covered" ></span>pa</span>rseObjectData(t,e,i,s){<span class="cstat-no" title="statement not covered" >return ii.bind(this)(t,e,i,s)}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >e.dataset,</span>s=<span class="cstat-no" title="statement not covered" >e.data||[],</span>n=<span class="cstat-no" title="statement not covered" >e.iScale.getLabels();<span class="cstat-no" title="statement not covered" ></span>if(i.points=s,"resize"!==t){const e=<span class="cstat-no" title="statement not covered" >this.resolveDatasetElementOptions(t);<span class="cstat-no" title="statement not covered" ></span>this.options.showLine||(e.borderWidth=0);c</span>onst o=<span class="cstat-no" title="statement not covered" >{_loop:!0,_fullLoop:n.length===s.length,options:e};<span class="cstat-no" title="statement not covered" ></span>this.updateElement(i,void 0,o,t)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.updateElements(s,0,s.length,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this._cachedMeta.rScale,</span>o=<span class="cstat-no" title="statement not covered" >"reset"===s;<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >e;</span>a&lt;e+i;a++){const e=<span class="cstat-no" title="statement not covered" >t[a],</span>i=<span class="cstat-no" title="statement not covered" >this.resolveDataElementOptions(a,e.active?"active":s),</span>r=<span class="cstat-no" title="statement not covered" >n.getPointPositionForValue(a,this.getParsed(a).r),</span>l=<span class="cstat-no" title="statement not covered" >o?n.xCenter:r.x,</span>h=<span class="cstat-no" title="statement not covered" >o?n.yCenter:r.y,</span>c=<span class="cstat-no" title="statement not covered" >{x:l,y:h,angle:r.angle,skip:isNaN(l)||isNaN(h),options:i};<span class="cstat-no" title="statement not covered" ></span>this.updateElement(e,a,c,s)}</span>}</span>},ScatterController:class extends js{static id=<span class="cstat-no" title="statement not covered" >"scatter";</span>static defaults=<span class="cstat-no" title="statement not covered" >{datasetElementType:!1,dataElementType:"point",showLine:!1,fill:!1};</span>static overrides=<span class="cstat-no" title="statement not covered" >{interaction:{mode:"point"},scales:{x:{type:"linear"},y:{type:"linear"}}};<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.chart.data.labels||[],</span>{xScale:s,yScale:n}=<span class="cstat-no" title="statement not covered" >e,</span>o=<span class="cstat-no" title="statement not covered" >this.getParsed(t),</span>a=<span class="cstat-no" title="statement not covered" >s.getLabelForValue(o.x),</span>r=<span class="cstat-no" title="statement not covered" >n.getLabelForValue(o.y);<span class="cstat-no" title="statement not covered" ></span>return{label:i[t]||"",value:"("+a+", "+r+")"}}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{data:i=<span class="branch-0 cbranch-no" title="branch not covered" >[]}</span>=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >this.chart._animationsDisabled;</span>let{start:n,count:o}=<span class="cstat-no" title="statement not covered" >pt(e,i,s);<span class="cstat-no" title="statement not covered" ></span>if(this._drawStart=n,this._drawCount=o,mt(e)&amp;&amp;(n=0,o=i.length),this.options.showLine){<span class="cstat-no" title="statement not covered" >this.datasetElementType||this.addElements();c</span>onst{dataset:n,_dataset:o}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>n._chart=this.chart,n._datasetIndex=this.index,n._decimated=!!o._decimated,n.points=i;c</span>onst a=<span class="cstat-no" title="statement not covered" >this.resolveDatasetElementOptions(t);<span class="cstat-no" title="statement not covered" ></span>a.segment=this.options.segment,this.updateElement(n,void 0,{animated:!s,options:a},t)}</span>else <span class="cstat-no" title="statement not covered" >this.datasetElementType&amp;&amp;(delete e.dataset,this.datasetElementType=!1);<span class="cstat-no" title="statement not covered" >t</span></span>his.updateElements(i,n,o,t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dElements(){const{showLine:t}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>!this.datasetElementType&amp;&amp;t&amp;&amp;(this.datasetElementType=this.chart.registry.getElement("line")),super.addElements()}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,n){const o=<span class="cstat-no" title="statement not covered" >"reset"===n,</span>{iScale:a,vScale:r,_stacked:l,_dataset:h}=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>c=<span class="cstat-no" title="statement not covered" >this.resolveDataElementOptions(e,n),</span>d=<span class="cstat-no" title="statement not covered" >this.getSharedOptions(c),</span>u=<span class="cstat-no" title="statement not covered" >this.includeOptions(n,d),</span>f=<span class="cstat-no" title="statement not covered" >a.axis,</span>g=<span class="cstat-no" title="statement not covered" >r.axis,</span>{spanGaps:p,segment:m}=<span class="cstat-no" title="statement not covered" >this.options,</span>x=<span class="cstat-no" title="statement not covered" >N(p)?p:Number.POSITIVE_INFINITY,</span>b=<span class="cstat-no" title="statement not covered" >this.chart._animationsDisabled||o||"none"===n;</span>let _=<span class="cstat-no" title="statement not covered" >e&gt;0&amp;&amp;this.getParsed(e-1);<span class="cstat-no" title="statement not covered" ></span>for(let c=<span class="cstat-no" title="statement not covered" >e;</span>c&lt;e+i;++c){const e=<span class="cstat-no" title="statement not covered" >t[c],</span>i=<span class="cstat-no" title="statement not covered" >this.getParsed(c),</span>p=<span class="cstat-no" title="statement not covered" >b?e:{},</span>y=<span class="cstat-no" title="statement not covered" >s(i[g]),</span>v=<span class="cstat-no" title="statement not covered" >p[f]=a.getPixelForValue(i[f],c),</span>M=<span class="cstat-no" title="statement not covered" >p[g]=o||y?r.getBasePixel():r.getPixelForValue(l?this.applyStack(r,i,l):i[g],c);<span class="cstat-no" title="statement not covered" ></span>p.skip=isNaN(v)||isNaN(M)||y,p.stop=c&gt;0&amp;&amp;Math.abs(i[f]-_[f])&gt;x,m&amp;&amp;(p.parsed=i,p.raw=h.data[c]),u&amp;&amp;(p.options=d||this.resolveDataElementOptions(c,e.active?"active":n)),b||this.updateElement(e,c,p,n),_=i}<span class="cstat-no" title="statement not covered" ></span>t</span>his.updateSharedOptions(d,n,c)}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >t.data||[];<span class="cstat-no" title="statement not covered" ></span>if(!this.options.showLine){let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >e.length-1;</span>i&gt;=0;--i)<span class="cstat-no" title="statement not covered" >t=Math.max(t,e[i].size(this.resolveDataElementOptions(i))/2);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t&gt;0&amp;&amp;t}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >t.dataset,</span>s=<span class="cstat-no" title="statement not covered" >i.options&amp;&amp;i.options.borderWidth||0;<span class="cstat-no" title="statement not covered" ></span>if(!e.length)<span class="cstat-no" title="statement not covered" >return s;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >e[0].size(this.resolveDataElementOptions(0)),</span>o=<span class="cstat-no" title="statement not covered" >e[e.length-1].size(this.resolveDataElementOptions(e.length-1));<span class="cstat-no" title="statement not covered" ></span>return Math.max(s,n,o)/2}</span>}});</span>function <span class="fstat-no" title="function not covered" >Xn(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >vi(t.options.borderRadius,["outerStart","outerEnd","innerStart","innerEnd"]);</span>const o=<span class="cstat-no" title="statement not covered" >(i-e)/2,</span>a=<span class="cstat-no" title="statement not covered" >Math.min(o,s*e/2),</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >(i-Math.min(o,t))*s/2;<span class="cstat-no" title="statement not covered" ></span>return Z(t,0,Math.min(o,e))}</span>;<span class="cstat-no" title="statement not covered" ></span>return{outerStart:r(n.outerStart),outerEnd:r(n.outerEnd),innerStart:Z(n.innerStart,0,a),innerEnd:Z(n.innerEnd,0,a)}}</span>function <span class="fstat-no" title="function not covered" >qn(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return{x:i+t*Math.cos(e),y:s+t*Math.sin(e)}}</span>function <span class="fstat-no" title="function not covered" >Kn(</span>t,e,i,s,n,o){const{x:a,y:r,startAngle:l,pixelMargin:h,innerRadius:c}=<span class="cstat-no" title="statement not covered" >e,</span>d=<span class="cstat-no" title="statement not covered" >Math.max(e.outerRadius+s+i-h,0),</span>u=<span class="cstat-no" title="statement not covered" >c&gt;0?c+s+i+h:0;</span>let f=<span class="cstat-no" title="statement not covered" >0;</span>const g=<span class="cstat-no" title="statement not covered" >n-l;<span class="cstat-no" title="statement not covered" ></span>if(s){const t=<span class="cstat-no" title="statement not covered" >((c&gt;0?c-s:0)+(d&gt;0?d-s:0))/2;<span class="cstat-no" title="statement not covered" ></span>f=(g-(0!==t?g*t/(t+s):g))/2}</span>c</span>onst p=<span class="cstat-no" title="statement not covered" >(g-Math.max(.001,g*d-i/C)/d)/2,</span>m=<span class="cstat-no" title="statement not covered" >l+p+f,</span>x=<span class="cstat-no" title="statement not covered" >n-p-f,</span>{outerStart:b,outerEnd:_,innerStart:y,innerEnd:v}=<span class="cstat-no" title="statement not covered" >Xn(e,u,d,x-m),</span>M=<span class="cstat-no" title="statement not covered" >d-b,</span>w=<span class="cstat-no" title="statement not covered" >d-_,</span>k=<span class="cstat-no" title="statement not covered" >m+b/M,</span>S=<span class="cstat-no" title="statement not covered" >x-_/w,</span>P=<span class="cstat-no" title="statement not covered" >u+y,</span>D=<span class="cstat-no" title="statement not covered" >u+v,</span>O=<span class="cstat-no" title="statement not covered" >m+y/P,</span>A=<span class="cstat-no" title="statement not covered" >x-v/D;<span class="cstat-no" title="statement not covered" ></span>if(t.beginPath(),o){const e=<span class="cstat-no" title="statement not covered" >(k+S)/2;<span class="cstat-no" title="statement not covered" ></span>if(t.arc(a,r,d,k,e),t.arc(a,r,d,e,S),_&gt;0){const e=<span class="cstat-no" title="statement not covered" >qn(w,S,a,r);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,_,S,x+E)}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >qn(D,x,a,r);<span class="cstat-no" title="statement not covered" ></span>if(t.lineTo(i.x,i.y),v&gt;0){const e=<span class="cstat-no" title="statement not covered" >qn(D,A,a,r);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,v,x+E,A+Math.PI)}</span>c</span>onst s=<span class="cstat-no" title="statement not covered" >(x-v/u+(m+y/u))/2;<span class="cstat-no" title="statement not covered" ></span>if(t.arc(a,r,u,x-v/u,s,!0),t.arc(a,r,u,s,m+y/u,!0),y&gt;0){const e=<span class="cstat-no" title="statement not covered" >qn(P,O,a,r);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,y,O+Math.PI,m-E)}</span>c</span>onst n=<span class="cstat-no" title="statement not covered" >qn(M,m,a,r);<span class="cstat-no" title="statement not covered" ></span>if(t.lineTo(n.x,n.y),b&gt;0){const e=<span class="cstat-no" title="statement not covered" >qn(M,k,a,r);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,b,m-E,k)}</span>}</span>else{<span class="cstat-no" title="statement not covered" >t.moveTo(a,r);c</span>onst e=<span class="cstat-no" title="statement not covered" >Math.cos(k)*d+a,</span>i=<span class="cstat-no" title="statement not covered" >Math.sin(k)*d+r;<span class="cstat-no" title="statement not covered" ></span>t.lineTo(e,i);c</span>onst s=<span class="cstat-no" title="statement not covered" >Math.cos(S)*d+a,</span>n=<span class="cstat-no" title="statement not covered" >Math.sin(S)*d+r;<span class="cstat-no" title="statement not covered" ></span>t.lineTo(s,n)}<span class="cstat-no" title="statement not covered" ></span>t</span>.closePath()}</span>function <span class="fstat-no" title="function not covered" >Gn(</span>t,e,i,s,n){const{fullCircles:o,startAngle:a,circumference:r,options:l}=<span class="cstat-no" title="statement not covered" >e,</span>{borderWidth:h,borderJoinStyle:c,borderDash:d,borderDashOffset:u,borderRadius:f}=<span class="cstat-no" title="statement not covered" >l,</span>g=<span class="cstat-no" title="statement not covered" >"inner"===l.borderAlign;<span class="cstat-no" title="statement not covered" ></span>if(!h)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>.setLineDash(d||[]),t.lineDashOffset=u,g?(t.lineWidth=2*h,t.lineJoin=c||"round"):(t.lineWidth=h,t.lineJoin=c||"bevel");l</span>et p=<span class="cstat-no" title="statement not covered" >e.endAngle;<span class="cstat-no" title="statement not covered" ></span>if(o){<span class="cstat-no" title="statement not covered" >Kn(t,e,i,s,p,n);<span class="cstat-no" title="statement not covered" >f</span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o;++e)<span class="cstat-no" title="statement not covered" >t.stroke();<span class="cstat-no" title="statement not covered" >i</span></span>sNaN(r)||(p=a+(r%O||O))}<span class="cstat-no" title="statement not covered" ></span>g</span>&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{startAngle:s,pixelMargin:n,x:o,y:a,outerRadius:r,innerRadius:l}=<span class="cstat-no" title="statement not covered" >e;</span>let h=<span class="cstat-no" title="statement not covered" >n/r;<span class="cstat-no" title="statement not covered" ></span>t.beginPath(),t.arc(o,a,r,s-h,i+h),l&gt;n?(h=n/l,t.arc(o,a,l,i+h,s-h,!0)):t.arc(o,a,n,i+E,s-E),t.closePath(),t.clip()}</span>(t,e,p),l.selfJoin&amp;&amp;p-a&gt;=C&amp;&amp;0===f&amp;&amp;"miter"!==c&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{startAngle:s,x:n,y:o,outerRadius:a,innerRadius:r,options:l}=<span class="cstat-no" title="statement not covered" >e,</span>{borderWidth:h,borderJoinStyle:c}=<span class="cstat-no" title="statement not covered" >l,</span>d=<span class="cstat-no" title="statement not covered" >Math.min(h/a,G(s-i));<span class="cstat-no" title="statement not covered" ></span>if(t.beginPath(),t.arc(n,o,a-h/2,s+d/2,i-d/2),r&gt;0){const e=<span class="cstat-no" title="statement not covered" >Math.min(h/r,G(s-i));<span class="cstat-no" title="statement not covered" ></span>t.arc(n,o,r+h/2,i-e/2,s+e/2,!0)}</span>else{const e=<span class="cstat-no" title="statement not covered" >Math.min(h/2,a*G(s-i));<span class="cstat-no" title="statement not covered" ></span>if("round"===c)<span class="cstat-no" title="statement not covered" >t.arc(n,o,e,i-C/2,s+C/2,!0);e</span>lse <span class="cstat-no" title="statement not covered" >if("bevel"===c){const a=<span class="cstat-no" title="statement not covered" >2*e*e,</span>r=<span class="cstat-no" title="statement not covered" >-a*Math.cos(i+C/2)+n,</span>l=<span class="cstat-no" title="statement not covered" >-a*Math.sin(i+C/2)+o,</span>h=<span class="cstat-no" title="statement not covered" >a*Math.cos(s+C/2)+n,</span>c=<span class="cstat-no" title="statement not covered" >a*Math.sin(s+C/2)+o;<span class="cstat-no" title="statement not covered" ></span>t.lineTo(r,l),t.lineTo(h,c)}</span>}<span class="cstat-no" title="statement not covered" ></span></span>t</span>.closePath(),t.moveTo(0,0),t.rect(0,0,t.canvas.width,t.canvas.height),t.clip("evenodd")}</span>(t,e,p),o||(Kn(t,e,i,s,p,n),t.stroke())}</span>function <span class="fstat-no" title="function not covered" >Jn(</span>t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >e)</span>{<span class="cstat-no" title="statement not covered" >t.lineCap=l(i.borderCapStyle,e.borderCapStyle),t.setLineDash(l(i.borderDash,e.borderDash)),t.lineDashOffset=l(i.borderDashOffset,e.borderDashOffset),t.lineJoin=l(i.borderJoinStyle,e.borderJoinStyle),t.lineWidth=l(i.borderWidth,e.borderWidth),t.strokeStyle=l(i.borderColor,e.borderColor)}</span>function <span class="fstat-no" title="function not covered" >Zn(</span>t,e,i){<span class="cstat-no" title="statement not covered" >t.lineTo(i.x,i.y)}</span>function <span class="fstat-no" title="function not covered" >Qn(</span>t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const s=<span class="cstat-no" title="statement not covered" >t.length,</span>{start:n=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>end:o=<span class="branch-0 cbranch-no" title="branch not covered" >s-1}</span>=<span class="cstat-no" title="statement not covered" >i,</span>{start:a,end:r}=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" >Math.max(n,a),</span>h=<span class="cstat-no" title="statement not covered" >Math.min(o,r),</span>c=<span class="cstat-no" title="statement not covered" >n&lt;a&amp;&amp;o&lt;a||n&gt;r&amp;&amp;o&gt;r;<span class="cstat-no" title="statement not covered" ></span>return{count:s,start:l,loop:e.loop,ilen:h&lt;l&amp;&amp;!c?s+h-l:h-l}}</span>function <span class="fstat-no" title="function not covered" >to(</span>t,e,i,s){const{points:n,options:o}=<span class="cstat-no" title="statement not covered" >e,</span>{count:a,start:r,loop:l,ilen:h}=<span class="cstat-no" title="statement not covered" >Qn(n,i,s),</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.stepped?Fe:t.tension||"monotone"===t.cubicInterpolationMode?Ve:Zn}</span>(o);</span>let d,u,f,{move:g=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>reverse:p}=<span class="cstat-no" title="statement not covered" >s||{};<span class="cstat-no" title="statement not covered" ></span>for(d=0;d&lt;=h;++d)<span class="cstat-no" title="statement not covered" >u=n[(r+(p?h-d:d))%a],u.skip||(g?(t.moveTo(u.x,u.y),g=!1):c(t,f,u,p,o.stepped),f=u);<span class="cstat-no" title="statement not covered" >r</span></span>eturn l&amp;&amp;(u=n[(r+(p?h:0))%a],c(t,f,u,p,o.stepped)),!!l}</span>function <span class="fstat-no" title="function not covered" >eo(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.points,</span>{count:o,start:a,ilen:r}=<span class="cstat-no" title="statement not covered" >Qn(n,i,s),</span>{move:l=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>reverse:h}=<span class="cstat-no" title="statement not covered" >s||{};</span>let c,d,u,f,g,p,m=<span class="cstat-no" title="statement not covered" >0,</span>x=<span class="cstat-no" title="statement not covered" >0;</span>const b=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(a+(h?r-t:t))%o,</span></span>_=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >f!==g&amp;&amp;(t.lineTo(m,g),t.lineTo(m,f),t.lineTo(m,p))}</span>;<span class="cstat-no" title="statement not covered" ></span>for(l&amp;&amp;(d=n[b(0)],t.moveTo(d.x,d.y)),c=0;c&lt;=r;++c){<span class="cstat-no" title="statement not covered" >if(d=n[b(c)],d.skip)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >d.x,</span>i=<span class="cstat-no" title="statement not covered" >d.y,</span>s=<span class="cstat-no" title="statement not covered" >0|e;<span class="cstat-no" title="statement not covered" ></span>s===u?(i&lt;f?f=i:i&gt;g&amp;&amp;(g=i),m=(x*m+e)/++x):(_(),t.lineTo(e,i),u=s,x=0,f=g=i),p=i}<span class="cstat-no" title="statement not covered" ></span>_</span>()}</span>function <span class="fstat-no" title="function not covered" >io(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.options,</span>i=<span class="cstat-no" title="statement not covered" >e.borderDash&amp;&amp;e.borderDash.length;<span class="cstat-no" title="statement not covered" ></span>return!(t._decimated||t._loop||e.tension||"monotone"===e.cubicInterpolationMode||e.stepped||i)?eo:to}</span>const so=<span class="cstat-no" title="statement not covered" >"function"==typeof Path2D;</span>function <span class="fstat-no" title="function not covered" >no(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >so&amp;&amp;!e.options.segment?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >e._path;<span class="cstat-no" title="statement not covered" ></span>n||(n=e._path=new Path2D,e.path(n,i,s)&amp;&amp;n.closePath()),Jn(t,e.options),t.stroke(n)}</span>(t,e,i,s):<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{segments:n,options:o}=<span class="cstat-no" title="statement not covered" >e,</span>a=<span class="cstat-no" title="statement not covered" >io(e);<span class="cstat-no" title="statement not covered" ></span>for(const r of n)<span class="cstat-no" title="statement not covered" >Jn(t,o,r.style),t.beginPath(),a(t,e,r,{start:i,end:i+s-1})&amp;&amp;t.closePath(),t.stroke()}</span></span>(t,e,i,s)}</span>class oo extends $s{static id=<span class="cstat-no" title="statement not covered" >"line";</span>static defaults=<span class="cstat-no" title="statement not covered" >{borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >{backgroundColor:"backgroundColor",borderColor:"borderColor"};</span>static descriptors=<span class="cstat-no" title="statement not covered" >{_scriptable:!0,_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"borderDash"!==t&amp;&amp;"fill"!==t}</span>;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateControlPoints(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if((i.tension||"monotone"===i.cubicInterpolationMode)&amp;&amp;!i.stepped&amp;&amp;!this._pointsUpdated){const s=<span class="cstat-no" title="statement not covered" >i.spanGaps?this._loop:this._fullLoop;<span class="cstat-no" title="statement not covered" ></span>hi(this._points,i,t,s,e),this._pointsUpdated=!0}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>t points(t){<span class="cstat-no" title="statement not covered" >this._points=t,delete this._segments,delete this._path,this._pointsUpdated=!1}<span class="fstat-no" title="function not covered" ></span>ge</span>t points(){<span class="cstat-no" title="statement not covered" >return this._points}<span class="fstat-no" title="function not covered" ></span>ge</span>t segments(){<span class="cstat-no" title="statement not covered" >return this._segments||(this._segments=zi(this,this.options.segment))}<span class="fstat-no" title="function not covered" ></span>fi</span>rst(){const t=<span class="cstat-no" title="statement not covered" >this.segments,</span>e=<span class="cstat-no" title="statement not covered" >this.points;<span class="cstat-no" title="statement not covered" ></span>return t.length&amp;&amp;e[t[0].start]}<span class="fstat-no" title="function not covered" ></span>la</span>st(){const t=<span class="cstat-no" title="statement not covered" >this.segments,</span>e=<span class="cstat-no" title="statement not covered" >this.points,</span>i=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;e[t[i-1].end]}<span class="fstat-no" title="function not covered" ></span>in</span>terpolate(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options,</span>s=<span class="cstat-no" title="statement not covered" >t[e],</span>n=<span class="cstat-no" title="statement not covered" >this.points,</span>o=<span class="cstat-no" title="statement not covered" >Ii(this,{property:e,start:s,end:s});<span class="cstat-no" title="statement not covered" ></span>if(!o.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.stepped?pi:t.tension||"monotone"===t.cubicInterpolationMode?mi:gi}</span>(i);</span>let l,h;<span class="cstat-no" title="statement not covered" >for(l=0,h=o.length;l&lt;h;++l){const{start:h,end:c}=<span class="cstat-no" title="statement not covered" >o[l],</span>d=<span class="cstat-no" title="statement not covered" >n[h],</span>u=<span class="cstat-no" title="statement not covered" >n[c];<span class="cstat-no" title="statement not covered" ></span>if(d===u){<span class="cstat-no" title="statement not covered" >a.push(d);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst f=<span class="cstat-no" title="statement not covered" >r(d,u,Math.abs((s-d[e])/(u[e]-d[e])),i.stepped);<span class="cstat-no" title="statement not covered" ></span>f[e]=t[e],a.push(f)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn 1===a.length?a[0]:a}<span class="fstat-no" title="function not covered" ></span>pa</span>thSegment(t,e,i){<span class="cstat-no" title="statement not covered" >return io(this)(t,this,e,i)}<span class="fstat-no" title="function not covered" ></span>pa</span>th(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.segments,</span>n=<span class="cstat-no" title="statement not covered" >io(this);</span>let o=<span class="cstat-no" title="statement not covered" >this._loop;<span class="cstat-no" title="statement not covered" ></span>e=e||0,i=i||this.points.length-e;<span class="cstat-no" title="statement not covered" >f</span>or(const a of s)<span class="cstat-no" title="statement not covered" >o&amp;=n(t,this,a,{start:e,end:e+i-1});<span class="cstat-no" title="statement not covered" >r</span></span>eturn!!o}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.options||{};<span class="cstat-no" title="statement not covered" ></span>(this.points||[]).length&amp;&amp;n.borderWidth&amp;&amp;(t.save(),no(t,this,i,s),t.restore()),this.animated&amp;&amp;(this._pointsUpdated=!1,this._path=void 0)}</span>}function <span class="fstat-no" title="function not covered" >ao(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.options,</span>{[i]:o}=<span class="cstat-no" title="statement not covered" >t.getProps([i],s);<span class="cstat-no" title="statement not covered" ></span>return Math.abs(e-o)&lt;n.radius+n.hitRadius}</span>function <span class="fstat-no" title="function not covered" >ro(</span>t,e){const{x:i,y:s,base:n,width:o,height:a}=<span class="cstat-no" title="statement not covered" >t.getProps(["x","y","base","width","height"],e);</span>let r,l,h,c,d;<span class="cstat-no" title="statement not covered" >return t.horizontal?(d=a/2,r=Math.min(i,n),l=Math.max(i,n),h=s-d,c=s+d):(d=o/2,r=i-d,l=i+d,h=Math.min(s,n),c=Math.max(s,n)),{left:r,top:h,right:l,bottom:c}}</span>function <span class="fstat-no" title="function not covered" >lo(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return t?0:Z(e,i,s)}</span>function <span class="fstat-no" title="function not covered" >ho(</span>t){const e=<span class="cstat-no" title="statement not covered" >ro(t),</span>i=<span class="cstat-no" title="statement not covered" >e.right-e.left,</span>s=<span class="cstat-no" title="statement not covered" >e.bottom-e.top,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.options.borderWidth,</span>n=<span class="cstat-no" title="statement not covered" >t.borderSkipped,</span>o=<span class="cstat-no" title="statement not covered" >Mi(s);<span class="cstat-no" title="statement not covered" ></span>return{t:lo(n.top,o.top,0,i),r:lo(n.right,o.right,0,e),b:lo(n.bottom,o.bottom,0,i),l:lo(n.left,o.left,0,e)}}</span>(t,i/2,s/2),</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{enableBorderRadius:s}=<span class="cstat-no" title="statement not covered" >t.getProps(["enableBorderRadius"]),</span>n=<span class="cstat-no" title="statement not covered" >t.options.borderRadius,</span>a=<span class="cstat-no" title="statement not covered" >wi(n),</span>r=<span class="cstat-no" title="statement not covered" >Math.min(e,i),</span>l=<span class="cstat-no" title="statement not covered" >t.borderSkipped,</span>h=<span class="cstat-no" title="statement not covered" >s||o(n);<span class="cstat-no" title="statement not covered" ></span>return{topLeft:lo(!h||l.top||l.left,a.topLeft,0,r),topRight:lo(!h||l.top||l.right,a.topRight,0,r),bottomLeft:lo(!h||l.bottom||l.left,a.bottomLeft,0,r),bottomRight:lo(!h||l.bottom||l.right,a.bottomRight,0,r)}}</span>(t,i/2,s/2);<span class="cstat-no" title="statement not covered" ></span>return{outer:{x:e.left,y:e.top,w:i,h:s,radius:a},inner:{x:e.left+n.l,y:e.top+n.t,w:i-n.l-n.r,h:s-n.t-n.b,radius:{topLeft:Math.max(0,a.topLeft-Math.max(n.t,n.l)),topRight:Math.max(0,a.topRight-Math.max(n.t,n.r)),bottomLeft:Math.max(0,a.bottomLeft-Math.max(n.b,n.l)),bottomRight:Math.max(0,a.bottomRight-Math.max(n.b,n.r))}}}}</span>function <span class="fstat-no" title="function not covered" >co(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >null===e,</span>o=<span class="cstat-no" title="statement not covered" >null===i,</span>a=<span class="cstat-no" title="statement not covered" >t&amp;&amp;!(n&amp;&amp;o)&amp;&amp;ro(t,s);<span class="cstat-no" title="statement not covered" ></span>return a&amp;&amp;(n||tt(e,a.left,a.right))&amp;&amp;(o||tt(i,a.top,a.bottom))}</span>function <span class="fstat-no" title="function not covered" >uo(</span>t,e){<span class="cstat-no" title="statement not covered" >t.rect(e.x,e.y,e.w,e.h)}</span>function <span class="fstat-no" title="function not covered" >fo(</span>t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const s=<span class="cstat-no" title="statement not covered" >t.x!==i.x?-e:0,</span>n=<span class="cstat-no" title="statement not covered" >t.y!==i.y?-e:0,</span>o=<span class="cstat-no" title="statement not covered" >(t.x+t.w!==i.x+i.w?e:0)-s,</span>a=<span class="cstat-no" title="statement not covered" >(t.y+t.h!==i.y+i.h?e:0)-n;<span class="cstat-no" title="statement not covered" ></span>return{x:t.x+s,y:t.y+n,w:t.w+o,h:t.h+a,radius:t.radius}}</span>var go=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,ArcElement:class extends $s{static id=<span class="cstat-no" title="statement not covered" >"arc";</span>static defaults=<span class="cstat-no" title="statement not covered" >{borderAlign:"center",borderColor:"#fff",borderDash:[],borderDashOffset:0,borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0,selfJoin:!1};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >{backgroundColor:"backgroundColor"};</span>static descriptors=<span class="cstat-no" title="statement not covered" >{_scriptable:!0,_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"borderDash"!==t}</span>;</span>circumference;endAngle;fullCircles;innerRadius;outerRadius;pixelMargin;startAngle;<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>in</span>Range(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],i),</span>{angle:n,distance:o}=<span class="cstat-no" title="statement not covered" >X(s,{x:t,y:e}),</span>{startAngle:a,endAngle:r,innerRadius:h,outerRadius:c,circumference:d}=<span class="cstat-no" title="statement not covered" >this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],i),</span>u=<span class="cstat-no" title="statement not covered" >(this.options.spacing+this.options.borderWidth)/2,</span>f=<span class="cstat-no" title="statement not covered" >l(d,r-a),</span>g=<span class="cstat-no" title="statement not covered" >J(n,a,r)&amp;&amp;a!==r,</span>p=<span class="cstat-no" title="statement not covered" >f&gt;=O||g,</span>m=<span class="cstat-no" title="statement not covered" >tt(o,h+u,c+u);<span class="cstat-no" title="statement not covered" ></span>return p&amp;&amp;m}<span class="fstat-no" title="function not covered" ></span>ge</span>tCenterPoint(t){const{x:e,y:i,startAngle:s,endAngle:n,innerRadius:o,outerRadius:a}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius"],t),</span>{offset:r,spacing:l}=<span class="cstat-no" title="statement not covered" >this.options,</span>h=<span class="cstat-no" title="statement not covered" >(s+n)/2,</span>c=<span class="cstat-no" title="statement not covered" >(o+a+l+r)/2;<span class="cstat-no" title="statement not covered" ></span>return{x:e+Math.cos(h)*c,y:i+Math.sin(h)*c}}<span class="fstat-no" title="function not covered" ></span>to</span>oltipPosition(t){<span class="cstat-no" title="statement not covered" >return this.getCenterPoint(t)}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){const{options:e,circumference:i}=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >(e.offset||0)/4,</span>n=<span class="cstat-no" title="statement not covered" >(e.spacing||0)/2,</span>o=<span class="cstat-no" title="statement not covered" >e.circular;<span class="cstat-no" title="statement not covered" ></span>if(this.pixelMargin="inner"===e.borderAlign?.33:0,this.fullCircles=i&gt;O?Math.floor(i/O):0,0===i||this.innerRadius&lt;0||this.outerRadius&lt;0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>.save();c</span>onst a=<span class="cstat-no" title="statement not covered" >(this.startAngle+this.endAngle)/2;<span class="cstat-no" title="statement not covered" ></span>t.translate(Math.cos(a)*s,Math.sin(a)*s);c</span>onst r=<span class="cstat-no" title="statement not covered" >s*(1-Math.sin(Math.min(C,i||0)));<span class="cstat-no" title="statement not covered" ></span>t.fillStyle=e.backgroundColor,t.strokeStyle=e.borderColor,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s,n){const{fullCircles:o,startAngle:a,circumference:r}=<span class="cstat-no" title="statement not covered" >e;</span>let l=<span class="cstat-no" title="statement not covered" >e.endAngle;<span class="cstat-no" title="statement not covered" ></span>if(o){<span class="cstat-no" title="statement not covered" >Kn(t,e,i,s,l,n);<span class="cstat-no" title="statement not covered" >f</span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o;++e)<span class="cstat-no" title="statement not covered" >t.fill();<span class="cstat-no" title="statement not covered" >i</span></span>sNaN(r)||(l=a+(r%O||O))}<span class="cstat-no" title="statement not covered" ></span>K</span>n(t,e,i,s,l,n),t.fill()}</span>(t,this,r,n,o),Gn(t,this,r,n,o),t.restore()}</span>},BarElement:class extends $s{static id=<span class="cstat-no" title="statement not covered" >"bar";</span>static defaults=<span class="cstat-no" title="statement not covered" >{borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >{backgroundColor:"backgroundColor",borderColor:"borderColor"};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){const{inflateAmount:e,options:{borderColor:i,backgroundColor:s}}=<span class="cstat-no" title="statement not covered" >this,</span>{inner:n,outer:o}=<span class="cstat-no" title="statement not covered" >ho(this),</span>a=<span class="cstat-no" title="statement not covered" >(r=o.radius).topLeft||r.topRight||r.bottomLeft||r.bottomRight?He:uo;</span>var r;<span class="cstat-no" title="statement not covered" >t.save(),o.w===n.w&amp;&amp;o.h===n.h||(t.beginPath(),a(t,fo(o,e,n)),t.clip(),a(t,fo(n,-e,o)),t.fillStyle=i,t.fill("evenodd")),t.beginPath(),a(t,fo(n,e)),t.fillStyle=s,t.fill(),t.restore()}<span class="fstat-no" title="function not covered" ></span>in</span>Range(t,e,i){<span class="cstat-no" title="statement not covered" >return co(this,t,e,i)}<span class="fstat-no" title="function not covered" ></span>in</span>XRange(t,e){<span class="cstat-no" title="statement not covered" >return co(this,t,null,e)}<span class="fstat-no" title="function not covered" ></span>in</span>YRange(t,e){<span class="cstat-no" title="statement not covered" >return co(this,null,t,e)}<span class="fstat-no" title="function not covered" ></span>ge</span>tCenterPoint(t){const{x:e,y:i,base:s,horizontal:n}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y","base","horizontal"],t);<span class="cstat-no" title="statement not covered" ></span>return{x:n?(e+s)/2:e,y:n?i:(i+s)/2}}<span class="fstat-no" title="function not covered" ></span>ge</span>tRange(t){<span class="cstat-no" title="statement not covered" >return"x"===t?this.width/2:this.height/2}</span>},LineElement:oo,PointElement:class extends $s{static id=<span class="cstat-no" title="statement not covered" >"point";</span>parsed;skip;stop;static defaults=<span class="cstat-no" title="statement not covered" >{borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >{backgroundColor:"backgroundColor",borderColor:"borderColor"};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>in</span>Range(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.options,</span>{x:n,y:o}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],i);<span class="cstat-no" title="statement not covered" ></span>return Math.pow(t-n,2)+Math.pow(e-o,2)&lt;Math.pow(s.hitRadius+s.radius,2)}<span class="fstat-no" title="function not covered" ></span>in</span>XRange(t,e){<span class="cstat-no" title="statement not covered" >return ao(this,t,"x",e)}<span class="fstat-no" title="function not covered" ></span>in</span>YRange(t,e){<span class="cstat-no" title="statement not covered" >return ao(this,t,"y",e)}<span class="fstat-no" title="function not covered" ></span>ge</span>tCenterPoint(t){const{x:e,y:i}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],t);<span class="cstat-no" title="statement not covered" ></span>return{x:e,y:i}}<span class="fstat-no" title="function not covered" ></span>si</span>ze(t){let e=<span class="cstat-no" title="statement not covered" >(t=t||this.options||{}).radius||0;<span class="cstat-no" title="statement not covered" ></span>e=Math.max(e,e&amp;&amp;t.hoverRadius||0);<span class="cstat-no" title="statement not covered" >r</span>eturn 2*(e+(e&amp;&amp;t.borderWidth||0))}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>this.skip||i.radius&lt;.1||!Re(this,e,this.size(i)/2)||(t.strokeStyle=i.borderColor,t.lineWidth=i.borderWidth,t.fillStyle=i.backgroundColor,Le(t,i,this.x,this.y))}<span class="fstat-no" title="function not covered" ></span>ge</span>tRange(){const t=<span class="cstat-no" title="statement not covered" >this.options||{};<span class="cstat-no" title="statement not covered" ></span>return t.radius+t.hitRadius}</span>}});</span>function <span class="fstat-no" title="function not covered" >po(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>if(-1===n)<span class="cstat-no" title="statement not covered" >return(<span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;(<span class="cstat-no" title="statement not covered" >"string"==typeof e?(i=t.push(e)-1,s.unshift({index:i,label:e})):isNaN(e)&amp;&amp;(i=null),i)</span>)(t,e,i,s);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n!==t.lastIndexOf(e)?i:n}</span>function <span class="fstat-no" title="function not covered" >mo(</span>t){const e=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>return t&gt;=0&amp;&amp;t&lt;e.length?e[t]:t}</span>function <span class="fstat-no" title="function not covered" >xo(</span>t,e,{horizontal:i,minRotation:s}){const n=<span class="cstat-no" title="statement not covered" >$(s),</span>o=<span class="cstat-no" title="statement not covered" >(i?Math.sin(n):Math.cos(n))||.001,</span>a=<span class="cstat-no" title="statement not covered" >.75*e*(""+t).length;<span class="cstat-no" title="statement not covered" ></span>return Math.min(e/o,a)}</span>class bo extends tn{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){<span class="cstat-no" title="statement not covered" >return s(t)||("number"==typeof t||t instanceof Number)&amp;&amp;!isFinite(+t)?null:+t}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleTickRangeOptions(){const{beginAtZero:t}=<span class="cstat-no" title="statement not covered" >this.options,</span>{minDefined:e,maxDefined:i}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();</span>let{min:s,max:n}=<span class="cstat-no" title="statement not covered" >this;</span>const o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >s=e?s:t,</span></span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >n=i?n:t;<span class="cstat-no" title="statement not covered" ></span></span>if(t){const t=<span class="cstat-no" title="statement not covered" >F(s),</span>e=<span class="cstat-no" title="statement not covered" >F(n);<span class="cstat-no" title="statement not covered" ></span>t&lt;0&amp;&amp;e&lt;0?a(0):t&gt;0&amp;&amp;e&gt;0&amp;&amp;o(0)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s===n){let e=<span class="cstat-no" title="statement not covered" >0===n?1:Math.abs(.05*n);<span class="cstat-no" title="statement not covered" ></span>a(n+e),t||o(s-e)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.min=s,this.max=n}<span class="fstat-no" title="function not covered" ></span>ge</span>tTickLimit(){const t=<span class="cstat-no" title="statement not covered" >this.options.ticks;</span>let e,{maxTicksLimit:i,stepSize:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return s?(e=Math.ceil(this.max/s)-Math.floor(this.min/s)+1,e&gt;1e3&amp;&amp;(console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${e} ticks. Limiting to 1000.`),e=1e3)):(e=this.computeTickLimit(),i=i||11),i&amp;&amp;(e=Math.min(i,e)),e}<span class="fstat-no" title="function not covered" ></span>co</span>mputeTickLimit(){<span class="cstat-no" title="statement not covered" >return Number.POSITIVE_INFINITY}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.ticks;</span>let i=<span class="cstat-no" title="statement not covered" >this.getTickLimit();<span class="cstat-no" title="statement not covered" ></span>i=Math.max(2,i);c</span>onst n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>{bounds:n,step:o,min:a,max:r,precision:l,count:h,maxTicks:c,maxDigits:d,includeBounds:u}=<span class="cstat-no" title="statement not covered" >t,</span>f=<span class="cstat-no" title="statement not covered" >o||1,</span>g=<span class="cstat-no" title="statement not covered" >c-1,</span>{min:p,max:m}=<span class="cstat-no" title="statement not covered" >e,</span>x=<span class="cstat-no" title="statement not covered" >!s(a),</span>b=<span class="cstat-no" title="statement not covered" >!s(r),</span>_=<span class="cstat-no" title="statement not covered" >!s(h),</span>y=<span class="cstat-no" title="statement not covered" >(m-p)/(d+1);</span>let v,M,w,k,S=<span class="cstat-no" title="statement not covered" >B((m-p)/g/f)*f;<span class="cstat-no" title="statement not covered" ></span>if(S&lt;1e-14&amp;&amp;!x&amp;&amp;!b)<span class="cstat-no" title="statement not covered" >return[{value:p},{value:m}];<span class="cstat-no" title="statement not covered" >k</span></span>=Math.ceil(m/S)-Math.floor(p/S),k&gt;g&amp;&amp;(S=B(k*S/g/f)*f),s(l)||(v=Math.pow(10,l),S=Math.ceil(S*v)/v),"ticks"===n?(M=Math.floor(p/S)*S,w=Math.ceil(m/S)*S):(M=p,w=m),x&amp;&amp;b&amp;&amp;o&amp;&amp;H((r-a)/o,S/1e3)?(k=Math.round(Math.min((r-a)/S,c)),S=(r-a)/k,M=a,w=r):_?(M=x?a:M,w=b?r:w,k=h-1,S=(w-M)/k):(k=(w-M)/S,k=V(k,Math.round(k),S/1e3)?Math.round(k):Math.ceil(k));c</span>onst P=<span class="cstat-no" title="statement not covered" >Math.max(U(S),U(M));<span class="cstat-no" title="statement not covered" ></span>v=Math.pow(10,s(l)?P:l),M=Math.round(M*v)/v,w=Math.round(w*v)/v;l</span>et D=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(x&amp;&amp;(u&amp;&amp;M!==a?(i.push({value:a}),M&lt;a&amp;&amp;D++,V(Math.round((M+D*S)*v)/v,a,xo(a,y,t))&amp;&amp;D++):M&lt;a&amp;&amp;D++);D&lt;k;++D){const t=<span class="cstat-no" title="statement not covered" >Math.round((M+D*S)*v)/v;<span class="cstat-no" title="statement not covered" ></span>if(b&amp;&amp;t&gt;r)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>.push({value:t})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn b&amp;&amp;u&amp;&amp;w!==r?i.length&amp;&amp;V(i[i.length-1].value,r,xo(r,y,t))?i[i.length-1].value=r:i.push({value:r}):b&amp;&amp;w!==r||i.push({value:w}),i}</span>({maxTicks:i,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:!1!==e.includeBounds},this._range||this);<span class="cstat-no" title="statement not covered" ></span>return"ticks"===t.bounds&amp;&amp;j(n,this,"value"),t.reverse?(n.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),n}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){const t=<span class="cstat-no" title="statement not covered" >this.ticks;</span>let e=<span class="cstat-no" title="statement not covered" >this.min,</span>i=<span class="cstat-no" title="statement not covered" >this.max;<span class="cstat-no" title="statement not covered" ></span>if(super.configure(),this.options.offset&amp;&amp;t.length){const s=<span class="cstat-no" title="statement not covered" >(i-e)/Math.max(t.length-1,1)/2;<span class="cstat-no" title="statement not covered" ></span>e-=s,i+=s}<span class="cstat-no" title="statement not covered" ></span>t</span>his._startValue=e,this._endValue=i,this._valueRange=i-e}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){<span class="cstat-no" title="statement not covered" >return ne(t,this.chart.options.locale,this.options.ticks.format)}</span>}class _o extends bo{static id=<span class="cstat-no" title="statement not covered" >"linear";</span>static defaults=<span class="cstat-no" title="statement not covered" >{ticks:{callback:ae.formatters.numeric}};<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){const{min:t,max:e}=<span class="cstat-no" title="statement not covered" >this.getMinMax(!0);<span class="cstat-no" title="statement not covered" ></span>this.min=a(t)?t:0,this.max=a(e)?e:1,this.handleTickRangeOptions()}<span class="fstat-no" title="function not covered" ></span>co</span>mputeTickLimit(){const t=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>e=<span class="cstat-no" title="statement not covered" >t?this.width:this.height,</span>i=<span class="cstat-no" title="statement not covered" >$(this.options.ticks.minRotation),</span>s=<span class="cstat-no" title="statement not covered" >(t?Math.sin(i):Math.cos(i))||.001,</span>n=<span class="cstat-no" title="statement not covered" >this._resolveTickFontOptions(0);<span class="cstat-no" title="statement not covered" ></span>return Math.ceil(e/Math.min(40,n.lineHeight/s))}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t){<span class="cstat-no" title="statement not covered" >return null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){<span class="cstat-no" title="statement not covered" >return this._startValue+this.getDecimalForPixel(t)*this._valueRange}</span>}const yo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.floor(z(t)),</span></span>vo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.pow(10,yo(t)+e);</span></span>function <span class="fstat-no" title="function not covered" >Mo(</span>t){<span class="cstat-no" title="statement not covered" >return 1===t/Math.pow(10,yo(t))}</span>function <span class="fstat-no" title="function not covered" >wo(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >Math.pow(10,i),</span>n=<span class="cstat-no" title="statement not covered" >Math.floor(t/s);<span class="cstat-no" title="statement not covered" ></span>return Math.ceil(e/s)-n}</span>function <span class="fstat-no" title="function not covered" >ko(</span>t,{min:e,max:i}){<span class="cstat-no" title="statement not covered" >e=r(t.min,e);c</span>onst s=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >yo(e);</span>let o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i=<span class="cstat-no" title="statement not covered" >yo(e-t);<span class="cstat-no" title="statement not covered" ></span>for(;wo(t,e,i)&gt;10;)<span class="cstat-no" title="statement not covered" >i++;<span class="cstat-no" title="statement not covered" >f</span></span>or(;wo(t,e,i)&lt;10;)<span class="cstat-no" title="statement not covered" >i--;<span class="cstat-no" title="statement not covered" >r</span></span>eturn Math.min(i,yo(t))}</span>(e,i),</span>a=<span class="cstat-no" title="statement not covered" >o&lt;0?Math.pow(10,Math.abs(o)):1;</span>const l=<span class="cstat-no" title="statement not covered" >Math.pow(10,o),</span>h=<span class="cstat-no" title="statement not covered" >n&gt;o?Math.pow(10,n):0,</span>c=<span class="cstat-no" title="statement not covered" >Math.round((e-h)*a)/a,</span>d=<span class="cstat-no" title="statement not covered" >Math.floor((e-h)/l/10)*l*10;</span>let u=<span class="cstat-no" title="statement not covered" >Math.floor((c-d)/Math.pow(10,o)),</span>f=<span class="cstat-no" title="statement not covered" >r(t.min,Math.round((h+d+u*Math.pow(10,o))*a)/a);<span class="cstat-no" title="statement not covered" ></span>for(;f&lt;i;)<span class="cstat-no" title="statement not covered" >s.push({value:f,major:Mo(f),significand:u}),u&gt;=10?u=u&lt;15?15:20:u++,u&gt;=20&amp;&amp;(o++,u=2,a=o&gt;=0?1:a),f=Math.round((h+d+u*Math.pow(10,o))*a)/a;c</span></span>onst g=<span class="cstat-no" title="statement not covered" >r(t.max,f);<span class="cstat-no" title="statement not covered" ></span>return s.push({value:g,major:Mo(g),significand:u}),s}</span>class So extends tn{static id=<span class="cstat-no" title="statement not covered" >"logarithmic";</span>static defaults=<span class="cstat-no" title="statement not covered" >{ticks:{callback:ae.formatters.logarithmic,major:{enabled:!0}}};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){const i=<span class="cstat-no" title="statement not covered" >bo.prototype.parse.apply(this,[t,e]);<span class="cstat-no" title="statement not covered" ></span>if(0!==i)<span class="cstat-no" title="statement not covered" >return a(i)&amp;&amp;i&gt;0?i:null;<span class="cstat-no" title="statement not covered" >t</span></span>his._zero=!0}<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){const{min:t,max:e}=<span class="cstat-no" title="statement not covered" >this.getMinMax(!0);<span class="cstat-no" title="statement not covered" ></span>this.min=a(t)?Math.max(0,t):null,this.max=a(e)?Math.max(0,e):null,this.options.beginAtZero&amp;&amp;(this._zero=!0),this._zero&amp;&amp;this.min!==this._suggestedMin&amp;&amp;!a(this._userMin)&amp;&amp;(this.min=t===vo(this.min,0)?vo(this.min,-1):vo(this.min,0)),this.handleTickRangeOptions()}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleTickRangeOptions(){const{minDefined:t,maxDefined:e}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();</span>let i=<span class="cstat-no" title="statement not covered" >this.min,</span>s=<span class="cstat-no" title="statement not covered" >this.max;</span>const n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >i=t?i:e,</span></span>o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >s=e?s:t;<span class="cstat-no" title="statement not covered" ></span></span>i===s&amp;&amp;(i&lt;=0?(n(1),o(10)):(n(vo(i,-1)),o(vo(s,1)))),i&lt;=0&amp;&amp;n(vo(s,-1)),s&lt;=0&amp;&amp;o(vo(i,1)),this.min=i,this.max=s}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >ko({min:this._userMin,max:this._userMax},this);<span class="cstat-no" title="statement not covered" ></span>return"ticks"===t.bounds&amp;&amp;j(e,this,"value"),t.reverse?(e.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),e}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){<span class="cstat-no" title="statement not covered" >return void 0===t?"0":ne(t,this.chart.options.locale,this.options.ticks.format)}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){const t=<span class="cstat-no" title="statement not covered" >this.min;<span class="cstat-no" title="statement not covered" ></span>super.configure(),this._startValue=z(t),this._valueRange=z(this.max)-z(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t){<span class="cstat-no" title="statement not covered" >return void 0!==t&amp;&amp;0!==t||(t=this.min),null===t||isNaN(t)?NaN:this.getPixelForDecimal(t===this.min?0:(z(t)-this._startValue)/this._valueRange)}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){const e=<span class="cstat-no" title="statement not covered" >this.getDecimalForPixel(t);<span class="cstat-no" title="statement not covered" ></span>return Math.pow(10,this._startValue+e*this._valueRange)}</span>}function <span class="fstat-no" title="function not covered" >Po(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.ticks;<span class="cstat-no" title="statement not covered" ></span>if(e.display&amp;&amp;t.display){const t=<span class="cstat-no" title="statement not covered" >ki(e.backdropPadding);<span class="cstat-no" title="statement not covered" ></span>return l(e.font&amp;&amp;e.font.size,ue.font.size)+t.height}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn 0}</span>function <span class="fstat-no" title="function not covered" >Do(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >return t===s||t===n?{start:e-i/2,end:e+i/2}:t&lt;s||t&gt;n?{start:e-i,end:e}:{start:e,end:e+i}}</span>function <span class="fstat-no" title="function not covered" >Co(</span>t){const e=<span class="cstat-no" title="statement not covered" >{l:t.left+t._padding.left,r:t.right-t._padding.right,t:t.top+t._padding.top,b:t.bottom-t._padding.bottom},</span>i=<span class="cstat-no" title="statement not covered" >Object.assign({},e),</span>s=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >t._pointLabels.length,</span>r=<span class="cstat-no" title="statement not covered" >t.options.pointLabels,</span>l=<span class="cstat-no" title="statement not covered" >r.centerPointLabels?C/a:0;<span class="cstat-no" title="statement not covered" ></span>for(let u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;a;u++){const a=<span class="cstat-no" title="statement not covered" >r.setContext(t.getPointLabelContext(u));<span class="cstat-no" title="statement not covered" ></span>o[u]=a.padding;c</span>onst f=<span class="cstat-no" title="statement not covered" >t.getPointPosition(u,t.drawingArea+o[u],l),</span>g=<span class="cstat-no" title="statement not covered" >Si(a.font),</span>p=(<span class="cstat-no" title="statement not covered" >h=t.ctx,c=g,d=n(d=t._pointLabels[u])?d:[d],{w:Oe(h,c.string,d),h:d.length*c.lineHeight})</span>;<span class="cstat-no" title="statement not covered" >s[u]=p;c</span>onst m=<span class="cstat-no" title="statement not covered" >G(t.getIndexAngle(u)+l),</span>x=<span class="cstat-no" title="statement not covered" >Math.round(Y(m));<span class="cstat-no" title="statement not covered" ></span>Oo(i,e,m,Do(x,f.x,p.w,0,180),Do(x,f.y,p.h,90,270))}</span>v</span>ar h,c,d;<span class="cstat-no" title="statement not covered" >t.setCenterPoint(e.l-i.l,i.r-e.r,e.t-i.t,i.b-e.b),t._pointLabelItems=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >t._pointLabels.length,</span>o=<span class="cstat-no" title="statement not covered" >t.options,</span>{centerPointLabels:a,display:r}=<span class="cstat-no" title="statement not covered" >o.pointLabels,</span>l=<span class="cstat-no" title="statement not covered" >{extra:Po(o)/2,additionalAngle:a?C/n:0};</span>let h;<span class="cstat-no" title="statement not covered" >for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;n;o++){<span class="cstat-no" title="statement not covered" >l.padding=i[o],l.size=e[o];c</span>onst n=<span class="cstat-no" title="statement not covered" >Ao(t,o,l);<span class="cstat-no" title="statement not covered" ></span>s.push(n),"auto"===r&amp;&amp;(n.visible=To(n,h),n.visible&amp;&amp;(h=n))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>(t,s,o)}</span>function <span class="fstat-no" title="function not covered" >Oo(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >Math.abs(Math.sin(i)),</span>a=<span class="cstat-no" title="statement not covered" >Math.abs(Math.cos(i));</span>let r=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>s.start&lt;e.l?(r=(e.l-s.start)/o,t.l=Math.min(t.l,e.l-r)):s.end&gt;e.r&amp;&amp;(r=(s.end-e.r)/o,t.r=Math.max(t.r,e.r+r)),n.start&lt;e.t?(l=(e.t-n.start)/a,t.t=Math.min(t.t,e.t-l)):n.end&gt;e.b&amp;&amp;(l=(n.end-e.b)/a,t.b=Math.max(t.b,e.b+l))}</span>function <span class="fstat-no" title="function not covered" >Ao(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.drawingArea,</span>{extra:n,additionalAngle:o,padding:a,size:r}=<span class="cstat-no" title="statement not covered" >i,</span>l=<span class="cstat-no" title="statement not covered" >t.getPointPosition(e,s+n+a,o),</span>h=<span class="cstat-no" title="statement not covered" >Math.round(Y(G(l.angle+E))),</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >90===i||270===i?t-=e/2:(i&gt;270||i&lt;90)&amp;&amp;(t-=e);<span class="cstat-no" title="statement not covered" >r</span>eturn t}</span>(l.y,r.h,h),</span>d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(0===t||180===t)<span class="cstat-no" title="statement not covered" >return"center";<span class="cstat-no" title="statement not covered" >i</span></span>f(t&lt;180)<span class="cstat-no" title="statement not covered" >return"left";<span class="cstat-no" title="statement not covered" >r</span></span>eturn"right"}</span>(h),</span>u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >"right"===i?t-=e:"center"===i&amp;&amp;(t-=e/2);<span class="cstat-no" title="statement not covered" >r</span>eturn t}</span>(l.x,r.w,d);<span class="cstat-no" title="statement not covered" ></span>return{visible:!0,x:l.x,y:c,textAlign:d,left:u,top:c,right:u+r.w,bottom:c+r.h}}</span>function <span class="fstat-no" title="function not covered" >To(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst{left:i,top:s,right:n,bottom:o}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return!(Re({x:i,y:s},e)||Re({x:i,y:o},e)||Re({x:n,y:s},e)||Re({x:n,y:o},e))}</span>function <span class="fstat-no" title="function not covered" >Lo(</span>t,e,i){const{left:n,top:o,right:a,bottom:r}=<span class="cstat-no" title="statement not covered" >i,</span>{backdropColor:l}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>if(!s(l)){const i=<span class="cstat-no" title="statement not covered" >wi(e.borderRadius),</span>s=<span class="cstat-no" title="statement not covered" >ki(e.backdropPadding);<span class="cstat-no" title="statement not covered" ></span>t.fillStyle=l;c</span>onst h=<span class="cstat-no" title="statement not covered" >n-s.left,</span>c=<span class="cstat-no" title="statement not covered" >o-s.top,</span>d=<span class="cstat-no" title="statement not covered" >a-n+s.width,</span>u=<span class="cstat-no" title="statement not covered" >r-o+s.height;<span class="cstat-no" title="statement not covered" ></span>Object.values(i).some((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0!==t)</span>)?(t.beginPath(),He(t,{x:h,y:c,w:d,h:u,radius:i}),t.fill()):t.fillRect(h,c,d,u)}</span>}</span>function <span class="fstat-no" title="function not covered" >Eo(</span>t,e,i,s){const{ctx:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >n.arc(t.xCenter,t.yCenter,e,0,O);e</span>lse{let i=<span class="cstat-no" title="statement not covered" >t.getPointPosition(0,e);<span class="cstat-no" title="statement not covered" ></span>n.moveTo(i.x,i.y);<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >1;</span>o&lt;s;o++)<span class="cstat-no" title="statement not covered" >i=t.getPointPosition(o,e),n.lineTo(i.x,i.y)}</span></span>}</span>class Ro extends bo{static id=<span class="cstat-no" title="statement not covered" >"radialLinear";</span>static defaults=<span class="cstat-no" title="statement not covered" >{display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:ae.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t,</span>padding:5,centerPointLabels:!1}};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >{"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"};</span>static descriptors=<span class="cstat-no" title="statement not covered" >{angleLines:{_fallback:"grid"}};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}<span class="fstat-no" title="function not covered" ></span>se</span>tDimensions(){const t=<span class="cstat-no" title="statement not covered" >this._padding=ki(Po(this.options)/2),</span>e=<span class="cstat-no" title="statement not covered" >this.width=this.maxWidth-t.width,</span>i=<span class="cstat-no" title="statement not covered" >this.height=this.maxHeight-t.height;<span class="cstat-no" title="statement not covered" ></span>this.xCenter=Math.floor(this.left+e/2+t.left),this.yCenter=Math.floor(this.top+i/2+t.top),this.drawingArea=Math.floor(Math.min(e,i)/2)}<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){const{min:t,max:e}=<span class="cstat-no" title="statement not covered" >this.getMinMax(!1);<span class="cstat-no" title="statement not covered" ></span>this.min=a(t)&amp;&amp;!isNaN(t)?t:0,this.max=a(e)&amp;&amp;!isNaN(e)?e:0,this.handleTickRangeOptions()}<span class="fstat-no" title="function not covered" ></span>co</span>mputeTickLimit(){<span class="cstat-no" title="statement not covered" >return Math.ceil(this.drawingArea/Po(this.options))}<span class="fstat-no" title="function not covered" ></span>ge</span>nerateTickLabels(t){<span class="cstat-no" title="statement not covered" >bo.prototype.generateTickLabels.call(this,t),this._pointLabels=this.getLabels().map((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const i=<span class="cstat-no" title="statement not covered" >d(this.options.pointLabels.callback,[t,e],this);<span class="cstat-no" title="statement not covered" ></span>return i||0===i?i:""}</span>)).filter((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >this.chart.getDataVisibility(e))</span>)}<span class="fstat-no" title="function not covered" ></span>fi</span>t(){const t=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>t.display&amp;&amp;t.pointLabels.display?Co(this):this.setCenterPoint(0,0,0,0)}<span class="fstat-no" title="function not covered" ></span>se</span>tCenterPoint(t,e,i,s){<span class="cstat-no" title="statement not covered" >this.xCenter+=Math.floor((t-e)/2),this.yCenter+=Math.floor((i-s)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(t,e,i,s))}<span class="fstat-no" title="function not covered" ></span>ge</span>tIndexAngle(t){<span class="cstat-no" title="statement not covered" >return G(t*(O/(this._pointLabels.length||1))+$(this.options.startAngle||0))}<span class="fstat-no" title="function not covered" ></span>ge</span>tDistanceFromCenterForValue(t){<span class="cstat-no" title="statement not covered" >if(s(t))<span class="cstat-no" title="statement not covered" >return NaN;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.drawingArea/(this.max-this.min);<span class="cstat-no" title="statement not covered" ></span>return this.options.reverse?(this.max-t)*e:(t-this.min)*e}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForDistanceFromCenter(t){<span class="cstat-no" title="statement not covered" >if(s(t))<span class="cstat-no" title="statement not covered" >return NaN;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t/(this.drawingArea/(this.max-this.min));<span class="cstat-no" title="statement not covered" ></span>return this.options.reverse?this.max-e:this.min+e}<span class="fstat-no" title="function not covered" ></span>ge</span>tPointLabelContext(t){const e=<span class="cstat-no" title="statement not covered" >this._pointLabels||[];<span class="cstat-no" title="statement not covered" ></span>if(t&gt;=0&amp;&amp;t&lt;e.length){const i=<span class="cstat-no" title="statement not covered" >e[t];<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return Ci(t,{label:i,index:e,type:"pointLabel"})}</span>(this.getContext(),t,i)}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tPointPosition(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{const s=<span class="cstat-no" title="statement not covered" >this.getIndexAngle(t)-E+i;<span class="cstat-no" title="statement not covered" ></span>return{x:Math.cos(s)*e+this.xCenter,y:Math.sin(s)*e+this.yCenter,angle:s}}<span class="fstat-no" title="function not covered" ></span>ge</span>tPointPositionForValue(t,e){<span class="cstat-no" title="statement not covered" >return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))}<span class="fstat-no" title="function not covered" ></span>ge</span>tBasePosition(t){<span class="cstat-no" title="statement not covered" >return this.getPointPositionForValue(t||0,this.getBaseValue())}<span class="fstat-no" title="function not covered" ></span>ge</span>tPointLabelPosition(t){const{left:e,top:i,right:s,bottom:n}=<span class="cstat-no" title="statement not covered" >this._pointLabelItems[t];<span class="cstat-no" title="statement not covered" ></span>return{left:e,top:i,right:s,bottom:n}}<span class="fstat-no" title="function not covered" ></span>dr</span>awBackground(){const{backgroundColor:t,grid:{circular:e}}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(t){const i=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>i.save(),i.beginPath(),Eo(this,this.getDistanceFromCenterForValue(this._endValue),e,this._pointLabels.length),i.closePath(),i.fillStyle=t,i.fill(),i.restore()}</span>}<span class="fstat-no" title="function not covered" ></span>dr</span>awGrid(){const t=<span class="cstat-no" title="statement not covered" >this.ctx,</span>e=<span class="cstat-no" title="statement not covered" >this.options,</span>{angleLines:i,grid:s,border:n}=<span class="cstat-no" title="statement not covered" >e,</span>o=<span class="cstat-no" title="statement not covered" >this._pointLabels.length;</span>let a,r,l;<span class="cstat-no" title="statement not covered" >if(e.pointLabels.display&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{ctx:i,options:{pointLabels:s}}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >e-1;</span>n&gt;=0;n--){const e=<span class="cstat-no" title="statement not covered" >t._pointLabelItems[n];<span class="cstat-no" title="statement not covered" ></span>if(!e.visible)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >s.setContext(t.getPointLabelContext(n));<span class="cstat-no" title="statement not covered" ></span>Lo(i,o,e);c</span>onst a=<span class="cstat-no" title="statement not covered" >Si(o.font),</span>{x:r,y:l,textAlign:h}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>Ne(i,t._pointLabels[n],r,l+a.lineHeight/2,a,{color:o.color,textAlign:h,textBaseline:"middle"})}</span>}</span>(this,o),s.display&amp;&amp;this.ticks.forEach((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >if(0!==e||0===e&amp;&amp;this.min&lt;0){<span class="cstat-no" title="statement not covered" >r=this.getDistanceFromCenterForValue(t.value);c</span>onst i=<span class="cstat-no" title="statement not covered" >this.getContext(e),</span>a=<span class="cstat-no" title="statement not covered" >s.setContext(i),</span>l=<span class="cstat-no" title="statement not covered" >n.setContext(i);<span class="cstat-no" title="statement not covered" ></span>!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >t.ctx,</span>a=<span class="cstat-no" title="statement not covered" >e.circular,</span>{color:r,lineWidth:l}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>!a&amp;&amp;!s||!r||!l||i&lt;0||(o.save(),o.strokeStyle=r,o.lineWidth=l,o.setLineDash(n.dash||[]),o.lineDashOffset=n.dashOffset,o.beginPath(),Eo(t,i,a,s),o.closePath(),o.stroke(),o.restore())}</span>(this,a,r,o,l)}</span>}</span>)),i.display){<span class="cstat-no" title="statement not covered" >for(t.save(),a=o-1;a&gt;=0;a--){const s=<span class="cstat-no" title="statement not covered" >i.setContext(this.getPointLabelContext(a)),</span>{color:n,lineWidth:o}=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;n&amp;&amp;(t.lineWidth=o,t.strokeStyle=n,t.setLineDash(s.borderDash),t.lineDashOffset=s.borderDashOffset,r=this.getDistanceFromCenterForValue(e.reverse?this.min:this.max),l=this.getPointPosition(a,r),t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(l.x,l.y),t.stroke())}<span class="cstat-no" title="statement not covered" ></span>t</span>.restore()}</span>}<span class="fstat-no" title="function not covered" ></span>dr</span>awBorder(){}<span class="fstat-no" title="function not covered" >dr</span>awLabels(){const t=<span class="cstat-no" title="statement not covered" >this.ctx,</span>e=<span class="cstat-no" title="statement not covered" >this.options,</span>i=<span class="cstat-no" title="statement not covered" >e.ticks;<span class="cstat-no" title="statement not covered" ></span>if(!i.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.getIndexAngle(0);</span>let n,o;<span class="cstat-no" title="statement not covered" >t.save(),t.translate(this.xCenter,this.yCenter),t.rotate(s),t.textAlign="center",t.textBaseline="middle",this.ticks.forEach((<span class="fstat-no" title="function not covered" >(s</span>,a)=&gt;{<span class="cstat-no" title="statement not covered" >if(0===a&amp;&amp;this.min&gt;=0&amp;&amp;!e.reverse)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >i.setContext(this.getContext(a)),</span>l=<span class="cstat-no" title="statement not covered" >Si(r.font);<span class="cstat-no" title="statement not covered" ></span>if(n=this.getDistanceFromCenterForValue(this.ticks[a].value),r.showLabelBackdrop){<span class="cstat-no" title="statement not covered" >t.font=l.string,o=t.measureText(s.label).width,t.fillStyle=r.backdropColor;c</span>onst e=<span class="cstat-no" title="statement not covered" >ki(r.backdropPadding);<span class="cstat-no" title="statement not covered" ></span>t.fillRect(-o/2-e.left,-n-l.size/2-e.top,o+e.width,l.size+e.height)}<span class="cstat-no" title="statement not covered" ></span>N</span>e(t,s.label,0,-n,l,{color:r.color,strokeColor:r.textStrokeColor,strokeWidth:r.textStrokeWidth})}</span>)),t.restore()}<span class="fstat-no" title="function not covered" ></span>dr</span>awTitle(){}}const Io=<span class="cstat-no" title="statement not covered" >{millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},</span>zo=<span class="cstat-no" title="statement not covered" >Object.keys(Io);</span>function <span class="fstat-no" title="function not covered" >Fo(</span>t,e){<span class="cstat-no" title="statement not covered" >return t-e}</span>function <span class="fstat-no" title="function not covered" >Vo(</span>t,e){<span class="cstat-no" title="statement not covered" >if(s(e))<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >t._adapter,</span>{parser:n,round:o,isoWeekday:r}=<span class="cstat-no" title="statement not covered" >t._parseOpts;</span>let l=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return"function"==typeof n&amp;&amp;(l=n(l)),a(l)||(l="string"==typeof n?i.parse(l,n):i.parse(l)),null===l?null:(o&amp;&amp;(l="week"!==o||!N(r)&amp;&amp;!0!==r?i.startOf(l,o):i.startOf(l,"isoWeek",r)),+l)}</span>function <span class="fstat-no" title="function not covered" >Bo(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >zo.length;<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >zo.indexOf(t);</span>o&lt;n-1;++o){const t=<span class="cstat-no" title="statement not covered" >Io[zo[o]],</span>n=<span class="cstat-no" title="statement not covered" >t.steps?t.steps:Number.MAX_SAFE_INTEGER;<span class="cstat-no" title="statement not covered" ></span>if(t.common&amp;&amp;Math.ceil((i-e)/(n*t.size))&lt;=s)<span class="cstat-no" title="statement not covered" >return zo[o]}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn zo[n-1]}</span>function <span class="fstat-no" title="function not covered" >Wo(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(i){<span class="cstat-no" title="statement not covered" >if(i.length){const{lo:s,hi:n}=<span class="cstat-no" title="statement not covered" >et(i,e);<span class="cstat-no" title="statement not covered" ></span>t[i[s]&gt;=e?i[s]:i[n]]=!0}</span>}</span>else <span class="cstat-no" title="statement not covered" >t[e]=!0}</span></span>function <span class="fstat-no" title="function not covered" >No(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >{},</span>o=<span class="cstat-no" title="statement not covered" >e.length;</span>let a,r;<span class="cstat-no" title="statement not covered" >for(a=0;a&lt;o;++a)<span class="cstat-no" title="statement not covered" >r=e[a],n[r]=a,s.push({value:r,major:!1});<span class="cstat-no" title="statement not covered" >r</span></span>eturn 0!==o&amp;&amp;i?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t._adapter,</span>o=<span class="cstat-no" title="statement not covered" >+n.startOf(e[0].value,s),</span>a=<span class="cstat-no" title="statement not covered" >e[e.length-1].value;</span>let r,l;<span class="cstat-no" title="statement not covered" >for(r=o;r&lt;=a;r=+n.add(r,1,s))<span class="cstat-no" title="statement not covered" >l=i[r],l&gt;=0&amp;&amp;(e[l].major=!0);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>(t,s,n,i):s}</span>class Ho extends tn{static id=<span class="cstat-no" title="statement not covered" >"time";</span>static defaults=<span class="cstat-no" title="statement not covered" >{bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",callback:!1,major:{enabled:!1}}};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}<span class="fstat-no" title="function not covered" ></span>in</span>it(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const i=<span class="cstat-no" title="statement not covered" >t.time||(t.time={}),</span>s=<span class="cstat-no" title="statement not covered" >this._adapter=new In._date(t.adapters.date);<span class="cstat-no" title="statement not covered" ></span>s.init(e),b(i.displayFormats,s.formats()),this._parseOpts={parser:i.parser,round:i.round,isoWeekday:i.isoWeekday},super.init(t),this._normalized=e.normalized}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){<span class="cstat-no" title="statement not covered" >return void 0===t?null:Vo(this,t)}<span class="fstat-no" title="function not covered" ></span>be</span>foreLayout(){<span class="cstat-no" title="statement not covered" >super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >this._adapter,</span>i=<span class="cstat-no" title="statement not covered" >t.time.unit||"day";</span>let{min:s,max:n,minDefined:o,maxDefined:r}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();</span>function <span class="fstat-no" title="function not covered" >l(</span>t){<span class="cstat-no" title="statement not covered" >o||isNaN(t.min)||(s=Math.min(s,t.min)),r||isNaN(t.max)||(n=Math.max(n,t.max))}<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;r||(l(this._getLabelBounds()),"ticks"===t.bounds&amp;&amp;"labels"===t.ticks.source||l(this.getMinMax(!1))),s=a(s)&amp;&amp;!isNaN(s)?s:+e.startOf(Date.now(),i),n=a(n)&amp;&amp;!isNaN(n)?n:+e.endOf(Date.now(),i)+1,this.min=Math.min(s,n-1),this.max=Math.max(s+1,n)}<span class="fstat-no" title="function not covered" ></span>_g</span>etLabelBounds(){const t=<span class="cstat-no" title="statement not covered" >this.getLabelTimestamps();</span>let e=<span class="cstat-no" title="statement not covered" >Number.POSITIVE_INFINITY,</span>i=<span class="cstat-no" title="statement not covered" >Number.NEGATIVE_INFINITY;<span class="cstat-no" title="statement not covered" ></span>return t.length&amp;&amp;(e=t[0],i=t[t.length-1]),{min:e,max:i}}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.time,</span>i=<span class="cstat-no" title="statement not covered" >t.ticks,</span>s=<span class="cstat-no" title="statement not covered" >"labels"===i.source?this.getLabelTimestamps():this._generate();<span class="cstat-no" title="statement not covered" ></span>"ticks"===t.bounds&amp;&amp;s.length&amp;&amp;(this.min=this._userMin||s[0],this.max=this._userMax||s[s.length-1]);c</span>onst n=<span class="cstat-no" title="statement not covered" >this.min,</span>o=<span class="cstat-no" title="statement not covered" >nt(s,n,this.max);<span class="cstat-no" title="statement not covered" ></span>return this._unit=e.unit||(i.autoSkip?Bo(e.minUnit,this.min,this.max,this._getLabelCapacity(n)):<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s,n){<span class="cstat-no" title="statement not covered" >for(let o=<span class="cstat-no" title="statement not covered" >zo.length-1;</span>o&gt;=zo.indexOf(i);o--){const i=<span class="cstat-no" title="statement not covered" >zo[o];<span class="cstat-no" title="statement not covered" ></span>if(Io[i].common&amp;&amp;t._adapter.diff(n,s,i)&gt;=e-1)<span class="cstat-no" title="statement not covered" >return i}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn zo[i?zo.indexOf(i):0]}</span>(this,o.length,e.minUnit,this.min,this.max)),this._majorUnit=i.major.enabled&amp;&amp;"year"!==this._unit?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >zo.indexOf(t)+1,</span>i=<span class="cstat-no" title="statement not covered" >zo.length;</span>e&lt;i;++e)<span class="cstat-no" title="statement not covered" >if(Io[zo[e]].common)<span class="cstat-no" title="statement not covered" >return zo[e]}</span></span></span>(this._unit):void 0,this.initOffsets(s),t.reverse&amp;&amp;o.reverse(),No(this,o,this._majorUnit)}<span class="fstat-no" title="function not covered" ></span>af</span>terAutoSkip(){<span class="cstat-no" title="statement not covered" >this.options.offsetAfterAutoskip&amp;&amp;this.initOffsets(this.ticks.map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >+t.value)</span>))}<span class="fstat-no" title="function not covered" ></span>in</span>itOffsets(t=<span class="branch-0 cbranch-no" title="branch not covered" >[])</span>{let e,i,s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>this.options.offset&amp;&amp;t.length&amp;&amp;(e=this.getDecimalForValue(t[0]),s=1===t.length?1-e:(this.getDecimalForValue(t[1])-e)/2,i=this.getDecimalForValue(t[t.length-1]),n=1===t.length?i:(i-this.getDecimalForValue(t[t.length-2]))/2);c</span>onst o=<span class="cstat-no" title="statement not covered" >t.length&lt;3?.5:.25;<span class="cstat-no" title="statement not covered" ></span>s=Z(s,0,o),n=Z(n,0,o),this._offsets={start:s,end:n,factor:1/(s+1+n)}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerate(){const t=<span class="cstat-no" title="statement not covered" >this._adapter,</span>e=<span class="cstat-no" title="statement not covered" >this.min,</span>i=<span class="cstat-no" title="statement not covered" >this.max,</span>s=<span class="cstat-no" title="statement not covered" >this.options,</span>n=<span class="cstat-no" title="statement not covered" >s.time,</span>o=<span class="cstat-no" title="statement not covered" >n.unit||Bo(n.minUnit,e,i,this._getLabelCapacity(e)),</span>a=<span class="cstat-no" title="statement not covered" >l(s.ticks.stepSize,1),</span>r=<span class="cstat-no" title="statement not covered" >"week"===o&amp;&amp;n.isoWeekday,</span>h=<span class="cstat-no" title="statement not covered" >N(r)||!0===r,</span>c=<span class="cstat-no" title="statement not covered" >{};</span>let d,u,f=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>if(h&amp;&amp;(f=+t.startOf(f,"isoWeek",r)),f=+t.startOf(f,h?"day":o),t.diff(i,e,o)&gt;1e5*a)<span class="cstat-no" title="statement not covered" >throw new Error(e+" and "+i+" are too far apart with stepSize of "+a+" "+o);c</span></span>onst g=<span class="cstat-no" title="statement not covered" >"data"===s.ticks.source&amp;&amp;this.getDataTimestamps();<span class="cstat-no" title="statement not covered" ></span>for(d=f,u=0;d&lt;i;d=+t.add(d,a,o),u++)<span class="cstat-no" title="statement not covered" >Wo(c,d,g);<span class="cstat-no" title="statement not covered" >r</span></span>eturn d!==i&amp;&amp;"ticks"!==s.bounds&amp;&amp;1!==u||Wo(c,d,g),Object.keys(c).sort(Fo).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >+t)</span>)}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){const e=<span class="cstat-no" title="statement not covered" >this._adapter,</span>i=<span class="cstat-no" title="statement not covered" >this.options.time;<span class="cstat-no" title="statement not covered" ></span>return i.tooltipFormat?e.format(t,i.tooltipFormat):e.format(t,i.displayFormats.datetime)}<span class="fstat-no" title="function not covered" ></span>fo</span>rmat(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options.time.displayFormats,</span>s=<span class="cstat-no" title="statement not covered" >this._unit,</span>n=<span class="cstat-no" title="statement not covered" >e||i[s];<span class="cstat-no" title="statement not covered" ></span>return this._adapter.format(t,n)}<span class="fstat-no" title="function not covered" ></span>_t</span>ickFormatFunction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.options,</span>o=<span class="cstat-no" title="statement not covered" >n.ticks.callback;<span class="cstat-no" title="statement not covered" ></span>if(o)<span class="cstat-no" title="statement not covered" >return d(o,[t,e,i],this);c</span></span>onst a=<span class="cstat-no" title="statement not covered" >n.time.displayFormats,</span>r=<span class="cstat-no" title="statement not covered" >this._unit,</span>l=<span class="cstat-no" title="statement not covered" >this._majorUnit,</span>h=<span class="cstat-no" title="statement not covered" >r&amp;&amp;a[r],</span>c=<span class="cstat-no" title="statement not covered" >l&amp;&amp;a[l],</span>u=<span class="cstat-no" title="statement not covered" >i[e],</span>f=<span class="cstat-no" title="statement not covered" >l&amp;&amp;c&amp;&amp;u&amp;&amp;u.major;<span class="cstat-no" title="statement not covered" ></span>return this._adapter.format(t,s||(f?c:h))}<span class="fstat-no" title="function not covered" ></span>ge</span>nerateTickLabels(t){let e,i,s;<span class="cstat-no" title="statement not covered" >for(e=0,i=t.length;e&lt;i;++e)<span class="cstat-no" title="statement not covered" >s=t[e],s.label=this._tickFormatFunction(s.value,e,t)}<span class="fstat-no" title="function not covered" ></span></span>ge</span>tDecimalForValue(t){<span class="cstat-no" title="statement not covered" >return null===t?NaN:(t-this.min)/(this.max-this.min)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t){const e=<span class="cstat-no" title="statement not covered" >this._offsets,</span>i=<span class="cstat-no" title="statement not covered" >this.getDecimalForValue(t);<span class="cstat-no" title="statement not covered" ></span>return this.getPixelForDecimal((e.start+i)*e.factor)}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){const e=<span class="cstat-no" title="statement not covered" >this._offsets,</span>i=<span class="cstat-no" title="statement not covered" >this.getDecimalForPixel(t)/e.factor-e.end;<span class="cstat-no" title="statement not covered" ></span>return this.min+i*(this.max-this.min)}<span class="fstat-no" title="function not covered" ></span>_g</span>etLabelSize(t){const e=<span class="cstat-no" title="statement not covered" >this.options.ticks,</span>i=<span class="cstat-no" title="statement not covered" >this.ctx.measureText(t).width,</span>s=<span class="cstat-no" title="statement not covered" >$(this.isHorizontal()?e.maxRotation:e.minRotation),</span>n=<span class="cstat-no" title="statement not covered" >Math.cos(s),</span>o=<span class="cstat-no" title="statement not covered" >Math.sin(s),</span>a=<span class="cstat-no" title="statement not covered" >this._resolveTickFontOptions(0).size;<span class="cstat-no" title="statement not covered" ></span>return{w:i*n+a*o,h:i*o+a*n}}<span class="fstat-no" title="function not covered" ></span>_g</span>etLabelCapacity(t){const e=<span class="cstat-no" title="statement not covered" >this.options.time,</span>i=<span class="cstat-no" title="statement not covered" >e.displayFormats,</span>s=<span class="cstat-no" title="statement not covered" >i[e.unit]||i.millisecond,</span>n=<span class="cstat-no" title="statement not covered" >this._tickFormatFunction(t,0,No(this,[t],this._majorUnit),s),</span>o=<span class="cstat-no" title="statement not covered" >this._getLabelSize(n),</span>a=<span class="cstat-no" title="statement not covered" >Math.floor(this.isHorizontal()?this.width/o.w:this.height/o.h)-1;<span class="cstat-no" title="statement not covered" ></span>return a&gt;0?a:1}<span class="fstat-no" title="function not covered" ></span>ge</span>tDataTimestamps(){let t,e,i=<span class="cstat-no" title="statement not covered" >this._cache.data||[];<span class="cstat-no" title="statement not covered" ></span>if(i.length)<span class="cstat-no" title="statement not covered" >return i;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.getMatchingVisibleMetas();<span class="cstat-no" title="statement not covered" ></span>if(this._normalized&amp;&amp;s.length)<span class="cstat-no" title="statement not covered" >return this._cache.data=s[0].controller.getAllParsedValues(this);<span class="cstat-no" title="statement not covered" >f</span></span>or(t=0,e=s.length;t&lt;e;++t)<span class="cstat-no" title="statement not covered" >i=i.concat(s[t].controller.getAllParsedValues(this));<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._cache.data=this.normalize(i)}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelTimestamps(){const t=<span class="cstat-no" title="statement not covered" >this._cache.labels||[];</span>let e,i;<span class="cstat-no" title="statement not covered" >if(t.length)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>for(e=0,i=s.length;e&lt;i;++e)<span class="cstat-no" title="statement not covered" >t.push(Vo(this,s[e]));<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._cache.labels=this._normalized?t:this.normalize(t)}<span class="fstat-no" title="function not covered" ></span>no</span>rmalize(t){<span class="cstat-no" title="statement not covered" >return lt(t.sort(Fo))}</span>}function <span class="fstat-no" title="function not covered" >jo(</span>t,e,i){let s,n,o,a,r=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >t.length-1;<span class="cstat-no" title="statement not covered" ></span>i?(e&gt;=t[r].pos&amp;&amp;e&lt;=t[l].pos&amp;&amp;({lo:r,hi:l}=it(t,"pos",e)),({pos:s,time:o}=t[r]),({pos:n,time:a}=t[l])):(e&gt;=t[r].time&amp;&amp;e&lt;=t[l].time&amp;&amp;({lo:r,hi:l}=it(t,"time",e)),({time:s,pos:o}=t[r]),({time:n,pos:a}=t[l]));c</span>onst h=<span class="cstat-no" title="statement not covered" >n-s;<span class="cstat-no" title="statement not covered" ></span>return h?o+(a-o)*(e-s)/h:o}</span>var $o=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,CategoryScale:class extends tn{static id=<span class="cstat-no" title="statement not covered" >"category";</span>static defaults=<span class="cstat-no" title="statement not covered" >{ticks:{callback:mo}};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}<span class="fstat-no" title="function not covered" ></span>in</span>it(t){const e=<span class="cstat-no" title="statement not covered" >this._addedLabels;<span class="cstat-no" title="statement not covered" ></span>if(e.length){const t=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>for(const{index:i,label:s}of e)<span class="cstat-no" title="statement not covered" >t[i]===s&amp;&amp;t.splice(i,1);<span class="cstat-no" title="statement not covered" >t</span></span>his._addedLabels=[]}<span class="cstat-no" title="statement not covered" ></span>s</span>uper.init(t)}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){<span class="cstat-no" title="statement not covered" >if(s(t))<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>return(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >null===t?null:Z(Math.round(t),0,e))</span>(e=isFinite(e)&amp;&amp;i[e]===t?e:po(i,t,l(e,t),this._addedLabels),i.length-1)}<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){const{minDefined:t,maxDefined:e}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();</span>let{min:i,max:s}=<span class="cstat-no" title="statement not covered" >this.getMinMax(!0);<span class="cstat-no" title="statement not covered" ></span>"ticks"===this.options.bounds&amp;&amp;(t||(i=0),e||(s=this.getLabels().length-1)),this.min=i,this.max=s}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){const t=<span class="cstat-no" title="statement not covered" >this.min,</span>e=<span class="cstat-no" title="statement not covered" >this.max,</span>i=<span class="cstat-no" title="statement not covered" >this.options.offset,</span>s=<span class="cstat-no" title="statement not covered" >[];</span>let n=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>n=0===t&amp;&amp;e===n.length-1?n:n.slice(t,e+1),this._valueRange=Math.max(n.length-(i?0:1),1),this._startValue=this.min-(i?.5:0);<span class="cstat-no" title="statement not covered" >f</span>or(let i=<span class="cstat-no" title="statement not covered" >t;</span>i&lt;=e;i++)<span class="cstat-no" title="statement not covered" >s.push({value:i});<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){<span class="cstat-no" title="statement not covered" >return mo.call(this,t)}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){<span class="cstat-no" title="statement not covered" >super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t){<span class="cstat-no" title="statement not covered" >return"number"!=typeof t&amp;&amp;(t=this.parse(t)),null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForTick(t){const e=<span class="cstat-no" title="statement not covered" >this.ticks;<span class="cstat-no" title="statement not covered" ></span>return t&lt;0||t&gt;e.length-1?null:this.getPixelForValue(e[t].value)}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){<span class="cstat-no" title="statement not covered" >return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}<span class="fstat-no" title="function not covered" ></span>ge</span>tBasePixel(){<span class="cstat-no" title="statement not covered" >return this.bottom}</span>},LinearScale:_o,LogarithmicScale:So,RadialLinearScale:Ro,TimeScale:Ho,TimeSeriesScale:class extends Ho{static id=<span class="cstat-no" title="statement not covered" >"timeseries";</span>static defaults=<span class="cstat-no" title="statement not covered" >Ho.defaults;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this._table=[],this._minPos=void 0,this._tableRange=void 0}<span class="fstat-no" title="function not covered" ></span>in</span>itOffsets(){const t=<span class="cstat-no" title="statement not covered" >this._getTimestampsForTable(),</span>e=<span class="cstat-no" title="statement not covered" >this._table=this.buildLookupTable(t);<span class="cstat-no" title="statement not covered" ></span>this._minPos=jo(e,this.min),this._tableRange=jo(e,this.max)-this._minPos,super.initOffsets(t)}<span class="fstat-no" title="function not covered" ></span>bu</span>ildLookupTable(t){const{min:e,max:i}=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >[];</span>let o,a,r,l,h;<span class="cstat-no" title="statement not covered" >for(o=0,a=t.length;o&lt;a;++o)<span class="cstat-no" title="statement not covered" >l=t[o],l&gt;=e&amp;&amp;l&lt;=i&amp;&amp;s.push(l);<span class="cstat-no" title="statement not covered" >i</span></span>f(s.length&lt;2)<span class="cstat-no" title="statement not covered" >return[{time:e,pos:0},{time:i,pos:1}];<span class="cstat-no" title="statement not covered" >f</span></span>or(o=0,a=s.length;o&lt;a;++o)<span class="cstat-no" title="statement not covered" >h=s[o+1],r=s[o-1],l=s[o],Math.round((h+r)/2)!==l&amp;&amp;n.push({time:l,pos:o/(a-1)});<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>_g</span>enerate(){const t=<span class="cstat-no" title="statement not covered" >this.min,</span>e=<span class="cstat-no" title="statement not covered" >this.max;</span>let i=<span class="cstat-no" title="statement not covered" >super.getDataTimestamps();<span class="cstat-no" title="statement not covered" ></span>return i.includes(t)&amp;&amp;i.length||i.splice(0,0,t),i.includes(e)&amp;&amp;1!==i.length||i.push(e),i.sort((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e)</span>)}<span class="fstat-no" title="function not covered" ></span>_g</span>etTimestampsForTable(){let t=<span class="cstat-no" title="statement not covered" >this._cache.all||[];<span class="cstat-no" title="statement not covered" ></span>if(t.length)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.getDataTimestamps(),</span>i=<span class="cstat-no" title="statement not covered" >this.getLabelTimestamps();<span class="cstat-no" title="statement not covered" ></span>return t=e.length&amp;&amp;i.length?this.normalize(e.concat(i)):e.length?e:i,t=this._cache.all=t,t}<span class="fstat-no" title="function not covered" ></span>ge</span>tDecimalForValue(t){<span class="cstat-no" title="statement not covered" >return(jo(this._table,t)-this._minPos)/this._tableRange}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){const e=<span class="cstat-no" title="statement not covered" >this._offsets,</span>i=<span class="cstat-no" title="statement not covered" >this.getDecimalForPixel(t)/e.factor-e.end;<span class="cstat-no" title="statement not covered" ></span>return jo(this._table,i*this._tableRange+this._minPos,!0)}</span>}});</span>const Yo=<span class="cstat-no" title="statement not covered" >["rgb(54, 162, 235)","rgb(255, 99, 132)","rgb(255, 159, 64)","rgb(255, 205, 86)","rgb(75, 192, 192)","rgb(153, 102, 255)","rgb(201, 203, 207)"],</span>Uo=<span class="cstat-no" title="statement not covered" >Yo.map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.replace("rgb(","rgba(").replace(")",", 0.5)"))</span>);</span>function <span class="fstat-no" title="function not covered" >Xo(</span>t){<span class="cstat-no" title="statement not covered" >return Yo[t%Yo.length]}</span>function <span class="fstat-no" title="function not covered" >qo(</span>t){<span class="cstat-no" title="statement not covered" >return Uo[t%Uo.length]}</span>function <span class="fstat-no" title="function not covered" >Ko(</span>t){let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return<span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{const n=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(s).controller;<span class="cstat-no" title="statement not covered" ></span>n instanceof $n?e=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.backgroundColor=t.data.map((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Xo(e++))</span>),e}</span>(i,e):n instanceof Yn?e=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.backgroundColor=t.data.map((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >qo(e++))</span>),e}</span>(i,e):n&amp;&amp;(e=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.borderColor=Xo(e),t.backgroundColor=qo(e),++e}</span>(i,e))}</span>}</span>function <span class="fstat-no" title="function not covered" >Go(</span>t){let e;<span class="cstat-no" title="statement not covered" >for(e in t)<span class="cstat-no" title="statement not covered" >if(t[e].borderColor||t[e].backgroundColor)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>var Jo=<span class="cstat-no" title="statement not covered" >{id:"colors",defaults:{enabled:!0,forceOverride:!1},<span class="fstat-no" title="function not covered" >be</span>foreLayout(t,e,i){<span class="cstat-no" title="statement not covered" >if(!i.enabled)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{data:{datasets:s},options:n}=<span class="cstat-no" title="statement not covered" >t.config,</span>{elements:o}=<span class="cstat-no" title="statement not covered" >n,</span>a=<span class="cstat-no" title="statement not covered" >Go(s)||(r=n)&amp;&amp;(r.borderColor||r.backgroundColor)||o&amp;&amp;Go(o)||"rgba(0,0,0,0.1)"!==ue.borderColor||"rgba(0,0,0,0.1)"!==ue.backgroundColor;</span>var r;<span class="cstat-no" title="statement not covered" >if(!i.forceOverride&amp;&amp;a)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst l=<span class="cstat-no" title="statement not covered" >Ko(t);<span class="cstat-no" title="statement not covered" ></span>s.forEach(l)}</span>};</span>function <span class="fstat-no" title="function not covered" >Zo(</span>t){<span class="cstat-no" title="statement not covered" >if(t._decimated){const e=<span class="cstat-no" title="statement not covered" >t._data;<span class="cstat-no" title="statement not covered" ></span>delete t._decimated,delete t._data,Object.defineProperty(t,"data",{configurable:!0,enumerable:!0,writable:!0,value:e})}</span>}</span>function <span class="fstat-no" title="function not covered" >Qo(</span>t){<span class="cstat-no" title="statement not covered" >t.data.datasets.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >Zo(t)}</span>))}</span>var ta=<span class="cstat-no" title="statement not covered" >{id:"decimation",defaults:{algorithm:"min-max",enabled:!1},beforeElementsUpdate:<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >if(!i.enabled)<span class="cstat-no" title="statement not covered" >return void Qo(t);c</span></span>onst n=<span class="cstat-no" title="statement not covered" >t.width;<span class="cstat-no" title="statement not covered" ></span>t.data.datasets.forEach((<span class="fstat-no" title="function not covered" >(e</span>,o)=&gt;{const{_data:a,indexAxis:r}=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(o),</span>h=<span class="cstat-no" title="statement not covered" >a||e.data;<span class="cstat-no" title="statement not covered" ></span>if("y"===Pi([r,t.options.indexAxis]))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!l.controller.supportsDecimation)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst c=<span class="cstat-no" title="statement not covered" >t.scales[l.xAxisID];<span class="cstat-no" title="statement not covered" ></span>if("linear"!==c.type&amp;&amp;"time"!==c.type)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.options.parsing)<span class="cstat-no" title="statement not covered" >return;l</span></span>et{start:d,count:u}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >e.length;</span>let s,n=<span class="cstat-no" title="statement not covered" >0;</span>const{iScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>{min:a,max:r,minDefined:l,maxDefined:h}=<span class="cstat-no" title="statement not covered" >o.getUserBounds();<span class="cstat-no" title="statement not covered" ></span>return l&amp;&amp;(n=Z(it(e,o.axis,a).lo,0,i-1)),s=h?Z(it(e,o.axis,r).hi+1,n,i)-n:i-n,{start:n,count:s}}</span>(l,h);<span class="cstat-no" title="statement not covered" ></span>if(u&lt;=(i.threshold||4*n))<span class="cstat-no" title="statement not covered" >return void Zo(e);l</span></span>et f;<span class="cstat-no" title="statement not covered" >switch(s(a)&amp;&amp;(e._data=h,delete e.data,Object.defineProperty(e,"data",{configurable:!0,enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._decimated}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this._data=t}</span>})),i.algorithm){case"lttb":<span class="cstat-no" title="statement not covered" >f=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >n.samples||s;<span class="cstat-no" title="statement not covered" ></span>if(o&gt;=i)<span class="cstat-no" title="statement not covered" >return t.slice(e,e+i);c</span></span>onst a=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >(i-2)/(o-2);</span>let l=<span class="cstat-no" title="statement not covered" >0;</span>const h=<span class="cstat-no" title="statement not covered" >e+i-1;</span>let c,d,u,f,g,p=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>for(a[l++]=t[p],c=0;c&lt;o-2;c++){let s,n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>const h=<span class="cstat-no" title="statement not covered" >Math.floor((c+1)*r)+1+e,</span>m=<span class="cstat-no" title="statement not covered" >Math.min(Math.floor((c+2)*r)+1,i)+e,</span>x=<span class="cstat-no" title="statement not covered" >m-h;<span class="cstat-no" title="statement not covered" ></span>for(s=h;s&lt;m;s++)<span class="cstat-no" title="statement not covered" >n+=t[s].x,o+=t[s].y;<span class="cstat-no" title="statement not covered" >n</span></span>/=x,o/=x;c</span>onst b=<span class="cstat-no" title="statement not covered" >Math.floor(c*r)+1+e,</span>_=<span class="cstat-no" title="statement not covered" >Math.min(Math.floor((c+1)*r)+1,i)+e,</span>{x:y,y:v}=<span class="cstat-no" title="statement not covered" >t[p];<span class="cstat-no" title="statement not covered" ></span>for(u=f=-1,s=b;s&lt;_;s++)<span class="cstat-no" title="statement not covered" >f=.5*Math.abs((y-n)*(t[s].y-v)-(y-t[s].x)*(o-v)),f&gt;u&amp;&amp;(u=f,d=t[s],g=s);<span class="cstat-no" title="statement not covered" >a</span></span>[l++]=d,p=g}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a[l++]=t[h],a}</span>(h,d,u,n,i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"min-max":<span class="cstat-no" title="statement not covered" >f=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,n){let o,a,r,l,h,c,d,u,f,g,p=<span class="cstat-no" title="statement not covered" >0,</span>m=<span class="cstat-no" title="statement not covered" >0;</span>const x=<span class="cstat-no" title="statement not covered" >[],</span>b=<span class="cstat-no" title="statement not covered" >e+i-1,</span>_=<span class="cstat-no" title="statement not covered" >t[e].x,</span>y=<span class="cstat-no" title="statement not covered" >t[b].x-_;<span class="cstat-no" title="statement not covered" ></span>for(o=e;o&lt;e+i;++o){<span class="cstat-no" title="statement not covered" >a=t[o],r=(a.x-_)/y*n,l=a.y;c</span>onst e=<span class="cstat-no" title="statement not covered" >0|r;<span class="cstat-no" title="statement not covered" ></span>if(e===h)<span class="cstat-no" title="statement not covered" >l&lt;f?(f=l,c=o):l&gt;g&amp;&amp;(g=l,d=o),p=(m*p+a.x)/++m;e</span>lse{const i=<span class="cstat-no" title="statement not covered" >o-1;<span class="cstat-no" title="statement not covered" ></span>if(!s(c)&amp;&amp;!s(d)){const e=<span class="cstat-no" title="statement not covered" >Math.min(c,d),</span>s=<span class="cstat-no" title="statement not covered" >Math.max(c,d);<span class="cstat-no" title="statement not covered" ></span>e!==u&amp;&amp;e!==i&amp;&amp;x.push({...t[e],x:p}),s!==u&amp;&amp;s!==i&amp;&amp;x.push({...t[s],x:p})}<span class="cstat-no" title="statement not covered" ></span>o</span>&gt;0&amp;&amp;i!==u&amp;&amp;x.push(t[i]),x.push(a),h=e,m=0,f=g=l,c=d=u=o}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn x}</span>(h,d,u,n);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`)}<span class="cstat-no" title="statement not covered" ></span>e</span>._decimated=f}</span>))}</span>,<span class="fstat-no" title="function not covered" >de</span>stroy(t){<span class="cstat-no" title="statement not covered" >Qo(t)}</span>};</span>function <span class="fstat-no" title="function not covered" >ea(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >if(s)<span class="cstat-no" title="statement not covered" >return;l</span></span>et n=<span class="cstat-no" title="statement not covered" >e[t],</span>o=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>return"angle"===t&amp;&amp;(n=G(n),o=G(o)),{property:t,start:n,end:o}}</span>function <span class="fstat-no" title="function not covered" >ia(</span>t,e,i){<span class="cstat-no" title="statement not covered" >for(;e&gt;t;e--){const t=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>if(!isNaN(t.x)&amp;&amp;!isNaN(t.y))<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >sa(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;e?s(t[i],e[i]):t?t[i]:e?e[i]:0}</span>function <span class="fstat-no" title="function not covered" >na(</span>t,e){let i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return n(t)?(s=!0,i=t):i=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{x:i=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>y:s=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>=<span class="cstat-no" title="statement not covered" >t||{},</span>n=<span class="cstat-no" title="statement not covered" >e.points,</span>o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return e.segments.forEach((<span class="fstat-no" title="function not covered" >({</span>start:t,end:e})=&gt;{<span class="cstat-no" title="statement not covered" >e=ia(t,e,n);c</span>onst a=<span class="cstat-no" title="statement not covered" >n[t],</span>r=<span class="cstat-no" title="statement not covered" >n[e];<span class="cstat-no" title="statement not covered" ></span>null!==s?(o.push({x:a.x,y:s}),o.push({x:r.x,y:s})):null!==i&amp;&amp;(o.push({x:i,y:a.y}),o.push({x:i,y:r.y}))}</span>)),o}</span>(t,e),i.length?new oo({points:i,options:{tension:0},_loop:s,_fullLoop:s}):null}</span>function <span class="fstat-no" title="function not covered" >oa(</span>t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;!1!==t.fill}</span>function <span class="fstat-no" title="function not covered" >aa(</span>t,e,i){let s=<span class="cstat-no" title="statement not covered" >t[e].fill;</span>const n=<span class="cstat-no" title="statement not covered" >[e];</span>let o;<span class="cstat-no" title="statement not covered" >if(!i)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >f</span></span>or(;!1!==s&amp;&amp;-1===n.indexOf(s);){<span class="cstat-no" title="statement not covered" >if(!a(s))<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >i</span></span>f(o=t[s],!o)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(o.visible)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >n</span></span>.push(s),s=o.fill}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >ra(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.options,</span>i=<span class="cstat-no" title="statement not covered" >e.fill;</span>let s=<span class="cstat-no" title="statement not covered" >l(i&amp;&amp;i.target,i);<span class="cstat-no" title="statement not covered" ></span>void 0===s&amp;&amp;(s=!!e.backgroundColor);<span class="cstat-no" title="statement not covered" >i</span>f(!1===s||null===s)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!0===s)<span class="cstat-no" title="statement not covered" >return"origin";<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>(t);<span class="cstat-no" title="statement not covered" ></span>if(o(s))<span class="cstat-no" title="statement not covered" >return!isNaN(s.value)&amp;&amp;s;l</span></span>et n=<span class="cstat-no" title="statement not covered" >parseFloat(s);<span class="cstat-no" title="statement not covered" ></span>return a(n)&amp;&amp;Math.floor(n)===n?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){<span class="cstat-no" title="statement not covered" >"-"!==t&amp;&amp;"+"!==t||(i=e+i);<span class="cstat-no" title="statement not covered" >i</span>f(i===e||i&lt;0||i&gt;=s)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>(s[0],e,n,i):["origin","start","end","stack","shape"].indexOf(s)&gt;=0&amp;&amp;s}</span>function <span class="fstat-no" title="function not covered" >la(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;i.length;n++){const o=<span class="cstat-no" title="statement not covered" >i[n],</span>{first:a,last:r,point:l}=<span class="cstat-no" title="statement not covered" >ha(o,e,"x");<span class="cstat-no" title="statement not covered" ></span>if(!(!l||a&amp;&amp;r))<span class="cstat-no" title="statement not covered" >if(a)<span class="cstat-no" title="statement not covered" >s.unshift(l);e</span>lse <span class="cstat-no" title="statement not covered" >if(t.push(l),!r)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span></span></span>t</span>.push(...s)}</span>function <span class="fstat-no" title="function not covered" >ha(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.interpolate(e,i);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return{};c</span></span>onst n=<span class="cstat-no" title="statement not covered" >s[i],</span>o=<span class="cstat-no" title="statement not covered" >t.segments,</span>a=<span class="cstat-no" title="statement not covered" >t.points;</span>let r=<span class="cstat-no" title="statement not covered" >!1,</span>l=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;o.length;t++){const e=<span class="cstat-no" title="statement not covered" >o[t],</span>s=<span class="cstat-no" title="statement not covered" >a[e.start][i],</span>h=<span class="cstat-no" title="statement not covered" >a[e.end][i];<span class="cstat-no" title="statement not covered" ></span>if(tt(n,s,h)){<span class="cstat-no" title="statement not covered" >r=n===s,l=n===h;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{first:r,last:l,point:s}}</span>class ca{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.x=t.x,this.y=t.y,this.radius=t.radius}<span class="fstat-no" title="function not covered" ></span>pa</span>thSegment(t,e,i){const{x:s,y:n,radius:o}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return e=e||{start:0,end:O},t.arc(s,n,o,e.end,e.start,!0),!i.bounds}<span class="fstat-no" title="function not covered" ></span>in</span>terpolate(t){const{x:e,y:i,radius:s}=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.angle;<span class="cstat-no" title="statement not covered" ></span>return{x:e+Math.cos(n)*s,y:i+Math.sin(n)*s,angle:n}}</span>}function <span class="fstat-no" title="function not covered" >da(</span>t){const{chart:e,fill:i,line:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(a(i))<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(e),</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;t.isDatasetVisible(e);<span class="cstat-no" title="statement not covered" ></span>return s?i.dataset:null}</span>(e,i);<span class="cstat-no" title="statement not covered" >i</span></span>f("stack"===i)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t){const{scale:e,index:i,line:s}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >s.segments,</span>a=<span class="cstat-no" title="statement not covered" >s.points,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >t.getMatchingVisibleMetas("line");<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;s.length;t++){const n=<span class="cstat-no" title="statement not covered" >s[t];<span class="cstat-no" title="statement not covered" ></span>if(n.index===e)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >n</span></span>.hidden||i.unshift(n.dataset)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>(e,i);<span class="cstat-no" title="statement not covered" ></span>r.push(na({x:null,y:e.bottom},s));<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;o.length;t++){const e=<span class="cstat-no" title="statement not covered" >o[t];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >e.start;</span>t&lt;=e.end;t++)<span class="cstat-no" title="statement not covered" >la(n,a[t],r)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn new oo({points:n,options:{}})}</span>(t);<span class="cstat-no" title="statement not covered" >i</span></span>f("shape"===i)<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.scale||{};<span class="cstat-no" title="statement not covered" ></span>if(e.getPointPositionForValue)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t){const{scale:e,fill:i}=<span class="cstat-no" title="statement not covered" >t,</span>s=<span class="cstat-no" title="statement not covered" >e.options,</span>n=<span class="cstat-no" title="statement not covered" >e.getLabels().length,</span>a=<span class="cstat-no" title="statement not covered" >s.reverse?e.max:e.min,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let s;<span class="cstat-no" title="statement not covered" >return s="start"===t?i:"end"===t?e.options.reverse?e.min:e.max:o(t)?t.value:e.getBaseValue(),s}</span>(i,e,a),</span>l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(s.grid.circular){const t=<span class="cstat-no" title="statement not covered" >e.getPointPositionForValue(0,a);<span class="cstat-no" title="statement not covered" ></span>return new ca({x:t.x,y:t.y,radius:e.getDistanceFromCenterForValue(r)})}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;n;++t)<span class="cstat-no" title="statement not covered" >l.push(e.getPointPositionForValue(t,r));<span class="cstat-no" title="statement not covered" >r</span></span>eturn l}</span>(t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn <span class="fstat-no" title="function not covered" >fu</span>nction(t){const{scale:e=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>fill:i}=<span class="cstat-no" title="statement not covered" >t,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return"start"===t?i=e.bottom:"end"===t?i=e.top:o(t)?i=e.getPixelForValue(t.value):e.getBasePixel&amp;&amp;(i=e.getBasePixel()),i}</span>(i,e);<span class="cstat-no" title="statement not covered" ></span>if(a(s)){const t=<span class="cstat-no" title="statement not covered" >e.isHorizontal();<span class="cstat-no" title="statement not covered" ></span>return{x:t?s:null,y:t?null:s}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}</span>(t)}</span>(t);<span class="cstat-no" title="statement not covered" ></span>return n instanceof ca?n:na(n,s)}</span>function <span class="fstat-no" title="function not covered" >ua(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >da(e),</span>{chart:n,index:o,line:a,scale:r,axis:l}=<span class="cstat-no" title="statement not covered" >e,</span>h=<span class="cstat-no" title="statement not covered" >a.options,</span>c=<span class="cstat-no" title="statement not covered" >h.fill,</span>d=<span class="cstat-no" title="statement not covered" >h.backgroundColor,</span>{above:u=<span class="branch-0 cbranch-no" title="branch not covered" >d,</span>below:f=<span class="branch-0 cbranch-no" title="branch not covered" >d}</span>=<span class="cstat-no" title="statement not covered" >c||{},</span>g=<span class="cstat-no" title="statement not covered" >n.getDatasetMeta(o),</span>p=<span class="cstat-no" title="statement not covered" >Ni(n,g);<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;a.points.length&amp;&amp;(Ie(t,i),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{line:i,target:s,above:n,below:o,area:a,scale:r,clip:l}=<span class="cstat-no" title="statement not covered" >e,</span>h=<span class="cstat-no" title="statement not covered" >i._loop?"angle":e.axis;<span class="cstat-no" title="statement not covered" ></span>t.save();l</span>et c=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>o!==n&amp;&amp;("x"===h?(fa(t,s,a.top),pa(t,{line:i,target:s,color:n,scale:r,property:h,clip:l}),t.restore(),t.save(),fa(t,s,a.bottom)):"y"===h&amp;&amp;(ga(t,s,a.left),pa(t,{line:i,target:s,color:o,scale:r,property:h,clip:l}),t.restore(),t.save(),ga(t,s,a.right),c=n));<span class="cstat-no" title="statement not covered" >p</span>a(t,{line:i,target:s,color:c,scale:r,property:h,clip:l}),t.restore()}</span>(t,{line:a,target:s,above:u,below:f,area:i,scale:r,axis:l,clip:p}),ze(t))}</span>function <span class="fstat-no" title="function not covered" >fa(</span>t,e,i){const{segments:s,points:n}=<span class="cstat-no" title="statement not covered" >e;</span>let o=<span class="cstat-no" title="statement not covered" >!0,</span>a=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>t.beginPath();<span class="cstat-no" title="statement not covered" >f</span>or(const r of s){const{start:s,end:l}=<span class="cstat-no" title="statement not covered" >r,</span>h=<span class="cstat-no" title="statement not covered" >n[s],</span>c=<span class="cstat-no" title="statement not covered" >n[ia(s,l,n)];<span class="cstat-no" title="statement not covered" ></span>o?(t.moveTo(h.x,h.y),o=!1):(t.lineTo(h.x,i),t.lineTo(h.x,h.y)),a=!!e.pathSegment(t,r,{move:a}),a?t.closePath():t.lineTo(c.x,i)}<span class="cstat-no" title="statement not covered" ></span>t</span>.lineTo(e.first().x,i),t.closePath(),t.clip()}</span>function <span class="fstat-no" title="function not covered" >ga(</span>t,e,i){const{segments:s,points:n}=<span class="cstat-no" title="statement not covered" >e;</span>let o=<span class="cstat-no" title="statement not covered" >!0,</span>a=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>t.beginPath();<span class="cstat-no" title="statement not covered" >f</span>or(const r of s){const{start:s,end:l}=<span class="cstat-no" title="statement not covered" >r,</span>h=<span class="cstat-no" title="statement not covered" >n[s],</span>c=<span class="cstat-no" title="statement not covered" >n[ia(s,l,n)];<span class="cstat-no" title="statement not covered" ></span>o?(t.moveTo(h.x,h.y),o=!1):(t.lineTo(i,h.y),t.lineTo(h.x,h.y)),a=!!e.pathSegment(t,r,{move:a}),a?t.closePath():t.lineTo(i,c.y)}<span class="cstat-no" title="statement not covered" ></span>t</span>.lineTo(i,e.first().y),t.closePath(),t.clip()}</span>function <span class="fstat-no" title="function not covered" >pa(</span>t,e){const{line:i,target:s,property:n,color:o,scale:a,clip:r}=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.segments,</span>n=<span class="cstat-no" title="statement not covered" >t.points,</span>o=<span class="cstat-no" title="statement not covered" >e.points,</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const t of s){let{start:s,end:r}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>r=ia(s,r,n);c</span>onst l=<span class="cstat-no" title="statement not covered" >ea(i,n[s],n[r],t.loop);<span class="cstat-no" title="statement not covered" ></span>if(!e.segments){<span class="cstat-no" title="statement not covered" >a.push({source:t,target:l,start:n[s],end:n[r]});<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst h=<span class="cstat-no" title="statement not covered" >Ii(e,l);<span class="cstat-no" title="statement not covered" ></span>for(const e of h){const s=<span class="cstat-no" title="statement not covered" >ea(i,o[e.start],o[e.end],e.loop),</span>r=<span class="cstat-no" title="statement not covered" >Ri(t,n,s);<span class="cstat-no" title="statement not covered" ></span>for(const t of r)<span class="cstat-no" title="statement not covered" >a.push({source:t,target:e,start:{[i]:sa(l,s,"start",Math.max)},end:{[i]:sa(l,s,"end",Math.min)}})}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>(i,s,n);<span class="cstat-no" title="statement not covered" ></span>for(const{source:e,target:h,start:c,end:d}of l){const{style:{backgroundColor:l=<span class="branch-0 cbranch-no" title="branch not covered" >o}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{}}</span>=<span class="cstat-no" title="statement not covered" >e,</span>u=<span class="cstat-no" title="statement not covered" >!0!==s;<span class="cstat-no" title="statement not covered" ></span>t.save(),t.fillStyle=l,ma(t,a,r,u&amp;&amp;ea(n,c,d)),t.beginPath();c</span>onst f=<span class="cstat-no" title="statement not covered" >!!i.pathSegment(t,e);</span>let g;<span class="cstat-no" title="statement not covered" >if(u){<span class="cstat-no" title="statement not covered" >f?t.closePath():xa(t,s,d,n);c</span>onst e=<span class="cstat-no" title="statement not covered" >!!s.pathSegment(t,h,{move:f,reverse:!0});<span class="cstat-no" title="statement not covered" ></span>g=f&amp;&amp;e,g||xa(t,s,c,n)}<span class="cstat-no" title="statement not covered" ></span>t</span>.closePath(),t.fill(g?"evenodd":"nonzero"),t.restore()}</span>}</span>function <span class="fstat-no" title="function not covered" >ma(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.chart.chartArea,</span>{property:o,start:a,end:r}=<span class="cstat-no" title="statement not covered" >s||{};<span class="cstat-no" title="statement not covered" ></span>if("x"===o||"y"===o){let e,s,l,h;<span class="cstat-no" title="statement not covered" >"x"===o?(e=a,s=n.top,l=r,h=n.bottom):(e=n.left,s=a,l=n.right,h=r),t.beginPath(),i&amp;&amp;(e=Math.max(e,i.left),l=Math.min(l,i.right),s=Math.max(s,i.top),h=Math.min(h,i.bottom)),t.rect(e,s,l-e,h-s),t.clip()}</span>}</span>function <span class="fstat-no" title="function not covered" >xa(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.interpolate(i,s);<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;t.lineTo(n.x,n.y)}</span>var ba=<span class="cstat-no" title="statement not covered" >{id:"filler",<span class="fstat-no" title="function not covered" >af</span>terDatasetsUpdate(t,e,i){const s=<span class="cstat-no" title="statement not covered" >(t.data.datasets||[]).length,</span>n=<span class="cstat-no" title="statement not covered" >[];</span>let o,a,r,l;<span class="cstat-no" title="statement not covered" >for(a=0;a&lt;s;++a)<span class="cstat-no" title="statement not covered" >o=t.getDatasetMeta(a),r=o.dataset,l=null,r&amp;&amp;r.options&amp;&amp;r instanceof oo&amp;&amp;(l={visible:t.isDatasetVisible(a),index:a,fill:ra(r,a,s),chart:t,axis:o.controller.options.indexAxis,scale:o.vScale,line:r}),o.$filler=l,n.push(l);<span class="cstat-no" title="statement not covered" >f</span></span>or(a=0;a&lt;s;++a)<span class="cstat-no" title="statement not covered" >l=n[a],l&amp;&amp;!1!==l.fill&amp;&amp;(l.fill=aa(n,a,i.propagate))}</span></span>,<span class="fstat-no" title="function not covered" >be</span>foreDraw(t,e,i){const s=<span class="cstat-no" title="statement not covered" >"beforeDraw"===i.drawTime,</span>n=<span class="cstat-no" title="statement not covered" >t.getSortedVisibleDatasetMetas(),</span>o=<span class="cstat-no" title="statement not covered" >t.chartArea;<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >n.length-1;</span>e&gt;=0;--e){const i=<span class="cstat-no" title="statement not covered" >n[e].$filler;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(i.line.updateControlPoints(o,i.axis),s&amp;&amp;i.fill&amp;&amp;ua(t.ctx,i,o))}</span>}</span>,<span class="fstat-no" title="function not covered" >be</span>foreDatasetsDraw(t,e,i){<span class="cstat-no" title="statement not covered" >if("beforeDatasetsDraw"!==i.drawTime)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >t.getSortedVisibleDatasetMetas();<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >s.length-1;</span>e&gt;=0;--e){const i=<span class="cstat-no" title="statement not covered" >s[e].$filler;<span class="cstat-no" title="statement not covered" ></span>oa(i)&amp;&amp;ua(t.ctx,i,t.chartArea)}</span>}</span>,<span class="fstat-no" title="function not covered" >be</span>foreDatasetDraw(t,e,i){const s=<span class="cstat-no" title="statement not covered" >e.meta.$filler;<span class="cstat-no" title="statement not covered" ></span>oa(s)&amp;&amp;"beforeDatasetDraw"===i.drawTime&amp;&amp;ua(t.ctx,s,t.chartArea)}</span>,defaults:{propagate:!0,drawTime:"beforeDatasetDraw"}};</span>const _a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{let{boxHeight:i=<span class="branch-0 cbranch-no" title="branch not covered" >e,</span>boxWidth:s=<span class="branch-0 cbranch-no" title="branch not covered" >e}</span>=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return t.usePointStyle&amp;&amp;(i=Math.min(i,e),s=t.pointStyleWidth||Math.min(s,e)),{boxWidth:s,boxHeight:i,itemHeight:Math.max(e,i)}}</span>;</span>class ya extends $s{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e,i){<span class="cstat-no" title="statement not covered" >this.maxWidth=t,this.maxHeight=e,this._margins=i,this.setDimensions(),this.buildLabels(),this.fit()}<span class="fstat-no" title="function not covered" ></span>se</span>tDimensions(){<span class="cstat-no" title="statement not covered" >this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}<span class="fstat-no" title="function not covered" ></span>bu</span>ildLabels(){const t=<span class="cstat-no" title="statement not covered" >this.options.labels||{};</span>let e=<span class="cstat-no" title="statement not covered" >d(t.generateLabels,[this.chart],this)||[];<span class="cstat-no" title="statement not covered" ></span>t.filter&amp;&amp;(e=e.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.filter(e,this.chart.data))</span>)),t.sort&amp;&amp;(e=e.sort((<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >t.sort(e,i,this.chart.data))</span>)),this.options.reverse&amp;&amp;e.reverse(),this.legendItems=e}<span class="fstat-no" title="function not covered" ></span>fi</span>t(){const{options:t,ctx:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!t.display)<span class="cstat-no" title="statement not covered" >return void(this.width=this.height=0);c</span></span>onst i=<span class="cstat-no" title="statement not covered" >t.labels,</span>s=<span class="cstat-no" title="statement not covered" >Si(i.font),</span>n=<span class="cstat-no" title="statement not covered" >s.size,</span>o=<span class="cstat-no" title="statement not covered" >this._computeTitleHeight(),</span>{boxWidth:a,itemHeight:r}=<span class="cstat-no" title="statement not covered" >_a(i,n);</span>let l,h;<span class="cstat-no" title="statement not covered" >e.font=s.string,this.isHorizontal()?(l=this.maxWidth,h=this._fitRows(o,n,a,r)+10):(h=this.maxHeight,l=this._fitCols(o,s,a,r)+10),this.width=Math.min(l,t.maxWidth||this.maxWidth),this.height=Math.min(h,t.maxHeight||this.maxHeight)}<span class="fstat-no" title="function not covered" ></span>_f</span>itRows(t,e,i,s){const{ctx:n,maxWidth:o,options:{labels:{padding:a}}}=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >this.legendHitBoxes=[],</span>l=<span class="cstat-no" title="statement not covered" >this.lineWidths=[0],</span>h=<span class="cstat-no" title="statement not covered" >s+a;</span>let c=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>n.textAlign="left",n.textBaseline="middle";l</span>et d=<span class="cstat-no" title="statement not covered" >-1,</span>u=<span class="cstat-no" title="statement not covered" >-h;<span class="cstat-no" title="statement not covered" ></span>return this.legendItems.forEach((<span class="fstat-no" title="function not covered" >(t</span>,f)=&gt;{const g=<span class="cstat-no" title="statement not covered" >i+e/2+n.measureText(t.text).width;<span class="cstat-no" title="statement not covered" ></span>(0===f||l[l.length-1]+g+2*a&gt;o)&amp;&amp;(c+=h,l[l.length-(f&gt;0?0:1)]=0,u+=h,d++),r[f]={left:0,top:u,row:d,width:g,height:s},l[l.length-1]+=g+a}</span>)),c}<span class="fstat-no" title="function not covered" ></span>_f</span>itCols(t,e,i,s){const{ctx:n,maxHeight:o,options:{labels:{padding:a}}}=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >this.legendHitBoxes=[],</span>l=<span class="cstat-no" title="statement not covered" >this.columnSizes=[],</span>h=<span class="cstat-no" title="statement not covered" >o-t;</span>let c=<span class="cstat-no" title="statement not covered" >a,</span>d=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >0,</span>f=<span class="cstat-no" title="statement not covered" >0,</span>g=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return this.legendItems.forEach((<span class="fstat-no" title="function not covered" >(t</span>,o)=&gt;{const{itemWidth:p,itemHeight:m}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >t.text;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;"string"!=typeof n&amp;&amp;(n=n.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.length&gt;e.length?t:e)</span>));<span class="cstat-no" title="statement not covered" >r</span>eturn e+i.size/2+s.measureText(n).width}</span>(s,t,e,i),</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let s=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>"string"!=typeof e.text&amp;&amp;(s=va(e,i));<span class="cstat-no" title="statement not covered" >r</span>eturn s}</span>(n,s,e.lineHeight);<span class="cstat-no" title="statement not covered" ></span>return{itemWidth:o,itemHeight:a}}</span>(i,e,n,t,s);<span class="cstat-no" title="statement not covered" ></span>o&gt;0&amp;&amp;u+m+2*a&gt;h&amp;&amp;(c+=d+a,l.push({width:d,height:u}),f+=d+a,g++,d=u=0),r[o]={left:f,top:u,col:g,width:p,height:m},d=Math.max(d,p),u+=m+a}</span>)),c+=d,l.push({width:d,height:u}),c}<span class="fstat-no" title="function not covered" ></span>ad</span>justHitBoxes(){<span class="cstat-no" title="statement not covered" >if(!this.options.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this._computeTitleHeight(),</span>{legendHitBoxes:e,options:{align:i,labels:{padding:s},rtl:n}}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >Oi(n,this.left,this.width);<span class="cstat-no" title="statement not covered" ></span>if(this.isHorizontal()){let n=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >ft(i,this.left+s,this.right-this.lineWidths[n]);<span class="cstat-no" title="statement not covered" ></span>for(const r of e)<span class="cstat-no" title="statement not covered" >n!==r.row&amp;&amp;(n=r.row,a=ft(i,this.left+s,this.right-this.lineWidths[n])),r.top+=this.top+t+s,r.left=o.leftForLtr(o.x(a),r.width),a+=r.width+s}</span></span>else{let n=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >ft(i,this.top+t+s,this.bottom-this.columnSizes[n].height);<span class="cstat-no" title="statement not covered" ></span>for(const r of e)<span class="cstat-no" title="statement not covered" >r.col!==n&amp;&amp;(n=r.col,a=ft(i,this.top+t+s,this.bottom-this.columnSizes[n].height)),r.top=a,r.left+=this.left+s,r.left=o.leftForLtr(o.x(r.left),r.width),a+=r.height+s}</span></span>}<span class="fstat-no" title="function not covered" ></span>is</span>Horizontal(){<span class="cstat-no" title="statement not covered" >return"top"===this.options.position||"bottom"===this.options.position}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){<span class="cstat-no" title="statement not covered" >if(this.options.display){const t=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>Ie(t,this),this._draw(),ze(t)}</span>}<span class="fstat-no" title="function not covered" ></span>_d</span>raw(){const{options:t,columnSizes:e,lineWidths:i,ctx:s}=<span class="cstat-no" title="statement not covered" >this,</span>{align:n,labels:o}=<span class="cstat-no" title="statement not covered" >t,</span>a=<span class="cstat-no" title="statement not covered" >ue.color,</span>r=<span class="cstat-no" title="statement not covered" >Oi(t.rtl,this.left,this.width),</span>h=<span class="cstat-no" title="statement not covered" >Si(o.font),</span>{padding:c}=<span class="cstat-no" title="statement not covered" >o,</span>d=<span class="cstat-no" title="statement not covered" >h.size,</span>u=<span class="cstat-no" title="statement not covered" >d/2;</span>let f;<span class="cstat-no" title="statement not covered" >this.drawTitle(),s.textAlign=r.textAlign("left"),s.textBaseline="middle",s.lineWidth=.5,s.font=h.string;c</span>onst{boxWidth:g,boxHeight:p,itemHeight:m}=<span class="cstat-no" title="statement not covered" >_a(o,d),</span>x=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>b=<span class="cstat-no" title="statement not covered" >this._computeTitleHeight();<span class="cstat-no" title="statement not covered" ></span>f=x?{x:ft(n,this.left+c,this.right-i[0]),y:this.top+c+b,line:0}:{x:this.left+c,y:ft(n,this.top+b+c,this.bottom-e[0].height),line:0},Ai(this.ctx,t.textDirection);c</span>onst _=<span class="cstat-no" title="statement not covered" >m+c;<span class="cstat-no" title="statement not covered" ></span>this.legendItems.forEach((<span class="fstat-no" title="function not covered" >(y</span>,v)=&gt;{<span class="cstat-no" title="statement not covered" >s.strokeStyle=y.fontColor,s.fillStyle=y.fontColor;c</span>onst M=<span class="cstat-no" title="statement not covered" >s.measureText(y.text).width,</span>w=<span class="cstat-no" title="statement not covered" >r.textAlign(y.textAlign||(y.textAlign=o.textAlign)),</span>k=<span class="cstat-no" title="statement not covered" >g+u+M;</span>let S=<span class="cstat-no" title="statement not covered" >f.x,</span>P=<span class="cstat-no" title="statement not covered" >f.y;<span class="cstat-no" title="statement not covered" ></span>r.setWidth(this.width),x?v&gt;0&amp;&amp;S+k+c&gt;this.right&amp;&amp;(P=f.y+=_,f.line++,S=f.x=ft(n,this.left+c,this.right-i[f.line])):v&gt;0&amp;&amp;P+_&gt;this.bottom&amp;&amp;(S=f.x=S+e[f.line].width+c,f.line++,P=f.y=ft(n,this.top+b+c,this.bottom-e[f.line].height));<span class="cstat-no" title="statement not covered" >i</span>f(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >if(isNaN(g)||g&lt;=0||isNaN(p)||p&lt;0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >s</span></span>.save();c</span>onst n=<span class="cstat-no" title="statement not covered" >l(i.lineWidth,1);<span class="cstat-no" title="statement not covered" ></span>if(s.fillStyle=l(i.fillStyle,a),s.lineCap=l(i.lineCap,"butt"),s.lineDashOffset=l(i.lineDashOffset,0),s.lineJoin=l(i.lineJoin,"miter"),s.lineWidth=n,s.strokeStyle=l(i.strokeStyle,a),s.setLineDash(l(i.lineDash,[])),o.usePointStyle){const a=<span class="cstat-no" title="statement not covered" >{radius:p*Math.SQRT2/2,pointStyle:i.pointStyle,rotation:i.rotation,borderWidth:n},</span>l=<span class="cstat-no" title="statement not covered" >r.xPlus(t,g/2);<span class="cstat-no" title="statement not covered" ></span>Ee(s,a,l,e+u,o.pointStyleWidth&amp;&amp;g)}</span>else{const o=<span class="cstat-no" title="statement not covered" >e+Math.max((d-p)/2,0),</span>a=<span class="cstat-no" title="statement not covered" >r.leftForLtr(t,g),</span>l=<span class="cstat-no" title="statement not covered" >wi(i.borderRadius);<span class="cstat-no" title="statement not covered" ></span>s.beginPath(),Object.values(l).some((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0!==t)</span>)?He(s,{x:a,y:o,w:g,h:p,radius:l}):s.rect(a,o,g,p),s.fill(),0!==n&amp;&amp;s.stroke()}<span class="cstat-no" title="statement not covered" ></span>s</span>.restore()}</span>(r.x(S),P,y),S=gt(w,S+g+u,x?S+k:this.right,t.rtl),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >Ne(s,i.text,t,e+m/2,h,{strikethrough:i.hidden,textAlign:r.textAlign(i.textAlign)})}</span>(r.x(S),P,y),x)<span class="cstat-no" title="statement not covered" >f.x+=k+c;e</span>lse <span class="cstat-no" title="statement not covered" >if("string"!=typeof y.text){const t=<span class="cstat-no" title="statement not covered" >h.lineHeight;<span class="cstat-no" title="statement not covered" ></span>f.y+=va(y,t)+c}</span>else <span class="cstat-no" title="statement not covered" >f.y+=_}</span></span></span>)),Ti(this.ctx,t.textDirection)}<span class="fstat-no" title="function not covered" ></span>dr</span>awTitle(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.title,</span>i=<span class="cstat-no" title="statement not covered" >Si(e.font),</span>s=<span class="cstat-no" title="statement not covered" >ki(e.padding);<span class="cstat-no" title="statement not covered" ></span>if(!e.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >Oi(t.rtl,this.left,this.width),</span>o=<span class="cstat-no" title="statement not covered" >this.ctx,</span>a=<span class="cstat-no" title="statement not covered" >e.position,</span>r=<span class="cstat-no" title="statement not covered" >i.size/2,</span>l=<span class="cstat-no" title="statement not covered" >s.top+r;</span>let h,c=<span class="cstat-no" title="statement not covered" >this.left,</span>d=<span class="cstat-no" title="statement not covered" >this.width;<span class="cstat-no" title="statement not covered" ></span>if(this.isHorizontal())<span class="cstat-no" title="statement not covered" >d=Math.max(...this.lineWidths),h=this.top+l,c=ft(t.align,c,this.right-d);e</span>lse{const e=<span class="cstat-no" title="statement not covered" >this.columnSizes.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.max(t,e.height))</span>,0);<span class="cstat-no" title="statement not covered" ></span>h=l+ft(t.align,this.top,this.bottom-e-t.labels.padding-this._computeTitleHeight())}</span>c</span>onst u=<span class="cstat-no" title="statement not covered" >ft(a,c,c+d);<span class="cstat-no" title="statement not covered" ></span>o.textAlign=n.textAlign(ut(a)),o.textBaseline="middle",o.strokeStyle=e.color,o.fillStyle=e.color,o.font=i.string,Ne(o,e.text,u,h,i)}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeTitleHeight(){const t=<span class="cstat-no" title="statement not covered" >this.options.title,</span>e=<span class="cstat-no" title="statement not covered" >Si(t.font),</span>i=<span class="cstat-no" title="statement not covered" >ki(t.padding);<span class="cstat-no" title="statement not covered" ></span>return t.display?e.lineHeight+i.height:0}<span class="fstat-no" title="function not covered" ></span>_g</span>etLegendItemAt(t,e){let i,s,n;<span class="cstat-no" title="statement not covered" >if(tt(t,this.left,this.right)&amp;&amp;tt(e,this.top,this.bottom))<span class="cstat-no" title="statement not covered" >for(n=this.legendHitBoxes,i=0;i&lt;n.length;++i)<span class="cstat-no" title="statement not covered" >if(s=n[i],tt(t,s.left,s.left+s.width)&amp;&amp;tt(e,s.top,s.top+s.height))<span class="cstat-no" title="statement not covered" >return this.legendItems[i];<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn null}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleEvent(t){const e=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(("mousemove"===t||"mouseout"===t)&amp;&amp;(e.onHover||e.onLeave))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.onClick&amp;&amp;("click"===t||"mouseup"===t))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn!1}</span>(t.type,e))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this._getLegendItemAt(t.x,t.y);<span class="cstat-no" title="statement not covered" ></span>if("mousemove"===t.type||"mouseout"===t.type){const o=<span class="cstat-no" title="statement not covered" >this._hoveredItem,</span>a=(<span class="cstat-no" title="statement not covered" >n=i,null!==(s=o)&amp;&amp;null!==n&amp;&amp;s.datasetIndex===n.datasetIndex&amp;&amp;s.index===n.index)</span>;<span class="cstat-no" title="statement not covered" >o&amp;&amp;!a&amp;&amp;d(e.onLeave,[t,o,this],this),this._hoveredItem=i,i&amp;&amp;!a&amp;&amp;d(e.onHover,[t,i,this],this)}</span>else <span class="cstat-no" title="statement not covered" >i&amp;&amp;d(e.onClick,[t,i,this],this);v</span></span>ar s,n}}function <span class="fstat-no" title="function not covered" >va(</span>t,e){<span class="cstat-no" title="statement not covered" >return e*(t.text?t.text.length:0)}</span>var Ma=<span class="cstat-no" title="statement not covered" >{id:"legend",_element:ya,<span class="fstat-no" title="function not covered" >st</span>art(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.legend=new ya({ctx:t.ctx,options:i,chart:t});<span class="cstat-no" title="statement not covered" ></span>ls.configure(t,s,i),ls.addBox(t,s)}</span>,<span class="fstat-no" title="function not covered" >st</span>op(t){<span class="cstat-no" title="statement not covered" >ls.removeBox(t,t.legend),delete t.legend}</span>,<span class="fstat-no" title="function not covered" >be</span>foreUpdate(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.legend;<span class="cstat-no" title="statement not covered" ></span>ls.configure(t,s,i),s.options=i}</span>,<span class="fstat-no" title="function not covered" >af</span>terUpdate(t){const e=<span class="cstat-no" title="statement not covered" >t.legend;<span class="cstat-no" title="statement not covered" ></span>e.buildLabels(),e.adjustHitBoxes()}</span>,<span class="fstat-no" title="function not covered" >af</span>terEvent(t,e){<span class="cstat-no" title="statement not covered" >e.replay||t.legend.handleEvent(e.event)}</span>,defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,<span class="fstat-no" title="function not covered" >on</span>Click(t,e,i){const s=<span class="cstat-no" title="statement not covered" >e.datasetIndex,</span>n=<span class="cstat-no" title="statement not covered" >i.chart;<span class="cstat-no" title="statement not covered" ></span>n.isDatasetVisible(s)?(n.hide(s),e.hidden=!0):(n.show(s),e.hidden=!1)}</span>,onHover:null,onLeave:null,labels:{color:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.chart.options.color,</span>boxWidth:40,padding:10,<span class="fstat-no" title="function not covered" >ge</span>nerateLabels(t){const e=<span class="cstat-no" title="statement not covered" >t.data.datasets,</span>{labels:{usePointStyle:i,pointStyle:s,textAlign:n,color:o,useBorderRadius:a,borderRadius:r}}=<span class="cstat-no" title="statement not covered" >t.legend.options;<span class="cstat-no" title="statement not covered" ></span>return t._getSortedDatasetMetas().map((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const l=<span class="cstat-no" title="statement not covered" >t.controller.getStyle(i?0:void 0),</span>h=<span class="cstat-no" title="statement not covered" >ki(l.borderWidth);<span class="cstat-no" title="statement not covered" ></span>return{text:e[t.index].label,fillStyle:l.backgroundColor,fontColor:o,hidden:!t.visible,lineCap:l.borderCapStyle,lineDash:l.borderDash,lineDashOffset:l.borderDashOffset,lineJoin:l.borderJoinStyle,lineWidth:(h.width+h.height)/4,strokeStyle:l.borderColor,pointStyle:s||l.pointStyle,rotation:l.rotation,textAlign:n||l.textAlign,borderRadius:a&amp;&amp;(r||l.borderRadius),datasetIndex:t.index}}</span>),this)}</span>},title:{color:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.chart.options.color,</span>display:!1,position:"center",text:""}},descriptors:{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.startsWith("on"),</span>labels:{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!["generateLabels","filter","sort"].includes(t)}</span>}};</span>class wa extends $s{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(this.left=0,this.top=0,!i.display)<span class="cstat-no" title="statement not covered" >return void(this.width=this.height=this.right=this.bottom=0);<span class="cstat-no" title="statement not covered" >t</span></span>his.width=this.right=t,this.height=this.bottom=e;c</span>onst s=<span class="cstat-no" title="statement not covered" >n(i.text)?i.text.length:1;<span class="cstat-no" title="statement not covered" ></span>this._padding=ki(i.padding);c</span>onst o=<span class="cstat-no" title="statement not covered" >s*Si(i.font).lineHeight+this._padding.height;<span class="cstat-no" title="statement not covered" ></span>this.isHorizontal()?this.height=o:this.width=o}<span class="fstat-no" title="function not covered" ></span>is</span>Horizontal(){const t=<span class="cstat-no" title="statement not covered" >this.options.position;<span class="cstat-no" title="statement not covered" ></span>return"top"===t||"bottom"===t}<span class="fstat-no" title="function not covered" ></span>_d</span>rawArgs(t){const{top:e,left:i,bottom:s,right:n,options:o}=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >o.align;</span>let r,l,h,c=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return this.isHorizontal()?(l=ft(a,i,n),h=e+t,r=n-i):("left"===o.position?(l=i+t,h=ft(a,s,e),c=-.5*C):(l=n-t,h=ft(a,e,s),c=.5*C),r=s-e),{titleX:l,titleY:h,maxWidth:r,rotation:c}}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this.ctx,</span>e=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(!e.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >Si(e.font),</span>s=<span class="cstat-no" title="statement not covered" >i.lineHeight/2+this._padding.top,</span>{titleX:n,titleY:o,maxWidth:a,rotation:r}=<span class="cstat-no" title="statement not covered" >this._drawArgs(s);<span class="cstat-no" title="statement not covered" ></span>Ne(t,e.text,0,0,i,{color:e.color,maxWidth:a,rotation:r,textAlign:ut(e.align),textBaseline:"middle",translation:[n,o]})}</span>}var ka=<span class="cstat-no" title="statement not covered" >{id:"title",_element:wa,<span class="fstat-no" title="function not covered" >st</span>art(t,e,i){<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >new wa({ctx:t.ctx,options:e,chart:t});<span class="cstat-no" title="statement not covered" ></span>ls.configure(t,i,e),ls.addBox(t,i),t.titleBlock=i}</span>(t,i)}</span>,<span class="fstat-no" title="function not covered" >st</span>op(t){const e=<span class="cstat-no" title="statement not covered" >t.titleBlock;<span class="cstat-no" title="statement not covered" ></span>ls.removeBox(t,e),delete t.titleBlock}</span>,<span class="fstat-no" title="function not covered" >be</span>foreUpdate(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.titleBlock;<span class="cstat-no" title="statement not covered" ></span>ls.configure(t,s,i),s.options=i}</span>,defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};</span>const Sa=<span class="cstat-no" title="statement not covered" >new WeakMap;</span>var Pa=<span class="cstat-no" title="statement not covered" >{id:"subtitle",<span class="fstat-no" title="function not covered" >st</span>art(t,e,i){const s=<span class="cstat-no" title="statement not covered" >new wa({ctx:t.ctx,options:i,chart:t});<span class="cstat-no" title="statement not covered" ></span>ls.configure(t,s,i),ls.addBox(t,s),Sa.set(t,s)}</span>,<span class="fstat-no" title="function not covered" >st</span>op(t){<span class="cstat-no" title="statement not covered" >ls.removeBox(t,Sa.get(t)),Sa.delete(t)}</span>,<span class="fstat-no" title="function not covered" >be</span>foreUpdate(t,e,i){const s=<span class="cstat-no" title="statement not covered" >Sa.get(t);<span class="cstat-no" title="statement not covered" ></span>ls.configure(t,s,i),s.options=i}</span>,defaults:{align:"center",display:!1,font:{weight:"normal"},fullSize:!0,padding:0,position:"top",text:"",weight:1500},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};</span>const Da=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >av</span>erage(t){<span class="cstat-no" title="statement not covered" >if(!t.length)<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et e,i,s=<span class="cstat-no" title="statement not covered" >new Set,</span>n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(e=0,i=t.length;e&lt;i;++e){const i=<span class="cstat-no" title="statement not covered" >t[e].element;<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;i.hasValue()){const t=<span class="cstat-no" title="statement not covered" >i.tooltipPosition();<span class="cstat-no" title="statement not covered" ></span>s.add(t.x),n+=t.y,++o}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0===o||0===s.size)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{x:[...s].reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t+e)</span>)/s.size,y:n/o}}</span>,<span class="fstat-no" title="function not covered" >ne</span>arest(t,e){<span class="cstat-no" title="statement not covered" >if(!t.length)<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et i,s,n,o=<span class="cstat-no" title="statement not covered" >e.x,</span>a=<span class="cstat-no" title="statement not covered" >e.y,</span>r=<span class="cstat-no" title="statement not covered" >Number.POSITIVE_INFINITY;<span class="cstat-no" title="statement not covered" ></span>for(i=0,s=t.length;i&lt;s;++i){const s=<span class="cstat-no" title="statement not covered" >t[i].element;<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;s.hasValue()){const t=<span class="cstat-no" title="statement not covered" >q(e,s.getCenterPoint());<span class="cstat-no" title="statement not covered" ></span>t&lt;r&amp;&amp;(r=t,n=s)}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n){const t=<span class="cstat-no" title="statement not covered" >n.tooltipPosition();<span class="cstat-no" title="statement not covered" ></span>o=t.x,a=t.y}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{x:o,y:a}}</span>};</span>function <span class="fstat-no" title="function not covered" >Ca(</span>t,e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;(n(e)?Array.prototype.push.apply(t,e):t.push(e)),t}</span>function <span class="fstat-no" title="function not covered" >Oa(</span>t){<span class="cstat-no" title="statement not covered" >return("string"==typeof t||t instanceof String)&amp;&amp;t.indexOf("\n")&gt;-1?t.split("\n"):t}</span>function <span class="fstat-no" title="function not covered" >Aa(</span>t,e){const{element:i,datasetIndex:s,index:n}=<span class="cstat-no" title="statement not covered" >e,</span>o=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(s).controller,</span>{label:a,value:r}=<span class="cstat-no" title="statement not covered" >o.getLabelAndValue(n);<span class="cstat-no" title="statement not covered" ></span>return{chart:t,label:a,parsed:o.getParsed(n),raw:t.data.datasets[s].data[n],formattedValue:r,dataset:o.getDataset(),dataIndex:n,datasetIndex:s,element:i}}</span>function <span class="fstat-no" title="function not covered" >Ta(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.chart.ctx,</span>{body:s,footer:n,title:o}=<span class="cstat-no" title="statement not covered" >t,</span>{boxWidth:a,boxHeight:r}=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" >Si(e.bodyFont),</span>h=<span class="cstat-no" title="statement not covered" >Si(e.titleFont),</span>c=<span class="cstat-no" title="statement not covered" >Si(e.footerFont),</span>d=<span class="cstat-no" title="statement not covered" >o.length,</span>f=<span class="cstat-no" title="statement not covered" >n.length,</span>g=<span class="cstat-no" title="statement not covered" >s.length,</span>p=<span class="cstat-no" title="statement not covered" >ki(e.padding);</span>let m=<span class="cstat-no" title="statement not covered" >p.height,</span>x=<span class="cstat-no" title="statement not covered" >0,</span>b=<span class="cstat-no" title="statement not covered" >s.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t+e.before.length+e.lines.length+e.after.length)</span>,0);<span class="cstat-no" title="statement not covered" ></span>if(b+=t.beforeBody.length+t.afterBody.length,d&amp;&amp;(m+=d*h.lineHeight+(d-1)*e.titleSpacing+e.titleMarginBottom),b){<span class="cstat-no" title="statement not covered" >m+=g*(e.displayColors?Math.max(r,l.lineHeight):l.lineHeight)+(b-g)*l.lineHeight+(b-1)*e.bodySpacing}<span class="cstat-no" title="statement not covered" ></span>f</span>&amp;&amp;(m+=e.footerMarginTop+f*c.lineHeight+(f-1)*e.footerSpacing);l</span>et _=<span class="cstat-no" title="statement not covered" >0;</span>const y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >x=Math.max(x,i.measureText(t).width+_)}</span>;<span class="cstat-no" title="statement not covered" ></span>return i.save(),i.font=h.string,u(t.title,y),i.font=l.string,u(t.beforeBody.concat(t.afterBody),y),_=e.displayColors?a+2+e.boxPadding:0,u(s,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >u(t.before,y),u(t.lines,y),u(t.after,y)}</span>)),_=0,i.font=c.string,u(t.footer,y),i.restore(),x+=p.width,{width:x,height:m}}</span>function <span class="fstat-no" title="function not covered" >La(</span>t,e,i,s){const{x:n,width:o}=<span class="cstat-no" title="statement not covered" >i,</span>{width:a,chartArea:{left:r,right:l}}=<span class="cstat-no" title="statement not covered" >t;</span>let h=<span class="cstat-no" title="statement not covered" >"center";<span class="cstat-no" title="statement not covered" ></span>return"center"===s?h=n&lt;=(r+l)/2?"left":"right":n&lt;=o/2?h="left":n&gt;=a-o/2&amp;&amp;(h="right"),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{x:n,width:o}=<span class="cstat-no" title="statement not covered" >s,</span>a=<span class="cstat-no" title="statement not covered" >i.caretSize+i.caretPadding;<span class="cstat-no" title="statement not covered" ></span>return"left"===t&amp;&amp;n+o+a&gt;e.width||"right"===t&amp;&amp;n-o-a&lt;0||void 0}</span>(h,t,e,i)&amp;&amp;(h="center"),h}</span>function <span class="fstat-no" title="function not covered" >Ea(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >i.yAlign||e.yAlign||<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{y:i,height:s}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return i&lt;s/2?"top":i&gt;t.height-s/2?"bottom":"center"}</span>(t,i);<span class="cstat-no" title="statement not covered" ></span>return{xAlign:i.xAlign||e.xAlign||La(t,e,i,s),yAlign:s}}</span>function <span class="fstat-no" title="function not covered" >Ra(</span>t,e,i,s){const{caretSize:n,caretPadding:o,cornerRadius:a}=<span class="cstat-no" title="statement not covered" >t,</span>{xAlign:r,yAlign:l}=<span class="cstat-no" title="statement not covered" >i,</span>h=<span class="cstat-no" title="statement not covered" >n+o,</span>{topLeft:c,topRight:d,bottomLeft:u,bottomRight:f}=<span class="cstat-no" title="statement not covered" >wi(a);</span>let g=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let{x:i,width:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return"right"===e?i-=s:"center"===e&amp;&amp;(i-=s/2),i}</span>(e,r);</span>const p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let{y:s,height:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return"top"===e?s+=i:s-="bottom"===e?n+i:n/2,s}</span>(e,l,h);<span class="cstat-no" title="statement not covered" ></span>return"center"===l?"left"===r?g+=h:"right"===r&amp;&amp;(g-=h):"left"===r?g-=Math.max(c,u)+n:"right"===r&amp;&amp;(g+=Math.max(d,f)+n),{x:Z(g,0,s.width-e.width),y:Z(p,0,s.height-e.height)}}</span>function <span class="fstat-no" title="function not covered" >Ia(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >ki(i.padding);<span class="cstat-no" title="statement not covered" ></span>return"center"===e?t.x+t.width/2:"right"===e?t.x+t.width-s.right:t.x+s.left}</span>function <span class="fstat-no" title="function not covered" >za(</span>t){<span class="cstat-no" title="statement not covered" >return Ca([],Oa(t))}</span>function <span class="fstat-no" title="function not covered" >Fa(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.dataset&amp;&amp;e.dataset.tooltip&amp;&amp;e.dataset.tooltip.callbacks;<span class="cstat-no" title="statement not covered" ></span>return i?t.override(i):t}</span>const Va=<span class="cstat-no" title="statement not covered" >{beforeTitle:e,<span class="fstat-no" title="function not covered" >ti</span>tle(t){<span class="cstat-no" title="statement not covered" >if(t.length&gt;0){const e=<span class="cstat-no" title="statement not covered" >t[0],</span>i=<span class="cstat-no" title="statement not covered" >e.chart.data.labels,</span>s=<span class="cstat-no" title="statement not covered" >i?i.length:0;<span class="cstat-no" title="statement not covered" ></span>if(this&amp;&amp;this.options&amp;&amp;"dataset"===this.options.mode)<span class="cstat-no" title="statement not covered" >return e.dataset.label||"";<span class="cstat-no" title="statement not covered" >i</span></span>f(e.label)<span class="cstat-no" title="statement not covered" >return e.label;<span class="cstat-no" title="statement not covered" >i</span></span>f(s&gt;0&amp;&amp;e.dataIndex&lt;s)<span class="cstat-no" title="statement not covered" >return i[e.dataIndex]}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn""}</span>,afterTitle:e,beforeBody:e,beforeLabel:e,<span class="fstat-no" title="function not covered" >la</span>bel(t){<span class="cstat-no" title="statement not covered" >if(this&amp;&amp;this.options&amp;&amp;"dataset"===this.options.mode)<span class="cstat-no" title="statement not covered" >return t.label+": "+t.formattedValue||t.formattedValue;l</span></span>et e=<span class="cstat-no" title="statement not covered" >t.dataset.label||"";<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(e+=": ");c</span>onst i=<span class="cstat-no" title="statement not covered" >t.formattedValue;<span class="cstat-no" title="statement not covered" ></span>return s(i)||(e+=i),e}</span>,<span class="fstat-no" title="function not covered" >la</span>belColor(t){const e=<span class="cstat-no" title="statement not covered" >t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);<span class="cstat-no" title="statement not covered" ></span>return{borderColor:e.borderColor,backgroundColor:e.backgroundColor,borderWidth:e.borderWidth,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderRadius:0}}</span>,<span class="fstat-no" title="function not covered" >la</span>belTextColor(){<span class="cstat-no" title="statement not covered" >return this.options.bodyColor}</span>,<span class="fstat-no" title="function not covered" >la</span>belPointStyle(t){const e=<span class="cstat-no" title="statement not covered" >t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);<span class="cstat-no" title="statement not covered" ></span>return{pointStyle:e.pointStyle,rotation:e.rotation}}</span>,afterLabel:e,afterBody:e,beforeFooter:e,footer:e,afterFooter:e};</span>function <span class="fstat-no" title="function not covered" >Ba(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t[e].call(i,s);<span class="cstat-no" title="statement not covered" ></span>return void 0===n?Va[e].call(i,s):n}</span>class Wa extends $s{static positioners=<span class="cstat-no" title="statement not covered" >Da;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=t.chart,this.options=t.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}<span class="fstat-no" title="function not covered" ></span>in</span>itialize(t){<span class="cstat-no" title="statement not covered" >this.options=t,this._cachedAnimations=void 0,this.$context=void 0}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveAnimations(){const t=<span class="cstat-no" title="statement not covered" >this._cachedAnimations;<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.chart,</span>i=<span class="cstat-no" title="statement not covered" >this.options.setContext(this.getContext()),</span>s=<span class="cstat-no" title="statement not covered" >i.enabled&amp;&amp;e.options.animation&amp;&amp;i.animations,</span>n=<span class="cstat-no" title="statement not covered" >new Ts(this.chart,s);<span class="cstat-no" title="statement not covered" ></span>return s._cacheable&amp;&amp;(this._cachedAnimations=Object.freeze(n)),n}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(){<span class="cstat-no" title="statement not covered" >return this.$context||(this.$context=(t=this.chart.getContext(),e=this,i=this._tooltipItems,Ci(t,{tooltip:e,tooltipItems:i,type:"tooltip"})));v</span>ar t,e,i}<span class="fstat-no" title="function not covered" >ge</span>tTitle(t,e){const{callbacks:i}=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >Ba(i,"beforeTitle",this,t),</span>n=<span class="cstat-no" title="statement not covered" >Ba(i,"title",this,t),</span>o=<span class="cstat-no" title="statement not covered" >Ba(i,"afterTitle",this,t);</span>let a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return a=Ca(a,Oa(s)),a=Ca(a,Oa(n)),a=Ca(a,Oa(o)),a}<span class="fstat-no" title="function not covered" ></span>ge</span>tBeforeBody(t,e){<span class="cstat-no" title="statement not covered" >return za(Ba(e.callbacks,"beforeBody",this,t))}<span class="fstat-no" title="function not covered" ></span>ge</span>tBody(t,e){const{callbacks:i}=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return u(t,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >{before:[],lines:[],after:[]},</span>n=<span class="cstat-no" title="statement not covered" >Fa(i,t);<span class="cstat-no" title="statement not covered" ></span>Ca(e.before,Oa(Ba(n,"beforeLabel",this,t))),Ca(e.lines,Ba(n,"label",this,t)),Ca(e.after,Oa(Ba(n,"afterLabel",this,t))),s.push(e)}</span>)),s}<span class="fstat-no" title="function not covered" ></span>ge</span>tAfterBody(t,e){<span class="cstat-no" title="statement not covered" >return za(Ba(e.callbacks,"afterBody",this,t))}<span class="fstat-no" title="function not covered" ></span>ge</span>tFooter(t,e){const{callbacks:i}=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >Ba(i,"beforeFooter",this,t),</span>n=<span class="cstat-no" title="statement not covered" >Ba(i,"footer",this,t),</span>o=<span class="cstat-no" title="statement not covered" >Ba(i,"afterFooter",this,t);</span>let a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return a=Ca(a,Oa(s)),a=Ca(a,Oa(n)),a=Ca(a,Oa(o)),a}<span class="fstat-no" title="function not covered" ></span>_c</span>reateItems(t){const e=<span class="cstat-no" title="statement not covered" >this._active,</span>i=<span class="cstat-no" title="statement not covered" >this.chart.data,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >[];</span>let a,r,l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(a=0,r=e.length;a&lt;r;++a)<span class="cstat-no" title="statement not covered" >l.push(Aa(this.chart,e[a]));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.filter&amp;&amp;(l=l.filter((<span class="fstat-no" title="function not covered" >(e</span>,s,n)=&gt;<span class="cstat-no" title="statement not covered" >t.filter(e,s,n,i))</span>)),t.itemSort&amp;&amp;(l=l.sort((<span class="fstat-no" title="function not covered" >(e</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t.itemSort(e,s,i))</span>)),u(l,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >Fa(t.callbacks,e);<span class="cstat-no" title="statement not covered" ></span>s.push(Ba(i,"labelColor",this,e)),n.push(Ba(i,"labelPointStyle",this,e)),o.push(Ba(i,"labelTextColor",this,e))}</span>)),this.labelColors=s,this.labelPointStyles=n,this.labelTextColors=o,this.dataPoints=l,l}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options.setContext(this.getContext()),</span>s=<span class="cstat-no" title="statement not covered" >this._active;</span>let n,o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(s.length){const t=<span class="cstat-no" title="statement not covered" >Da[i.position].call(this,s,this._eventPosition);<span class="cstat-no" title="statement not covered" ></span>o=this._createItems(i),this.title=this.getTitle(o,i),this.beforeBody=this.getBeforeBody(o,i),this.body=this.getBody(o,i),this.afterBody=this.getAfterBody(o,i),this.footer=this.getFooter(o,i);c</span>onst e=<span class="cstat-no" title="statement not covered" >this._size=Ta(this,i),</span>a=<span class="cstat-no" title="statement not covered" >Object.assign({},t,e),</span>r=<span class="cstat-no" title="statement not covered" >Ea(this.chart,i,a),</span>l=<span class="cstat-no" title="statement not covered" >Ra(i,a,r,this.chart);<span class="cstat-no" title="statement not covered" ></span>this.xAlign=r.xAlign,this.yAlign=r.yAlign,n={opacity:1,x:l.x,y:l.y,width:e.width,height:e.height,caretX:t.x,caretY:t.y}}</span>else <span class="cstat-no" title="statement not covered" >0!==this.opacity&amp;&amp;(n={opacity:0});<span class="cstat-no" title="statement not covered" >t</span></span>his._tooltipItems=o,this.$context=void 0,n&amp;&amp;this._resolveAnimations().update(this,n),t&amp;&amp;i.external&amp;&amp;i.external.call(this,{chart:this.chart,tooltip:this,replay:e})}<span class="fstat-no" title="function not covered" ></span>dr</span>awCaret(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.getCaretPosition(t,i,s);<span class="cstat-no" title="statement not covered" ></span>e.lineTo(n.x1,n.y1),e.lineTo(n.x2,n.y2),e.lineTo(n.x3,n.y3)}<span class="fstat-no" title="function not covered" ></span>ge</span>tCaretPosition(t,e,i){const{xAlign:s,yAlign:n}=<span class="cstat-no" title="statement not covered" >this,</span>{caretSize:o,cornerRadius:a}=<span class="cstat-no" title="statement not covered" >i,</span>{topLeft:r,topRight:l,bottomLeft:h,bottomRight:c}=<span class="cstat-no" title="statement not covered" >wi(a),</span>{x:d,y:u}=<span class="cstat-no" title="statement not covered" >t,</span>{width:f,height:g}=<span class="cstat-no" title="statement not covered" >e;</span>let p,m,x,b,_,y;<span class="cstat-no" title="statement not covered" >return"center"===n?(_=u+g/2,"left"===s?(p=d,m=p-o,b=_+o,y=_-o):(p=d+f,m=p+o,b=_-o,y=_+o),x=p):(m="left"===s?d+Math.max(r,h)+o:"right"===s?d+f-Math.max(l,c)-o:this.caretX,"top"===n?(b=u,_=b-o,p=m-o,x=m+o):(b=u+g,_=b+o,p=m+o,x=m-o),y=b),{x1:p,x2:m,x3:x,y1:b,y2:_,y3:y}}<span class="fstat-no" title="function not covered" ></span>dr</span>awTitle(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.title,</span>n=<span class="cstat-no" title="statement not covered" >s.length;</span>let o,a,r;<span class="cstat-no" title="statement not covered" >if(n){const l=<span class="cstat-no" title="statement not covered" >Oi(i.rtl,this.x,this.width);<span class="cstat-no" title="statement not covered" ></span>for(t.x=Ia(this,i.titleAlign,i),e.textAlign=l.textAlign(i.titleAlign),e.textBaseline="middle",o=Si(i.titleFont),a=i.titleSpacing,e.fillStyle=i.titleColor,e.font=o.string,r=0;r&lt;n;++r)<span class="cstat-no" title="statement not covered" >e.fillText(s[r],l.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+a,r+1===n&amp;&amp;(t.y+=i.titleMarginBottom-a)}</span></span>}<span class="fstat-no" title="function not covered" ></span>_d</span>rawColorBox(t,e,i,s,n){const a=<span class="cstat-no" title="statement not covered" >this.labelColors[i],</span>r=<span class="cstat-no" title="statement not covered" >this.labelPointStyles[i],</span>{boxHeight:l,boxWidth:h}=<span class="cstat-no" title="statement not covered" >n,</span>c=<span class="cstat-no" title="statement not covered" >Si(n.bodyFont),</span>d=<span class="cstat-no" title="statement not covered" >Ia(this,"left",n),</span>u=<span class="cstat-no" title="statement not covered" >s.x(d),</span>f=<span class="cstat-no" title="statement not covered" >l&lt;c.lineHeight?(c.lineHeight-l)/2:0,</span>g=<span class="cstat-no" title="statement not covered" >e.y+f;<span class="cstat-no" title="statement not covered" ></span>if(n.usePointStyle){const e=<span class="cstat-no" title="statement not covered" >{radius:Math.min(h,l)/2,pointStyle:r.pointStyle,rotation:r.rotation,borderWidth:1},</span>i=<span class="cstat-no" title="statement not covered" >s.leftForLtr(u,h)+h/2,</span>o=<span class="cstat-no" title="statement not covered" >g+l/2;<span class="cstat-no" title="statement not covered" ></span>t.strokeStyle=n.multiKeyBackground,t.fillStyle=n.multiKeyBackground,Le(t,e,i,o),t.strokeStyle=a.borderColor,t.fillStyle=a.backgroundColor,Le(t,e,i,o)}</span>else{<span class="cstat-no" title="statement not covered" >t.lineWidth=o(a.borderWidth)?Math.max(...Object.values(a.borderWidth)):a.borderWidth||1,t.strokeStyle=a.borderColor,t.setLineDash(a.borderDash||[]),t.lineDashOffset=a.borderDashOffset||0;c</span>onst e=<span class="cstat-no" title="statement not covered" >s.leftForLtr(u,h),</span>i=<span class="cstat-no" title="statement not covered" >s.leftForLtr(s.xPlus(u,1),h-2),</span>r=<span class="cstat-no" title="statement not covered" >wi(a.borderRadius);<span class="cstat-no" title="statement not covered" ></span>Object.values(r).some((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0!==t)</span>)?(t.beginPath(),t.fillStyle=n.multiKeyBackground,He(t,{x:e,y:g,w:h,h:l,radius:r}),t.fill(),t.stroke(),t.fillStyle=a.backgroundColor,t.beginPath(),He(t,{x:i,y:g+1,w:h-2,h:l-2,radius:r}),t.fill()):(t.fillStyle=n.multiKeyBackground,t.fillRect(e,g,h,l),t.strokeRect(e,g,h,l),t.fillStyle=a.backgroundColor,t.fillRect(i,g+1,h-2,l-2))}<span class="cstat-no" title="statement not covered" ></span>t</span>.fillStyle=this.labelTextColors[i]}<span class="fstat-no" title="function not covered" ></span>dr</span>awBody(t,e,i){const{body:s}=<span class="cstat-no" title="statement not covered" >this,</span>{bodySpacing:n,bodyAlign:o,displayColors:a,boxHeight:r,boxWidth:l,boxPadding:h}=<span class="cstat-no" title="statement not covered" >i,</span>c=<span class="cstat-no" title="statement not covered" >Si(i.bodyFont);</span>let d=<span class="cstat-no" title="statement not covered" >c.lineHeight,</span>f=<span class="cstat-no" title="statement not covered" >0;</span>const g=<span class="cstat-no" title="statement not covered" >Oi(i.rtl,this.x,this.width),</span>p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >e.fillText(i,g.x(t.x+f),t.y+d/2),t.y+=d+n}</span>,</span>m=<span class="cstat-no" title="statement not covered" >g.textAlign(o);</span>let x,b,_,y,v,M,w;<span class="cstat-no" title="statement not covered" >for(e.textAlign=o,e.textBaseline="middle",e.font=c.string,t.x=Ia(this,m,i),e.fillStyle=i.bodyColor,u(this.beforeBody,p),f=a&amp;&amp;"right"!==m?"center"===o?l/2+h:l+2+h:0,y=0,M=s.length;y&lt;M;++y){<span class="cstat-no" title="statement not covered" >for(x=s[y],b=this.labelTextColors[y],e.fillStyle=b,u(x.before,p),_=x.lines,a&amp;&amp;_.length&amp;&amp;(this._drawColorBox(e,t,y,g,i),d=Math.max(c.lineHeight,r)),v=0,w=_.length;v&lt;w;++v)<span class="cstat-no" title="statement not covered" >p(_[v]),d=c.lineHeight;<span class="cstat-no" title="statement not covered" >u</span></span>(x.after,p)}<span class="cstat-no" title="statement not covered" ></span>f</span>=0,d=c.lineHeight,u(this.afterBody,p),t.y-=n}<span class="fstat-no" title="function not covered" ></span>dr</span>awFooter(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.footer,</span>n=<span class="cstat-no" title="statement not covered" >s.length;</span>let o,a;<span class="cstat-no" title="statement not covered" >if(n){const r=<span class="cstat-no" title="statement not covered" >Oi(i.rtl,this.x,this.width);<span class="cstat-no" title="statement not covered" ></span>for(t.x=Ia(this,i.footerAlign,i),t.y+=i.footerMarginTop,e.textAlign=r.textAlign(i.footerAlign),e.textBaseline="middle",o=Si(i.footerFont),e.fillStyle=i.footerColor,e.font=o.string,a=0;a&lt;n;++a)<span class="cstat-no" title="statement not covered" >e.fillText(s[a],r.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+i.footerSpacing}</span></span>}<span class="fstat-no" title="function not covered" ></span>dr</span>awBackground(t,e,i,s){const{xAlign:n,yAlign:o}=<span class="cstat-no" title="statement not covered" >this,</span>{x:a,y:r}=<span class="cstat-no" title="statement not covered" >t,</span>{width:l,height:h}=<span class="cstat-no" title="statement not covered" >i,</span>{topLeft:c,topRight:d,bottomLeft:u,bottomRight:f}=<span class="cstat-no" title="statement not covered" >wi(s.cornerRadius);<span class="cstat-no" title="statement not covered" ></span>e.fillStyle=s.backgroundColor,e.strokeStyle=s.borderColor,e.lineWidth=s.borderWidth,e.beginPath(),e.moveTo(a+c,r),"top"===o&amp;&amp;this.drawCaret(t,e,i,s),e.lineTo(a+l-d,r),e.quadraticCurveTo(a+l,r,a+l,r+d),"center"===o&amp;&amp;"right"===n&amp;&amp;this.drawCaret(t,e,i,s),e.lineTo(a+l,r+h-f),e.quadraticCurveTo(a+l,r+h,a+l-f,r+h),"bottom"===o&amp;&amp;this.drawCaret(t,e,i,s),e.lineTo(a+u,r+h),e.quadraticCurveTo(a,r+h,a,r+h-u),"center"===o&amp;&amp;"left"===n&amp;&amp;this.drawCaret(t,e,i,s),e.lineTo(a,r+c),e.quadraticCurveTo(a,r,a+c,r),e.closePath(),e.fill(),s.borderWidth&gt;0&amp;&amp;e.stroke()}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateAnimationTarget(t){const e=<span class="cstat-no" title="statement not covered" >this.chart,</span>i=<span class="cstat-no" title="statement not covered" >this.$animations,</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.x,</span>n=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.y;<span class="cstat-no" title="statement not covered" ></span>if(s||n){const i=<span class="cstat-no" title="statement not covered" >Da[t.position].call(this,this._active,this._eventPosition);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >this._size=Ta(this,t),</span>a=<span class="cstat-no" title="statement not covered" >Object.assign({},i,this._size),</span>r=<span class="cstat-no" title="statement not covered" >Ea(e,t,a),</span>l=<span class="cstat-no" title="statement not covered" >Ra(t,a,r,e);<span class="cstat-no" title="statement not covered" ></span>s._to===l.x&amp;&amp;n._to===l.y||(this.xAlign=r.xAlign,this.yAlign=r.yAlign,this.width=o.width,this.height=o.height,this.caretX=i.x,this.caretY=i.y,this._resolveAnimations().update(this,l))}</span>}<span class="fstat-no" title="function not covered" ></span>_w</span>illRender(){<span class="cstat-no" title="statement not covered" >return!!this.opacity}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){const e=<span class="cstat-no" title="statement not covered" >this.options.setContext(this.getContext());</span>let i=<span class="cstat-no" title="statement not covered" >this.opacity;<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his._updateAnimationTarget(e);c</span>onst s=<span class="cstat-no" title="statement not covered" >{width:this.width,height:this.height},</span>n=<span class="cstat-no" title="statement not covered" >{x:this.x,y:this.y};<span class="cstat-no" title="statement not covered" ></span>i=Math.abs(i)&lt;.001?0:i;c</span>onst o=<span class="cstat-no" title="statement not covered" >ki(e.padding),</span>a=<span class="cstat-no" title="statement not covered" >this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;<span class="cstat-no" title="statement not covered" ></span>e.enabled&amp;&amp;a&amp;&amp;(t.save(),t.globalAlpha=i,this.drawBackground(n,t,s,e),Ai(t,e.textDirection),n.y+=o.top,this.drawTitle(n,t,e),this.drawBody(n,t,e),this.drawFooter(n,t,e),Ti(t,e.textDirection),t.restore())}<span class="fstat-no" title="function not covered" ></span>ge</span>tActiveElements(){<span class="cstat-no" title="statement not covered" >return this._active||[]}<span class="fstat-no" title="function not covered" ></span>se</span>tActiveElements(t,e){const i=<span class="cstat-no" title="statement not covered" >this._active,</span>s=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >({</span>datasetIndex:t,index:e})=&gt;{const i=<span class="cstat-no" title="statement not covered" >this.chart.getDatasetMeta(t);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >throw new Error("Cannot find a dataset at index "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{datasetIndex:t,element:i.data[e],index:e}}</span>)),</span>n=<span class="cstat-no" title="statement not covered" >!f(i,s),</span>o=<span class="cstat-no" title="statement not covered" >this._positionChanged(s,e);<span class="cstat-no" title="statement not covered" ></span>(n||o)&amp;&amp;(this._active=s,this._eventPosition=e,this._ignoreReplayEvents=!0,this.update(!0))}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleEvent(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;this._ignoreReplayEvents)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >t</span></span>his._ignoreReplayEvents=!1;c</span>onst s=<span class="cstat-no" title="statement not covered" >this.options,</span>n=<span class="cstat-no" title="statement not covered" >this._active||[],</span>o=<span class="cstat-no" title="statement not covered" >this._getActiveElements(t,n,e,i),</span>a=<span class="cstat-no" title="statement not covered" >this._positionChanged(o,t),</span>r=<span class="cstat-no" title="statement not covered" >e||!f(o,n)||a;<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;(this._active=o,(s.enabled||s.external)&amp;&amp;(this._eventPosition={x:t.x,y:t.y},this.update(!0,e))),r}<span class="fstat-no" title="function not covered" ></span>_g</span>etActiveElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if("mouseout"===t.type)<span class="cstat-no" title="statement not covered" >return[];<span class="cstat-no" title="statement not covered" >i</span></span>f(!s)<span class="cstat-no" title="statement not covered" >return e.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.chart.data.datasets[t.datasetIndex]&amp;&amp;void 0!==this.chart.getDatasetMeta(t.datasetIndex).controller.getParsed(t.index))</span>);c</span></span>onst o=<span class="cstat-no" title="statement not covered" >this.chart.getElementsAtEventForMode(t,n.mode,n,i);<span class="cstat-no" title="statement not covered" ></span>return n.reverse&amp;&amp;o.reverse(),o}<span class="fstat-no" title="function not covered" ></span>_p</span>ositionChanged(t,e){const{caretX:i,caretY:s,options:n}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >Da[n.position].call(this,t,e);<span class="cstat-no" title="statement not covered" ></span>return!1!==o&amp;&amp;(i!==o.x||s!==o.y)}</span>}var Na=<span class="cstat-no" title="statement not covered" >{id:"tooltip",_element:Wa,positioners:Da,<span class="fstat-no" title="function not covered" >af</span>terInit(t,e,i){<span class="cstat-no" title="statement not covered" >i&amp;&amp;(t.tooltip=new Wa({chart:t,options:i}))}</span>,<span class="fstat-no" title="function not covered" >be</span>foreUpdate(t,e,i){<span class="cstat-no" title="statement not covered" >t.tooltip&amp;&amp;t.tooltip.initialize(i)}</span>,<span class="fstat-no" title="function not covered" >re</span>set(t,e,i){<span class="cstat-no" title="statement not covered" >t.tooltip&amp;&amp;t.tooltip.initialize(i)}</span>,<span class="fstat-no" title="function not covered" >af</span>terDraw(t){const e=<span class="cstat-no" title="statement not covered" >t.tooltip;<span class="cstat-no" title="statement not covered" ></span>if(e&amp;&amp;e._willRender()){const i=<span class="cstat-no" title="statement not covered" >{tooltip:e};<span class="cstat-no" title="statement not covered" ></span>if(!1===t.notifyPlugins("beforeTooltipDraw",{...i,cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >e</span></span>.draw(t.ctx),t.notifyPlugins("afterTooltipDraw",i)}</span>}</span>,<span class="fstat-no" title="function not covered" >af</span>terEvent(t,e){<span class="cstat-no" title="statement not covered" >if(t.tooltip){const i=<span class="cstat-no" title="statement not covered" >e.replay;<span class="cstat-no" title="statement not covered" ></span>t.tooltip.handleEvent(e.event,i,e.inChartArea)&amp;&amp;(e.changed=!0)}</span>}</span>,defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.bodyFont.size,</span>boxWidth:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.bodyFont.size,</span>multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:Va},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"filter"!==t&amp;&amp;"itemSort"!==t&amp;&amp;"external"!==t,</span>_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};<span class="cstat-no" title="statement not covered" ></span>return Tn.register(Un,$o,go,t),Tn.helpers={...Hi},Tn._adapters=In,Tn.Animation=As,Tn.Animations=Ts,Tn.animator=bt,Tn.controllers=nn.controllers.items,Tn.DatasetController=js,Tn.Element=$s,Tn.elements=go,Tn.Interaction=Ki,Tn.layouts=ls,Tn.platforms=Ds,Tn.Scale=tn,Tn.Ticks=ae,Object.assign(Tn,Un,$o,go,t,Ds),Tn.Chart=Tn,"undefined"!=typeof window&amp;&amp;(window.Chart=Tn),Tn}</span>));
//# sourceMappingURL=chart.umd.min.js.map
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-08-19T11:01:38.619Z
            </div>
        <script src="../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../sorter.js"></script>
        <script src="../../block-navigation.js"></script>
    </body>
</html>
    