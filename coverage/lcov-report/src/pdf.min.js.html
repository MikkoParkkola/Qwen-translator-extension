
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for src/pdf.min.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../prettify.css" />
    <link rel="stylesheet" href="../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../index.html">All files</a> / <a href="index.html">src</a> pdf.min.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/9399</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/4131</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/1471</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2023 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */
<span class="cstat-no" title="statement not covered" >!function <span class="fstat-no" title="function not covered" >webpackUniversalModuleDefinition(</span>t,e){<span class="cstat-no" title="statement not covered" >"object"==typeof exports&amp;&amp;"object"==typeof module?module.exports=t.pdfjsLib=e():"function"==typeof define&amp;&amp;define.amd?define("pdfjs-dist/build/pdf",[],(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.pdfjsLib=e())</span>):"object"==typeof exports?exports["pdfjs-dist/build/pdf"]=t.pdfjsLib=e():t["pdfjs-dist/build/pdf"]=t.pdfjsLib=e()}</span>(globalThis,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >()</span>=&gt;{"use strict";var __webpack_modules__=<span class="cstat-no" title="statement not covered" >[,<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.VerbosityLevel=e.Util=e.UnknownErrorException=e.UnexpectedResponseException=e.TextRenderingMode=e.RenderingIntentFlag=e.PromiseCapability=e.PermissionFlag=e.PasswordResponses=e.PasswordException=e.PageActionEventType=e.OPS=e.MissingPDFException=e.MAX_IMAGE_SIZE_TO_CACHE=e.LINE_FACTOR=e.LINE_DESCENT_FACTOR=e.InvalidPDFException=e.ImageKind=e.IDENTITY_MATRIX=e.FormatError=e.FeatureTest=e.FONT_IDENTITY_MATRIX=e.DocumentActionEventType=e.CMapCompressionType=e.BaseException=e.BASELINE_FACTOR=e.AnnotationType=e.AnnotationReplyType=e.AnnotationMode=e.AnnotationFlag=e.AnnotationFieldFlag=e.AnnotationEditorType=e.AnnotationEditorPrefix=e.AnnotationEditorParamsType=e.AnnotationBorderStyleType=e.AnnotationActionEventType=e.AbortException=void 0;<span class="cstat-no" title="statement not covered" >e</span>.assert=function <span class="fstat-no" title="function not covered" >assert(</span>t,e){<span class="cstat-no" title="statement not covered" >t||unreachable(e)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.bytesToString=bytesToString;<span class="cstat-no" title="statement not covered" >e</span>.createValidAbsoluteUrl=function <span class="fstat-no" title="function not covered" >createValidAbsoluteUrl(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >if(i&amp;&amp;"string"==typeof t){<span class="cstat-no" title="statement not covered" >if(i.addDefaultProtocol&amp;&amp;t.startsWith("www.")){const e=<span class="cstat-no" title="statement not covered" >t.match(/\./g);<span class="cstat-no" title="statement not covered" ></span>e?.length&gt;=2&amp;&amp;(t=`http://${t}`)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i.tryConvertEncoding)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t=stringToUTF8String(t)}</span>catch{}}</span></span>c</span>onst s=<span class="cstat-no" title="statement not covered" >e?new URL(t,e):new URL(t);<span class="cstat-no" title="statement not covered" ></span>if(function <span class="fstat-no" title="function not covered" >_isValidProtocol(</span>t){<span class="cstat-no" title="statement not covered" >switch(t?.protocol){case"http:":case"https:":case"ftp:":case"mailto:":case"tel:":<span class="cstat-no" title="statement not covered" >return!0;d</span>efault:<span class="cstat-no" title="statement not covered" >return!1}</span>}</span>(s))<span class="cstat-no" title="statement not covered" >return s}</span></span>catch{}<span class="cstat-no" title="statement not covered" >r</span>eturn null}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getModificationDate=function <span class="fstat-no" title="function not covered" >getModificationDate(</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >new Date)</span>{<span class="cstat-no" title="statement not covered" >return[t.getUTCFullYear().toString(),(t.getUTCMonth()+1).toString().padStart(2,"0"),t.getUTCDate().toString().padStart(2,"0"),t.getUTCHours().toString().padStart(2,"0"),t.getUTCMinutes().toString().padStart(2,"0"),t.getUTCSeconds().toString().padStart(2,"0")].join("")}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getUuid=function <span class="fstat-no" title="function not covered" >getUuid(</span>){<span class="cstat-no" title="statement not covered" >if("undefined"!=typeof crypto&amp;&amp;"function"==typeof crypto?.randomUUID)<span class="cstat-no" title="statement not covered" >return crypto.randomUUID();c</span></span>onst t=<span class="cstat-no" title="statement not covered" >new Uint8Array(32);<span class="cstat-no" title="statement not covered" ></span>if("undefined"!=typeof crypto&amp;&amp;"function"==typeof crypto?.getRandomValues)<span class="cstat-no" title="statement not covered" >crypto.getRandomValues(t);e</span>lse <span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;32;e++)<span class="cstat-no" title="statement not covered" >t[e]=Math.floor(255*Math.random());<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn bytesToString(t)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getVerbosityLevel=function <span class="fstat-no" title="function not covered" >getVerbosityLevel(</span>){<span class="cstat-no" title="statement not covered" >return n}</span>;<span class="cstat-no" title="statement not covered" >e</span>.info=function <span class="fstat-no" title="function not covered" >info(</span>t){<span class="cstat-no" title="statement not covered" >n&gt;=s.INFOS&amp;&amp;console.log(`Info: ${t}`)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.isArrayBuffer=function <span class="fstat-no" title="function not covered" >isArrayBuffer(</span>t){<span class="cstat-no" title="statement not covered" >return"object"==typeof t&amp;&amp;void 0!==t?.byteLength}</span>;<span class="cstat-no" title="statement not covered" >e</span>.isArrayEqual=function <span class="fstat-no" title="function not covered" >isArrayEqual(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t.length!==e.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(let i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>i&lt;s;i++)<span class="cstat-no" title="statement not covered" >if(t[i]!==e[i])<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>;<span class="cstat-no" title="statement not covered" >e</span>.isNodeJS=void 0;<span class="cstat-no" title="statement not covered" >e</span>.normalizeUnicode=function <span class="fstat-no" title="function not covered" >normalizeUnicode(</span>t){<span class="cstat-no" title="statement not covered" >if(!l){<span class="cstat-no" title="statement not covered" >l=/([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;<span class="cstat-no" title="statement not covered" >c</span>=new Map([["ﬅ","ſt"]])}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.replaceAll(l,(<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >e?e.normalize("NFKC"):c.get(i))</span>)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.objectFromMap=function <span class="fstat-no" title="function not covered" >objectFromMap(</span>t){const e=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>for(const[i,s]of t)<span class="cstat-no" title="statement not covered" >e[i]=s;<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>;<span class="cstat-no" title="statement not covered" >e</span>.objectSize=function <span class="fstat-no" title="function not covered" >objectSize(</span>t){<span class="cstat-no" title="statement not covered" >return Object.keys(t).length}</span>;<span class="cstat-no" title="statement not covered" >e</span>.setVerbosityLevel=function <span class="fstat-no" title="function not covered" >setVerbosityLevel(</span>t){<span class="cstat-no" title="statement not covered" >Number.isInteger(t)&amp;&amp;(n=t)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.shadow=shadow;<span class="cstat-no" title="statement not covered" >e</span>.string32=function <span class="fstat-no" title="function not covered" >string32(</span>t){<span class="cstat-no" title="statement not covered" >return String.fromCharCode(t&gt;&gt;24&amp;255,t&gt;&gt;16&amp;255,t&gt;&gt;8&amp;255,255&amp;t)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.stringToBytes=stringToBytes;<span class="cstat-no" title="statement not covered" >e</span>.stringToPDFString=function <span class="fstat-no" title="function not covered" >stringToPDFString(</span>t){<span class="cstat-no" title="statement not covered" >if(t[0]&gt;="ï"){let e;<span class="cstat-no" title="statement not covered" >"þ"===t[0]&amp;&amp;"ÿ"===t[1]?e="utf-16be":"ÿ"===t[0]&amp;&amp;"þ"===t[1]?e="utf-16le":"ï"===t[0]&amp;&amp;"»"===t[1]&amp;&amp;"¿"===t[2]&amp;&amp;(e="utf-8");<span class="cstat-no" title="statement not covered" >i</span>f(e)<span class="cstat-no" title="statement not covered" >try{const i=<span class="cstat-no" title="statement not covered" >new TextDecoder(e,{fatal:!0}),</span>s=<span class="cstat-no" title="statement not covered" >stringToBytes(t);<span class="cstat-no" title="statement not covered" ></span>return i.decode(s)}</span>catch(t){<span class="cstat-no" title="statement not covered" >warn(`stringToPDFString: "${t}".`)}</span>}</span></span>c</span>onst e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>i&lt;s;i++){const s=<span class="cstat-no" title="statement not covered" >o[t.charCodeAt(i)];<span class="cstat-no" title="statement not covered" ></span>e.push(s?String.fromCharCode(s):t.charAt(i))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.join("")}</span>;<span class="cstat-no" title="statement not covered" >e</span>.stringToUTF8String=stringToUTF8String;<span class="cstat-no" title="statement not covered" >e</span>.unreachable=unreachable;<span class="cstat-no" title="statement not covered" >e</span>.utf8StringToString=function <span class="fstat-no" title="function not covered" >utf8StringToString(</span>t){<span class="cstat-no" title="statement not covered" >return unescape(encodeURIComponent(t))}</span>;<span class="cstat-no" title="statement not covered" >e</span>.warn=warn;c</span>onst i=<span class="cstat-no" title="statement not covered" >!("object"!=typeof process||process+""!="[object process]"||process.versions.nw||process.versions.electron&amp;&amp;process.type&amp;&amp;"browser"!==process.type);<span class="cstat-no" title="statement not covered" ></span>e.isNodeJS=i;<span class="cstat-no" title="statement not covered" >e</span>.IDENTITY_MATRIX=[1,0,0,1,0,0];<span class="cstat-no" title="statement not covered" >e</span>.FONT_IDENTITY_MATRIX=[.001,0,0,.001,0,0];<span class="cstat-no" title="statement not covered" >e</span>.MAX_IMAGE_SIZE_TO_CACHE=1e7;<span class="cstat-no" title="statement not covered" >e</span>.LINE_FACTOR=1.35;<span class="cstat-no" title="statement not covered" >e</span>.LINE_DESCENT_FACTOR=.35;<span class="cstat-no" title="statement not covered" >e</span>.BASELINE_FACTOR=.25925925925925924;<span class="cstat-no" title="statement not covered" >e</span>.RenderingIntentFlag={ANY:1,DISPLAY:2,PRINT:4,SAVE:8,ANNOTATIONS_FORMS:16,ANNOTATIONS_STORAGE:32,ANNOTATIONS_DISABLE:64,OPLIST:256};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationMode={DISABLE:0,ENABLE:1,ENABLE_FORMS:2,ENABLE_STORAGE:3};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationEditorPrefix="pdfjs_internal_editor_";<span class="cstat-no" title="statement not covered" >e</span>.AnnotationEditorType={DISABLE:-1,NONE:0,FREETEXT:3,STAMP:13,INK:15};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationEditorParamsType={RESIZE:1,CREATE:2,FREETEXT_SIZE:11,FREETEXT_COLOR:12,FREETEXT_OPACITY:13,INK_COLOR:21,INK_THICKNESS:22,INK_OPACITY:23};<span class="cstat-no" title="statement not covered" >e</span>.PermissionFlag={PRINT:4,MODIFY_CONTENTS:8,COPY:16,MODIFY_ANNOTATIONS:32,FILL_INTERACTIVE_FORMS:256,COPY_FOR_ACCESSIBILITY:512,ASSEMBLE:1024,PRINT_HIGH_QUALITY:2048};<span class="cstat-no" title="statement not covered" >e</span>.TextRenderingMode={FILL:0,STROKE:1,FILL_STROKE:2,INVISIBLE:3,FILL_ADD_TO_PATH:4,STROKE_ADD_TO_PATH:5,FILL_STROKE_ADD_TO_PATH:6,ADD_TO_PATH:7,FILL_STROKE_MASK:3,ADD_TO_PATH_FLAG:4};<span class="cstat-no" title="statement not covered" >e</span>.ImageKind={GRAYSCALE_1BPP:1,RGB_24BPP:2,RGBA_32BPP:3};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationType={TEXT:1,LINK:2,FREETEXT:3,LINE:4,SQUARE:5,CIRCLE:6,POLYGON:7,POLYLINE:8,HIGHLIGHT:9,UNDERLINE:10,SQUIGGLY:11,STRIKEOUT:12,STAMP:13,CARET:14,INK:15,POPUP:16,FILEATTACHMENT:17,SOUND:18,MOVIE:19,WIDGET:20,SCREEN:21,PRINTERMARK:22,TRAPNET:23,WATERMARK:24,THREED:25,REDACT:26};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationReplyType={GROUP:"Group",REPLY:"R"};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationFlag={INVISIBLE:1,HIDDEN:2,PRINT:4,NOZOOM:8,NOROTATE:16,NOVIEW:32,READONLY:64,LOCKED:128,TOGGLENOVIEW:256,LOCKEDCONTENTS:512};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationFieldFlag={READONLY:1,REQUIRED:2,NOEXPORT:4,MULTILINE:4096,PASSWORD:8192,NOTOGGLETOOFF:16384,RADIO:32768,PUSHBUTTON:65536,COMBO:131072,EDIT:262144,SORT:524288,FILESELECT:1048576,MULTISELECT:2097152,DONOTSPELLCHECK:4194304,DONOTSCROLL:8388608,COMB:16777216,RICHTEXT:33554432,RADIOSINUNISON:33554432,COMMITONSELCHANGE:67108864};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationBorderStyleType={SOLID:1,DASHED:2,BEVELED:3,INSET:4,UNDERLINE:5};<span class="cstat-no" title="statement not covered" >e</span>.AnnotationActionEventType={E:"Mouse Enter",X:"Mouse Exit",D:"Mouse Down",U:"Mouse Up",Fo:"Focus",Bl:"Blur",PO:"PageOpen",PC:"PageClose",PV:"PageVisible",PI:"PageInvisible",K:"Keystroke",F:"Format",V:"Validate",C:"Calculate"};<span class="cstat-no" title="statement not covered" >e</span>.DocumentActionEventType={WC:"WillClose",WS:"WillSave",DS:"DidSave",WP:"WillPrint",DP:"DidPrint"};<span class="cstat-no" title="statement not covered" >e</span>.PageActionEventType={O:"PageOpen",C:"PageClose"};c</span>onst s=<span class="cstat-no" title="statement not covered" >{ERRORS:0,WARNINGS:1,INFOS:5};<span class="cstat-no" title="statement not covered" ></span>e.VerbosityLevel=s;<span class="cstat-no" title="statement not covered" >e</span>.CMapCompressionType={NONE:0,BINARY:1};<span class="cstat-no" title="statement not covered" >e</span>.OPS={dependency:1,setLineWidth:2,setLineCap:3,setLineJoin:4,setMiterLimit:5,setDash:6,setRenderingIntent:7,setFlatness:8,setGState:9,save:10,restore:11,transform:12,moveTo:13,lineTo:14,curveTo:15,curveTo2:16,curveTo3:17,closePath:18,rectangle:19,stroke:20,closeStroke:21,fill:22,eoFill:23,fillStroke:24,eoFillStroke:25,closeFillStroke:26,closeEOFillStroke:27,endPath:28,clip:29,eoClip:30,beginText:31,endText:32,setCharSpacing:33,setWordSpacing:34,setHScale:35,setLeading:36,setFont:37,setTextRenderingMode:38,setTextRise:39,moveText:40,setLeadingMoveText:41,setTextMatrix:42,nextLine:43,showText:44,showSpacedText:45,nextLineShowText:46,nextLineSetSpacingShowText:47,setCharWidth:48,setCharWidthAndBounds:49,setStrokeColorSpace:50,setFillColorSpace:51,setStrokeColor:52,setStrokeColorN:53,setFillColor:54,setFillColorN:55,setStrokeGray:56,setFillGray:57,setStrokeRGBColor:58,setFillRGBColor:59,setStrokeCMYKColor:60,setFillCMYKColor:61,shadingFill:62,beginInlineImage:63,beginImageData:64,endInlineImage:65,paintXObject:66,markPoint:67,markPointProps:68,beginMarkedContent:69,beginMarkedContentProps:70,endMarkedContent:71,beginCompat:72,endCompat:73,paintFormXObjectBegin:74,paintFormXObjectEnd:75,beginGroup:76,endGroup:77,beginAnnotation:80,endAnnotation:81,paintImageMaskXObject:83,paintImageMaskXObjectGroup:84,paintImageXObject:85,paintInlineImageXObject:86,paintInlineImageXObjectGroup:87,paintImageXObjectRepeat:88,paintImageMaskXObjectRepeat:89,paintSolidColorImageMask:90,constructPath:91};<span class="cstat-no" title="statement not covered" >e</span>.PasswordResponses={NEED_PASSWORD:1,INCORRECT_PASSWORD:2};l</span>et n=<span class="cstat-no" title="statement not covered" >s.WARNINGS;</span>function <span class="fstat-no" title="function not covered" >warn(</span>t){<span class="cstat-no" title="statement not covered" >n&gt;=s.WARNINGS&amp;&amp;console.log(`Warning: ${t}`)}</span>function <span class="fstat-no" title="function not covered" >unreachable(</span>t){<span class="cstat-no" title="statement not covered" >throw new Error(t)}</span>function <span class="fstat-no" title="function not covered" >shadow(</span>t,e,i,s=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,e,{value:i,enumerable:!s,configurable:!0,writable:!1});<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>const a=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >BaseExceptionClosure(</span>){function <span class="fstat-no" title="function not covered" >BaseException(</span>t,e){<span class="cstat-no" title="statement not covered" >this.constructor===BaseException&amp;&amp;unreachable("Cannot initialize BaseException.");<span class="cstat-no" title="statement not covered" >t</span>his.message=t;<span class="cstat-no" title="statement not covered" >t</span>his.name=e}<span class="cstat-no" title="statement not covered" ></span>BaseException.prototype=new Error;<span class="cstat-no" title="statement not covered" >B</span>aseException.constructor=BaseException;<span class="cstat-no" title="statement not covered" >r</span>eturn BaseException}</span>();<span class="cstat-no" title="statement not covered" ></span>e.BaseException=a;<span class="cstat-no" title="statement not covered" >e</span>.PasswordException=class PasswordException extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(t,"PasswordException");<span class="cstat-no" title="statement not covered" >t</span>his.code=e}</span>};<span class="cstat-no" title="statement not covered" >e</span>.UnknownErrorException=class UnknownErrorException extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(t,"UnknownErrorException");<span class="cstat-no" title="statement not covered" >t</span>his.details=e}</span>};<span class="cstat-no" title="statement not covered" >e</span>.InvalidPDFException=class InvalidPDFException extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,"InvalidPDFException")}</span>};<span class="cstat-no" title="statement not covered" >e</span>.MissingPDFException=class MissingPDFException extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,"MissingPDFException")}</span>};<span class="cstat-no" title="statement not covered" >e</span>.UnexpectedResponseException=class UnexpectedResponseException extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(t,"UnexpectedResponseException");<span class="cstat-no" title="statement not covered" >t</span>his.status=e}</span>};<span class="cstat-no" title="statement not covered" >e</span>.FormatError=class FormatError extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,"FormatError")}</span>};<span class="cstat-no" title="statement not covered" >e</span>.AbortException=class AbortException extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,"AbortException")}</span>};f</span>unction <span class="fstat-no" title="function not covered" >bytesToString(</span>t){<span class="cstat-no" title="statement not covered" >"object"==typeof t&amp;&amp;void 0!==t?.length||unreachable("Invalid argument for bytesToString");c</span>onst e=<span class="cstat-no" title="statement not covered" >t.length,</span>i=<span class="cstat-no" title="statement not covered" >8192;<span class="cstat-no" title="statement not covered" ></span>if(e&lt;i)<span class="cstat-no" title="statement not covered" >return String.fromCharCode.apply(null,t);c</span></span>onst s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e;n+=i){const a=<span class="cstat-no" title="statement not covered" >Math.min(n+i,e),</span>r=<span class="cstat-no" title="statement not covered" >t.subarray(n,a);<span class="cstat-no" title="statement not covered" ></span>s.push(String.fromCharCode.apply(null,r))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.join("")}</span>function <span class="fstat-no" title="function not covered" >stringToBytes(</span>t){<span class="cstat-no" title="statement not covered" >"string"!=typeof t&amp;&amp;unreachable("Invalid argument for stringToBytes");c</span>onst e=<span class="cstat-no" title="statement not covered" >t.length,</span>i=<span class="cstat-no" title="statement not covered" >new Uint8Array(e);<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;e;++s)<span class="cstat-no" title="statement not covered" >i[s]=255&amp;t.charCodeAt(s);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="cstat-no" title="statement not covered" ></span>e.FeatureTest=class FeatureTest{<span class="fstat-no" title="function not covered" >st</span>atic get isLittleEndian(){<span class="cstat-no" title="statement not covered" >return shadow(this,"isLittleEndian",function <span class="fstat-no" title="function not covered" >isLittleEndian(</span>){const t=<span class="cstat-no" title="statement not covered" >new Uint8Array(4);<span class="cstat-no" title="statement not covered" ></span>t[0]=1;<span class="cstat-no" title="statement not covered" >r</span>eturn 1===new Uint32Array(t.buffer,0,1)[0]}</span>())}<span class="fstat-no" title="function not covered" ></span>st</span>atic get isEvalSupported(){<span class="cstat-no" title="statement not covered" >return shadow(this,"isEvalSupported",function <span class="fstat-no" title="function not covered" >isEvalSupported(</span>){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >new Function("");<span class="cstat-no" title="statement not covered" >r</span>eturn!0}</span>catch{<span class="cstat-no" title="statement not covered" >return!1}</span>}</span>())}<span class="fstat-no" title="function not covered" ></span>st</span>atic get isOffscreenCanvasSupported(){<span class="cstat-no" title="statement not covered" >return shadow(this,"isOffscreenCanvasSupported","undefined"!=typeof OffscreenCanvas)}<span class="fstat-no" title="function not covered" ></span>st</span>atic get platform(){<span class="cstat-no" title="statement not covered" >return"undefined"==typeof navigator?shadow(this,"platform",{isWin:!1,isMac:!1}):shadow(this,"platform",{isWin:navigator.platform.includes("Win"),isMac:navigator.platform.includes("Mac")})}<span class="fstat-no" title="function not covered" ></span>st</span>atic get isCSSRoundSupported(){<span class="cstat-no" title="statement not covered" >return shadow(this,"isCSSRoundSupported",globalThis.CSS?.supports?.("width: round(1.5px, 1px)"))}</span>};c</span>onst r=<span class="cstat-no" title="statement not covered" >[...Array(256).keys()].map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.toString(16).padStart(2,"0"))</span>);<span class="cstat-no" title="statement not covered" ></span>e.Util=class Util{<span class="fstat-no" title="function not covered" >st</span>atic makeHexColor(t,e,i){<span class="cstat-no" title="statement not covered" >return`#${r[t]}${r[e]}${r[i]}`}<span class="fstat-no" title="function not covered" ></span>st</span>atic scaleMinMax(t,e){let i;<span class="cstat-no" title="statement not covered" >if(t[0]){<span class="cstat-no" title="statement not covered" >if(t[0]&lt;0){<span class="cstat-no" title="statement not covered" >i=e[0];<span class="cstat-no" title="statement not covered" >e</span>[0]=e[1];<span class="cstat-no" title="statement not covered" >e</span>[1]=i}<span class="cstat-no" title="statement not covered" ></span>e</span>[0]*=t[0];<span class="cstat-no" title="statement not covered" >e</span>[1]*=t[0];<span class="cstat-no" title="statement not covered" >i</span>f(t[3]&lt;0){<span class="cstat-no" title="statement not covered" >i=e[2];<span class="cstat-no" title="statement not covered" >e</span>[2]=e[3];<span class="cstat-no" title="statement not covered" >e</span>[3]=i}<span class="cstat-no" title="statement not covered" ></span>e</span>[2]*=t[3];<span class="cstat-no" title="statement not covered" >e</span>[3]*=t[3]}</span>else{<span class="cstat-no" title="statement not covered" >i=e[0];<span class="cstat-no" title="statement not covered" >e</span>[0]=e[2];<span class="cstat-no" title="statement not covered" >e</span>[2]=i;<span class="cstat-no" title="statement not covered" >i</span>=e[1];<span class="cstat-no" title="statement not covered" >e</span>[1]=e[3];<span class="cstat-no" title="statement not covered" >e</span>[3]=i;<span class="cstat-no" title="statement not covered" >i</span>f(t[1]&lt;0){<span class="cstat-no" title="statement not covered" >i=e[2];<span class="cstat-no" title="statement not covered" >e</span>[2]=e[3];<span class="cstat-no" title="statement not covered" >e</span>[3]=i}<span class="cstat-no" title="statement not covered" ></span>e</span>[2]*=t[1];<span class="cstat-no" title="statement not covered" >e</span>[3]*=t[1];<span class="cstat-no" title="statement not covered" >i</span>f(t[2]&lt;0){<span class="cstat-no" title="statement not covered" >i=e[0];<span class="cstat-no" title="statement not covered" >e</span>[0]=e[1];<span class="cstat-no" title="statement not covered" >e</span>[1]=i}<span class="cstat-no" title="statement not covered" ></span>e</span>[0]*=t[2];<span class="cstat-no" title="statement not covered" >e</span>[1]*=t[2]}<span class="cstat-no" title="statement not covered" ></span>e</span>[0]+=t[4];<span class="cstat-no" title="statement not covered" >e</span>[1]+=t[4];<span class="cstat-no" title="statement not covered" >e</span>[2]+=t[5];<span class="cstat-no" title="statement not covered" >e</span>[3]+=t[5]}<span class="fstat-no" title="function not covered" ></span>st</span>atic transform(t,e){<span class="cstat-no" title="statement not covered" >return[t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1],t[0]*e[2]+t[2]*e[3],t[1]*e[2]+t[3]*e[3],t[0]*e[4]+t[2]*e[5]+t[4],t[1]*e[4]+t[3]*e[5]+t[5]]}<span class="fstat-no" title="function not covered" ></span>st</span>atic applyTransform(t,e){<span class="cstat-no" title="statement not covered" >return[t[0]*e[0]+t[1]*e[2]+e[4],t[0]*e[1]+t[1]*e[3]+e[5]]}<span class="fstat-no" title="function not covered" ></span>st</span>atic applyInverseTransform(t,e){const i=<span class="cstat-no" title="statement not covered" >e[0]*e[3]-e[1]*e[2];<span class="cstat-no" title="statement not covered" ></span>return[(t[0]*e[3]-t[1]*e[2]+e[2]*e[5]-e[4]*e[3])/i,(-t[0]*e[1]+t[1]*e[0]+e[4]*e[1]-e[5]*e[0])/i]}<span class="fstat-no" title="function not covered" ></span>st</span>atic getAxialAlignedBoundingBox(t,e){const i=<span class="cstat-no" title="statement not covered" >this.applyTransform(t,e),</span>s=<span class="cstat-no" title="statement not covered" >this.applyTransform(t.slice(2,4),e),</span>n=<span class="cstat-no" title="statement not covered" >this.applyTransform([t[0],t[3]],e),</span>a=<span class="cstat-no" title="statement not covered" >this.applyTransform([t[2],t[1]],e);<span class="cstat-no" title="statement not covered" ></span>return[Math.min(i[0],s[0],n[0],a[0]),Math.min(i[1],s[1],n[1],a[1]),Math.max(i[0],s[0],n[0],a[0]),Math.max(i[1],s[1],n[1],a[1])]}<span class="fstat-no" title="function not covered" ></span>st</span>atic inverseTransform(t){const e=<span class="cstat-no" title="statement not covered" >t[0]*t[3]-t[1]*t[2];<span class="cstat-no" title="statement not covered" ></span>return[t[3]/e,-t[1]/e,-t[2]/e,t[0]/e,(t[2]*t[5]-t[4]*t[3])/e,(t[4]*t[1]-t[5]*t[0])/e]}<span class="fstat-no" title="function not covered" ></span>st</span>atic singularValueDecompose2dScale(t){const e=<span class="cstat-no" title="statement not covered" >[t[0],t[2],t[1],t[3]],</span>i=<span class="cstat-no" title="statement not covered" >t[0]*e[0]+t[1]*e[2],</span>s=<span class="cstat-no" title="statement not covered" >t[0]*e[1]+t[1]*e[3],</span>n=<span class="cstat-no" title="statement not covered" >t[2]*e[0]+t[3]*e[2],</span>a=<span class="cstat-no" title="statement not covered" >t[2]*e[1]+t[3]*e[3],</span>r=<span class="cstat-no" title="statement not covered" >(i+a)/2,</span>o=<span class="cstat-no" title="statement not covered" >Math.sqrt((i+a)**2-4*(i*a-n*s))/2,</span>l=<span class="cstat-no" title="statement not covered" >r+o||1,</span>c=<span class="cstat-no" title="statement not covered" >r-o||1;<span class="cstat-no" title="statement not covered" ></span>return[Math.sqrt(l),Math.sqrt(c)]}<span class="fstat-no" title="function not covered" ></span>st</span>atic normalizeRect(t){const e=<span class="cstat-no" title="statement not covered" >t.slice(0);<span class="cstat-no" title="statement not covered" ></span>if(t[0]&gt;t[2]){<span class="cstat-no" title="statement not covered" >e[0]=t[2];<span class="cstat-no" title="statement not covered" >e</span>[2]=t[0]}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t[1]&gt;t[3]){<span class="cstat-no" title="statement not covered" >e[1]=t[3];<span class="cstat-no" title="statement not covered" >e</span>[3]=t[1]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>st</span>atic intersect(t,e){const i=<span class="cstat-no" title="statement not covered" >Math.max(Math.min(t[0],t[2]),Math.min(e[0],e[2])),</span>s=<span class="cstat-no" title="statement not covered" >Math.min(Math.max(t[0],t[2]),Math.max(e[0],e[2]));<span class="cstat-no" title="statement not covered" ></span>if(i&gt;s)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >Math.max(Math.min(t[1],t[3]),Math.min(e[1],e[3])),</span>a=<span class="cstat-no" title="statement not covered" >Math.min(Math.max(t[1],t[3]),Math.max(e[1],e[3]));<span class="cstat-no" title="statement not covered" ></span>return n&gt;a?null:[i,n,s,a]}<span class="fstat-no" title="function not covered" ></span>st</span>atic bezierBoundingBox(t,e,i,s,n,a,r,o){const l=<span class="cstat-no" title="statement not covered" >[],</span>c=<span class="cstat-no" title="statement not covered" >[[],[]];</span>let h,d,u,p,g,m,f,b;<span class="cstat-no" title="statement not covered" >for(let c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;2;++c){<span class="cstat-no" title="statement not covered" >if(0===c){<span class="cstat-no" title="statement not covered" >d=6*t-12*i+6*n;<span class="cstat-no" title="statement not covered" >h</span>=-3*t+9*i-9*n+3*r;<span class="cstat-no" title="statement not covered" >u</span>=3*i-3*t}</span>else{<span class="cstat-no" title="statement not covered" >d=6*e-12*s+6*a;<span class="cstat-no" title="statement not covered" >h</span>=-3*e+9*s-9*a+3*o;<span class="cstat-no" title="statement not covered" >u</span>=3*s-3*e}<span class="cstat-no" title="statement not covered" ></span>i</span>f(Math.abs(h)&lt;1e-12){<span class="cstat-no" title="statement not covered" >if(Math.abs(d)&lt;1e-12)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >p</span></span>=-u/d;<span class="cstat-no" title="statement not covered" >0</span>&lt;p&amp;&amp;p&lt;1&amp;&amp;l.push(p)}</span>else{<span class="cstat-no" title="statement not covered" >f=d*d-4*u*h;<span class="cstat-no" title="statement not covered" >b</span>=Math.sqrt(f);<span class="cstat-no" title="statement not covered" >i</span>f(!(f&lt;0)){<span class="cstat-no" title="statement not covered" >g=(-d+b)/(2*h);<span class="cstat-no" title="statement not covered" >0</span>&lt;g&amp;&amp;g&lt;1&amp;&amp;l.push(g);<span class="cstat-no" title="statement not covered" >m</span>=(-d-b)/(2*h);<span class="cstat-no" title="statement not covered" >0</span>&lt;m&amp;&amp;m&lt;1&amp;&amp;l.push(m)}</span>}</span>}</span>l</span>et A,_=<span class="cstat-no" title="statement not covered" >l.length;</span>const v=<span class="cstat-no" title="statement not covered" >_;<span class="cstat-no" title="statement not covered" ></span>for(;_--;){<span class="cstat-no" title="statement not covered" >p=l[_];<span class="cstat-no" title="statement not covered" >A</span>=1-p;<span class="cstat-no" title="statement not covered" >c</span>[0][_]=A*A*A*t+3*A*A*p*i+3*A*p*p*n+p*p*p*r;<span class="cstat-no" title="statement not covered" >c</span>[1][_]=A*A*A*e+3*A*A*p*s+3*A*p*p*a+p*p*p*o}<span class="cstat-no" title="statement not covered" ></span>c</span>[0][v]=t;<span class="cstat-no" title="statement not covered" >c</span>[1][v]=e;<span class="cstat-no" title="statement not covered" >c</span>[0][v+1]=r;<span class="cstat-no" title="statement not covered" >c</span>[1][v+1]=o;<span class="cstat-no" title="statement not covered" >c</span>[0].length=c[1].length=v+2;<span class="cstat-no" title="statement not covered" >r</span>eturn[Math.min(...c[0]),Math.min(...c[1]),Math.max(...c[0]),Math.max(...c[1])]}</span>};c</span>onst o=<span class="cstat-no" title="statement not covered" >[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,728,711,710,729,733,731,730,732,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8226,8224,8225,8230,8212,8211,402,8260,8249,8250,8722,8240,8222,8220,8221,8216,8217,8218,8482,64257,64258,321,338,352,376,381,305,322,339,353,382,0,8364];</span>function <span class="fstat-no" title="function not covered" >stringToUTF8String(</span>t){<span class="cstat-no" title="statement not covered" >return decodeURIComponent(escape(t))}<span class="cstat-no" title="statement not covered" ></span>e.PromiseCapability=class PromiseCapability{#t=<span class="cstat-no" title="statement not covered" >!1;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.promise=new Promise((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.resolve=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.#t=!0;<span class="cstat-no" title="statement not covered" >t</span>(e)}</span>;<span class="cstat-no" title="statement not covered" >t</span>his.reject=<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.#t=!0;<span class="cstat-no" title="statement not covered" >e</span>(t)}</span>}</span>))}<span class="fstat-no" title="function not covered" ></span>ge</span>t settled(){<span class="cstat-no" title="statement not covered" >return this.#t}</span>};l</span>et l=<span class="cstat-no" title="statement not covered" >null,</span>c=<span class="cstat-no" title="statement not covered" >null}</span>,<span class="fstat-no" title="function not covered" >(_</span>_unused_webpack_module,exports,__w_pdfjs_require__)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(exports,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>xports.RenderTask=exports.PDFWorkerUtil=exports.PDFWorker=exports.PDFPageProxy=exports.PDFDocumentProxy=exports.PDFDocumentLoadingTask=exports.PDFDataRangeTransport=exports.LoopbackPort=exports.DefaultStandardFontDataFactory=exports.DefaultFilterFactory=exports.DefaultCanvasFactory=exports.DefaultCMapReaderFactory=void 0;<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(exports,"SVGGraphics",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return _displaySvg.SVGGraphics}</span>});<span class="cstat-no" title="statement not covered" >e</span>xports.build=void 0;<span class="cstat-no" title="statement not covered" >e</span>xports.getDocument=getDocument;<span class="cstat-no" title="statement not covered" >e</span>xports.version=void 0;v</span>ar _util=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(1),</span>_annotation_storage=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(3),</span>_display_utils=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(6),</span>_font_loader=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(9),</span>_displayNode_utils=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(10),</span>_canvas=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(11),</span>_worker_options=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(14),</span>_message_handler=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(15),</span>_metadata=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(16),</span>_optional_content_config=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(17),</span>_transport_stream=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(18),</span>_displayFetch_stream=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(19),</span>_displayNetwork=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(22),</span>_displayNode_stream=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(23),</span>_displaySvg=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(24),</span>_xfa_text=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(25);</span>const DEFAULT_RANGE_CHUNK_SIZE=<span class="cstat-no" title="statement not covered" >65536,</span>RENDERING_CANCELLED_TIMEOUT=<span class="cstat-no" title="statement not covered" >100,</span>DELAYED_CLEANUP_TIMEOUT=<span class="cstat-no" title="statement not covered" >5e3,</span>DefaultCanvasFactory=<span class="cstat-no" title="statement not covered" >_util.isNodeJS?_displayNode_utils.NodeCanvasFactory:_display_utils.DOMCanvasFactory;<span class="cstat-no" title="statement not covered" ></span>exports.DefaultCanvasFactory=DefaultCanvasFactory;c</span>onst DefaultCMapReaderFactory=<span class="cstat-no" title="statement not covered" >_util.isNodeJS?_displayNode_utils.NodeCMapReaderFactory:_display_utils.DOMCMapReaderFactory;<span class="cstat-no" title="statement not covered" ></span>exports.DefaultCMapReaderFactory=DefaultCMapReaderFactory;c</span>onst DefaultFilterFactory=<span class="cstat-no" title="statement not covered" >_util.isNodeJS?_displayNode_utils.NodeFilterFactory:_display_utils.DOMFilterFactory;<span class="cstat-no" title="statement not covered" ></span>exports.DefaultFilterFactory=DefaultFilterFactory;c</span>onst DefaultStandardFontDataFactory=<span class="cstat-no" title="statement not covered" >_util.isNodeJS?_displayNode_utils.NodeStandardFontDataFactory:_display_utils.DOMStandardFontDataFactory;<span class="cstat-no" title="statement not covered" ></span>exports.DefaultStandardFontDataFactory=DefaultStandardFontDataFactory;f</span>unction <span class="fstat-no" title="function not covered" >getDocument(</span>t){<span class="cstat-no" title="statement not covered" >"string"==typeof t||t instanceof URL?t={url:t}:(0,_util.isArrayBuffer)(t)&amp;&amp;(t={data:t});<span class="cstat-no" title="statement not covered" >i</span>f("object"!=typeof t)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid parameter in getDocument, need parameter object.");<span class="cstat-no" title="statement not covered" >i</span></span>f(!t.url&amp;&amp;!t.data&amp;&amp;!t.range)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid parameter object: need either .data, .range or .url");c</span></span>onst e=<span class="cstat-no" title="statement not covered" >new PDFDocumentLoadingTask,</span>{docId:i}=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >t.url?getUrlProp(t.url):null,</span>n=<span class="cstat-no" title="statement not covered" >t.data?getDataProp(t.data):null,</span>a=<span class="cstat-no" title="statement not covered" >t.httpHeaders||null,</span>r=<span class="cstat-no" title="statement not covered" >!0===t.withCredentials,</span>o=<span class="cstat-no" title="statement not covered" >t.password??null,</span>l=<span class="cstat-no" title="statement not covered" >t.range instanceof PDFDataRangeTransport?t.range:null,</span>c=<span class="cstat-no" title="statement not covered" >Number.isInteger(t.rangeChunkSize)&amp;&amp;t.rangeChunkSize&gt;0?t.rangeChunkSize:DEFAULT_RANGE_CHUNK_SIZE;</span>let h=<span class="cstat-no" title="statement not covered" >t.worker instanceof PDFWorker?t.worker:null;</span>const d=<span class="cstat-no" title="statement not covered" >t.verbosity,</span>u=<span class="cstat-no" title="statement not covered" >"string"!=typeof t.docBaseUrl||(0,_display_utils.isDataScheme)(t.docBaseUrl)?null:t.docBaseUrl,</span>p=<span class="cstat-no" title="statement not covered" >"string"==typeof t.cMapUrl?t.cMapUrl:null,</span>g=<span class="cstat-no" title="statement not covered" >!1!==t.cMapPacked,</span>m=<span class="cstat-no" title="statement not covered" >t.CMapReaderFactory||DefaultCMapReaderFactory,</span>f=<span class="cstat-no" title="statement not covered" >"string"==typeof t.standardFontDataUrl?t.standardFontDataUrl:null,</span>b=<span class="cstat-no" title="statement not covered" >t.StandardFontDataFactory||DefaultStandardFontDataFactory,</span>A=<span class="cstat-no" title="statement not covered" >!0!==t.stopAtErrors,</span>_=<span class="cstat-no" title="statement not covered" >Number.isInteger(t.maxImageSize)&amp;&amp;t.maxImageSize&gt;-1?t.maxImageSize:-1,</span>v=<span class="cstat-no" title="statement not covered" >!1!==t.isEvalSupported,</span>y=<span class="cstat-no" title="statement not covered" >"boolean"==typeof t.isOffscreenCanvasSupported?t.isOffscreenCanvasSupported:!_util.isNodeJS,</span>S=<span class="cstat-no" title="statement not covered" >Number.isInteger(t.canvasMaxAreaInBytes)?t.canvasMaxAreaInBytes:-1,</span>E=<span class="cstat-no" title="statement not covered" >"boolean"==typeof t.disableFontFace?t.disableFontFace:_util.isNodeJS,</span>x=<span class="cstat-no" title="statement not covered" >!0===t.fontExtraProperties,</span>w=<span class="cstat-no" title="statement not covered" >!0===t.enableXfa,</span>C=<span class="cstat-no" title="statement not covered" >t.ownerDocument||globalThis.document,</span>T=<span class="cstat-no" title="statement not covered" >!0===t.disableRange,</span>P=<span class="cstat-no" title="statement not covered" >!0===t.disableStream,</span>M=<span class="cstat-no" title="statement not covered" >!0===t.disableAutoFetch,</span>F=<span class="cstat-no" title="statement not covered" >!0===t.pdfBug,</span>k=<span class="cstat-no" title="statement not covered" >l?l.length:t.length??NaN,</span>R=<span class="cstat-no" title="statement not covered" >"boolean"==typeof t.useSystemFonts?t.useSystemFonts:!_util.isNodeJS&amp;&amp;!E,</span>D=<span class="cstat-no" title="statement not covered" >"boolean"==typeof t.useWorkerFetch?t.useWorkerFetch:m===_display_utils.DOMCMapReaderFactory&amp;&amp;b===_display_utils.DOMStandardFontDataFactory&amp;&amp;p&amp;&amp;f&amp;&amp;(0,_display_utils.isValidFetchUrl)(p,document.baseURI)&amp;&amp;(0,_display_utils.isValidFetchUrl)(f,document.baseURI),</span>I=<span class="cstat-no" title="statement not covered" >t.canvasFactory||new DefaultCanvasFactory({ownerDocument:C}),</span>L=<span class="cstat-no" title="statement not covered" >t.filterFactory||new DefaultFilterFactory({docId:i,ownerDocument:C});<span class="cstat-no" title="statement not covered" ></span>(0,_util.setVerbosityLevel)(d);c</span>onst O=<span class="cstat-no" title="statement not covered" >{canvasFactory:I,filterFactory:L};<span class="cstat-no" title="statement not covered" ></span>if(!D){<span class="cstat-no" title="statement not covered" >O.cMapReaderFactory=new m({baseUrl:p,isCompressed:g});<span class="cstat-no" title="statement not covered" >O</span>.standardFontDataFactory=new b({baseUrl:f})}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!h){const t=<span class="cstat-no" title="statement not covered" >{verbosity:d,port:_worker_options.GlobalWorkerOptions.workerPort};<span class="cstat-no" title="statement not covered" ></span>h=t.port?PDFWorker.fromPort(t):new PDFWorker(t);<span class="cstat-no" title="statement not covered" >e</span>._worker=h}</span>c</span>onst N=<span class="cstat-no" title="statement not covered" >{docId:i,apiVersion:"3.10.111",data:n,password:o,disableAutoFetch:M,rangeChunkSize:c,length:k,docBaseUrl:u,enableXfa:w,evaluatorOptions:{maxImageSize:_,disableFontFace:E,ignoreErrors:A,isEvalSupported:v,isOffscreenCanvasSupported:y,canvasMaxAreaInBytes:S,fontExtraProperties:x,useSystemFonts:R,cMapUrl:D?p:null,standardFontDataUrl:D?f:null}},</span>B=<span class="cstat-no" title="statement not covered" >{ignoreErrors:A,isEvalSupported:v,disableFontFace:E,fontExtraProperties:x,enableXfa:w,ownerDocument:C,disableAutoFetch:M,pdfBug:F,styleElement:null};<span class="cstat-no" title="statement not covered" ></span>h.promise.then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(e.destroyed)<span class="cstat-no" title="statement not covered" >throw new Error("Loading aborted");c</span></span>onst t=<span class="cstat-no" title="statement not covered" >_fetchDocument(h,N),</span>o=<span class="cstat-no" title="statement not covered" >new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(t){let e;<span class="cstat-no" title="statement not covered" >if(l)<span class="cstat-no" title="statement not covered" >e=new _transport_stream.PDFDataTransportStream({length:k,initialData:l.initialData,progressiveDone:l.progressiveDone,contentDispositionFilename:l.contentDispositionFilename,disableRange:T,disableStream:P},l);e</span>lse <span class="cstat-no" title="statement not covered" >if(!n){<span class="cstat-no" title="statement not covered" >e=(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >_util.isNodeJS?new _displayNode_stream.PDFNodeStream(t):(0,_display_utils.isValidFetchUrl)(t.url)?new _displayFetch_stream.PDFFetchStream(t):new _displayNetwork.PDFNetworkStream(t))</span>({url:s,length:k,httpHeaders:a,withCredentials:r,rangeChunkSize:c,disableRange:T,disableStream:P})}<span class="cstat-no" title="statement not covered" ></span>t</span></span>(e)}</span>));<span class="cstat-no" title="statement not covered" ></span>return Promise.all([t,o]).then((<span class="fstat-no" title="function not covered" >fu</span>nction([t,s]){<span class="cstat-no" title="statement not covered" >if(e.destroyed)<span class="cstat-no" title="statement not covered" >throw new Error("Loading aborted");c</span></span>onst n=<span class="cstat-no" title="statement not covered" >new _message_handler.MessageHandler(i,t,h.port),</span>a=<span class="cstat-no" title="statement not covered" >new WorkerTransport(n,e,s,B,O);<span class="cstat-no" title="statement not covered" ></span>e._transport=a;<span class="cstat-no" title="statement not covered" >n</span>.send("Ready",null)}</span>))}</span>)).catch(e._capability.reject);<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>async function <span class="fstat-no" title="function not covered" >_fetchDocument(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t.destroyed)<span class="cstat-no" title="statement not covered" >throw new Error("Worker was destroyed");c</span></span>onst i=<span class="cstat-no" title="statement not covered" >await t.messageHandler.sendWithPromise("GetDocRequest",e,e.data?[e.data.buffer]:null);<span class="cstat-no" title="statement not covered" ></span>if(t.destroyed)<span class="cstat-no" title="statement not covered" >throw new Error("Worker was destroyed");<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >getUrlProp(</span>t){<span class="cstat-no" title="statement not covered" >if(t instanceof URL)<span class="cstat-no" title="statement not covered" >return t.href;<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >return new URL(t,window.location).href}</span>catch{<span class="cstat-no" title="statement not covered" >if(_util.isNodeJS&amp;&amp;"string"==typeof t)<span class="cstat-no" title="statement not covered" >return t}<span class="cstat-no" title="statement not covered" ></span></span>t</span>hrow new Error("Invalid PDF url data: either string or URL-object is expected in the url property.")}</span>function <span class="fstat-no" title="function not covered" >getDataProp(</span>t){<span class="cstat-no" title="statement not covered" >if(_util.isNodeJS&amp;&amp;"undefined"!=typeof Buffer&amp;&amp;t instanceof Buffer)<span class="cstat-no" title="statement not covered" >throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof Uint8Array&amp;&amp;t.byteLength===t.buffer.byteLength)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >i</span></span>f("string"==typeof t)<span class="cstat-no" title="statement not covered" >return(0,_util.stringToBytes)(t);<span class="cstat-no" title="statement not covered" >i</span></span>f("object"==typeof t&amp;&amp;!isNaN(t?.length)||(0,_util.isArrayBuffer)(t))<span class="cstat-no" title="statement not covered" >return new Uint8Array(t);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.")}</span>class PDFDocumentLoadingTask{static#e=<span class="cstat-no" title="statement not covered" >0;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._capability=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his._transport=null;<span class="cstat-no" title="statement not covered" >t</span>his._worker=null;<span class="cstat-no" title="statement not covered" >t</span>his.docId="d"+PDFDocumentLoadingTask.#e++;<span class="cstat-no" title="statement not covered" >t</span>his.destroyed=!1;<span class="cstat-no" title="statement not covered" >t</span>his.onPassword=null;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null}<span class="fstat-no" title="function not covered" ></span>ge</span>t promise(){<span class="cstat-no" title="statement not covered" >return this._capability.promise}<span class="fstat-no" title="function not covered" ></span>as</span>ync destroy(){<span class="cstat-no" title="statement not covered" >this.destroyed=!0;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >this._worker?.port&amp;&amp;(this._worker._pendingDestroy=!0);<span class="cstat-no" title="statement not covered" >a</span>wait(this._transport?.destroy())}</span>catch(t){<span class="cstat-no" title="statement not covered" >this._worker?.port&amp;&amp;delete this._worker._pendingDestroy;<span class="cstat-no" title="statement not covered" >t</span>hrow t}<span class="cstat-no" title="statement not covered" ></span>t</span>his._transport=null;<span class="cstat-no" title="statement not covered" >i</span>f(this._worker){<span class="cstat-no" title="statement not covered" >this._worker.destroy();<span class="cstat-no" title="statement not covered" >t</span>his._worker=null}</span>}</span>}<span class="cstat-no" title="statement not covered" >exports.PDFDocumentLoadingTask=PDFDocumentLoadingTask;c</span>lass PDFDataRangeTransport{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >this.length=t;<span class="cstat-no" title="statement not covered" >t</span>his.initialData=e;<span class="cstat-no" title="statement not covered" >t</span>his.progressiveDone=i;<span class="cstat-no" title="statement not covered" >t</span>his.contentDispositionFilename=s;<span class="cstat-no" title="statement not covered" >t</span>his._rangeListeners=[];<span class="cstat-no" title="statement not covered" >t</span>his._progressListeners=[];<span class="cstat-no" title="statement not covered" >t</span>his._progressiveReadListeners=[];<span class="cstat-no" title="statement not covered" >t</span>his._progressiveDoneListeners=[];<span class="cstat-no" title="statement not covered" >t</span>his._readyCapability=new _util.PromiseCapability}<span class="fstat-no" title="function not covered" ></span>ad</span>dRangeListener(t){<span class="cstat-no" title="statement not covered" >this._rangeListeners.push(t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dProgressListener(t){<span class="cstat-no" title="statement not covered" >this._progressListeners.push(t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dProgressiveReadListener(t){<span class="cstat-no" title="statement not covered" >this._progressiveReadListeners.push(t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dProgressiveDoneListener(t){<span class="cstat-no" title="statement not covered" >this._progressiveDoneListeners.push(t)}<span class="fstat-no" title="function not covered" ></span>on</span>DataRange(t,e){<span class="cstat-no" title="statement not covered" >for(const i of this._rangeListeners)<span class="cstat-no" title="statement not covered" >i(t,e)}<span class="fstat-no" title="function not covered" ></span></span>on</span>DataProgress(t,e){<span class="cstat-no" title="statement not covered" >this._readyCapability.promise.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const i of this._progressListeners)<span class="cstat-no" title="statement not covered" >i(t,e)}</span></span>))}<span class="fstat-no" title="function not covered" ></span>on</span>DataProgressiveRead(t){<span class="cstat-no" title="statement not covered" >this._readyCapability.promise.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const e of this._progressiveReadListeners)<span class="cstat-no" title="statement not covered" >e(t)}</span></span>))}<span class="fstat-no" title="function not covered" ></span>on</span>DataProgressiveDone(){<span class="cstat-no" title="statement not covered" >this._readyCapability.promise.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const t of this._progressiveDoneListeners)<span class="cstat-no" title="statement not covered" >t()}</span></span>))}<span class="fstat-no" title="function not covered" ></span>tr</span>ansportReady(){<span class="cstat-no" title="statement not covered" >this._readyCapability.resolve()}<span class="fstat-no" title="function not covered" ></span>re</span>questDataRange(t,e){<span class="cstat-no" title="statement not covered" >(0,_util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange")}<span class="fstat-no" title="function not covered" ></span>ab</span>ort(){}}<span class="cstat-no" title="statement not covered" >exports.PDFDataRangeTransport=PDFDataRangeTransport;c</span>lass PDFDocumentProxy{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this._pdfInfo=t;<span class="cstat-no" title="statement not covered" >t</span>his._transport=e;<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(this,"getJavaScript",{value:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >(0,_display_utils.deprecated)("`PDFDocumentProxy.getJavaScript`, please use `PDFDocumentProxy.getJSActions` instead.");<span class="cstat-no" title="statement not covered" >r</span>eturn this.getJSActions().then((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const i in t)<span class="cstat-no" title="statement not covered" >e.push(...t[i]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>))}</span>})}<span class="fstat-no" title="function not covered" ></span>ge</span>t annotationStorage(){<span class="cstat-no" title="statement not covered" >return this._transport.annotationStorage}<span class="fstat-no" title="function not covered" ></span>ge</span>t filterFactory(){<span class="cstat-no" title="statement not covered" >return this._transport.filterFactory}<span class="fstat-no" title="function not covered" ></span>ge</span>t numPages(){<span class="cstat-no" title="statement not covered" >return this._pdfInfo.numPages}<span class="fstat-no" title="function not covered" ></span>ge</span>t fingerprints(){<span class="cstat-no" title="statement not covered" >return this._pdfInfo.fingerprints}<span class="fstat-no" title="function not covered" ></span>ge</span>t isPureXfa(){<span class="cstat-no" title="statement not covered" >return(0,_util.shadow)(this,"isPureXfa",!!this._transport._htmlForXfa)}<span class="fstat-no" title="function not covered" ></span>ge</span>t allXfaHtml(){<span class="cstat-no" title="statement not covered" >return this._transport._htmlForXfa}<span class="fstat-no" title="function not covered" ></span>ge</span>tPage(t){<span class="cstat-no" title="statement not covered" >return this._transport.getPage(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageIndex(t){<span class="cstat-no" title="statement not covered" >return this._transport.getPageIndex(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDestinations(){<span class="cstat-no" title="statement not covered" >return this._transport.getDestinations()}<span class="fstat-no" title="function not covered" ></span>ge</span>tDestination(t){<span class="cstat-no" title="statement not covered" >return this._transport.getDestination(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageLabels(){<span class="cstat-no" title="statement not covered" >return this._transport.getPageLabels()}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageLayout(){<span class="cstat-no" title="statement not covered" >return this._transport.getPageLayout()}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageMode(){<span class="cstat-no" title="statement not covered" >return this._transport.getPageMode()}<span class="fstat-no" title="function not covered" ></span>ge</span>tViewerPreferences(){<span class="cstat-no" title="statement not covered" >return this._transport.getViewerPreferences()}<span class="fstat-no" title="function not covered" ></span>ge</span>tOpenAction(){<span class="cstat-no" title="statement not covered" >return this._transport.getOpenAction()}<span class="fstat-no" title="function not covered" ></span>ge</span>tAttachments(){<span class="cstat-no" title="statement not covered" >return this._transport.getAttachments()}<span class="fstat-no" title="function not covered" ></span>ge</span>tJSActions(){<span class="cstat-no" title="statement not covered" >return this._transport.getDocJSActions()}<span class="fstat-no" title="function not covered" ></span>ge</span>tOutline(){<span class="cstat-no" title="statement not covered" >return this._transport.getOutline()}<span class="fstat-no" title="function not covered" ></span>ge</span>tOptionalContentConfig(){<span class="cstat-no" title="statement not covered" >return this._transport.getOptionalContentConfig()}<span class="fstat-no" title="function not covered" ></span>ge</span>tPermissions(){<span class="cstat-no" title="statement not covered" >return this._transport.getPermissions()}<span class="fstat-no" title="function not covered" ></span>ge</span>tMetadata(){<span class="cstat-no" title="statement not covered" >return this._transport.getMetadata()}<span class="fstat-no" title="function not covered" ></span>ge</span>tMarkInfo(){<span class="cstat-no" title="statement not covered" >return this._transport.getMarkInfo()}<span class="fstat-no" title="function not covered" ></span>ge</span>tData(){<span class="cstat-no" title="statement not covered" >return this._transport.getData()}<span class="fstat-no" title="function not covered" ></span>sa</span>veDocument(){<span class="cstat-no" title="statement not covered" >return this._transport.saveDocument()}<span class="fstat-no" title="function not covered" ></span>ge</span>tDownloadInfo(){<span class="cstat-no" title="statement not covered" >return this._transport.downloadInfoCapability.promise}<span class="fstat-no" title="function not covered" ></span>cl</span>eanup(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >return this._transport.startCleanup(t||this.isPureXfa)}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >return this.loadingTask.destroy()}<span class="fstat-no" title="function not covered" ></span>ge</span>t loadingParams(){<span class="cstat-no" title="statement not covered" >return this._transport.loadingParams}<span class="fstat-no" title="function not covered" ></span>ge</span>t loadingTask(){<span class="cstat-no" title="statement not covered" >return this._transport.loadingTask}<span class="fstat-no" title="function not covered" ></span>ge</span>tFieldObjects(){<span class="cstat-no" title="statement not covered" >return this._transport.getFieldObjects()}<span class="fstat-no" title="function not covered" ></span>ha</span>sJSActions(){<span class="cstat-no" title="statement not covered" >return this._transport.hasJSActions()}<span class="fstat-no" title="function not covered" ></span>ge</span>tCalculationOrderIds(){<span class="cstat-no" title="statement not covered" >return this._transport.getCalculationOrderIds()}</span>}<span class="cstat-no" title="statement not covered" >exports.PDFDocumentProxy=PDFDocumentProxy;c</span>lass PDFPageProxy{#i=<span class="cstat-no" title="statement not covered" >null;</span>#s=<span class="cstat-no" title="statement not covered" >!1;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e,i,s=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >this._pageIndex=t;<span class="cstat-no" title="statement not covered" >t</span>his._pageInfo=e;<span class="cstat-no" title="statement not covered" >t</span>his._transport=i;<span class="cstat-no" title="statement not covered" >t</span>his._stats=s?new _display_utils.StatTimer:null;<span class="cstat-no" title="statement not covered" >t</span>his._pdfBug=s;<span class="cstat-no" title="statement not covered" >t</span>his.commonObjs=i.commonObjs;<span class="cstat-no" title="statement not covered" >t</span>his.objs=new PDFObjects;<span class="cstat-no" title="statement not covered" >t</span>his._maybeCleanupAfterRender=!1;<span class="cstat-no" title="statement not covered" >t</span>his._intentStates=new Map;<span class="cstat-no" title="statement not covered" >t</span>his.destroyed=!1}<span class="fstat-no" title="function not covered" ></span>ge</span>t pageNumber(){<span class="cstat-no" title="statement not covered" >return this._pageIndex+1}<span class="fstat-no" title="function not covered" ></span>ge</span>t rotate(){<span class="cstat-no" title="statement not covered" >return this._pageInfo.rotate}<span class="fstat-no" title="function not covered" ></span>ge</span>t ref(){<span class="cstat-no" title="statement not covered" >return this._pageInfo.ref}<span class="fstat-no" title="function not covered" ></span>ge</span>t userUnit(){<span class="cstat-no" title="statement not covered" >return this._pageInfo.userUnit}<span class="fstat-no" title="function not covered" ></span>ge</span>t view(){<span class="cstat-no" title="statement not covered" >return this._pageInfo.view}<span class="fstat-no" title="function not covered" ></span>ge</span>tViewport({scale:t,rotation:e=<span class="branch-0 cbranch-no" title="branch not covered" >this.rotate,</span>offsetX:i=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>offsetY:s=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>dontFlip:n=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return new _display_utils.PageViewport({viewBox:this.view,scale:t,rotation:e,offsetX:i,offsetY:s,dontFlip:n})}<span class="fstat-no" title="function not covered" ></span>ge</span>tAnnotations({intent:t=<span class="branch-0 cbranch-no" title="branch not covered" >"display"}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const e=<span class="cstat-no" title="statement not covered" >this._transport.getRenderingIntent(t);<span class="cstat-no" title="statement not covered" ></span>return this._transport.getAnnotations(this._pageIndex,e.renderingIntent)}<span class="fstat-no" title="function not covered" ></span>ge</span>tJSActions(){<span class="cstat-no" title="statement not covered" >return this._transport.getPageJSActions(this._pageIndex)}<span class="fstat-no" title="function not covered" ></span>ge</span>t filterFactory(){<span class="cstat-no" title="statement not covered" >return this._transport.filterFactory}<span class="fstat-no" title="function not covered" ></span>ge</span>t isPureXfa(){<span class="cstat-no" title="statement not covered" >return(0,_util.shadow)(this,"isPureXfa",!!this._transport._htmlForXfa)}<span class="fstat-no" title="function not covered" ></span>as</span>ync getXfa(){<span class="cstat-no" title="statement not covered" >return this._transport._htmlForXfa?.children[this._pageIndex]||null}<span class="fstat-no" title="function not covered" ></span>re</span>nder({canvasContext:t,viewport:e,intent:i=<span class="branch-0 cbranch-no" title="branch not covered" >"display",</span>annotationMode:s=<span class="branch-0 cbranch-no" title="branch not covered" >_util.AnnotationMode.ENABLE,</span>transform:n=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>background:a=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>optionalContentConfigPromise:r=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>annotationCanvasMap:o=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>pageColors:l=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>printAnnotationStorage:c=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>){<span class="cstat-no" title="statement not covered" >this._stats?.time("Overall");c</span>onst h=<span class="cstat-no" title="statement not covered" >this._transport.getRenderingIntent(i,s,c);<span class="cstat-no" title="statement not covered" ></span>this.#s=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#n();<span class="cstat-no" title="statement not covered" >r</span>||(r=this._transport.getOptionalContentConfig());l</span>et d=<span class="cstat-no" title="statement not covered" >this._intentStates.get(h.cacheKey);<span class="cstat-no" title="statement not covered" ></span>if(!d){<span class="cstat-no" title="statement not covered" >d=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his._intentStates.set(h.cacheKey,d)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(d.streamReaderCancelTimeout){<span class="cstat-no" title="statement not covered" >clearTimeout(d.streamReaderCancelTimeout);<span class="cstat-no" title="statement not covered" >d</span>.streamReaderCancelTimeout=null}</span>c</span>onst u=<span class="cstat-no" title="statement not covered" >!!(h.renderingIntent&amp;_util.RenderingIntentFlag.PRINT);<span class="cstat-no" title="statement not covered" ></span>if(!d.displayReadyCapability){<span class="cstat-no" title="statement not covered" >d.displayReadyCapability=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >d</span>.operatorList={fnArray:[],argsArray:[],lastChunk:!1,separateAnnots:null};<span class="cstat-no" title="statement not covered" >t</span>his._stats?.time("Page Request");<span class="cstat-no" title="statement not covered" >t</span>his._pumpOperatorList(h)}</span>c</span>onst complete=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >d.renderTasks.delete(p);<span class="cstat-no" title="statement not covered" >(</span>this._maybeCleanupAfterRender||u)&amp;&amp;(this.#s=!0);<span class="cstat-no" title="statement not covered" >t</span>his.#a(!u);<span class="cstat-no" title="statement not covered" >i</span>f(t){<span class="cstat-no" title="statement not covered" >p.capability.reject(t);<span class="cstat-no" title="statement not covered" >t</span>his._abortOperatorList({intentState:d,reason:t instanceof Error?t:new Error(t)})}</span>else <span class="cstat-no" title="statement not covered" >p.capability.resolve();<span class="cstat-no" title="statement not covered" >t</span></span>his._stats?.timeEnd("Rendering");<span class="cstat-no" title="statement not covered" >t</span>his._stats?.timeEnd("Overall")}</span>,</span>p=<span class="cstat-no" title="statement not covered" >new InternalRenderTask({callback:complete,params:{canvasContext:t,viewport:e,transform:n,background:a},objs:this.objs,commonObjs:this.commonObjs,annotationCanvasMap:o,operatorList:d.operatorList,pageIndex:this._pageIndex,canvasFactory:this._transport.canvasFactory,filterFactory:this._transport.filterFactory,useRequestAnimationFrame:!u,pdfBug:this._pdfBug,pageColors:l});<span class="cstat-no" title="statement not covered" ></span>(d.renderTasks||=new Set).add(p);c</span>onst g=<span class="cstat-no" title="statement not covered" >p.task;<span class="cstat-no" title="statement not covered" ></span>Promise.all([d.displayReadyCapability.promise,r]).then((<span class="fstat-no" title="function not covered" >([</span>t,e])=&gt;{<span class="cstat-no" title="statement not covered" >if(this.destroyed)<span class="cstat-no" title="statement not covered" >complete();e</span>lse{<span class="cstat-no" title="statement not covered" >this._stats?.time("Rendering");<span class="cstat-no" title="statement not covered" >p</span>.initializeGraphics({transparency:t,optionalContentConfig:e});<span class="cstat-no" title="statement not covered" >p</span>.operatorListChanged()}</span>}</span>)).catch(complete);<span class="cstat-no" title="statement not covered" >r</span>eturn g}<span class="fstat-no" title="function not covered" ></span>ge</span>tOperatorList({intent:t=<span class="branch-0 cbranch-no" title="branch not covered" >"display",</span>annotationMode:e=<span class="branch-0 cbranch-no" title="branch not covered" >_util.AnnotationMode.ENABLE,</span>printAnnotationStorage:i=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const s=<span class="cstat-no" title="statement not covered" >this._transport.getRenderingIntent(t,e,i,!0);</span>let n,a=<span class="cstat-no" title="statement not covered" >this._intentStates.get(s.cacheKey);<span class="cstat-no" title="statement not covered" ></span>if(!a){<span class="cstat-no" title="statement not covered" >a=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his._intentStates.set(s.cacheKey,a)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!a.opListReadCapability){<span class="cstat-no" title="statement not covered" >n=Object.create(null);<span class="cstat-no" title="statement not covered" >n</span>.operatorListChanged=function <span class="fstat-no" title="function not covered" >operatorListChanged(</span>){<span class="cstat-no" title="statement not covered" >if(a.operatorList.lastChunk){<span class="cstat-no" title="statement not covered" >a.opListReadCapability.resolve(a.operatorList);<span class="cstat-no" title="statement not covered" >a</span>.renderTasks.delete(n)}</span>}</span>;<span class="cstat-no" title="statement not covered" >a</span>.opListReadCapability=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >(</span>a.renderTasks||=new Set).add(n);<span class="cstat-no" title="statement not covered" >a</span>.operatorList={fnArray:[],argsArray:[],lastChunk:!1,separateAnnots:null};<span class="cstat-no" title="statement not covered" >t</span>his._stats?.time("Page Request");<span class="cstat-no" title="statement not covered" >t</span>his._pumpOperatorList(s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a.opListReadCapability.promise}<span class="fstat-no" title="function not covered" ></span>st</span>reamTextContent({includeMarkedContent:t=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>disableNormalization:e=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return this._transport.messageHandler.sendWithStream("GetTextContent",{pageIndex:this._pageIndex,includeMarkedContent:!0===t,disableNormalization:!0===e},{highWaterMark:100,size:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.items.length}</span>)}<span class="fstat-no" title="function not covered" ></span>ge</span>tTextContent(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >if(this._transport._htmlForXfa)<span class="cstat-no" title="statement not covered" >return this.getXfa().then((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >_xfa_text.XfaText.textContent(t))</span>);c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.streamTextContent(t);<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){const s=<span class="cstat-no" title="statement not covered" >e.getReader(),</span>n=<span class="cstat-no" title="statement not covered" >{items:[],styles:Object.create(null)};<span class="cstat-no" title="statement not covered" ></span>!function <span class="fstat-no" title="function not covered" >pump(</span>){<span class="cstat-no" title="statement not covered" >s.read().then((<span class="fstat-no" title="function not covered" >fu</span>nction({value:e,done:i}){<span class="cstat-no" title="statement not covered" >if(i)<span class="cstat-no" title="statement not covered" >t(n);e</span>lse{<span class="cstat-no" title="statement not covered" >Object.assign(n.styles,e.styles);<span class="cstat-no" title="statement not covered" >n</span>.items.push(...e.items);<span class="cstat-no" title="statement not covered" >p</span>ump()}</span>}</span>),i)}</span>()}</span>))}<span class="fstat-no" title="function not covered" ></span>ge</span>tStructTree(){<span class="cstat-no" title="statement not covered" >return this._transport.getStructTree(this._pageIndex)}<span class="fstat-no" title="function not covered" ></span>_d</span>estroy(){<span class="cstat-no" title="statement not covered" >this.destroyed=!0;c</span>onst t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const e of this._intentStates.values()){<span class="cstat-no" title="statement not covered" >this._abortOperatorList({intentState:e,reason:new Error("Page was destroyed."),force:!0});<span class="cstat-no" title="statement not covered" >i</span>f(!e.opListReadCapability)<span class="cstat-no" title="statement not covered" >for(const i of e.renderTasks){<span class="cstat-no" title="statement not covered" >t.push(i.completed);<span class="cstat-no" title="statement not covered" >i</span>.cancel()}</span>}<span class="cstat-no" title="statement not covered" ></span></span>t</span>his.objs.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#s=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#n();<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.all(t)}<span class="fstat-no" title="function not covered" ></span>cl</span>eanup(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >this.#s=!0;c</span>onst e=<span class="cstat-no" title="statement not covered" >this.#a(!1);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;e&amp;&amp;(this._stats&amp;&amp;=new _display_utils.StatTimer);<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>#a(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >this.#n();<span class="cstat-no" title="statement not covered" >i</span>f(!this.#s||this.destroyed)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(t){<span class="cstat-no" title="statement not covered" >this.#i=setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.#i=null;<span class="cstat-no" title="statement not covered" >t</span>his.#a(!1)}</span>),DELAYED_CLEANUP_TIMEOUT);<span class="cstat-no" title="statement not covered" >r</span>eturn!1}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const{renderTasks:t,operatorList:e}of this._intentStates.values())<span class="cstat-no" title="statement not covered" >if(t.size&gt;0||!e.lastChunk)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >t</span></span></span>his._intentStates.clear();<span class="cstat-no" title="statement not covered" >t</span>his.objs.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#s=!1;<span class="cstat-no" title="statement not covered" >r</span>eturn!0}</span>#n(){<span class="cstat-no" title="statement not covered" >if(this.#i){<span class="cstat-no" title="statement not covered" >clearTimeout(this.#i);<span class="cstat-no" title="statement not covered" >t</span>his.#i=null}</span>}<span class="fstat-no" title="function not covered" ></span>_s</span>tartRenderPage(t,e){const i=<span class="cstat-no" title="statement not covered" >this._intentStates.get(e);<span class="cstat-no" title="statement not covered" ></span>if(i){<span class="cstat-no" title="statement not covered" >this._stats?.timeEnd("Page Request");<span class="cstat-no" title="statement not covered" >i</span>.displayReadyCapability?.resolve(t)}</span>}<span class="fstat-no" title="function not covered" ></span>_r</span>enderPageChunk(t,e){<span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>i&lt;s;i++){<span class="cstat-no" title="statement not covered" >e.operatorList.fnArray.push(t.fnArray[i]);<span class="cstat-no" title="statement not covered" >e</span>.operatorList.argsArray.push(t.argsArray[i])}<span class="cstat-no" title="statement not covered" ></span>e</span>.operatorList.lastChunk=t.lastChunk;<span class="cstat-no" title="statement not covered" >e</span>.operatorList.separateAnnots=t.separateAnnots;<span class="cstat-no" title="statement not covered" >f</span>or(const t of e.renderTasks)<span class="cstat-no" title="statement not covered" >t.operatorListChanged();<span class="cstat-no" title="statement not covered" >t</span></span>.lastChunk&amp;&amp;this.#a(!0)}<span class="fstat-no" title="function not covered" ></span>_p</span>umpOperatorList({renderingIntent:t,cacheKey:e,annotationStorageSerializable:i}){const{map:s,transfers:n}=<span class="cstat-no" title="statement not covered" >i,</span>a=<span class="cstat-no" title="statement not covered" >this._transport.messageHandler.sendWithStream("GetOperatorList",{pageIndex:this._pageIndex,intent:t,cacheKey:e,annotationStorage:s},n).getReader(),</span>r=<span class="cstat-no" title="statement not covered" >this._intentStates.get(e);<span class="cstat-no" title="statement not covered" ></span>r.streamReader=a;c</span>onst pump=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >a.read().then((<span class="fstat-no" title="function not covered" >({</span>value:t,done:e})=&gt;{<span class="cstat-no" title="statement not covered" >if(e)<span class="cstat-no" title="statement not covered" >r.streamReader=null;e</span>lse <span class="cstat-no" title="statement not covered" >if(!this._transport.destroyed){<span class="cstat-no" title="statement not covered" >this._renderPageChunk(t,r);<span class="cstat-no" title="statement not covered" >p</span>ump()}</span>}</span></span>),(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >r.streamReader=null;<span class="cstat-no" title="statement not covered" >i</span>f(!this._transport.destroyed){<span class="cstat-no" title="statement not covered" >if(r.operatorList){<span class="cstat-no" title="statement not covered" >r.operatorList.lastChunk=!0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of r.renderTasks)<span class="cstat-no" title="statement not covered" >t.operatorListChanged();<span class="cstat-no" title="statement not covered" >t</span></span>his.#a(!0)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r.displayReadyCapability)<span class="cstat-no" title="statement not covered" >r.displayReadyCapability.reject(t);e</span>lse{<span class="cstat-no" title="statement not covered" >if(!r.opListReadCapability)<span class="cstat-no" title="statement not covered" >throw t;<span class="cstat-no" title="statement not covered" >r</span></span>.opListReadCapability.reject(t)}</span>}</span>}</span>))}</span>;<span class="cstat-no" title="statement not covered" ></span>pump()}<span class="fstat-no" title="function not covered" ></span>_a</span>bortOperatorList({intentState:t,reason:e,force:i=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>){<span class="cstat-no" title="statement not covered" >if(t.streamReader){<span class="cstat-no" title="statement not covered" >if(t.streamReaderCancelTimeout){<span class="cstat-no" title="statement not covered" >clearTimeout(t.streamReaderCancelTimeout);<span class="cstat-no" title="statement not covered" >t</span>.streamReaderCancelTimeout=null}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!i){<span class="cstat-no" title="statement not covered" >if(t.renderTasks.size&gt;0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(e instanceof _display_utils.RenderingCancelledException){let i=<span class="cstat-no" title="statement not covered" >RENDERING_CANCELLED_TIMEOUT;<span class="cstat-no" title="statement not covered" ></span>e.extraDelay&gt;0&amp;&amp;e.extraDelay&lt;1e3&amp;&amp;(i+=e.extraDelay);<span class="cstat-no" title="statement not covered" >t</span>.streamReaderCancelTimeout=setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.streamReaderCancelTimeout=null;<span class="cstat-no" title="statement not covered" >t</span>his._abortOperatorList({intentState:t,reason:e,force:!0})}</span>),i);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>.streamReader.cancel(new _util.AbortException(e.message)).catch((<span class="fstat-no" title="function not covered" >()</span>=&gt;{}));<span class="cstat-no" title="statement not covered" >t</span>.streamReader=null;<span class="cstat-no" title="statement not covered" >i</span>f(!this._transport.destroyed){<span class="cstat-no" title="statement not covered" >for(const[e,i]of this._intentStates)<span class="cstat-no" title="statement not covered" >if(i===t){<span class="cstat-no" title="statement not covered" >this._intentStates.delete(e);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>t</span></span>his.cleanup()}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t stats(){<span class="cstat-no" title="statement not covered" >return this._stats}</span>}<span class="cstat-no" title="statement not covered" >exports.PDFPageProxy=PDFPageProxy;c</span>lass LoopbackPort{#r=<span class="cstat-no" title="statement not covered" >new Set;</span>#o=<span class="cstat-no" title="statement not covered" >Promise.resolve();<span class="fstat-no" title="function not covered" ></span>po</span>stMessage(t,e){const i=<span class="cstat-no" title="statement not covered" >{data:structuredClone(t,e?{transfer:e}:null)};<span class="cstat-no" title="statement not covered" ></span>this.#o.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const t of this.#r)<span class="cstat-no" title="statement not covered" >t.call(this,i)}</span></span>))}<span class="fstat-no" title="function not covered" ></span>ad</span>dEventListener(t,e){<span class="cstat-no" title="statement not covered" >this.#r.add(e)}<span class="fstat-no" title="function not covered" ></span>re</span>moveEventListener(t,e){<span class="cstat-no" title="statement not covered" >this.#r.delete(e)}<span class="fstat-no" title="function not covered" ></span>te</span>rminate(){<span class="cstat-no" title="statement not covered" >this.#r.clear()}</span>}<span class="cstat-no" title="statement not covered" >exports.LoopbackPort=LoopbackPort;c</span>onst PDFWorkerUtil=<span class="cstat-no" title="statement not covered" >{isWorkerDisabled:!1,fallbackWorkerSrc:null,fakeWorkerId:0};<span class="cstat-no" title="statement not covered" ></span>exports.PDFWorkerUtil=PDFWorkerUtil;<span class="cstat-no" title="statement not covered" >i</span>f(_util.isNodeJS&amp;&amp;"function"==typeof require){<span class="cstat-no" title="statement not covered" >PDFWorkerUtil.isWorkerDisabled=!0;<span class="cstat-no" title="statement not covered" >P</span>DFWorkerUtil.fallbackWorkerSrc="./pdf.worker.js"}</span>else <span class="cstat-no" title="statement not covered" >if("object"==typeof document){const t=<span class="cstat-no" title="statement not covered" >document?.currentScript?.src;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(PDFWorkerUtil.fallbackWorkerSrc=t.replace(/(\.(?:min\.)?js)(\?.*)?$/i,".worker$1$2"))}<span class="cstat-no" title="statement not covered" ></span>P</span></span>DFWorkerUtil.isSameOrigin=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >i=new URL(t);<span class="cstat-no" title="statement not covered" >i</span>f(!i.origin||"null"===i.origin)<span class="cstat-no" title="statement not covered" >return!1}</span></span>catch{<span class="cstat-no" title="statement not covered" >return!1}</span>c</span>onst s=<span class="cstat-no" title="statement not covered" >new URL(e,i);<span class="cstat-no" title="statement not covered" ></span>return i.origin===s.origin}</span>;<span class="cstat-no" title="statement not covered" >P</span>DFWorkerUtil.createCDNWrapper=<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >`importScripts("${t}");`;<span class="cstat-no" title="statement not covered" ></span>return URL.createObjectURL(new Blob([e]))}</span>;c</span>lass PDFWorker{static#l;<span class="fstat-no" title="function not covered" >co</span>nstructor({name:t=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>port:e=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>verbosity:i=<span class="branch-0 cbranch-no" title="branch not covered" >(0,_util.getVerbosityLevel)()}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this.name=t;<span class="cstat-no" title="statement not covered" >t</span>his.destroyed=!1;<span class="cstat-no" title="statement not covered" >t</span>his.verbosity=i;<span class="cstat-no" title="statement not covered" >t</span>his._readyCapability=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his._port=null;<span class="cstat-no" title="statement not covered" >t</span>his._webWorker=null;<span class="cstat-no" title="statement not covered" >t</span>his._messageHandler=null;<span class="cstat-no" title="statement not covered" >i</span>f(e){<span class="cstat-no" title="statement not covered" >if(PDFWorker.#l?.has(e))<span class="cstat-no" title="statement not covered" >throw new Error("Cannot use more than one PDFWorker per port.");<span class="cstat-no" title="statement not covered" >(</span></span>PDFWorker.#l||=new WeakMap).set(e,this);<span class="cstat-no" title="statement not covered" >t</span>his._initializeFromPort(e)}</span>else <span class="cstat-no" title="statement not covered" >this._initialize()}<span class="fstat-no" title="function not covered" ></span></span>ge</span>t promise(){<span class="cstat-no" title="statement not covered" >return this._readyCapability.promise}<span class="fstat-no" title="function not covered" ></span>ge</span>t port(){<span class="cstat-no" title="statement not covered" >return this._port}<span class="fstat-no" title="function not covered" ></span>ge</span>t messageHandler(){<span class="cstat-no" title="statement not covered" >return this._messageHandler}<span class="fstat-no" title="function not covered" ></span>_i</span>nitializeFromPort(t){<span class="cstat-no" title="statement not covered" >this._port=t;<span class="cstat-no" title="statement not covered" >t</span>his._messageHandler=new _message_handler.MessageHandler("main","worker",t);<span class="cstat-no" title="statement not covered" >t</span>his._messageHandler.on("ready",(<span class="fstat-no" title="function not covered" >fu</span>nction(){}));<span class="cstat-no" title="statement not covered" >t</span>his._readyCapability.resolve();<span class="cstat-no" title="statement not covered" >t</span>his._messageHandler.send("configure",{verbosity:this.verbosity})}<span class="fstat-no" title="function not covered" ></span>_i</span>nitialize(){<span class="cstat-no" title="statement not covered" >if(!PDFWorkerUtil.isWorkerDisabled&amp;&amp;!PDFWorker._mainThreadWorkerMessageHandler){let{workerSrc:t}=<span class="cstat-no" title="statement not covered" >PDFWorker;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >PDFWorkerUtil.isSameOrigin(window.location.href,t)||(t=PDFWorkerUtil.createCDNWrapper(new URL(t,window.location).href));c</span>onst e=<span class="cstat-no" title="statement not covered" >new Worker(t),</span>i=<span class="cstat-no" title="statement not covered" >new _message_handler.MessageHandler("main","worker",e),</span>terminateEarly=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e.removeEventListener("error",onWorkerError);<span class="cstat-no" title="statement not covered" >i</span>.destroy();<span class="cstat-no" title="statement not covered" >e</span>.terminate();<span class="cstat-no" title="statement not covered" >t</span>his.destroyed?this._readyCapability.reject(new Error("Worker was destroyed")):this._setupFakeWorker()}</span>,</span>onWorkerError=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._webWorker||terminateEarly()}</span>;<span class="cstat-no" title="statement not covered" ></span>e.addEventListener("error",onWorkerError);<span class="cstat-no" title="statement not covered" >i</span>.on("test",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.removeEventListener("error",onWorkerError);<span class="cstat-no" title="statement not covered" >i</span>f(this.destroyed)<span class="cstat-no" title="statement not covered" >terminateEarly();e</span>lse <span class="cstat-no" title="statement not covered" >if(t){<span class="cstat-no" title="statement not covered" >this._messageHandler=i;<span class="cstat-no" title="statement not covered" >t</span>his._port=e;<span class="cstat-no" title="statement not covered" >t</span>his._webWorker=e;<span class="cstat-no" title="statement not covered" >t</span>his._readyCapability.resolve();<span class="cstat-no" title="statement not covered" >i</span>.send("configure",{verbosity:this.verbosity})}</span>else{<span class="cstat-no" title="statement not covered" >this._setupFakeWorker();<span class="cstat-no" title="statement not covered" >i</span>.destroy();<span class="cstat-no" title="statement not covered" >e</span>.terminate()}</span>}</span></span>));<span class="cstat-no" title="statement not covered" >i</span>.on("ready",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.removeEventListener("error",onWorkerError);<span class="cstat-no" title="statement not covered" >i</span>f(this.destroyed)<span class="cstat-no" title="statement not covered" >terminateEarly();e</span>lse <span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >sendTest()}</span>catch{<span class="cstat-no" title="statement not covered" >this._setupFakeWorker()}</span>}</span></span>));c</span>onst sendTest=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{const t=<span class="cstat-no" title="statement not covered" >new Uint8Array;<span class="cstat-no" title="statement not covered" ></span>i.send("test",t,[t.buffer])}</span>;<span class="cstat-no" title="statement not covered" ></span>sendTest();<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>catch{<span class="cstat-no" title="statement not covered" >(0,_util.info)("The worker has been disabled.")}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his._setupFakeWorker()}<span class="fstat-no" title="function not covered" ></span>_s</span>etupFakeWorker(){<span class="cstat-no" title="statement not covered" >if(!PDFWorkerUtil.isWorkerDisabled){<span class="cstat-no" title="statement not covered" >(0,_util.warn)("Setting up fake worker.");<span class="cstat-no" title="statement not covered" >P</span>DFWorkerUtil.isWorkerDisabled=!0}<span class="cstat-no" title="statement not covered" ></span>P</span>DFWorker._setupFakeWorkerGlobal.then((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(this.destroyed){<span class="cstat-no" title="statement not covered" >this._readyCapability.reject(new Error("Worker was destroyed"));<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >new LoopbackPort;<span class="cstat-no" title="statement not covered" ></span>this._port=e;c</span>onst i=<span class="cstat-no" title="statement not covered" >"fake"+PDFWorkerUtil.fakeWorkerId++,</span>s=<span class="cstat-no" title="statement not covered" >new _message_handler.MessageHandler(i+"_worker",i,e);<span class="cstat-no" title="statement not covered" ></span>t.setup(s,e);c</span>onst n=<span class="cstat-no" title="statement not covered" >new _message_handler.MessageHandler(i,i+"_worker",e);<span class="cstat-no" title="statement not covered" ></span>this._messageHandler=n;<span class="cstat-no" title="statement not covered" >t</span>his._readyCapability.resolve();<span class="cstat-no" title="statement not covered" >n</span>.send("configure",{verbosity:this.verbosity})}</span>)).catch((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._readyCapability.reject(new Error(`Setting up fake worker failed: "${t.message}".`))}</span>))}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.destroyed=!0;<span class="cstat-no" title="statement not covered" >i</span>f(this._webWorker){<span class="cstat-no" title="statement not covered" >this._webWorker.terminate();<span class="cstat-no" title="statement not covered" >t</span>his._webWorker=null}<span class="cstat-no" title="statement not covered" ></span>P</span>DFWorker.#l?.delete(this._port);<span class="cstat-no" title="statement not covered" >t</span>his._port=null;<span class="cstat-no" title="statement not covered" >i</span>f(this._messageHandler){<span class="cstat-no" title="statement not covered" >this._messageHandler.destroy();<span class="cstat-no" title="statement not covered" >t</span>his._messageHandler=null}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>atic fromPort(t){<span class="cstat-no" title="statement not covered" >if(!t?.port)<span class="cstat-no" title="statement not covered" >throw new Error("PDFWorker.fromPort - invalid method signature.");c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.#l?.get(t.port);<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >if(e._pendingDestroy)<span class="cstat-no" title="statement not covered" >throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new PDFWorker(t)}<span class="fstat-no" title="function not covered" ></span>st</span>atic get workerSrc(){<span class="cstat-no" title="statement not covered" >if(_worker_options.GlobalWorkerOptions.workerSrc)<span class="cstat-no" title="statement not covered" >return _worker_options.GlobalWorkerOptions.workerSrc;<span class="cstat-no" title="statement not covered" >i</span></span>f(null!==PDFWorkerUtil.fallbackWorkerSrc){<span class="cstat-no" title="statement not covered" >_util.isNodeJS||(0,_display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');<span class="cstat-no" title="statement not covered" >r</span>eturn PDFWorkerUtil.fallbackWorkerSrc}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new Error('No "GlobalWorkerOptions.workerSrc" specified.')}<span class="fstat-no" title="function not covered" ></span>st</span>atic get _mainThreadWorkerMessageHandler(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return globalThis.pdfjsWorker?.WorkerMessageHandler||null}</span>catch{<span class="cstat-no" title="statement not covered" >return null}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>atic get _setupFakeWorkerGlobal(){const loader=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{const mainWorkerMessageHandler=<span class="cstat-no" title="statement not covered" >this._mainThreadWorkerMessageHandler;<span class="cstat-no" title="statement not covered" ></span>if(mainWorkerMessageHandler)<span class="cstat-no" title="statement not covered" >return mainWorkerMessageHandler;<span class="cstat-no" title="statement not covered" >i</span></span>f(_util.isNodeJS&amp;&amp;"function"==typeof require){const worker=<span class="cstat-no" title="statement not covered" >eval("require")(this.workerSrc);<span class="cstat-no" title="statement not covered" ></span>return worker.WorkerMessageHandler}<span class="cstat-no" title="statement not covered" ></span>a</span>wait(0,_display_utils.loadScript)(this.workerSrc);<span class="cstat-no" title="statement not covered" >r</span>eturn window.pdfjsWorker.WorkerMessageHandler}</span>;<span class="cstat-no" title="statement not covered" ></span>return(0,_util.shadow)(this,"_setupFakeWorkerGlobal",loader())}</span>}<span class="cstat-no" title="statement not covered" >exports.PDFWorker=PDFWorker;c</span>lass WorkerTransport{#c=<span class="cstat-no" title="statement not covered" >new Map;</span>#h=<span class="cstat-no" title="statement not covered" >new Map;</span>#d=<span class="cstat-no" title="statement not covered" >new Map;</span>#u=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e,i,s,n){<span class="cstat-no" title="statement not covered" >this.messageHandler=t;<span class="cstat-no" title="statement not covered" >t</span>his.loadingTask=e;<span class="cstat-no" title="statement not covered" >t</span>his.commonObjs=new PDFObjects;<span class="cstat-no" title="statement not covered" >t</span>his.fontLoader=new _font_loader.FontLoader({ownerDocument:s.ownerDocument,styleElement:s.styleElement});<span class="cstat-no" title="statement not covered" >t</span>his._params=s;<span class="cstat-no" title="statement not covered" >t</span>his.canvasFactory=n.canvasFactory;<span class="cstat-no" title="statement not covered" >t</span>his.filterFactory=n.filterFactory;<span class="cstat-no" title="statement not covered" >t</span>his.cMapReaderFactory=n.cMapReaderFactory;<span class="cstat-no" title="statement not covered" >t</span>his.standardFontDataFactory=n.standardFontDataFactory;<span class="cstat-no" title="statement not covered" >t</span>his.destroyed=!1;<span class="cstat-no" title="statement not covered" >t</span>his.destroyCapability=null;<span class="cstat-no" title="statement not covered" >t</span>his._networkStream=i;<span class="cstat-no" title="statement not covered" >t</span>his._fullReader=null;<span class="cstat-no" title="statement not covered" >t</span>his._lastProgress=null;<span class="cstat-no" title="statement not covered" >t</span>his.downloadInfoCapability=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his.setupMessageHandler()}</span>#p(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{const i=<span class="cstat-no" title="statement not covered" >this.#c.get(t);<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >return i;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.messageHandler.sendWithPromise(t,e);<span class="cstat-no" title="statement not covered" ></span>this.#c.set(t,s);<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>ge</span>t annotationStorage(){<span class="cstat-no" title="statement not covered" >return(0,_util.shadow)(this,"annotationStorage",new _annotation_storage.AnnotationStorage)}<span class="fstat-no" title="function not covered" ></span>ge</span>tRenderingIntent(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >_util.AnnotationMode.ENABLE,</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{let n=<span class="cstat-no" title="statement not covered" >_util.RenderingIntentFlag.DISPLAY,</span>a=<span class="cstat-no" title="statement not covered" >_annotation_storage.SerializableEmpty;<span class="cstat-no" title="statement not covered" ></span>switch(t){case"any":<span class="cstat-no" title="statement not covered" >n=_util.RenderingIntentFlag.ANY;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"display":<span class="cstat-no" title="statement not covered" >break;c</span>ase"print":<span class="cstat-no" title="statement not covered" >n=_util.RenderingIntentFlag.PRINT;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >(0,_util.warn)(`getRenderingIntent - invalid intent: ${t}`)}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(e){case _util.AnnotationMode.DISABLE:<span class="cstat-no" title="statement not covered" >n+=_util.RenderingIntentFlag.ANNOTATIONS_DISABLE;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase _util.AnnotationMode.ENABLE:<span class="cstat-no" title="statement not covered" >break;c</span>ase _util.AnnotationMode.ENABLE_FORMS:<span class="cstat-no" title="statement not covered" >n+=_util.RenderingIntentFlag.ANNOTATIONS_FORMS;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase _util.AnnotationMode.ENABLE_STORAGE:<span class="cstat-no" title="statement not covered" >n+=_util.RenderingIntentFlag.ANNOTATIONS_STORAGE;<span class="cstat-no" title="statement not covered" >a</span>=(n&amp;_util.RenderingIntentFlag.PRINT&amp;&amp;i instanceof _annotation_storage.PrintAnnotationStorage?i:this.annotationStorage).serializable;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >(0,_util.warn)(`getRenderingIntent - invalid annotationMode: ${e}`)}<span class="cstat-no" title="statement not covered" ></span>s</span>&amp;&amp;(n+=_util.RenderingIntentFlag.OPLIST);<span class="cstat-no" title="statement not covered" >r</span>eturn{renderingIntent:n,cacheKey:`${n}_${a.hash}`,annotationStorageSerializable:a}}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >if(this.destroyCapability)<span class="cstat-no" title="statement not covered" >return this.destroyCapability.promise;<span class="cstat-no" title="statement not covered" >t</span></span>his.destroyed=!0;<span class="cstat-no" title="statement not covered" >t</span>his.destroyCapability=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his.#u?.reject(new Error("Worker was destroyed during onPassword callback"));c</span>onst t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const e of this.#h.values())<span class="cstat-no" title="statement not covered" >t.push(e._destroy());<span class="cstat-no" title="statement not covered" >t</span></span>his.#h.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#d.clear();<span class="cstat-no" title="statement not covered" >t</span>his.hasOwnProperty("annotationStorage")&amp;&amp;this.annotationStorage.resetModified();c</span>onst e=<span class="cstat-no" title="statement not covered" >this.messageHandler.sendWithPromise("Terminate",null);<span class="cstat-no" title="statement not covered" ></span>t.push(e);<span class="cstat-no" title="statement not covered" >P</span>romise.all(t).then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.commonObjs.clear();<span class="cstat-no" title="statement not covered" >t</span>his.fontLoader.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#c.clear();<span class="cstat-no" title="statement not covered" >t</span>his.filterFactory.destroy();<span class="cstat-no" title="statement not covered" >t</span>his._networkStream?.cancelAllRequests(new _util.AbortException("Worker was terminated."));<span class="cstat-no" title="statement not covered" >i</span>f(this.messageHandler){<span class="cstat-no" title="statement not covered" >this.messageHandler.destroy();<span class="cstat-no" title="statement not covered" >t</span>his.messageHandler=null}<span class="cstat-no" title="statement not covered" ></span>t</span>his.destroyCapability.resolve()}</span>),this.destroyCapability.reject);<span class="cstat-no" title="statement not covered" >r</span>eturn this.destroyCapability.promise}<span class="fstat-no" title="function not covered" ></span>se</span>tupMessageHandler(){const{messageHandler:t,loadingTask:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t.on("GetReader",(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >(0,_util.assert)(this._networkStream,"GetReader - no `IPDFStream` instance available.");<span class="cstat-no" title="statement not covered" >t</span>his._fullReader=this._networkStream.getFullReader();<span class="cstat-no" title="statement not covered" >t</span>his._fullReader.onProgress=<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._lastProgress={loaded:t.loaded,total:t.total}}</span>;<span class="cstat-no" title="statement not covered" >e</span>.onPull=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._fullReader.read().then((<span class="fstat-no" title="function not covered" >fu</span>nction({value:t,done:i}){<span class="cstat-no" title="statement not covered" >if(i)<span class="cstat-no" title="statement not covered" >e.close();e</span>lse{<span class="cstat-no" title="statement not covered" >(0,_util.assert)(t instanceof ArrayBuffer,"GetReader - expected an ArrayBuffer.");<span class="cstat-no" title="statement not covered" >e</span>.enqueue(new Uint8Array(t),1,[t])}</span>}</span>)).catch((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.error(t)}</span>))}</span>;<span class="cstat-no" title="statement not covered" >e</span>.onCancel=<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._fullReader.cancel(t);<span class="cstat-no" title="statement not covered" >e</span>.ready.catch((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!this.destroyed)<span class="cstat-no" title="statement not covered" >throw t}</span></span>))}</span>}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("ReaderHeadersReady",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >new _util.PromiseCapability,</span>s=<span class="cstat-no" title="statement not covered" >this._fullReader;<span class="cstat-no" title="statement not covered" ></span>s.headersReady.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!s.isStreamingSupported||!s.isRangeSupported){<span class="cstat-no" title="statement not covered" >this._lastProgress&amp;&amp;e.onProgress?.(this._lastProgress);<span class="cstat-no" title="statement not covered" >s</span>.onProgress=<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.onProgress?.({loaded:t.loaded,total:t.total})}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>.resolve({isStreamingSupported:s.isStreamingSupported,isRangeSupported:s.isRangeSupported,contentLength:s.contentLength})}</span>),i.reject);<span class="cstat-no" title="statement not covered" >r</span>eturn i.promise}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("GetRangeReader",(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >(0,_util.assert)(this._networkStream,"GetRangeReader - no `IPDFStream` instance available.");c</span>onst i=<span class="cstat-no" title="statement not covered" >this._networkStream.getRangeReader(t.begin,t.end);<span class="cstat-no" title="statement not covered" ></span>if(i){<span class="cstat-no" title="statement not covered" >e.onPull=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i.read().then((<span class="fstat-no" title="function not covered" >fu</span>nction({value:t,done:i}){<span class="cstat-no" title="statement not covered" >if(i)<span class="cstat-no" title="statement not covered" >e.close();e</span>lse{<span class="cstat-no" title="statement not covered" >(0,_util.assert)(t instanceof ArrayBuffer,"GetRangeReader - expected an ArrayBuffer.");<span class="cstat-no" title="statement not covered" >e</span>.enqueue(new Uint8Array(t),1,[t])}</span>}</span>)).catch((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.error(t)}</span>))}</span>;<span class="cstat-no" title="statement not covered" >e</span>.onCancel=<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >i.cancel(t);<span class="cstat-no" title="statement not covered" >e</span>.ready.catch((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!this.destroyed)<span class="cstat-no" title="statement not covered" >throw t}</span></span>))}</span>}</span>else <span class="cstat-no" title="statement not covered" >e.close()}</span></span>));<span class="cstat-no" title="statement not covered" >t</span>.on("GetDoc",(<span class="fstat-no" title="function not covered" >({</span>pdfInfo:t})=&gt;{<span class="cstat-no" title="statement not covered" >this._numPages=t.numPages;<span class="cstat-no" title="statement not covered" >t</span>his._htmlForXfa=t.htmlForXfa;<span class="cstat-no" title="statement not covered" >d</span>elete t.htmlForXfa;<span class="cstat-no" title="statement not covered" >e</span>._capability.resolve(new PDFDocumentProxy(t,this))}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("DocException",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){let i;<span class="cstat-no" title="statement not covered" >switch(t.name){case"PasswordException":<span class="cstat-no" title="statement not covered" >i=new _util.PasswordException(t.message,t.code);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidPDFException":<span class="cstat-no" title="statement not covered" >i=new _util.InvalidPDFException(t.message);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"MissingPDFException":<span class="cstat-no" title="statement not covered" >i=new _util.MissingPDFException(t.message);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnexpectedResponseException":<span class="cstat-no" title="statement not covered" >i=new _util.UnexpectedResponseException(t.message,t.status);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownErrorException":<span class="cstat-no" title="statement not covered" >i=new _util.UnknownErrorException(t.message,t.details);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >(0,_util.unreachable)("DocException - expected a valid Error.")}<span class="cstat-no" title="statement not covered" ></span>e</span>._capability.reject(i)}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("PasswordRequest",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.#u=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >i</span>f(e.onPassword){const updatePassword=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t instanceof Error?this.#u.reject(t):this.#u.resolve({password:t})}</span>;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >e.onPassword(updatePassword,t.code)}</span>catch(t){<span class="cstat-no" title="statement not covered" >this.#u.reject(t)}</span>}</span>else <span class="cstat-no" title="statement not covered" >this.#u.reject(new _util.PasswordException(t.message,t.code));<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.#u.promise}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("DataLoaded",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.onProgress?.({loaded:t.length,total:t.length});<span class="cstat-no" title="statement not covered" >t</span>his.downloadInfoCapability.resolve(t)}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("StartRenderPage",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(this.destroyed)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.#h.get(t.pageIndex)._startRenderPage(t.transparency,t.cacheKey)}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("commonobj",(<span class="fstat-no" title="function not covered" >([</span>e,i,s])=&gt;{<span class="cstat-no" title="statement not covered" >if(!this.destroyed&amp;&amp;!this.commonObjs.has(e))<span class="cstat-no" title="statement not covered" >switch(i){case"Font":const n=<span class="cstat-no" title="statement not covered" >this._params;<span class="cstat-no" title="statement not covered" ></span>if("error"in s){const t=<span class="cstat-no" title="statement not covered" >s.error;<span class="cstat-no" title="statement not covered" ></span>(0,_util.warn)(`Error during font loading: ${t}`);<span class="cstat-no" title="statement not covered" >t</span>his.commonObjs.resolve(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>c</span>onst a=<span class="cstat-no" title="statement not covered" >n.pdfBug&amp;&amp;globalThis.FontInspector?.enabled?<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >globalThis.FontInspector.fontAdded(t,e):</span>null,</span>r=<span class="cstat-no" title="statement not covered" >new _font_loader.FontFaceObject(s,{isEvalSupported:n.isEvalSupported,disableFontFace:n.disableFontFace,ignoreErrors:n.ignoreErrors,inspectFont:a});<span class="cstat-no" title="statement not covered" ></span>this.fontLoader.bind(r).catch((<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >t.sendWithPromise("FontFallback",{id:e}))</span>).finally((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >!n.fontExtraProperties&amp;&amp;r.data&amp;&amp;(r.data=null);<span class="cstat-no" title="statement not covered" >t</span>his.commonObjs.resolve(e,r)}</span>));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"FontPath":case"Image":case"Pattern":<span class="cstat-no" title="statement not covered" >this.commonObjs.resolve(e,s);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error(`Got unknown common object type ${i}`)}</span>}</span></span>));<span class="cstat-no" title="statement not covered" >t</span>.on("obj",(<span class="fstat-no" title="function not covered" >([</span>t,e,i,s])=&gt;{<span class="cstat-no" title="statement not covered" >if(this.destroyed)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this.#h.get(e);<span class="cstat-no" title="statement not covered" ></span>if(!n.objs.has(t))<span class="cstat-no" title="statement not covered" >switch(i){case"Image":<span class="cstat-no" title="statement not covered" >n.objs.resolve(t,s);<span class="cstat-no" title="statement not covered" >i</span>f(s){let t;<span class="cstat-no" title="statement not covered" >if(s.bitmap){const{width:e,height:i}=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>t=e*i*4}</span>else <span class="cstat-no" title="statement not covered" >t=s.data?.length||0;<span class="cstat-no" title="statement not covered" >t</span></span>&gt;_util.MAX_IMAGE_SIZE_TO_CACHE&amp;&amp;(n._maybeCleanupAfterRender=!0)}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase"Pattern":<span class="cstat-no" title="statement not covered" >n.objs.resolve(t,s);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error(`Got unknown object type ${i}`)}</span>}</span></span>));<span class="cstat-no" title="statement not covered" >t</span>.on("DocProgress",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.destroyed||e.onProgress?.({loaded:t.loaded,total:t.total})}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("FetchBuiltInCMap",(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.destroyed?Promise.reject(new Error("Worker was destroyed.")):this.cMapReaderFactory?this.cMapReaderFactory.fetch(t):Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.")))</span>);<span class="cstat-no" title="statement not covered" >t</span>.on("FetchStandardFontData",(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.destroyed?Promise.reject(new Error("Worker was destroyed.")):this.standardFontDataFactory?this.standardFontDataFactory.fetch(t):Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")))</span>)}<span class="fstat-no" title="function not covered" ></span>ge</span>tData(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetData",null)}<span class="fstat-no" title="function not covered" ></span>sa</span>veDocument(){<span class="cstat-no" title="statement not covered" >this.annotationStorage.size&lt;=0&amp;&amp;(0,_util.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");c</span>onst{map:t,transfers:e}=<span class="cstat-no" title="statement not covered" >this.annotationStorage.serializable;<span class="cstat-no" title="statement not covered" ></span>return this.messageHandler.sendWithPromise("SaveDocument",{isPureXfa:!!this._htmlForXfa,numPages:this._numPages,annotationStorage:t,filename:this._fullReader?.filename??null},e).finally((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.annotationStorage.resetModified()}</span>))}<span class="fstat-no" title="function not covered" ></span>ge</span>tPage(t){<span class="cstat-no" title="statement not covered" >if(!Number.isInteger(t)||t&lt;=0||t&gt;this._numPages)<span class="cstat-no" title="statement not covered" >return Promise.reject(new Error("Invalid page request."));c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t-1,</span>i=<span class="cstat-no" title="statement not covered" >this.#d.get(e);<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >return i;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.messageHandler.sendWithPromise("GetPage",{pageIndex:e}).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(this.destroyed)<span class="cstat-no" title="statement not covered" >throw new Error("Transport destroyed");c</span></span>onst i=<span class="cstat-no" title="statement not covered" >new PDFPageProxy(e,t,this,this._params.pdfBug);<span class="cstat-no" title="statement not covered" ></span>this.#h.set(e,i);<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>));<span class="cstat-no" title="statement not covered" ></span>this.#d.set(e,s);<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageIndex(t){<span class="cstat-no" title="statement not covered" >return"object"!=typeof t||null===t||!Number.isInteger(t.num)||t.num&lt;0||!Number.isInteger(t.gen)||t.gen&lt;0?Promise.reject(new Error("Invalid pageIndex request.")):this.messageHandler.sendWithPromise("GetPageIndex",{num:t.num,gen:t.gen})}<span class="fstat-no" title="function not covered" ></span>ge</span>tAnnotations(t,e){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetAnnotations",{pageIndex:t,intent:e})}<span class="fstat-no" title="function not covered" ></span>ge</span>tFieldObjects(){<span class="cstat-no" title="statement not covered" >return this.#p("GetFieldObjects")}<span class="fstat-no" title="function not covered" ></span>ha</span>sJSActions(){<span class="cstat-no" title="statement not covered" >return this.#p("HasJSActions")}<span class="fstat-no" title="function not covered" ></span>ge</span>tCalculationOrderIds(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetCalculationOrderIds",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDestinations(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetDestinations",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDestination(t){<span class="cstat-no" title="statement not covered" >return"string"!=typeof t?Promise.reject(new Error("Invalid destination request.")):this.messageHandler.sendWithPromise("GetDestination",{id:t})}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageLabels(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetPageLabels",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageLayout(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetPageLayout",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageMode(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetPageMode",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tViewerPreferences(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetViewerPreferences",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tOpenAction(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetOpenAction",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tAttachments(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetAttachments",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDocJSActions(){<span class="cstat-no" title="statement not covered" >return this.#p("GetDocJSActions")}<span class="fstat-no" title="function not covered" ></span>ge</span>tPageJSActions(t){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetPageJSActions",{pageIndex:t})}<span class="fstat-no" title="function not covered" ></span>ge</span>tStructTree(t){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetStructTree",{pageIndex:t})}<span class="fstat-no" title="function not covered" ></span>ge</span>tOutline(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetOutline",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tOptionalContentConfig(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetOptionalContentConfig",null).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >new _optional_content_config.OptionalContentConfig(t))</span>)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPermissions(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetPermissions",null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tMetadata(){const t=<span class="cstat-no" title="statement not covered" >"GetMetadata",</span>e=<span class="cstat-no" title="statement not covered" >this.#c.get(t);<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return e;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.messageHandler.sendWithPromise(t,null).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{info:t[0],metadata:t[1]?new _metadata.Metadata(t[1]):null,contentDispositionFilename:this._fullReader?.filename??null,contentLength:this._fullReader?.contentLength??null})</span>));<span class="cstat-no" title="statement not covered" ></span>this.#c.set(t,i);<span class="cstat-no" title="statement not covered" >r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>ge</span>tMarkInfo(){<span class="cstat-no" title="statement not covered" >return this.messageHandler.sendWithPromise("GetMarkInfo",null)}<span class="fstat-no" title="function not covered" ></span>as</span>ync startCleanup(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(!this.destroyed){<span class="cstat-no" title="statement not covered" >await this.messageHandler.sendWithPromise("Cleanup",null);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#h.values()){<span class="cstat-no" title="statement not covered" >if(!t.cleanup())<span class="cstat-no" title="statement not covered" >throw new Error(`startCleanup: Page ${t.pageNumber} is currently rendering.`)}<span class="cstat-no" title="statement not covered" ></span></span>t</span>his.commonObjs.clear();<span class="cstat-no" title="statement not covered" >t</span>||this.fontLoader.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#c.clear();<span class="cstat-no" title="statement not covered" >t</span>his.filterFactory.destroy(!0)}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t loadingParams(){const{disableAutoFetch:t,enableXfa:e}=<span class="cstat-no" title="statement not covered" >this._params;<span class="cstat-no" title="statement not covered" ></span>return(0,_util.shadow)(this,"loadingParams",{disableAutoFetch:t,enableXfa:e})}</span>}class PDFObjects{#g=<span class="cstat-no" title="statement not covered" >Object.create(null);</span>#m(t){<span class="cstat-no" title="statement not covered" >return this.#g[t]||={capability:new _util.PromiseCapability,data:null}}<span class="fstat-no" title="function not covered" ></span>ge</span>t(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >if(e){const i=<span class="cstat-no" title="statement not covered" >this.#m(t);<span class="cstat-no" title="statement not covered" ></span>i.capability.promise.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e(i.data))</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn null}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >this.#g[t];<span class="cstat-no" title="statement not covered" ></span>if(!i?.capability.settled)<span class="cstat-no" title="statement not covered" >throw new Error(`Requesting object that isn't resolved yet ${t}.`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i.data}<span class="fstat-no" title="function not covered" ></span>ha</span>s(t){const e=<span class="cstat-no" title="statement not covered" >this.#g[t];<span class="cstat-no" title="statement not covered" ></span>return e?.capability.settled||!1}<span class="fstat-no" title="function not covered" ></span>re</span>solve(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{const i=<span class="cstat-no" title="statement not covered" >this.#m(t);<span class="cstat-no" title="statement not covered" ></span>i.data=e;<span class="cstat-no" title="statement not covered" >i</span>.capability.resolve()}<span class="fstat-no" title="function not covered" ></span>cl</span>ear(){<span class="cstat-no" title="statement not covered" >for(const t in this.#g){const{data:e}=<span class="cstat-no" title="statement not covered" >this.#g[t];<span class="cstat-no" title="statement not covered" ></span>e?.bitmap?.close()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#g=Object.create(null)}</span>}class RenderTask{#f=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.#f=t;<span class="cstat-no" title="statement not covered" >t</span>his.onContinue=null}<span class="fstat-no" title="function not covered" ></span>ge</span>t promise(){<span class="cstat-no" title="statement not covered" >return this.#f.capability.promise}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >this.#f.cancel(null,t)}<span class="fstat-no" title="function not covered" ></span>ge</span>t separateAnnots(){const{separateAnnots:t}=<span class="cstat-no" title="statement not covered" >this.#f.operatorList;<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst{annotationCanvasMap:e}=<span class="cstat-no" title="statement not covered" >this.#f;<span class="cstat-no" title="statement not covered" ></span>return t.form||t.canvas&amp;&amp;e?.size&gt;0}</span>}<span class="cstat-no" title="statement not covered" >exports.RenderTask=RenderTask;c</span>lass InternalRenderTask{static#b=<span class="cstat-no" title="statement not covered" >new WeakSet;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor({callback:t,params:e,objs:i,commonObjs:s,annotationCanvasMap:n,operatorList:a,pageIndex:r,canvasFactory:o,filterFactory:l,useRequestAnimationFrame:c=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>pdfBug:h=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>pageColors:d=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>){<span class="cstat-no" title="statement not covered" >this.callback=t;<span class="cstat-no" title="statement not covered" >t</span>his.params=e;<span class="cstat-no" title="statement not covered" >t</span>his.objs=i;<span class="cstat-no" title="statement not covered" >t</span>his.commonObjs=s;<span class="cstat-no" title="statement not covered" >t</span>his.annotationCanvasMap=n;<span class="cstat-no" title="statement not covered" >t</span>his.operatorListIdx=null;<span class="cstat-no" title="statement not covered" >t</span>his.operatorList=a;<span class="cstat-no" title="statement not covered" >t</span>his._pageIndex=r;<span class="cstat-no" title="statement not covered" >t</span>his.canvasFactory=o;<span class="cstat-no" title="statement not covered" >t</span>his.filterFactory=l;<span class="cstat-no" title="statement not covered" >t</span>his._pdfBug=h;<span class="cstat-no" title="statement not covered" >t</span>his.pageColors=d;<span class="cstat-no" title="statement not covered" >t</span>his.running=!1;<span class="cstat-no" title="statement not covered" >t</span>his.graphicsReadyCallback=null;<span class="cstat-no" title="statement not covered" >t</span>his.graphicsReady=!1;<span class="cstat-no" title="statement not covered" >t</span>his._useRequestAnimationFrame=!0===c&amp;&amp;"undefined"!=typeof window;<span class="cstat-no" title="statement not covered" >t</span>his.cancelled=!1;<span class="cstat-no" title="statement not covered" >t</span>his.capability=new _util.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his.task=new RenderTask(this);<span class="cstat-no" title="statement not covered" >t</span>his._cancelBound=this.cancel.bind(this);<span class="cstat-no" title="statement not covered" >t</span>his._continueBound=this._continue.bind(this);<span class="cstat-no" title="statement not covered" >t</span>his._scheduleNextBound=this._scheduleNext.bind(this);<span class="cstat-no" title="statement not covered" >t</span>his._nextBound=this._next.bind(this);<span class="cstat-no" title="statement not covered" >t</span>his._canvas=e.canvasContext.canvas}<span class="fstat-no" title="function not covered" ></span>ge</span>t completed(){<span class="cstat-no" title="statement not covered" >return this.capability.promise.catch((<span class="fstat-no" title="function not covered" >fu</span>nction(){}))}<span class="fstat-no" title="function not covered" ></span>in</span>itializeGraphics({transparency:t=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>optionalContentConfig:e}){<span class="cstat-no" title="statement not covered" >if(this.cancelled)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(this._canvas){<span class="cstat-no" title="statement not covered" >if(InternalRenderTask.#b.has(this._canvas))<span class="cstat-no" title="statement not covered" >throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");<span class="cstat-no" title="statement not covered" >I</span></span>nternalRenderTask.#b.add(this._canvas)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this._pdfBug&amp;&amp;globalThis.StepperManager?.enabled){<span class="cstat-no" title="statement not covered" >this.stepper=globalThis.StepperManager.create(this._pageIndex);<span class="cstat-no" title="statement not covered" >t</span>his.stepper.init(this.operatorList);<span class="cstat-no" title="statement not covered" >t</span>his.stepper.nextBreakPoint=this.stepper.getNextBreakPoint()}</span>c</span>onst{canvasContext:i,viewport:s,transform:n,background:a}=<span class="cstat-no" title="statement not covered" >this.params;<span class="cstat-no" title="statement not covered" ></span>this.gfx=new _canvas.CanvasGraphics(i,this.commonObjs,this.objs,this.canvasFactory,this.filterFactory,{optionalContentConfig:e},this.annotationCanvasMap,this.pageColors);<span class="cstat-no" title="statement not covered" >t</span>his.gfx.beginDrawing({transform:n,viewport:s,transparency:t,background:a});<span class="cstat-no" title="statement not covered" >t</span>his.operatorListIdx=0;<span class="cstat-no" title="statement not covered" >t</span>his.graphicsReady=!0;<span class="cstat-no" title="statement not covered" >t</span>his.graphicsReadyCallback?.()}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >this.running=!1;<span class="cstat-no" title="statement not covered" >t</span>his.cancelled=!0;<span class="cstat-no" title="statement not covered" >t</span>his.gfx?.endDrawing();<span class="cstat-no" title="statement not covered" >t</span>his._canvas&amp;&amp;InternalRenderTask.#b.delete(this._canvas);<span class="cstat-no" title="statement not covered" >t</span>his.callback(t||new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex+1}`,e))}<span class="fstat-no" title="function not covered" ></span>op</span>eratorListChanged(){<span class="cstat-no" title="statement not covered" >if(this.graphicsReady){<span class="cstat-no" title="statement not covered" >this.stepper?.updateOperatorList(this.operatorList);<span class="cstat-no" title="statement not covered" >t</span>his.running||this._continue()}</span>else <span class="cstat-no" title="statement not covered" >this.graphicsReadyCallback||=this._continueBound}<span class="fstat-no" title="function not covered" ></span></span>_c</span>ontinue(){<span class="cstat-no" title="statement not covered" >this.running=!0;<span class="cstat-no" title="statement not covered" >t</span>his.cancelled||(this.task.onContinue?this.task.onContinue(this._scheduleNextBound):this._scheduleNext())}<span class="fstat-no" title="function not covered" ></span>_s</span>cheduleNext(){<span class="cstat-no" title="statement not covered" >this._useRequestAnimationFrame?window.requestAnimationFrame((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._nextBound().catch(this._cancelBound)}</span>)):Promise.resolve().then(this._nextBound).catch(this._cancelBound)}<span class="fstat-no" title="function not covered" ></span>as</span>ync _next(){<span class="cstat-no" title="statement not covered" >if(!this.cancelled){<span class="cstat-no" title="statement not covered" >this.operatorListIdx=this.gfx.executeOperatorList(this.operatorList,this.operatorListIdx,this._continueBound,this.stepper);<span class="cstat-no" title="statement not covered" >i</span>f(this.operatorListIdx===this.operatorList.argsArray.length){<span class="cstat-no" title="statement not covered" >this.running=!1;<span class="cstat-no" title="statement not covered" >i</span>f(this.operatorList.lastChunk){<span class="cstat-no" title="statement not covered" >this.gfx.endDrawing(this.pageColors);<span class="cstat-no" title="statement not covered" >t</span>his._canvas&amp;&amp;InternalRenderTask.#b.delete(this._canvas);<span class="cstat-no" title="statement not covered" >t</span>his.callback()}</span>}</span>}</span>}</span>}const version=<span class="cstat-no" title="statement not covered" >"3.10.111";<span class="cstat-no" title="statement not covered" ></span>exports.version=version;c</span>onst build=<span class="cstat-no" title="statement not covered" >"e142baecb";<span class="cstat-no" title="statement not covered" ></span>exports.build=build}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.SerializableEmpty=e.PrintAnnotationStorage=e.AnnotationStorage=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(4),</span>a=<span class="cstat-no" title="statement not covered" >i(8);</span>const r=<span class="cstat-no" title="statement not covered" >Object.freeze({map:null,hash:"",transfers:void 0});<span class="cstat-no" title="statement not covered" ></span>e.SerializableEmpty=r;c</span>lass AnnotationStorage{#A=<span class="cstat-no" title="statement not covered" >!1;</span>#_=<span class="cstat-no" title="statement not covered" >new Map;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.onSetModified=null;<span class="cstat-no" title="statement not covered" >t</span>his.onResetModified=null;<span class="cstat-no" title="statement not covered" >t</span>his.onAnnotationEditor=null}<span class="fstat-no" title="function not covered" ></span>ge</span>tValue(t,e){const i=<span class="cstat-no" title="statement not covered" >this.#_.get(t);<span class="cstat-no" title="statement not covered" ></span>return void 0===i?e:Object.assign(e,i)}<span class="fstat-no" title="function not covered" ></span>ge</span>tRawValue(t){<span class="cstat-no" title="statement not covered" >return this.#_.get(t)}<span class="fstat-no" title="function not covered" ></span>re</span>move(t){<span class="cstat-no" title="statement not covered" >this.#_.delete(t);<span class="cstat-no" title="statement not covered" >0</span>===this.#_.size&amp;&amp;this.resetModified();<span class="cstat-no" title="statement not covered" >i</span>f("function"==typeof this.onAnnotationEditor){<span class="cstat-no" title="statement not covered" >for(const t of this.#_.values())<span class="cstat-no" title="statement not covered" >if(t instanceof n.AnnotationEditor)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span></span>his.onAnnotationEditor(null)}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tValue(t,e){const i=<span class="cstat-no" title="statement not covered" >this.#_.get(t);</span>let s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==i){<span class="cstat-no" title="statement not covered" >for(const[t,n]of Object.entries(e))<span class="cstat-no" title="statement not covered" >if(i[t]!==n){<span class="cstat-no" title="statement not covered" >s=!0;<span class="cstat-no" title="statement not covered" >i</span>[t]=n}</span>}</span></span>else{<span class="cstat-no" title="statement not covered" >s=!0;<span class="cstat-no" title="statement not covered" >t</span>his.#_.set(t,e)}<span class="cstat-no" title="statement not covered" ></span>s</span>&amp;&amp;this.#v();<span class="cstat-no" title="statement not covered" >e</span> instanceof n.AnnotationEditor&amp;&amp;"function"==typeof this.onAnnotationEditor&amp;&amp;this.onAnnotationEditor(e.constructor._type)}<span class="fstat-no" title="function not covered" ></span>ha</span>s(t){<span class="cstat-no" title="statement not covered" >return this.#_.has(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tAll(){<span class="cstat-no" title="statement not covered" >return this.#_.size&gt;0?(0,s.objectFromMap)(this.#_):null}<span class="fstat-no" title="function not covered" ></span>se</span>tAll(t){<span class="cstat-no" title="statement not covered" >for(const[e,i]of Object.entries(t))<span class="cstat-no" title="statement not covered" >this.setValue(e,i)}<span class="fstat-no" title="function not covered" ></span></span>ge</span>t size(){<span class="cstat-no" title="statement not covered" >return this.#_.size}</span>#v(){<span class="cstat-no" title="statement not covered" >if(!this.#A){<span class="cstat-no" title="statement not covered" >this.#A=!0;<span class="cstat-no" title="statement not covered" >"</span>function"==typeof this.onSetModified&amp;&amp;this.onSetModified()}</span>}<span class="fstat-no" title="function not covered" ></span>re</span>setModified(){<span class="cstat-no" title="statement not covered" >if(this.#A){<span class="cstat-no" title="statement not covered" >this.#A=!1;<span class="cstat-no" title="statement not covered" >"</span>function"==typeof this.onResetModified&amp;&amp;this.onResetModified()}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t print(){<span class="cstat-no" title="statement not covered" >return new PrintAnnotationStorage(this)}<span class="fstat-no" title="function not covered" ></span>ge</span>t serializable(){<span class="cstat-no" title="statement not covered" >if(0===this.#_.size)<span class="cstat-no" title="statement not covered" >return r;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >new Map,</span>e=<span class="cstat-no" title="statement not covered" >new a.MurmurHash3_64,</span>i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >Object.create(null);</span>let o=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(const[i,a]of this.#_){const r=<span class="cstat-no" title="statement not covered" >a instanceof n.AnnotationEditor?a.serialize(!1,s):a;<span class="cstat-no" title="statement not covered" ></span>if(r){<span class="cstat-no" title="statement not covered" >t.set(i,r);<span class="cstat-no" title="statement not covered" >e</span>.update(`${i}:${JSON.stringify(r)}`);<span class="cstat-no" title="statement not covered" >o</span>||=!!r.bitmap}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o)<span class="cstat-no" title="statement not covered" >for(const e of t.values())<span class="cstat-no" title="statement not covered" >e.bitmap&amp;&amp;i.push(e.bitmap);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t.size&gt;0?{map:t,hash:e.hexdigest(),transfers:i}:r}</span>}<span class="cstat-no" title="statement not covered" >e.AnnotationStorage=AnnotationStorage;c</span>lass PrintAnnotationStorage extends AnnotationStorage{#y;<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super();c</span>onst{map:e,hash:i,transfers:s}=<span class="cstat-no" title="statement not covered" >t.serializable,</span>n=<span class="cstat-no" title="statement not covered" >structuredClone(e,s?{transfer:s}:null);<span class="cstat-no" title="statement not covered" ></span>this.#y={map:n,hash:i,transfers:s}}<span class="fstat-no" title="function not covered" ></span>ge</span>t print(){<span class="cstat-no" title="statement not covered" >(0,s.unreachable)("Should not call PrintAnnotationStorage.print")}<span class="fstat-no" title="function not covered" ></span>ge</span>t serializable(){<span class="cstat-no" title="statement not covered" >return this.#y}</span>}<span class="cstat-no" title="statement not covered" >e.PrintAnnotationStorage=PrintAnnotationStorage}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.AnnotationEditor=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(5),</span>n=<span class="cstat-no" title="statement not covered" >i(1);</span>class AnnotationEditor{#S=<span class="cstat-no" title="statement not covered" >!1;</span>#E=<span class="cstat-no" title="statement not covered" >null;</span>#x=<span class="cstat-no" title="statement not covered" >this.focusin.bind(this);</span>#w=<span class="cstat-no" title="statement not covered" >this.focusout.bind(this);</span>#C=<span class="cstat-no" title="statement not covered" >!1;</span>#T=<span class="cstat-no" title="statement not covered" >!1;</span>#P=<span class="cstat-no" title="statement not covered" >!1;</span>_initialOptions=<span class="cstat-no" title="statement not covered" >Object.create(null);</span>_uiManager=<span class="cstat-no" title="statement not covered" >null;</span>_focusEventsAllowed=<span class="cstat-no" title="statement not covered" >!0;</span>#M=<span class="cstat-no" title="statement not covered" >!1;</span>#F=<span class="cstat-no" title="statement not covered" >AnnotationEditor._zIndex++;</span>static _colorManager=<span class="cstat-no" title="statement not covered" >new s.ColorManager;</span>static _zIndex=<span class="cstat-no" title="statement not covered" >1;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.constructor===AnnotationEditor&amp;&amp;(0,n.unreachable)("Cannot initialize AnnotationEditor.");<span class="cstat-no" title="statement not covered" >t</span>his.parent=t.parent;<span class="cstat-no" title="statement not covered" >t</span>his.id=t.id;<span class="cstat-no" title="statement not covered" >t</span>his.width=this.height=null;<span class="cstat-no" title="statement not covered" >t</span>his.pageIndex=t.parent.pageIndex;<span class="cstat-no" title="statement not covered" >t</span>his.name=t.name;<span class="cstat-no" title="statement not covered" >t</span>his.div=null;<span class="cstat-no" title="statement not covered" >t</span>his._uiManager=t.uiManager;<span class="cstat-no" title="statement not covered" >t</span>his.annotationElementId=null;<span class="cstat-no" title="statement not covered" >t</span>his._willKeepAspectRatio=!1;<span class="cstat-no" title="statement not covered" >t</span>his._initialOptions.isCentered=t.isCentered;c</span>onst{rotation:e,rawDims:{pageWidth:i,pageHeight:s,pageX:a,pageY:r}}=<span class="cstat-no" title="statement not covered" >this.parent.viewport;<span class="cstat-no" title="statement not covered" ></span>this.rotation=e;<span class="cstat-no" title="statement not covered" >t</span>his.pageRotation=(360+e-this._uiManager.viewParameters.rotation)%360;<span class="cstat-no" title="statement not covered" >t</span>his.pageDimensions=[i,s];<span class="cstat-no" title="statement not covered" >t</span>his.pageTranslation=[a,r];c</span>onst[o,l]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.x=t.x/o;<span class="cstat-no" title="statement not covered" >t</span>his.y=t.y/l;<span class="cstat-no" title="statement not covered" >t</span>his.isAttachedToDOM=!1;<span class="cstat-no" title="statement not covered" >t</span>his.deleted=!1}<span class="fstat-no" title="function not covered" ></span>st</span>atic get _defaultLineColor(){<span class="cstat-no" title="statement not covered" >return(0,n.shadow)(this,"_defaultLineColor",this._colorManager.getHexCode("CanvasText"))}<span class="fstat-no" title="function not covered" ></span>st</span>atic deleteAnnotationElement(t){const e=<span class="cstat-no" title="statement not covered" >new FakeEditor({id:t.parent.getNextId(),parent:t.parent,uiManager:t._uiManager});<span class="cstat-no" title="statement not covered" ></span>e.annotationElementId=t.annotationElementId;<span class="cstat-no" title="statement not covered" >e</span>.deleted=!0;<span class="cstat-no" title="statement not covered" >e</span>._uiManager.addToAnnotationStorage(e)}<span class="fstat-no" title="function not covered" ></span>st</span>atic initialize(t){}<span class="fstat-no" title="function not covered" >st</span>atic updateDefaultParams(t,e){}<span class="fstat-no" title="function not covered" >st</span>atic get defaultPropertiesToUpdate(){<span class="cstat-no" title="statement not covered" >return[]}<span class="fstat-no" title="function not covered" ></span>st</span>atic isHandlingMimeForPasting(t){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>st</span>atic paste(t,e){<span class="cstat-no" title="statement not covered" >(0,n.unreachable)("Not implemented")}<span class="fstat-no" title="function not covered" ></span>ge</span>t propertiesToUpdate(){<span class="cstat-no" title="statement not covered" >return[]}<span class="fstat-no" title="function not covered" ></span>ge</span>t _isDraggable(){<span class="cstat-no" title="statement not covered" >return this.#M}<span class="fstat-no" title="function not covered" ></span>se</span>t _isDraggable(t){<span class="cstat-no" title="statement not covered" >this.#M=t;<span class="cstat-no" title="statement not covered" >t</span>his.div?.classList.toggle("draggable",t)}<span class="fstat-no" title="function not covered" ></span>ce</span>nter(){const[t,e]=<span class="cstat-no" title="statement not covered" >this.pageDimensions;<span class="cstat-no" title="statement not covered" ></span>switch(this.parentRotation){case 90:<span class="cstat-no" title="statement not covered" >this.x-=this.height*e/(2*t);<span class="cstat-no" title="statement not covered" >t</span>his.y+=this.width*t/(2*e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 180:<span class="cstat-no" title="statement not covered" >this.x+=this.width/2;<span class="cstat-no" title="statement not covered" >t</span>his.y+=this.height/2;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 270:<span class="cstat-no" title="statement not covered" >this.x+=this.height*e/(2*t);<span class="cstat-no" title="statement not covered" >t</span>his.y-=this.width*t/(2*e);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >this.x-=this.width/2;<span class="cstat-no" title="statement not covered" >t</span>his.y-=this.height/2}<span class="cstat-no" title="statement not covered" ></span>t</span>his.fixAndSetPosition()}<span class="fstat-no" title="function not covered" ></span>ad</span>dCommands(t){<span class="cstat-no" title="statement not covered" >this._uiManager.addCommands(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>t currentLayer(){<span class="cstat-no" title="statement not covered" >return this._uiManager.currentLayer}<span class="fstat-no" title="function not covered" ></span>se</span>tInBackground(){<span class="cstat-no" title="statement not covered" >this.div.style.zIndex=0}<span class="fstat-no" title="function not covered" ></span>se</span>tInForeground(){<span class="cstat-no" title="statement not covered" >this.div.style.zIndex=this.#F}<span class="fstat-no" title="function not covered" ></span>se</span>tParent(t){<span class="cstat-no" title="statement not covered" >if(null!==t){<span class="cstat-no" title="statement not covered" >this.pageIndex=t.pageIndex;<span class="cstat-no" title="statement not covered" >t</span>his.pageDimensions=t.pageDimensions}<span class="cstat-no" title="statement not covered" ></span>t</span>his.parent=t}<span class="fstat-no" title="function not covered" ></span>fo</span>cusin(t){<span class="cstat-no" title="statement not covered" >this._focusEventsAllowed&amp;&amp;(this.#C?this.#C=!1:this.parent.setSelected(this))}<span class="fstat-no" title="function not covered" ></span>fo</span>cusout(t){<span class="cstat-no" title="statement not covered" >if(!this._focusEventsAllowed)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.isAttachedToDOM)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t.relatedTarget;<span class="cstat-no" title="statement not covered" ></span>if(!e?.closest(`#${this.id}`)){<span class="cstat-no" title="statement not covered" >t.preventDefault();<span class="cstat-no" title="statement not covered" >t</span>his.parent?.isMultipleSelection||this.commitOrRemove()}</span>}<span class="fstat-no" title="function not covered" ></span>co</span>mmitOrRemove(){<span class="cstat-no" title="statement not covered" >this.isEmpty()?this.remove():this.commit()}<span class="fstat-no" title="function not covered" ></span>co</span>mmit(){<span class="cstat-no" title="statement not covered" >this.addToAnnotationStorage()}<span class="fstat-no" title="function not covered" ></span>ad</span>dToAnnotationStorage(){<span class="cstat-no" title="statement not covered" >this._uiManager.addToAnnotationStorage(this)}<span class="fstat-no" title="function not covered" ></span>se</span>tAt(t,e,i,s){const[n,a]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>[i,s]=this.screenToPageTranslation(i,s);<span class="cstat-no" title="statement not covered" >t</span>his.x=(t+i)/n;<span class="cstat-no" title="statement not covered" >t</span>his.y=(e+s)/a;<span class="cstat-no" title="statement not covered" >t</span>his.fixAndSetPosition()}</span>#k([t,e],i,s){<span class="cstat-no" title="statement not covered" >[i,s]=this.screenToPageTranslation(i,s);<span class="cstat-no" title="statement not covered" >t</span>his.x+=i/t;<span class="cstat-no" title="statement not covered" >t</span>his.y+=s/e;<span class="cstat-no" title="statement not covered" >t</span>his.fixAndSetPosition()}<span class="fstat-no" title="function not covered" ></span>tr</span>anslate(t,e){<span class="cstat-no" title="statement not covered" >this.#k(this.parentDimensions,t,e)}<span class="fstat-no" title="function not covered" ></span>tr</span>anslateInPage(t,e){<span class="cstat-no" title="statement not covered" >this.#k(this.pageDimensions,t,e);<span class="cstat-no" title="statement not covered" >t</span>his.moveInDOM();<span class="cstat-no" title="statement not covered" >t</span>his.div.scrollIntoView({block:"nearest"})}<span class="fstat-no" title="function not covered" ></span>dr</span>ag(t,e){const[i,s]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.x+=t/i;<span class="cstat-no" title="statement not covered" >t</span>his.y+=e/s;<span class="cstat-no" title="statement not covered" >i</span>f(this.x&lt;0||this.x&gt;1||this.y&lt;0||this.y&gt;1){const{x:t,y:e}=<span class="cstat-no" title="statement not covered" >this.div.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>if(this.parent.findNewParent(this,t,e)){<span class="cstat-no" title="statement not covered" >this.x-=Math.floor(this.x);<span class="cstat-no" title="statement not covered" >t</span>his.y-=Math.floor(this.y)}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.div.style.left=`${(100*this.x).toFixed(2)}%`;<span class="cstat-no" title="statement not covered" >t</span>his.div.style.top=`${(100*this.y).toFixed(2)}%`;<span class="cstat-no" title="statement not covered" >t</span>his.div.scrollIntoView({block:"nearest"})}<span class="fstat-no" title="function not covered" ></span>fi</span>xAndSetPosition(){const[t,e]=<span class="cstat-no" title="statement not covered" >this.pageDimensions;</span>let{x:i,y:s,width:n,height:a}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>n*=t;<span class="cstat-no" title="statement not covered" >a</span>*=e;<span class="cstat-no" title="statement not covered" >i</span>*=t;<span class="cstat-no" title="statement not covered" >s</span>*=e;<span class="cstat-no" title="statement not covered" >s</span>witch(this.rotation){case 0:<span class="cstat-no" title="statement not covered" >i=Math.max(0,Math.min(t-n,i));<span class="cstat-no" title="statement not covered" >s</span>=Math.max(0,Math.min(e-a,s));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 90:<span class="cstat-no" title="statement not covered" >i=Math.max(0,Math.min(t-a,i));<span class="cstat-no" title="statement not covered" >s</span>=Math.min(e,Math.max(n,s));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 180:<span class="cstat-no" title="statement not covered" >i=Math.min(t,Math.max(n,i));<span class="cstat-no" title="statement not covered" >s</span>=Math.min(e,Math.max(a,s));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 270:<span class="cstat-no" title="statement not covered" >i=Math.min(t,Math.max(a,i));<span class="cstat-no" title="statement not covered" >s</span>=Math.max(0,Math.min(e-n,s))}<span class="cstat-no" title="statement not covered" ></span>t</span>his.x=i/t;<span class="cstat-no" title="statement not covered" >t</span>his.y=s/e;<span class="cstat-no" title="statement not covered" >t</span>his.div.style.left=`${(100*this.x).toFixed(2)}%`;<span class="cstat-no" title="statement not covered" >t</span>his.div.style.top=`${(100*this.y).toFixed(2)}%`}</span>static#R(t,e,i){<span class="cstat-no" title="statement not covered" >switch(i){case 90:<span class="cstat-no" title="statement not covered" >return[e,-t];c</span>ase 180:<span class="cstat-no" title="statement not covered" >return[-t,-e];c</span>ase 270:<span class="cstat-no" title="statement not covered" >return[-e,t];d</span>efault:<span class="cstat-no" title="statement not covered" >return[t,e]}</span>}<span class="fstat-no" title="function not covered" ></span>sc</span>reenToPageTranslation(t,e){<span class="cstat-no" title="statement not covered" >return AnnotationEditor.#R(t,e,this.parentRotation)}<span class="fstat-no" title="function not covered" ></span>pa</span>geTranslationToScreen(t,e){<span class="cstat-no" title="statement not covered" >return AnnotationEditor.#R(t,e,360-this.parentRotation)}</span>#D(t){<span class="cstat-no" title="statement not covered" >switch(t){case 90:{const[t,e]=<span class="cstat-no" title="statement not covered" >this.pageDimensions;<span class="cstat-no" title="statement not covered" ></span>return[0,-t/e,e/t,0]}</span>case 180:<span class="cstat-no" title="statement not covered" >return[-1,0,0,-1];c</span>ase 270:{const[t,e]=<span class="cstat-no" title="statement not covered" >this.pageDimensions;<span class="cstat-no" title="statement not covered" ></span>return[0,t/e,-e/t,0]}</span>default:<span class="cstat-no" title="statement not covered" >return[1,0,0,1]}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t parentScale(){<span class="cstat-no" title="statement not covered" >return this._uiManager.viewParameters.realScale}<span class="fstat-no" title="function not covered" ></span>ge</span>t parentRotation(){<span class="cstat-no" title="statement not covered" >return(this._uiManager.viewParameters.rotation+this.pageRotation)%360}<span class="fstat-no" title="function not covered" ></span>ge</span>t parentDimensions(){const{parentScale:t,pageDimensions:[e,i]}=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >e*t,</span>a=<span class="cstat-no" title="statement not covered" >i*t;<span class="cstat-no" title="statement not covered" ></span>return n.FeatureTest.isCSSRoundSupported?[Math.round(s),Math.round(a)]:[s,a]}<span class="fstat-no" title="function not covered" ></span>se</span>tDims(t,e){const[i,s]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.div.style.width=`${(100*t/i).toFixed(2)}%`;<span class="cstat-no" title="statement not covered" >t</span>his.#S||(this.div.style.height=`${(100*e/s).toFixed(2)}%`)}<span class="fstat-no" title="function not covered" ></span>fi</span>xDims(){const{style:t}=<span class="cstat-no" title="statement not covered" >this.div,</span>{height:e,width:i}=<span class="cstat-no" title="statement not covered" >t,</span>s=<span class="cstat-no" title="statement not covered" >i.endsWith("%"),</span>n=<span class="cstat-no" title="statement not covered" >!this.#S&amp;&amp;e.endsWith("%");<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;n)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst[a,r]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>s||(t.width=`${(100*parseFloat(i)/a).toFixed(2)}%`);<span class="cstat-no" title="statement not covered" >t</span>his.#S||n||(t.height=`${(100*parseFloat(e)/r).toFixed(2)}%`)}<span class="fstat-no" title="function not covered" ></span>ge</span>tInitialTranslation(){<span class="cstat-no" title="statement not covered" >return[0,0]}</span>static#I(t){<span class="cstat-no" title="statement not covered" >t.preventDefault()}</span>#L(){<span class="cstat-no" title="statement not covered" >if(this.#E)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.#E=document.createElement("div");<span class="cstat-no" title="statement not covered" >t</span>his.#E.classList.add("resizers");c</span>onst t=<span class="cstat-no" title="statement not covered" >["topLeft","topRight","bottomRight","bottomLeft"];<span class="cstat-no" title="statement not covered" ></span>this._willKeepAspectRatio||t.push("topMiddle","middleRight","bottomMiddle","middleLeft");<span class="cstat-no" title="statement not covered" >f</span>or(const e of t){const t=<span class="cstat-no" title="statement not covered" >document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>this.#E.append(t);<span class="cstat-no" title="statement not covered" >t</span>.classList.add("resizer",e);<span class="cstat-no" title="statement not covered" >t</span>.addEventListener("pointerdown",this.#O.bind(this,e));<span class="cstat-no" title="statement not covered" >t</span>.addEventListener("contextmenu",AnnotationEditor.#I)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.div.prepend(this.#E)}</span>#O(t,e){<span class="cstat-no" title="statement not covered" >e.preventDefault();c</span>onst{isMac:i}=<span class="cstat-no" title="statement not covered" >n.FeatureTest.platform;<span class="cstat-no" title="statement not covered" ></span>if(0!==e.button||e.ctrlKey&amp;&amp;i)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.#N.bind(this,t),</span>a=<span class="cstat-no" title="statement not covered" >this._isDraggable;<span class="cstat-no" title="statement not covered" ></span>this._isDraggable=!1;c</span>onst r=<span class="cstat-no" title="statement not covered" >{passive:!0,capture:!0};<span class="cstat-no" title="statement not covered" ></span>window.addEventListener("pointermove",s,r);c</span>onst o=<span class="cstat-no" title="statement not covered" >this.x,</span>l=<span class="cstat-no" title="statement not covered" >this.y,</span>c=<span class="cstat-no" title="statement not covered" >this.width,</span>h=<span class="cstat-no" title="statement not covered" >this.height,</span>d=<span class="cstat-no" title="statement not covered" >this.parent.div.style.cursor,</span>u=<span class="cstat-no" title="statement not covered" >this.div.style.cursor;<span class="cstat-no" title="statement not covered" ></span>this.div.style.cursor=this.parent.div.style.cursor=window.getComputedStyle(e.target).cursor;c</span>onst pointerUpCallback=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._isDraggable=a;<span class="cstat-no" title="statement not covered" >w</span>indow.removeEventListener("pointerup",pointerUpCallback);<span class="cstat-no" title="statement not covered" >w</span>indow.removeEventListener("blur",pointerUpCallback);<span class="cstat-no" title="statement not covered" >w</span>indow.removeEventListener("pointermove",s,r);<span class="cstat-no" title="statement not covered" >t</span>his.parent.div.style.cursor=d;<span class="cstat-no" title="statement not covered" >t</span>his.div.style.cursor=u;c</span>onst t=<span class="cstat-no" title="statement not covered" >this.x,</span>e=<span class="cstat-no" title="statement not covered" >this.y,</span>i=<span class="cstat-no" title="statement not covered" >this.width,</span>n=<span class="cstat-no" title="statement not covered" >this.height;<span class="cstat-no" title="statement not covered" ></span>t===o&amp;&amp;e===l&amp;&amp;i===c&amp;&amp;n===h||this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.width=i;<span class="cstat-no" title="statement not covered" >t</span>his.height=n;<span class="cstat-no" title="statement not covered" >t</span>his.x=t;<span class="cstat-no" title="statement not covered" >t</span>his.y=e;c</span>onst[s,a]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.setDims(s*i,a*n);<span class="cstat-no" title="statement not covered" >t</span>his.fixAndSetPosition();<span class="cstat-no" title="statement not covered" >t</span>his.moveInDOM()}</span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.width=c;<span class="cstat-no" title="statement not covered" >t</span>his.height=h;<span class="cstat-no" title="statement not covered" >t</span>his.x=o;<span class="cstat-no" title="statement not covered" >t</span>his.y=l;c</span>onst[t,e]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.setDims(t*c,e*h);<span class="cstat-no" title="statement not covered" >t</span>his.fixAndSetPosition();<span class="cstat-no" title="statement not covered" >t</span>his.moveInDOM()}</span>,mustExec:!0})}</span>;<span class="cstat-no" title="statement not covered" ></span>window.addEventListener("pointerup",pointerUpCallback);<span class="cstat-no" title="statement not covered" >w</span>indow.addEventListener("blur",pointerUpCallback)}</span>#N(t,e){const[i,s]=<span class="cstat-no" title="statement not covered" >this.parentDimensions,</span>n=<span class="cstat-no" title="statement not covered" >this.x,</span>a=<span class="cstat-no" title="statement not covered" >this.y,</span>r=<span class="cstat-no" title="statement not covered" >this.width,</span>o=<span class="cstat-no" title="statement not covered" >this.height,</span>l=<span class="cstat-no" title="statement not covered" >AnnotationEditor.MIN_SIZE/i,</span>c=<span class="cstat-no" title="statement not covered" >AnnotationEditor.MIN_SIZE/s,</span>round=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.round(1e4*t)/1e4,</span></span>h=<span class="cstat-no" title="statement not covered" >this.#D(this.rotation),</span>transf=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[h[0]*t+h[2]*e,h[1]*t+h[3]*e],</span></span>d=<span class="cstat-no" title="statement not covered" >this.#D(360-this.rotation);</span>let u,p,g=<span class="cstat-no" title="statement not covered" >!1,</span>m=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>switch(t){case"topLeft":<span class="cstat-no" title="statement not covered" >g=!0;<span class="cstat-no" title="statement not covered" >u</span>=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[0,0];<span class="cstat-no" title="statement not covered" ></span>p</span>=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[t,e];<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase"topMiddle":<span class="cstat-no" title="statement not covered" >u=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[t/2,0];<span class="cstat-no" title="statement not covered" ></span>p</span>=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[t/2,e];<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase"topRight":<span class="cstat-no" title="statement not covered" >g=!0;<span class="cstat-no" title="statement not covered" >u</span>=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[t,0];<span class="cstat-no" title="statement not covered" ></span>p</span>=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[0,e];<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase"middleRight":<span class="cstat-no" title="statement not covered" >m=!0;<span class="cstat-no" title="statement not covered" >u</span>=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[t,e/2];<span class="cstat-no" title="statement not covered" ></span>p</span>=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[0,e/2];<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase"bottomRight":<span class="cstat-no" title="statement not covered" >g=!0;<span class="cstat-no" title="statement not covered" >u</span>=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[t,e];<span class="cstat-no" title="statement not covered" ></span>p</span>=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[0,0];<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase"bottomMiddle":<span class="cstat-no" title="statement not covered" >u=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[t/2,e];<span class="cstat-no" title="statement not covered" ></span>p</span>=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[t/2,0];<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase"bottomLeft":<span class="cstat-no" title="statement not covered" >g=!0;<span class="cstat-no" title="statement not covered" >u</span>=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[0,e];<span class="cstat-no" title="statement not covered" ></span>p</span>=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[t,0];<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase"middleLeft":<span class="cstat-no" title="statement not covered" >m=!0;<span class="cstat-no" title="statement not covered" >u</span>=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[0,e/2];<span class="cstat-no" title="statement not covered" ></span>p</span>=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >[t,e/2]}</span></span>c</span>onst f=<span class="cstat-no" title="statement not covered" >u(r,o),</span>b=<span class="cstat-no" title="statement not covered" >p(r,o);</span>let A=<span class="cstat-no" title="statement not covered" >transf(...b);</span>const _=<span class="cstat-no" title="statement not covered" >round(n+A[0]),</span>v=<span class="cstat-no" title="statement not covered" >round(a+A[1]);</span>let y=<span class="cstat-no" title="statement not covered" >1,</span>S=<span class="cstat-no" title="statement not covered" >1,</span>[E,x]=<span class="cstat-no" title="statement not covered" >this.screenToPageTranslation(e.movementX,e.movementY);<span class="cstat-no" title="statement not covered" ></span>[E,x]=(w=E/i,C=x/s,[d[0]*w+d[2]*C,d[1]*w+d[3]*C]);v</span>ar w,C;<span class="cstat-no" title="statement not covered" >if(g){const t=<span class="cstat-no" title="statement not covered" >Math.hypot(r,o);<span class="cstat-no" title="statement not covered" ></span>y=S=Math.max(Math.min(Math.hypot(b[0]-f[0]-E,b[1]-f[1]-x)/t,1/r,1/o),l/r,c/o)}</span>else <span class="cstat-no" title="statement not covered" >m?y=Math.max(l,Math.min(1,Math.abs(b[0]-f[0]-E)))/r:S=Math.max(c,Math.min(1,Math.abs(b[1]-f[1]-x)))/o;c</span></span>onst T=<span class="cstat-no" title="statement not covered" >round(r*y),</span>P=<span class="cstat-no" title="statement not covered" >round(o*S);<span class="cstat-no" title="statement not covered" ></span>A=transf(...p(T,P));c</span>onst M=<span class="cstat-no" title="statement not covered" >_-A[0],</span>F=<span class="cstat-no" title="statement not covered" >v-A[1];<span class="cstat-no" title="statement not covered" ></span>this.width=T;<span class="cstat-no" title="statement not covered" >t</span>his.height=P;<span class="cstat-no" title="statement not covered" >t</span>his.x=M;<span class="cstat-no" title="statement not covered" >t</span>his.y=F;<span class="cstat-no" title="statement not covered" >t</span>his.setDims(i*T,s*P);<span class="cstat-no" title="statement not covered" >t</span>his.fixAndSetPosition()}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.div=document.createElement("div");<span class="cstat-no" title="statement not covered" >t</span>his.div.setAttribute("data-editor-rotation",(360-this.rotation)%360);<span class="cstat-no" title="statement not covered" >t</span>his.div.className=this.name;<span class="cstat-no" title="statement not covered" >t</span>his.div.setAttribute("id",this.id);<span class="cstat-no" title="statement not covered" >t</span>his.div.setAttribute("tabIndex",0);<span class="cstat-no" title="statement not covered" >t</span>his.setInForeground();<span class="cstat-no" title="statement not covered" >t</span>his.div.addEventListener("focusin",this.#x);<span class="cstat-no" title="statement not covered" >t</span>his.div.addEventListener("focusout",this.#w);c</span>onst[t,e]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>if(this.parentRotation%180!=0){<span class="cstat-no" title="statement not covered" >this.div.style.maxWidth=`${(100*e/t).toFixed(2)}%`;<span class="cstat-no" title="statement not covered" >t</span>his.div.style.maxHeight=`${(100*t/e).toFixed(2)}%`}</span>c</span>onst[i,n]=<span class="cstat-no" title="statement not covered" >this.getInitialTranslation();<span class="cstat-no" title="statement not covered" ></span>this.translate(i,n);<span class="cstat-no" title="statement not covered" >(</span>0,s.bindEvents)(this,this.div,["pointerdown"]);<span class="cstat-no" title="statement not covered" >r</span>eturn this.div}<span class="fstat-no" title="function not covered" ></span>po</span>interdown(t){const{isMac:e}=<span class="cstat-no" title="statement not covered" >n.FeatureTest.platform;<span class="cstat-no" title="statement not covered" ></span>if(0!==t.button||t.ctrlKey&amp;&amp;e)<span class="cstat-no" title="statement not covered" >t.preventDefault();e</span>lse{<span class="cstat-no" title="statement not covered" >this.#C=!0;<span class="cstat-no" title="statement not covered" >t</span>his.#B(t)}</span>}</span>#B(t){<span class="cstat-no" title="statement not covered" >if(!this._isDraggable)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this._uiManager.isSelected(this);<span class="cstat-no" title="statement not covered" ></span>this._uiManager.setUpDragSession();l</span>et i,s;<span class="cstat-no" title="statement not covered" >if(e){<span class="cstat-no" title="statement not covered" >i={passive:!0,capture:!0};<span class="cstat-no" title="statement not covered" >s</span>=<span class="fstat-no" title="function not covered" >t=</span>&gt;{const[e,i]=<span class="cstat-no" title="statement not covered" >this.screenToPageTranslation(t.movementX,t.movementY);<span class="cstat-no" title="statement not covered" ></span>this._uiManager.dragSelectedEditors(e,i)}</span>;<span class="cstat-no" title="statement not covered" >w</span>indow.addEventListener("pointermove",s,i)}</span>c</span>onst pointerUpCallback=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >window.removeEventListener("pointerup",pointerUpCallback);<span class="cstat-no" title="statement not covered" >w</span>indow.removeEventListener("blur",pointerUpCallback);<span class="cstat-no" title="statement not covered" >e</span>&amp;&amp;window.removeEventListener("pointermove",s,i);<span class="cstat-no" title="statement not covered" >t</span>his.#C=!1;<span class="cstat-no" title="statement not covered" >i</span>f(!this._uiManager.endDragSession()){const{isMac:e}=<span class="cstat-no" title="statement not covered" >n.FeatureTest.platform;<span class="cstat-no" title="statement not covered" ></span>t.ctrlKey&amp;&amp;!e||t.shiftKey||t.metaKey&amp;&amp;e?this.parent.toggleSelected(this):this.parent.setSelected(this)}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>window.addEventListener("pointerup",pointerUpCallback);<span class="cstat-no" title="statement not covered" >w</span>indow.addEventListener("blur",pointerUpCallback)}<span class="fstat-no" title="function not covered" ></span>mo</span>veInDOM(){<span class="cstat-no" title="statement not covered" >this.parent.moveEditorInDOM(this)}<span class="fstat-no" title="function not covered" ></span>_s</span>etParentAndPosition(t,e,i){<span class="cstat-no" title="statement not covered" >t.changeParent(this);<span class="cstat-no" title="statement not covered" >t</span>his.x=e;<span class="cstat-no" title="statement not covered" >t</span>his.y=i;<span class="cstat-no" title="statement not covered" >t</span>his.fixAndSetPosition();<span class="cstat-no" title="statement not covered" >t</span>his.moveInDOM()}<span class="fstat-no" title="function not covered" ></span>ge</span>tRect(t,e){const i=<span class="cstat-no" title="statement not covered" >this.parentScale,</span>[s,n]=<span class="cstat-no" title="statement not covered" >this.pageDimensions,</span>[a,r]=<span class="cstat-no" title="statement not covered" >this.pageTranslation,</span>o=<span class="cstat-no" title="statement not covered" >t/i,</span>l=<span class="cstat-no" title="statement not covered" >e/i,</span>c=<span class="cstat-no" title="statement not covered" >this.x*s,</span>h=<span class="cstat-no" title="statement not covered" >this.y*n,</span>d=<span class="cstat-no" title="statement not covered" >this.width*s,</span>u=<span class="cstat-no" title="statement not covered" >this.height*n;<span class="cstat-no" title="statement not covered" ></span>switch(this.rotation){case 0:<span class="cstat-no" title="statement not covered" >return[c+o+a,n-h-l-u+r,c+o+d+a,n-h-l+r];c</span>ase 90:<span class="cstat-no" title="statement not covered" >return[c+l+a,n-h+o+r,c+l+u+a,n-h+o+d+r];c</span>ase 180:<span class="cstat-no" title="statement not covered" >return[c-o-d+a,n-h+l+r,c-o+a,n-h+l+u+r];c</span>ase 270:<span class="cstat-no" title="statement not covered" >return[c-l-u+a,n-h-o-d+r,c-l+a,n-h-o+r];d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("Invalid rotation")}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tRectInCurrentCoords(t,e){const[i,s,n,a]=<span class="cstat-no" title="statement not covered" >t,</span>r=<span class="cstat-no" title="statement not covered" >n-i,</span>o=<span class="cstat-no" title="statement not covered" >a-s;<span class="cstat-no" title="statement not covered" ></span>switch(this.rotation){case 0:<span class="cstat-no" title="statement not covered" >return[i,e-a,r,o];c</span>ase 90:<span class="cstat-no" title="statement not covered" >return[i,e-s,o,r];c</span>ase 180:<span class="cstat-no" title="statement not covered" >return[n,e-s,r,o];c</span>ase 270:<span class="cstat-no" title="statement not covered" >return[n,e-a,o,r];d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("Invalid rotation")}</span>}<span class="fstat-no" title="function not covered" ></span>on</span>ceAdded(){}<span class="fstat-no" title="function not covered" >is</span>Empty(){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>en</span>ableEditMode(){<span class="cstat-no" title="statement not covered" >this.#P=!0}<span class="fstat-no" title="function not covered" ></span>di</span>sableEditMode(){<span class="cstat-no" title="statement not covered" >this.#P=!1}<span class="fstat-no" title="function not covered" ></span>is</span>InEditMode(){<span class="cstat-no" title="statement not covered" >return this.#P}<span class="fstat-no" title="function not covered" ></span>sh</span>ouldGetKeyboardEvents(){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>ne</span>edsToBeRebuilt(){<span class="cstat-no" title="statement not covered" >return this.div&amp;&amp;!this.isAttachedToDOM}<span class="fstat-no" title="function not covered" ></span>re</span>build(){<span class="cstat-no" title="statement not covered" >this.div?.addEventListener("focusin",this.#x);<span class="cstat-no" title="statement not covered" >t</span>his.div?.addEventListener("focusout",this.#w)}<span class="fstat-no" title="function not covered" ></span>se</span>rialize(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >(0,n.unreachable)("An editor must be serializable")}<span class="fstat-no" title="function not covered" ></span>st</span>atic deserialize(t,e,i){const s=<span class="cstat-no" title="statement not covered" >new this.prototype.constructor({parent:e,id:e.getNextId(),uiManager:i});<span class="cstat-no" title="statement not covered" ></span>s.rotation=t.rotation;c</span>onst[n,a]=<span class="cstat-no" title="statement not covered" >s.pageDimensions,</span>[r,o,l,c]=<span class="cstat-no" title="statement not covered" >s.getRectInCurrentCoords(t.rect,a);<span class="cstat-no" title="statement not covered" ></span>s.x=r/n;<span class="cstat-no" title="statement not covered" >s</span>.y=o/a;<span class="cstat-no" title="statement not covered" >s</span>.width=l/n;<span class="cstat-no" title="statement not covered" >s</span>.height=c/a;<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>re</span>move(){<span class="cstat-no" title="statement not covered" >this.div.removeEventListener("focusin",this.#x);<span class="cstat-no" title="statement not covered" >t</span>his.div.removeEventListener("focusout",this.#w);<span class="cstat-no" title="statement not covered" >t</span>his.isEmpty()||this.commit();<span class="cstat-no" title="statement not covered" >t</span>his.parent?this.parent.remove(this):this._uiManager.removeEditor(this)}<span class="fstat-no" title="function not covered" ></span>ge</span>t isResizable(){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>ma</span>keResizable(){<span class="cstat-no" title="statement not covered" >if(this.isResizable){<span class="cstat-no" title="statement not covered" >this.#L();<span class="cstat-no" title="statement not covered" >t</span>his.#E.classList.remove("hidden")}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>lect(){<span class="cstat-no" title="statement not covered" >this.makeResizable();<span class="cstat-no" title="statement not covered" >t</span>his.div?.classList.add("selectedEditor")}<span class="fstat-no" title="function not covered" ></span>un</span>select(){<span class="cstat-no" title="statement not covered" >this.#E?.classList.add("hidden");<span class="cstat-no" title="statement not covered" >t</span>his.div?.classList.remove("selectedEditor");<span class="cstat-no" title="statement not covered" >t</span>his.div?.contains(document.activeElement)&amp;&amp;this._uiManager.currentLayer.div.focus()}<span class="fstat-no" title="function not covered" ></span>up</span>dateParams(t,e){}<span class="fstat-no" title="function not covered" >di</span>sableEditing(){}<span class="fstat-no" title="function not covered" >en</span>ableEditing(){}<span class="fstat-no" title="function not covered" >en</span>terInEditMode(){}<span class="fstat-no" title="function not covered" >ge</span>t contentDiv(){<span class="cstat-no" title="statement not covered" >return this.div}<span class="fstat-no" title="function not covered" ></span>ge</span>t isEditing(){<span class="cstat-no" title="statement not covered" >return this.#T}<span class="fstat-no" title="function not covered" ></span>se</span>t isEditing(t){<span class="cstat-no" title="statement not covered" >this.#T=t;<span class="cstat-no" title="statement not covered" >i</span>f(this.parent)<span class="cstat-no" title="statement not covered" >if(t){<span class="cstat-no" title="statement not covered" >this.parent.setSelected(this);<span class="cstat-no" title="statement not covered" >t</span>his.parent.setActiveEditor(this)}</span>else <span class="cstat-no" title="statement not covered" >this.parent.setActiveEditor(null)}<span class="fstat-no" title="function not covered" ></span></span></span>se</span>tAspectRatio(t,e){<span class="cstat-no" title="statement not covered" >this.#S=!0;c</span>onst i=<span class="cstat-no" title="statement not covered" >t/e,</span>{style:s}=<span class="cstat-no" title="statement not covered" >this.div;<span class="cstat-no" title="statement not covered" ></span>s.aspectRatio=i;<span class="cstat-no" title="statement not covered" >s</span>.height="auto"}<span class="fstat-no" title="function not covered" ></span>st</span>atic get MIN_SIZE(){<span class="cstat-no" title="statement not covered" >return 16}</span>}<span class="cstat-no" title="statement not covered" >e.AnnotationEditor=AnnotationEditor;c</span>lass FakeEditor extends AnnotationEditor{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t);<span class="cstat-no" title="statement not covered" >t</span>his.annotationElementId=t.annotationElementId;<span class="cstat-no" title="statement not covered" >t</span>his.deleted=!0}<span class="fstat-no" title="function not covered" ></span>se</span>rialize(){<span class="cstat-no" title="statement not covered" >return{id:this.annotationElementId,deleted:!0,pageIndex:this.pageIndex}}</span>}},<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.KeyboardManager=e.CommandManager=e.ColorManager=e.AnnotationEditorUIManager=void 0;<span class="cstat-no" title="statement not covered" >e</span>.bindEvents=function <span class="fstat-no" title="function not covered" >bindEvents(</span>t,e,i){<span class="cstat-no" title="statement not covered" >for(const s of i)<span class="cstat-no" title="statement not covered" >e.addEventListener(s,t[s].bind(t))}</span></span>;<span class="cstat-no" title="statement not covered" >e</span>.opacityToHex=function <span class="fstat-no" title="function not covered" >opacityToHex(</span>t){<span class="cstat-no" title="statement not covered" >return Math.round(Math.min(255,Math.max(1,255*t))).toString(16).padStart(2,"0")}</span>;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(6);</span>class IdManager{#U=<span class="cstat-no" title="statement not covered" >0;<span class="fstat-no" title="function not covered" ></span>ge</span>tId(){<span class="cstat-no" title="statement not covered" >return`${s.AnnotationEditorPrefix}${this.#U++}`}</span>}class ImageManager{#j=<span class="cstat-no" title="statement not covered" >(0,s.getUuid)();</span>#U=<span class="cstat-no" title="statement not covered" >0;</span>#z=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>st</span>atic get _isSVGFittingCanvas(){const t=<span class="cstat-no" title="statement not covered" >new OffscreenCanvas(1,3).getContext("2d"),</span>e=<span class="cstat-no" title="statement not covered" >new Image;<span class="cstat-no" title="statement not covered" ></span>e.src='data:image/svg+xml;charset=UTF-8,&lt;svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"&gt;&lt;rect width="1" height="1" style="fill:red;"/&gt;&lt;/svg&gt;';c</span>onst i=<span class="cstat-no" title="statement not covered" >e.decode().then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.drawImage(e,0,0,1,1,0,0,1,3);<span class="cstat-no" title="statement not covered" >r</span>eturn 0===new Uint32Array(t.getImageData(0,0,1,1).data.buffer)[0]}</span>));<span class="cstat-no" title="statement not covered" ></span>return(0,s.shadow)(this,"_isSVGFittingCanvas",i)}</span>async#H(t,e){<span class="cstat-no" title="statement not covered" >this.#z||=new Map;l</span>et i=<span class="cstat-no" title="statement not covered" >this.#z.get(t);<span class="cstat-no" title="statement not covered" ></span>if(null===i)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(i?.bitmap){<span class="cstat-no" title="statement not covered" >i.refCounter+=1;<span class="cstat-no" title="statement not covered" >r</span>eturn i}<span class="cstat-no" title="statement not covered" ></span>t</span>ry{<span class="cstat-no" title="statement not covered" >i||={bitmap:null,id:`image_${this.#j}_${this.#U++}`,refCounter:0,isSvg:!1};l</span>et t;<span class="cstat-no" title="statement not covered" >if("string"==typeof e){<span class="cstat-no" title="statement not covered" >i.url=e;c</span>onst s=<span class="cstat-no" title="statement not covered" >await fetch(e);<span class="cstat-no" title="statement not covered" ></span>if(!s.ok)<span class="cstat-no" title="statement not covered" >throw new Error(s.statusText);<span class="cstat-no" title="statement not covered" >t</span></span>=await s.blob()}</span>else <span class="cstat-no" title="statement not covered" >t=i.file=e;<span class="cstat-no" title="statement not covered" >i</span></span>f("image/svg+xml"===t.type){const e=<span class="cstat-no" title="statement not covered" >ImageManager._isSVGFittingCanvas,</span>s=<span class="cstat-no" title="statement not covered" >new FileReader,</span>n=<span class="cstat-no" title="statement not covered" >new Image,</span>a=<span class="cstat-no" title="statement not covered" >new Promise((<span class="fstat-no" title="function not covered" >(t</span>,a)=&gt;{<span class="cstat-no" title="statement not covered" >n.onload=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i.bitmap=n;<span class="cstat-no" title="statement not covered" >i</span>.isSvg=!0;<span class="cstat-no" title="statement not covered" >t</span>()}</span>;<span class="cstat-no" title="statement not covered" >s</span>.onload=<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{const t=<span class="cstat-no" title="statement not covered" >i.svgUrl=s.result;<span class="cstat-no" title="statement not covered" ></span>n.src=await e?`${t}#svgView(preserveAspectRatio(none))`:t}</span>;<span class="cstat-no" title="statement not covered" >n</span>.onerror=s.onerror=a}</span>));<span class="cstat-no" title="statement not covered" ></span>s.readAsDataURL(t);<span class="cstat-no" title="statement not covered" >a</span>wait a}</span>else <span class="cstat-no" title="statement not covered" >i.bitmap=await createImageBitmap(t);<span class="cstat-no" title="statement not covered" >i</span></span>.refCounter=1}</span>catch(t){<span class="cstat-no" title="statement not covered" >console.error(t);<span class="cstat-no" title="statement not covered" >i</span>=null}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#z.set(t,i);<span class="cstat-no" title="statement not covered" >i</span>&amp;&amp;this.#z.set(i.id,i);<span class="cstat-no" title="statement not covered" >r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>as</span>ync getFromFile(t){const{lastModified:e,name:i,size:s,type:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return this.#H(`${e}_${i}_${s}_${n}`,t)}<span class="fstat-no" title="function not covered" ></span>as</span>ync getFromUrl(t){<span class="cstat-no" title="statement not covered" >return this.#H(t,t)}<span class="fstat-no" title="function not covered" ></span>as</span>ync getFromId(t){<span class="cstat-no" title="statement not covered" >this.#z||=new Map;c</span>onst e=<span class="cstat-no" title="statement not covered" >this.#z.get(t);<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.bitmap){<span class="cstat-no" title="statement not covered" >e.refCounter+=1;<span class="cstat-no" title="statement not covered" >r</span>eturn e}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.file?this.getFromFile(e.file):this.getFromUrl(e.url)}<span class="fstat-no" title="function not covered" ></span>ge</span>tSvgUrl(t){const e=<span class="cstat-no" title="statement not covered" >this.#z.get(t);<span class="cstat-no" title="statement not covered" ></span>return e?.isSvg?e.svgUrl:null}<span class="fstat-no" title="function not covered" ></span>de</span>leteId(t){<span class="cstat-no" title="statement not covered" >this.#z||=new Map;c</span>onst e=<span class="cstat-no" title="statement not covered" >this.#z.get(t);<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >e.refCounter-=1;<span class="cstat-no" title="statement not covered" >0</span>===e.refCounter&amp;&amp;(e.bitmap=null)}</span>}<span class="fstat-no" title="function not covered" ></span>is</span>ValidId(t){<span class="cstat-no" title="statement not covered" >return t.startsWith(`image_${this.#j}_`)}</span>}class CommandManager{#W=<span class="cstat-no" title="statement not covered" >[];</span>#G=<span class="cstat-no" title="statement not covered" >!1;</span>#q;#V=<span class="cstat-no" title="statement not covered" >-1;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >128)</span>{<span class="cstat-no" title="statement not covered" >this.#q=t}<span class="fstat-no" title="function not covered" ></span>ad</span>d({cmd:t,undo:e,mustExec:i,type:s=<span class="branch-0 cbranch-no" title="branch not covered" >NaN,</span>overwriteIfSameType:n=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>keepUndo:a=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>){<span class="cstat-no" title="statement not covered" >i&amp;&amp;t();<span class="cstat-no" title="statement not covered" >i</span>f(this.#G)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >{cmd:t,undo:e,type:s};<span class="cstat-no" title="statement not covered" ></span>if(-1===this.#V){<span class="cstat-no" title="statement not covered" >this.#W.length&gt;0&amp;&amp;(this.#W.length=0);<span class="cstat-no" title="statement not covered" >t</span>his.#V=0;<span class="cstat-no" title="statement not covered" >t</span>his.#W.push(r);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n&amp;&amp;this.#W[this.#V].type===s){<span class="cstat-no" title="statement not covered" >a&amp;&amp;(r.undo=this.#W[this.#V].undo);<span class="cstat-no" title="statement not covered" >t</span>his.#W[this.#V]=r;<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst o=<span class="cstat-no" title="statement not covered" >this.#V+1;<span class="cstat-no" title="statement not covered" ></span>if(o===this.#q)<span class="cstat-no" title="statement not covered" >this.#W.splice(0,1);e</span>lse{<span class="cstat-no" title="statement not covered" >this.#V=o;<span class="cstat-no" title="statement not covered" >o</span>&lt;this.#W.length&amp;&amp;this.#W.splice(o)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#W.push(r)}<span class="fstat-no" title="function not covered" ></span>un</span>do(){<span class="cstat-no" title="statement not covered" >if(-1!==this.#V){<span class="cstat-no" title="statement not covered" >this.#G=!0;<span class="cstat-no" title="statement not covered" >t</span>his.#W[this.#V].undo();<span class="cstat-no" title="statement not covered" >t</span>his.#G=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#V-=1}</span>}<span class="fstat-no" title="function not covered" ></span>re</span>do(){<span class="cstat-no" title="statement not covered" >if(this.#V&lt;this.#W.length-1){<span class="cstat-no" title="statement not covered" >this.#V+=1;<span class="cstat-no" title="statement not covered" >t</span>his.#G=!0;<span class="cstat-no" title="statement not covered" >t</span>his.#W[this.#V].cmd();<span class="cstat-no" title="statement not covered" >t</span>his.#G=!1}</span>}<span class="fstat-no" title="function not covered" ></span>ha</span>sSomethingToUndo(){<span class="cstat-no" title="statement not covered" >return-1!==this.#V}<span class="fstat-no" title="function not covered" ></span>ha</span>sSomethingToRedo(){<span class="cstat-no" title="statement not covered" >return this.#V&lt;this.#W.length-1}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.#W=null}</span>}<span class="cstat-no" title="statement not covered" >e.CommandManager=CommandManager;c</span>lass KeyboardManager{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.buffer=[];<span class="cstat-no" title="statement not covered" >t</span>his.callbacks=new Map;<span class="cstat-no" title="statement not covered" >t</span>his.allKeys=new Set;c</span>onst{isMac:e}=<span class="cstat-no" title="statement not covered" >s.FeatureTest.platform;<span class="cstat-no" title="statement not covered" ></span>for(const[i,s,n=<span class="branch-0 cbranch-no" title="branch not covered" >{}]</span>of t)<span class="cstat-no" title="statement not covered" >for(const t of i){const i=<span class="cstat-no" title="statement not covered" >t.startsWith("mac+");<span class="cstat-no" title="statement not covered" ></span>if(e&amp;&amp;i){<span class="cstat-no" title="statement not covered" >this.callbacks.set(t.slice(4),{callback:s,options:n});<span class="cstat-no" title="statement not covered" >t</span>his.allKeys.add(t.split("+").at(-1))}</span>else <span class="cstat-no" title="statement not covered" >if(!e&amp;&amp;!i){<span class="cstat-no" title="statement not covered" >this.callbacks.set(t,{callback:s,options:n});<span class="cstat-no" title="statement not covered" >t</span>his.allKeys.add(t.split("+").at(-1))}</span>}</span></span>}</span></span>#$(t){<span class="cstat-no" title="statement not covered" >t.altKey&amp;&amp;this.buffer.push("alt");<span class="cstat-no" title="statement not covered" >t</span>.ctrlKey&amp;&amp;this.buffer.push("ctrl");<span class="cstat-no" title="statement not covered" >t</span>.metaKey&amp;&amp;this.buffer.push("meta");<span class="cstat-no" title="statement not covered" >t</span>.shiftKey&amp;&amp;this.buffer.push("shift");<span class="cstat-no" title="statement not covered" >t</span>his.buffer.push(t.key);c</span>onst e=<span class="cstat-no" title="statement not covered" >this.buffer.join("+");<span class="cstat-no" title="statement not covered" ></span>this.buffer.length=0;<span class="cstat-no" title="statement not covered" >r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>ex</span>ec(t,e){<span class="cstat-no" title="statement not covered" >if(!this.allKeys.has(e.key))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.callbacks.get(this.#$(e));<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{callback:s,options:{bubbles:n=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>args:a=<span class="branch-0 cbranch-no" title="branch not covered" >[],</span>checker:r=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(!r||r(t,e)){<span class="cstat-no" title="statement not covered" >s.bind(t,...a)();<span class="cstat-no" title="statement not covered" >i</span>f(!n){<span class="cstat-no" title="statement not covered" >e.stopPropagation();<span class="cstat-no" title="statement not covered" >e</span>.preventDefault()}</span>}</span>}</span>}<span class="cstat-no" title="statement not covered" >e.KeyboardManager=KeyboardManager;c</span>lass ColorManager{static _colorsMapping=<span class="cstat-no" title="statement not covered" >new Map([["CanvasText",[0,0,0]],["Canvas",[255,255,255]]]);<span class="fstat-no" title="function not covered" ></span>ge</span>t _colors(){const t=<span class="cstat-no" title="statement not covered" >new Map([["CanvasText",null],["Canvas",null]]);<span class="cstat-no" title="statement not covered" ></span>(0,n.getColorValues)(t);<span class="cstat-no" title="statement not covered" >r</span>eturn(0,s.shadow)(this,"_colors",t)}<span class="fstat-no" title="function not covered" ></span>co</span>nvert(t){const e=<span class="cstat-no" title="statement not covered" >(0,n.getRGB)(t);<span class="cstat-no" title="statement not covered" ></span>if(!window.matchMedia("(forced-colors: active)").matches)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >f</span></span>or(const[t,i]of this._colors)<span class="cstat-no" title="statement not covered" >if(i.every((<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >t===e[i])</span>))<span class="cstat-no" title="statement not covered" >return ColorManager._colorsMapping.get(t);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>ge</span>tHexCode(t){const e=<span class="cstat-no" title="statement not covered" >this._colors.get(t);<span class="cstat-no" title="statement not covered" ></span>return e?s.Util.makeHexColor(...e):t}</span>}<span class="cstat-no" title="statement not covered" >e.ColorManager=ColorManager;c</span>lass AnnotationEditorUIManager{#X=<span class="cstat-no" title="statement not covered" >null;</span>#K=<span class="cstat-no" title="statement not covered" >new Map;</span>#Y=<span class="cstat-no" title="statement not covered" >new Map;</span>#J=<span class="cstat-no" title="statement not covered" >null;</span>#Q=<span class="cstat-no" title="statement not covered" >new CommandManager;</span>#Z=<span class="cstat-no" title="statement not covered" >0;</span>#tt=<span class="cstat-no" title="statement not covered" >new Set;</span>#et=<span class="cstat-no" title="statement not covered" >null;</span>#it=<span class="cstat-no" title="statement not covered" >null;</span>#st=<span class="cstat-no" title="statement not covered" >new Set;</span>#nt=<span class="cstat-no" title="statement not covered" >null;</span>#at=<span class="cstat-no" title="statement not covered" >null;</span>#rt=<span class="cstat-no" title="statement not covered" >new IdManager;</span>#ot=<span class="cstat-no" title="statement not covered" >!1;</span>#lt=<span class="cstat-no" title="statement not covered" >!1;</span>#ct=<span class="cstat-no" title="statement not covered" >null;</span>#ht=<span class="cstat-no" title="statement not covered" >s.AnnotationEditorType.NONE;</span>#dt=<span class="cstat-no" title="statement not covered" >new Set;</span>#ut=<span class="cstat-no" title="statement not covered" >null;</span>#pt=<span class="cstat-no" title="statement not covered" >this.blur.bind(this);</span>#gt=<span class="cstat-no" title="statement not covered" >this.focus.bind(this);</span>#mt=<span class="cstat-no" title="statement not covered" >this.copy.bind(this);</span>#ft=<span class="cstat-no" title="statement not covered" >this.cut.bind(this);</span>#bt=<span class="cstat-no" title="statement not covered" >this.paste.bind(this);</span>#At=<span class="cstat-no" title="statement not covered" >this.keydown.bind(this);</span>#_t=<span class="cstat-no" title="statement not covered" >this.onEditingAction.bind(this);</span>#vt=<span class="cstat-no" title="statement not covered" >this.onPageChanging.bind(this);</span>#yt=<span class="cstat-no" title="statement not covered" >this.onScaleChanging.bind(this);</span>#St=<span class="cstat-no" title="statement not covered" >this.onRotationChanging.bind(this);</span>#Et=<span class="cstat-no" title="statement not covered" >{isEditing:!1,isEmpty:!0,hasSomethingToUndo:!1,hasSomethingToRedo:!1,hasSelectedEditor:!1};</span>#xt=<span class="cstat-no" title="statement not covered" >[0,0];</span>#wt=<span class="cstat-no" title="statement not covered" >null;</span>#Ct=<span class="cstat-no" title="statement not covered" >null;</span>#Tt=<span class="cstat-no" title="statement not covered" >null;</span>static TRANSLATE_SMALL=<span class="cstat-no" title="statement not covered" >1;</span>static TRANSLATE_BIG=<span class="cstat-no" title="statement not covered" >10;<span class="fstat-no" title="function not covered" ></span>st</span>atic get _keyboardManager(){const t=<span class="cstat-no" title="statement not covered" >AnnotationEditorUIManager.prototype,</span>arrowChecker=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const{activeElement:e}=<span class="cstat-no" title="statement not covered" >document;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;t.#Ct.contains(e)&amp;&amp;t.hasSomethingToControl()}</span>,</span>e=<span class="cstat-no" title="statement not covered" >this.TRANSLATE_SMALL,</span>i=<span class="cstat-no" title="statement not covered" >this.TRANSLATE_BIG;<span class="cstat-no" title="statement not covered" ></span>return(0,s.shadow)(this,"_keyboardManager",new KeyboardManager([[["ctrl+a","mac+meta+a"],t.selectAll],[["ctrl+z","mac+meta+z"],t.undo],[["ctrl+y","ctrl+shift+z","mac+meta+shift+z","ctrl+shift+Z","mac+meta+shift+Z"],t.redo],[["Backspace","alt+Backspace","ctrl+Backspace","shift+Backspace","mac+Backspace","mac+alt+Backspace","mac+ctrl+Backspace","Delete","ctrl+Delete","shift+Delete","mac+Delete"],t.delete],[["Escape","mac+Escape"],t.unselectAll],[["ArrowLeft","mac+ArrowLeft"],t.translateSelectedEditors,{args:[-e,0],checker:arrowChecker}],[["ctrl+ArrowLeft","mac+shift+ArrowLeft"],t.translateSelectedEditors,{args:[-i,0],checker:arrowChecker}],[["ArrowRight","mac+ArrowRight"],t.translateSelectedEditors,{args:[e,0],checker:arrowChecker}],[["ctrl+ArrowRight","mac+shift+ArrowRight"],t.translateSelectedEditors,{args:[i,0],checker:arrowChecker}],[["ArrowUp","mac+ArrowUp"],t.translateSelectedEditors,{args:[0,-e],checker:arrowChecker}],[["ctrl+ArrowUp","mac+shift+ArrowUp"],t.translateSelectedEditors,{args:[0,-i],checker:arrowChecker}],[["ArrowDown","mac+ArrowDown"],t.translateSelectedEditors,{args:[0,e],checker:arrowChecker}],[["ctrl+ArrowDown","mac+shift+ArrowDown"],t.translateSelectedEditors,{args:[0,i],checker:arrowChecker}]]))}<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e,i,s,a){<span class="cstat-no" title="statement not covered" >this.#Ct=t;<span class="cstat-no" title="statement not covered" >t</span>his.#Tt=e;<span class="cstat-no" title="statement not covered" >t</span>his.#nt=i;<span class="cstat-no" title="statement not covered" >t</span>his.#nt._on("editingaction",this.#_t);<span class="cstat-no" title="statement not covered" >t</span>his.#nt._on("pagechanging",this.#vt);<span class="cstat-no" title="statement not covered" >t</span>his.#nt._on("scalechanging",this.#yt);<span class="cstat-no" title="statement not covered" >t</span>his.#nt._on("rotationchanging",this.#St);<span class="cstat-no" title="statement not covered" >t</span>his.#J=s.annotationStorage;<span class="cstat-no" title="statement not covered" >t</span>his.#at=s.filterFactory;<span class="cstat-no" title="statement not covered" >t</span>his.#ut=a;<span class="cstat-no" title="statement not covered" >t</span>his.viewParameters={realScale:n.PixelsPerInch.PDF_TO_CSS_UNITS,rotation:0}}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.#Pt();<span class="cstat-no" title="statement not covered" >t</span>his.#Mt();<span class="cstat-no" title="statement not covered" >t</span>his.#nt._off("editingaction",this.#_t);<span class="cstat-no" title="statement not covered" >t</span>his.#nt._off("pagechanging",this.#vt);<span class="cstat-no" title="statement not covered" >t</span>his.#nt._off("scalechanging",this.#yt);<span class="cstat-no" title="statement not covered" >t</span>his.#nt._off("rotationchanging",this.#St);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#Y.values())<span class="cstat-no" title="statement not covered" >t.destroy();<span class="cstat-no" title="statement not covered" >t</span></span>his.#Y.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#K.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#st.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#X=null;<span class="cstat-no" title="statement not covered" >t</span>his.#dt.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#Q.destroy()}<span class="fstat-no" title="function not covered" ></span>ge</span>t hcmFilter(){<span class="cstat-no" title="statement not covered" >return(0,s.shadow)(this,"hcmFilter",this.#ut?this.#at.addHCMFilter(this.#ut.foreground,this.#ut.background):"none")}<span class="fstat-no" title="function not covered" ></span>on</span>PageChanging({pageNumber:t}){<span class="cstat-no" title="statement not covered" >this.#Z=t-1}<span class="fstat-no" title="function not covered" ></span>fo</span>cusMainContainer(){<span class="cstat-no" title="statement not covered" >this.#Ct.focus()}<span class="fstat-no" title="function not covered" ></span>fi</span>ndParent(t,e){<span class="cstat-no" title="statement not covered" >for(const i of this.#Y.values()){const{x:s,y:n,width:a,height:r}=<span class="cstat-no" title="statement not covered" >i.div.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>if(t&gt;=s&amp;&amp;t&lt;=s+a&amp;&amp;e&gt;=n&amp;&amp;e&lt;=n+r)<span class="cstat-no" title="statement not covered" >return i}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn null}<span class="fstat-no" title="function not covered" ></span>di</span>sableUserSelect(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >this.#Tt.classList.toggle("noUserSelect",t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dShouldRescale(t){<span class="cstat-no" title="statement not covered" >this.#st.add(t)}<span class="fstat-no" title="function not covered" ></span>re</span>moveShouldRescale(t){<span class="cstat-no" title="statement not covered" >this.#st.delete(t)}<span class="fstat-no" title="function not covered" ></span>on</span>ScaleChanging({scale:t}){<span class="cstat-no" title="statement not covered" >this.commitOrRemove();<span class="cstat-no" title="statement not covered" >t</span>his.viewParameters.realScale=t*n.PixelsPerInch.PDF_TO_CSS_UNITS;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#st)<span class="cstat-no" title="statement not covered" >t.onScaleChanging()}<span class="fstat-no" title="function not covered" ></span></span>on</span>RotationChanging({pagesRotation:t}){<span class="cstat-no" title="statement not covered" >this.commitOrRemove();<span class="cstat-no" title="statement not covered" >t</span>his.viewParameters.rotation=t}<span class="fstat-no" title="function not covered" ></span>ad</span>dToAnnotationStorage(t){<span class="cstat-no" title="statement not covered" >t.isEmpty()||!this.#J||this.#J.has(t.id)||this.#J.setValue(t.id,t)}</span>#Ft(){<span class="cstat-no" title="statement not covered" >window.addEventListener("focus",this.#gt);<span class="cstat-no" title="statement not covered" >w</span>indow.addEventListener("blur",this.#pt)}</span>#Mt(){<span class="cstat-no" title="statement not covered" >window.removeEventListener("focus",this.#gt);<span class="cstat-no" title="statement not covered" >w</span>indow.removeEventListener("blur",this.#pt)}<span class="fstat-no" title="function not covered" ></span>bl</span>ur(){<span class="cstat-no" title="statement not covered" >if(!this.hasSelection)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{activeElement:t}=<span class="cstat-no" title="statement not covered" >document;<span class="cstat-no" title="statement not covered" ></span>for(const e of this.#dt)<span class="cstat-no" title="statement not covered" >if(e.div.contains(t)){<span class="cstat-no" title="statement not covered" >this.#ct=[e,t];<span class="cstat-no" title="statement not covered" >e</span>._focusEventsAllowed=!1;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="fstat-no" title="function not covered" ></span></span>fo</span>cus(){<span class="cstat-no" title="statement not covered" >if(!this.#ct)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst[t,e]=<span class="cstat-no" title="statement not covered" >this.#ct;<span class="cstat-no" title="statement not covered" ></span>this.#ct=null;<span class="cstat-no" title="statement not covered" >e</span>.addEventListener("focusin",(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t._focusEventsAllowed=!0}</span>),{once:!0});<span class="cstat-no" title="statement not covered" >e</span>.focus()}</span>#kt(){<span class="cstat-no" title="statement not covered" >window.addEventListener("keydown",this.#At,{capture:!0})}</span>#Pt(){<span class="cstat-no" title="statement not covered" >window.removeEventListener("keydown",this.#At,{capture:!0})}</span>#Rt(){<span class="cstat-no" title="statement not covered" >document.addEventListener("copy",this.#mt);<span class="cstat-no" title="statement not covered" >d</span>ocument.addEventListener("cut",this.#ft);<span class="cstat-no" title="statement not covered" >d</span>ocument.addEventListener("paste",this.#bt)}</span>#Dt(){<span class="cstat-no" title="statement not covered" >document.removeEventListener("copy",this.#mt);<span class="cstat-no" title="statement not covered" >d</span>ocument.removeEventListener("cut",this.#ft);<span class="cstat-no" title="statement not covered" >d</span>ocument.removeEventListener("paste",this.#bt)}<span class="fstat-no" title="function not covered" ></span>co</span>py(t){<span class="cstat-no" title="statement not covered" >t.preventDefault();<span class="cstat-no" title="statement not covered" >t</span>his.#X?.commitOrRemove();<span class="cstat-no" title="statement not covered" >i</span>f(!this.hasSelection)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const t of this.#dt){const i=<span class="cstat-no" title="statement not covered" >t.serialize(!0);<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;e.push(i)}<span class="cstat-no" title="statement not covered" ></span>0</span>!==e.length&amp;&amp;t.clipboardData.setData("application/pdfjs",JSON.stringify(e))}<span class="fstat-no" title="function not covered" ></span>cu</span>t(t){<span class="cstat-no" title="statement not covered" >this.copy(t);<span class="cstat-no" title="statement not covered" >t</span>his.delete()}<span class="fstat-no" title="function not covered" ></span>pa</span>ste(t){<span class="cstat-no" title="statement not covered" >t.preventDefault();c</span>onst{clipboardData:e}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>for(const t of e.items)<span class="cstat-no" title="statement not covered" >for(const e of this.#it)<span class="cstat-no" title="statement not covered" >if(e.isHandlingMimeForPasting(t.type)){<span class="cstat-no" title="statement not covered" >e.paste(t,this.currentLayer);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>l</span></span></span>et i=<span class="cstat-no" title="statement not covered" >e.getData("application/pdfjs");<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >i=JSON.parse(i)}</span>catch(t){<span class="cstat-no" title="statement not covered" >(0,s.warn)(`paste: "${t.message}".`);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Array.isArray(i))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.unselectAll();c</span>onst n=<span class="cstat-no" title="statement not covered" >this.currentLayer;<span class="cstat-no" title="statement not covered" ></span>try{const t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const e of i){const i=<span class="cstat-no" title="statement not covered" >n.deserialize(e);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>.push(i)}</span>c</span>onst cmd=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const e of t)<span class="cstat-no" title="statement not covered" >this.#It(e);<span class="cstat-no" title="statement not covered" >t</span></span>his.#Lt(t)}</span>,</span>undo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const e of t)<span class="cstat-no" title="statement not covered" >e.remove()}</span></span>;<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:cmd,undo:undo,mustExec:!0})}</span>catch(t){<span class="cstat-no" title="statement not covered" >(0,s.warn)(`paste: "${t.message}".`)}</span>}<span class="fstat-no" title="function not covered" ></span>ke</span>ydown(t){<span class="cstat-no" title="statement not covered" >this.getActive()?.shouldGetKeyboardEvents()||AnnotationEditorUIManager._keyboardManager.exec(this,t)}<span class="fstat-no" title="function not covered" ></span>on</span>EditingAction(t){<span class="cstat-no" title="statement not covered" >["undo","redo","delete","selectAll"].includes(t.name)&amp;&amp;this[t.name]()}</span>#Ot(t){<span class="cstat-no" title="statement not covered" >Object.entries(t).some((<span class="fstat-no" title="function not covered" >([</span>t,e])=&gt;<span class="cstat-no" title="statement not covered" >this.#Et[t]!==e)</span>)&amp;&amp;this.#nt.dispatch("annotationeditorstateschanged",{source:this,details:Object.assign(this.#Et,t)})}</span>#Nt(t){<span class="cstat-no" title="statement not covered" >this.#nt.dispatch("annotationeditorparamschanged",{source:this,details:t})}<span class="fstat-no" title="function not covered" ></span>se</span>tEditingState(t){<span class="cstat-no" title="statement not covered" >if(t){<span class="cstat-no" title="statement not covered" >this.#Ft();<span class="cstat-no" title="statement not covered" >t</span>his.#kt();<span class="cstat-no" title="statement not covered" >t</span>his.#Rt();<span class="cstat-no" title="statement not covered" >t</span>his.#Ot({isEditing:this.#ht!==s.AnnotationEditorType.NONE,isEmpty:this.#Bt(),hasSomethingToUndo:this.#Q.hasSomethingToUndo(),hasSomethingToRedo:this.#Q.hasSomethingToRedo(),hasSelectedEditor:!1})}</span>else{<span class="cstat-no" title="statement not covered" >this.#Mt();<span class="cstat-no" title="statement not covered" >t</span>his.#Pt();<span class="cstat-no" title="statement not covered" >t</span>his.#Dt();<span class="cstat-no" title="statement not covered" >t</span>his.#Ot({isEditing:!1});<span class="cstat-no" title="statement not covered" >t</span>his.disableUserSelect(!1)}</span>}<span class="fstat-no" title="function not covered" ></span>re</span>gisterEditorTypes(t){<span class="cstat-no" title="statement not covered" >if(!this.#it){<span class="cstat-no" title="statement not covered" >this.#it=t;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#it)<span class="cstat-no" title="statement not covered" >this.#Nt(t.defaultPropertiesToUpdate)}</span></span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tId(){<span class="cstat-no" title="statement not covered" >return this.#rt.getId()}<span class="fstat-no" title="function not covered" ></span>ge</span>t currentLayer(){<span class="cstat-no" title="statement not covered" >return this.#Y.get(this.#Z)}<span class="fstat-no" title="function not covered" ></span>ge</span>tLayer(t){<span class="cstat-no" title="statement not covered" >return this.#Y.get(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>t currentPageIndex(){<span class="cstat-no" title="statement not covered" >return this.#Z}<span class="fstat-no" title="function not covered" ></span>ad</span>dLayer(t){<span class="cstat-no" title="statement not covered" >this.#Y.set(t.pageIndex,t);<span class="cstat-no" title="statement not covered" >t</span>his.#ot?t.enable():t.disable()}<span class="fstat-no" title="function not covered" ></span>re</span>moveLayer(t){<span class="cstat-no" title="statement not covered" >this.#Y.delete(t.pageIndex)}<span class="fstat-no" title="function not covered" ></span>up</span>dateMode(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >if(this.#ht!==t){<span class="cstat-no" title="statement not covered" >this.#ht=t;<span class="cstat-no" title="statement not covered" >i</span>f(t!==s.AnnotationEditorType.NONE){<span class="cstat-no" title="statement not covered" >this.setEditingState(!0);<span class="cstat-no" title="statement not covered" >t</span>his.#Ut();<span class="cstat-no" title="statement not covered" >t</span>his.unselectAll();<span class="cstat-no" title="statement not covered" >f</span>or(const e of this.#Y.values())<span class="cstat-no" title="statement not covered" >e.updateMode(t);<span class="cstat-no" title="statement not covered" >i</span></span>f(e)<span class="cstat-no" title="statement not covered" >for(const t of this.#K.values())<span class="cstat-no" title="statement not covered" >if(t.annotationElementId===e){<span class="cstat-no" title="statement not covered" >this.setSelected(t);<span class="cstat-no" title="statement not covered" >t</span>.enterInEditMode();<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span></span>else{<span class="cstat-no" title="statement not covered" >this.setEditingState(!1);<span class="cstat-no" title="statement not covered" >t</span>his.#jt()}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>up</span>dateToolbar(t){<span class="cstat-no" title="statement not covered" >t!==this.#ht&amp;&amp;this.#nt.dispatch("switchannotationeditormode",{source:this,mode:t})}<span class="fstat-no" title="function not covered" ></span>up</span>dateParams(t,e){<span class="cstat-no" title="statement not covered" >if(this.#it)<span class="cstat-no" title="statement not covered" >if(t!==s.AnnotationEditorParamsType.CREATE){<span class="cstat-no" title="statement not covered" >for(const i of this.#dt)<span class="cstat-no" title="statement not covered" >i.updateParams(t,e);<span class="cstat-no" title="statement not covered" >f</span></span>or(const i of this.#it)<span class="cstat-no" title="statement not covered" >i.updateDefaultParams(t,e)}</span></span>else <span class="cstat-no" title="statement not covered" >this.currentLayer.addNewEditor(t)}<span class="fstat-no" title="function not covered" ></span></span></span>en</span>ableWaiting(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(this.#lt!==t){<span class="cstat-no" title="statement not covered" >this.#lt=t;<span class="cstat-no" title="statement not covered" >f</span>or(const e of this.#Y.values()){<span class="cstat-no" title="statement not covered" >t?e.disableClick():e.enableClick();<span class="cstat-no" title="statement not covered" >e</span>.div.classList.toggle("waiting",t)}</span>}</span>}</span>#Ut(){<span class="cstat-no" title="statement not covered" >if(!this.#ot){<span class="cstat-no" title="statement not covered" >this.#ot=!0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#Y.values())<span class="cstat-no" title="statement not covered" >t.enable()}</span></span>}</span>#jt(){<span class="cstat-no" title="statement not covered" >this.unselectAll();<span class="cstat-no" title="statement not covered" >i</span>f(this.#ot){<span class="cstat-no" title="statement not covered" >this.#ot=!1;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#Y.values())<span class="cstat-no" title="statement not covered" >t.disable()}</span></span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tEditors(t){const e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const i of this.#K.values())<span class="cstat-no" title="statement not covered" >i.pageIndex===t&amp;&amp;e.push(i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>ge</span>tEditor(t){<span class="cstat-no" title="statement not covered" >return this.#K.get(t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dEditor(t){<span class="cstat-no" title="statement not covered" >this.#K.set(t.id,t)}<span class="fstat-no" title="function not covered" ></span>re</span>moveEditor(t){<span class="cstat-no" title="statement not covered" >this.#K.delete(t.id);<span class="cstat-no" title="statement not covered" >t</span>his.unselect(t);<span class="cstat-no" title="statement not covered" >t</span>.annotationElementId&amp;&amp;this.#tt.has(t.annotationElementId)||this.#J?.remove(t.id)}<span class="fstat-no" title="function not covered" ></span>ad</span>dDeletedAnnotationElement(t){<span class="cstat-no" title="statement not covered" >this.#tt.add(t.annotationElementId);<span class="cstat-no" title="statement not covered" >t</span>.deleted=!0}<span class="fstat-no" title="function not covered" ></span>is</span>DeletedAnnotationElement(t){<span class="cstat-no" title="statement not covered" >return this.#tt.has(t)}<span class="fstat-no" title="function not covered" ></span>re</span>moveDeletedAnnotationElement(t){<span class="cstat-no" title="statement not covered" >this.#tt.delete(t.annotationElementId);<span class="cstat-no" title="statement not covered" >t</span>.deleted=!1}</span>#It(t){const e=<span class="cstat-no" title="statement not covered" >this.#Y.get(t.pageIndex);<span class="cstat-no" title="statement not covered" ></span>e?e.addOrRebuild(t):this.addEditor(t)}<span class="fstat-no" title="function not covered" ></span>se</span>tActiveEditor(t){<span class="cstat-no" title="statement not covered" >if(this.#X!==t){<span class="cstat-no" title="statement not covered" >this.#X=t;<span class="cstat-no" title="statement not covered" >t</span>&amp;&amp;this.#Nt(t.propertiesToUpdate)}</span>}<span class="fstat-no" title="function not covered" ></span>to</span>ggleSelected(t){<span class="cstat-no" title="statement not covered" >if(this.#dt.has(t)){<span class="cstat-no" title="statement not covered" >this.#dt.delete(t);<span class="cstat-no" title="statement not covered" >t</span>.unselect();<span class="cstat-no" title="statement not covered" >t</span>his.#Ot({hasSelectedEditor:this.hasSelection})}</span>else{<span class="cstat-no" title="statement not covered" >this.#dt.add(t);<span class="cstat-no" title="statement not covered" >t</span>.select();<span class="cstat-no" title="statement not covered" >t</span>his.#Nt(t.propertiesToUpdate);<span class="cstat-no" title="statement not covered" >t</span>his.#Ot({hasSelectedEditor:!0})}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tSelected(t){<span class="cstat-no" title="statement not covered" >for(const e of this.#dt)<span class="cstat-no" title="statement not covered" >e!==t&amp;&amp;e.unselect();<span class="cstat-no" title="statement not covered" >t</span></span>his.#dt.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#dt.add(t);<span class="cstat-no" title="statement not covered" >t</span>.select();<span class="cstat-no" title="statement not covered" >t</span>his.#Nt(t.propertiesToUpdate);<span class="cstat-no" title="statement not covered" >t</span>his.#Ot({hasSelectedEditor:!0})}<span class="fstat-no" title="function not covered" ></span>is</span>Selected(t){<span class="cstat-no" title="statement not covered" >return this.#dt.has(t)}<span class="fstat-no" title="function not covered" ></span>un</span>select(t){<span class="cstat-no" title="statement not covered" >t.unselect();<span class="cstat-no" title="statement not covered" >t</span>his.#dt.delete(t);<span class="cstat-no" title="statement not covered" >t</span>his.#Ot({hasSelectedEditor:this.hasSelection})}<span class="fstat-no" title="function not covered" ></span>ge</span>t hasSelection(){<span class="cstat-no" title="statement not covered" >return 0!==this.#dt.size}<span class="fstat-no" title="function not covered" ></span>un</span>do(){<span class="cstat-no" title="statement not covered" >this.#Q.undo();<span class="cstat-no" title="statement not covered" >t</span>his.#Ot({hasSomethingToUndo:this.#Q.hasSomethingToUndo(),hasSomethingToRedo:!0,isEmpty:this.#Bt()})}<span class="fstat-no" title="function not covered" ></span>re</span>do(){<span class="cstat-no" title="statement not covered" >this.#Q.redo();<span class="cstat-no" title="statement not covered" >t</span>his.#Ot({hasSomethingToUndo:!0,hasSomethingToRedo:this.#Q.hasSomethingToRedo(),isEmpty:this.#Bt()})}<span class="fstat-no" title="function not covered" ></span>ad</span>dCommands(t){<span class="cstat-no" title="statement not covered" >this.#Q.add(t);<span class="cstat-no" title="statement not covered" >t</span>his.#Ot({hasSomethingToUndo:!0,hasSomethingToRedo:!1,isEmpty:this.#Bt()})}</span>#Bt(){<span class="cstat-no" title="statement not covered" >if(0===this.#K.size)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(1===this.#K.size)<span class="cstat-no" title="statement not covered" >for(const t of this.#K.values())<span class="cstat-no" title="statement not covered" >return t.isEmpty();<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}<span class="fstat-no" title="function not covered" ></span>de</span>lete(){<span class="cstat-no" title="statement not covered" >this.commitOrRemove();<span class="cstat-no" title="statement not covered" >i</span>f(!this.hasSelection)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >[...this.#dt];<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const e of t)<span class="cstat-no" title="statement not covered" >e.remove()}</span></span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const e of t)<span class="cstat-no" title="statement not covered" >this.#It(e)}</span></span>,mustExec:!0})}<span class="fstat-no" title="function not covered" ></span>co</span>mmitOrRemove(){<span class="cstat-no" title="statement not covered" >this.#X?.commitOrRemove()}<span class="fstat-no" title="function not covered" ></span>ha</span>sSomethingToControl(){<span class="cstat-no" title="statement not covered" >return this.#X||this.hasSelection}</span>#Lt(t){<span class="cstat-no" title="statement not covered" >this.#dt.clear();<span class="cstat-no" title="statement not covered" >f</span>or(const e of t)<span class="cstat-no" title="statement not covered" >if(!e.isEmpty()){<span class="cstat-no" title="statement not covered" >this.#dt.add(e);<span class="cstat-no" title="statement not covered" >e</span>.select()}<span class="cstat-no" title="statement not covered" ></span>t</span></span>his.#Ot({hasSelectedEditor:!0})}<span class="fstat-no" title="function not covered" ></span>se</span>lectAll(){<span class="cstat-no" title="statement not covered" >for(const t of this.#dt)<span class="cstat-no" title="statement not covered" >t.commit();<span class="cstat-no" title="statement not covered" >t</span></span>his.#Lt(this.#K.values())}<span class="fstat-no" title="function not covered" ></span>un</span>selectAll(){<span class="cstat-no" title="statement not covered" >if(this.#X)<span class="cstat-no" title="statement not covered" >this.#X.commitOrRemove();e</span>lse <span class="cstat-no" title="statement not covered" >if(this.hasSelection){<span class="cstat-no" title="statement not covered" >for(const t of this.#dt)<span class="cstat-no" title="statement not covered" >t.unselect();<span class="cstat-no" title="statement not covered" >t</span></span>his.#dt.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#Ot({hasSelectedEditor:!1})}</span>}<span class="fstat-no" title="function not covered" ></span></span>tr</span>anslateSelectedEditors(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >i||this.commitOrRemove();<span class="cstat-no" title="statement not covered" >i</span>f(!this.hasSelection)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.#xt[0]+=t;<span class="cstat-no" title="statement not covered" >t</span>his.#xt[1]+=e;c</span>onst[s,n]=<span class="cstat-no" title="statement not covered" >this.#xt,</span>a=<span class="cstat-no" title="statement not covered" >[...this.#dt];<span class="cstat-no" title="statement not covered" ></span>this.#wt&amp;&amp;clearTimeout(this.#wt);<span class="cstat-no" title="statement not covered" >t</span>his.#wt=setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.#wt=null;<span class="cstat-no" title="statement not covered" >t</span>his.#xt[0]=this.#xt[1]=0;<span class="cstat-no" title="statement not covered" >t</span>his.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const t of a)<span class="cstat-no" title="statement not covered" >this.#K.has(t.id)&amp;&amp;t.translateInPage(s,n)}</span></span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const t of a)<span class="cstat-no" title="statement not covered" >this.#K.has(t.id)&amp;&amp;t.translateInPage(-s,-n)}</span></span>,mustExec:!1})}</span>),1e3);<span class="cstat-no" title="statement not covered" >f</span>or(const i of a)<span class="cstat-no" title="statement not covered" >i.translateInPage(t,e)}<span class="fstat-no" title="function not covered" ></span></span>se</span>tUpDragSession(){<span class="cstat-no" title="statement not covered" >if(this.hasSelection){<span class="cstat-no" title="statement not covered" >this.disableUserSelect(!0);<span class="cstat-no" title="statement not covered" >t</span>his.#et=new Map;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#dt)<span class="cstat-no" title="statement not covered" >this.#et.set(t,{savedX:t.x,savedY:t.y,savedPageIndex:t.parent.pageIndex,newX:0,newY:0,newPageIndex:-1})}</span></span>}<span class="fstat-no" title="function not covered" ></span>en</span>dDragSession(){<span class="cstat-no" title="statement not covered" >if(!this.#et)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >t</span></span>his.disableUserSelect(!1);c</span>onst t=<span class="cstat-no" title="statement not covered" >this.#et;<span class="cstat-no" title="statement not covered" ></span>this.#et=null;l</span>et e=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(const[{x:i,y:s,parent:n},a]of t){<span class="cstat-no" title="statement not covered" >a.newX=i;<span class="cstat-no" title="statement not covered" >a</span>.newY=s;<span class="cstat-no" title="statement not covered" >a</span>.newPageIndex=n.pageIndex;<span class="cstat-no" title="statement not covered" >e</span>||=i!==a.savedX||s!==a.savedY||n.pageIndex!==a.savedPageIndex}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!e)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst move=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;{<span class="cstat-no" title="statement not covered" >if(this.#K.has(t.id)){const n=<span class="cstat-no" title="statement not covered" >this.#Y.get(s);<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >t._setParentAndPosition(n,e,i);e</span>lse{<span class="cstat-no" title="statement not covered" >t.pageIndex=s;<span class="cstat-no" title="statement not covered" >t</span>.x=e;<span class="cstat-no" title="statement not covered" >t</span>.y=i}</span>}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const[e,{newX:i,newY:s,newPageIndex:n}]of t)<span class="cstat-no" title="statement not covered" >move(e,i,s,n)}</span></span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const[e,{savedX:i,savedY:s,savedPageIndex:n}]of t)<span class="cstat-no" title="statement not covered" >move(e,i,s,n)}</span></span>,mustExec:!0});<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="fstat-no" title="function not covered" ></span>dr</span>agSelectedEditors(t,e){<span class="cstat-no" title="statement not covered" >if(this.#et)<span class="cstat-no" title="statement not covered" >for(const i of this.#et.keys())<span class="cstat-no" title="statement not covered" >i.drag(t,e)}<span class="fstat-no" title="function not covered" ></span></span></span>re</span>build(t){<span class="cstat-no" title="statement not covered" >if(null===t.parent){const e=<span class="cstat-no" title="statement not covered" >this.getLayer(t.pageIndex);<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >e.changeParent(t);<span class="cstat-no" title="statement not covered" >e</span>.addOrRebuild(t)}</span>else{<span class="cstat-no" title="statement not covered" >this.addEditor(t);<span class="cstat-no" title="statement not covered" >t</span>his.addToAnnotationStorage(t);<span class="cstat-no" title="statement not covered" >t</span>.rebuild()}</span>}</span>else <span class="cstat-no" title="statement not covered" >t.parent.addOrRebuild(t)}<span class="fstat-no" title="function not covered" ></span></span>is</span>Active(t){<span class="cstat-no" title="statement not covered" >return this.#X===t}<span class="fstat-no" title="function not covered" ></span>ge</span>tActive(){<span class="cstat-no" title="statement not covered" >return this.#X}<span class="fstat-no" title="function not covered" ></span>ge</span>tMode(){<span class="cstat-no" title="statement not covered" >return this.#ht}<span class="fstat-no" title="function not covered" ></span>ge</span>t imageManager(){<span class="cstat-no" title="statement not covered" >return(0,s.shadow)(this,"imageManager",new ImageManager)}</span>}<span class="cstat-no" title="statement not covered" >e.AnnotationEditorUIManager=AnnotationEditorUIManager}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.StatTimer=e.RenderingCancelledException=e.PixelsPerInch=e.PageViewport=e.PDFDateString=e.DOMStandardFontDataFactory=e.DOMSVGFactory=e.DOMFilterFactory=e.DOMCanvasFactory=e.DOMCMapReaderFactory=e.AnnotationPrefix=void 0;<span class="cstat-no" title="statement not covered" >e</span>.deprecated=function <span class="fstat-no" title="function not covered" >deprecated(</span>t){<span class="cstat-no" title="statement not covered" >console.log("Deprecated API usage: "+t)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getColorValues=function <span class="fstat-no" title="function not covered" >getColorValues(</span>t){const e=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>e.style.visibility="hidden";<span class="cstat-no" title="statement not covered" >d</span>ocument.body.append(e);<span class="cstat-no" title="statement not covered" >f</span>or(const i of t.keys()){<span class="cstat-no" title="statement not covered" >e.style.color=i;c</span>onst s=<span class="cstat-no" title="statement not covered" >window.getComputedStyle(e).color;<span class="cstat-no" title="statement not covered" ></span>t.set(i,getRGB(s))}<span class="cstat-no" title="statement not covered" ></span>e</span>.remove()}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getCurrentTransform=function <span class="fstat-no" title="function not covered" >getCurrentTransform(</span>t){const{a:e,b:i,c:s,d:n,e:a,f:r}=<span class="cstat-no" title="statement not covered" >t.getTransform();<span class="cstat-no" title="statement not covered" ></span>return[e,i,s,n,a,r]}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getCurrentTransformInverse=function <span class="fstat-no" title="function not covered" >getCurrentTransformInverse(</span>t){const{a:e,b:i,c:s,d:n,e:a,f:r}=<span class="cstat-no" title="statement not covered" >t.getTransform().invertSelf();<span class="cstat-no" title="statement not covered" ></span>return[e,i,s,n,a,r]}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getFilenameFromUrl=function <span class="fstat-no" title="function not covered" >getFilenameFromUrl(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >e||([t]=t.split(/[#?]/,1));<span class="cstat-no" title="statement not covered" >r</span>eturn t.substring(t.lastIndexOf("/")+1)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getPdfFilenameFromUrl=function <span class="fstat-no" title="function not covered" >getPdfFilenameFromUrl(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >"document.pdf")</span>{<span class="cstat-no" title="statement not covered" >if("string"!=typeof t)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(isDataScheme(t)){<span class="cstat-no" title="statement not covered" >(0,n.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >/[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i,</span>s=<span class="cstat-no" title="statement not covered" >/^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/.exec(t);</span>let a=<span class="cstat-no" title="statement not covered" >i.exec(s[1])||i.exec(s[2])||i.exec(s[3]);<span class="cstat-no" title="statement not covered" ></span>if(a){<span class="cstat-no" title="statement not covered" >a=a[0];<span class="cstat-no" title="statement not covered" >i</span>f(a.includes("%"))<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >a=i.exec(decodeURIComponent(a))[0]}</span>catch{}}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn a||e}</span>;<span class="cstat-no" title="statement not covered" >e</span>.getRGB=getRGB;<span class="cstat-no" title="statement not covered" >e</span>.getXfaPageViewport=function <span class="fstat-no" title="function not covered" >getXfaPageViewport(</span>t,{scale:e=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>rotation:i=<span class="branch-0 cbranch-no" title="branch not covered" >0}</span>){const{width:s,height:n}=<span class="cstat-no" title="statement not covered" >t.attributes.style,</span>a=<span class="cstat-no" title="statement not covered" >[0,0,parseInt(s),parseInt(n)];<span class="cstat-no" title="statement not covered" ></span>return new PageViewport({viewBox:a,scale:e,rotation:i})}</span>;<span class="cstat-no" title="statement not covered" >e</span>.isDataScheme=isDataScheme;<span class="cstat-no" title="statement not covered" >e</span>.isPdfFile=function <span class="fstat-no" title="function not covered" >isPdfFile(</span>t){<span class="cstat-no" title="statement not covered" >return"string"==typeof t&amp;&amp;/\.pdf$/i.test(t)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.isValidFetchUrl=isValidFetchUrl;<span class="cstat-no" title="statement not covered" >e</span>.loadScript=function <span class="fstat-no" title="function not covered" >loadScript(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >return new Promise((<span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{const n=<span class="cstat-no" title="statement not covered" >document.createElement("script");<span class="cstat-no" title="statement not covered" ></span>n.src=t;<span class="cstat-no" title="statement not covered" >n</span>.onload=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e&amp;&amp;n.remove();<span class="cstat-no" title="statement not covered" >i</span>(t)}</span>;<span class="cstat-no" title="statement not covered" >n</span>.onerror=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >s(new Error(`Cannot load script at: ${n.src}`))}</span>;<span class="cstat-no" title="statement not covered" >(</span>document.head||document.documentElement).append(n)}</span>))}</span>;<span class="cstat-no" title="statement not covered" >e</span>.setLayerDimensions=function <span class="fstat-no" title="function not covered" >setLayerDimensions(</span>t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >if(e instanceof PageViewport){const{pageWidth:s,pageHeight:a}=<span class="cstat-no" title="statement not covered" >e.rawDims,</span>{style:r}=<span class="cstat-no" title="statement not covered" >t,</span>o=<span class="cstat-no" title="statement not covered" >n.FeatureTest.isCSSRoundSupported,</span>l=<span class="cstat-no" title="statement not covered" >`var(--scale-factor) * ${s}px`,</span>c=<span class="cstat-no" title="statement not covered" >`var(--scale-factor) * ${a}px`,</span>h=<span class="cstat-no" title="statement not covered" >o?`round(${l}, 1px)`:`calc(${l})`,</span>d=<span class="cstat-no" title="statement not covered" >o?`round(${c}, 1px)`:`calc(${c})`;<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;e.rotation%180!=0){<span class="cstat-no" title="statement not covered" >r.width=d;<span class="cstat-no" title="statement not covered" >r</span>.height=h}</span>else{<span class="cstat-no" title="statement not covered" >r.width=h;<span class="cstat-no" title="statement not covered" >r</span>.height=d}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>&amp;&amp;t.setAttribute("data-main-rotation",e.rotation)}</span>;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(7),</span>n=<span class="cstat-no" title="statement not covered" >i(1);</span>const a=<span class="cstat-no" title="statement not covered" >"http://www.w3.org/2000/svg";<span class="cstat-no" title="statement not covered" ></span>e.AnnotationPrefix="pdfjs_internal_id_";c</span>lass PixelsPerInch{static CSS=<span class="cstat-no" title="statement not covered" >96;</span>static PDF=<span class="cstat-no" title="statement not covered" >72;</span>static PDF_TO_CSS_UNITS=<span class="cstat-no" title="statement not covered" >this.CSS/this.PDF}<span class="cstat-no" title="statement not covered" ></span>e.PixelsPerInch=PixelsPerInch;c</span>lass DOMFilterFactory extends s.BaseFilterFactory{#zt;#Ht;#e;#Wt;#Gt;#qt;#Vt;#$t;#Xt;#Kt;#U=<span class="cstat-no" title="statement not covered" >0;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor({docId:t,ownerDocument:e=<span class="branch-0 cbranch-no" title="branch not covered" >globalThis.document}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.#e=t;<span class="cstat-no" title="statement not covered" >t</span>his.#Wt=e}</span>get#z(){<span class="cstat-no" title="statement not covered" >return this.#zt||=new Map}</span>get#Yt(){<span class="cstat-no" title="statement not covered" >if(!this.#Ht){const t=<span class="cstat-no" title="statement not covered" >this.#Wt.createElement("div"),</span>{style:e}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>e.visibility="hidden";<span class="cstat-no" title="statement not covered" >e</span>.contain="strict";<span class="cstat-no" title="statement not covered" >e</span>.width=e.height=0;<span class="cstat-no" title="statement not covered" >e</span>.position="absolute";<span class="cstat-no" title="statement not covered" >e</span>.top=e.left=0;<span class="cstat-no" title="statement not covered" >e</span>.zIndex=-1;c</span>onst i=<span class="cstat-no" title="statement not covered" >this.#Wt.createElementNS(a,"svg");<span class="cstat-no" title="statement not covered" ></span>i.setAttribute("width",0);<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("height",0);<span class="cstat-no" title="statement not covered" >t</span>his.#Ht=this.#Wt.createElementNS(a,"defs");<span class="cstat-no" title="statement not covered" >t</span>.append(i);<span class="cstat-no" title="statement not covered" >i</span>.append(this.#Ht);<span class="cstat-no" title="statement not covered" >t</span>his.#Wt.body.append(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.#Ht}<span class="fstat-no" title="function not covered" ></span>ad</span>dFilter(t){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return"none";l</span></span>et e,i,s,n,a=<span class="cstat-no" title="statement not covered" >this.#z.get(t);<span class="cstat-no" title="statement not covered" ></span>if(a)<span class="cstat-no" title="statement not covered" >return a;<span class="cstat-no" title="statement not covered" >i</span></span>f(1===t.length){const a=<span class="cstat-no" title="statement not covered" >t[0],</span>r=<span class="cstat-no" title="statement not covered" >new Array(256);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;256;t++)<span class="cstat-no" title="statement not covered" >r[t]=a[t]/255;<span class="cstat-no" title="statement not covered" >n</span></span>=e=i=s=r.join(",")}</span>else{const[a,r,o]=<span class="cstat-no" title="statement not covered" >t,</span>l=<span class="cstat-no" title="statement not covered" >new Array(256),</span>c=<span class="cstat-no" title="statement not covered" >new Array(256),</span>h=<span class="cstat-no" title="statement not covered" >new Array(256);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;256;t++){<span class="cstat-no" title="statement not covered" >l[t]=a[t]/255;<span class="cstat-no" title="statement not covered" >c</span>[t]=r[t]/255;<span class="cstat-no" title="statement not covered" >h</span>[t]=o[t]/255}<span class="cstat-no" title="statement not covered" ></span>e</span>=l.join(",");<span class="cstat-no" title="statement not covered" >i</span>=c.join(",");<span class="cstat-no" title="statement not covered" >s</span>=h.join(",");<span class="cstat-no" title="statement not covered" >n</span>=`${e}${i}${s}`}<span class="cstat-no" title="statement not covered" ></span>a</span>=this.#z.get(n);<span class="cstat-no" title="statement not covered" >i</span>f(a){<span class="cstat-no" title="statement not covered" >this.#z.set(t,a);<span class="cstat-no" title="statement not covered" >r</span>eturn a}</span>c</span>onst r=<span class="cstat-no" title="statement not covered" >`g_${this.#e}_transfer_map_${this.#U++}`,</span>o=<span class="cstat-no" title="statement not covered" >`url(#${r})`;<span class="cstat-no" title="statement not covered" ></span>this.#z.set(t,o);<span class="cstat-no" title="statement not covered" >t</span>his.#z.set(n,o);c</span>onst l=<span class="cstat-no" title="statement not covered" >this.#Jt(r);<span class="cstat-no" title="statement not covered" ></span>this.#Qt(e,i,s,l);<span class="cstat-no" title="statement not covered" >r</span>eturn o}<span class="fstat-no" title="function not covered" ></span>ad</span>dHCMFilter(t,e){const i=<span class="cstat-no" title="statement not covered" >`${t}-${e}`;<span class="cstat-no" title="statement not covered" ></span>if(this.#qt===i)<span class="cstat-no" title="statement not covered" >return this.#Vt;<span class="cstat-no" title="statement not covered" >t</span></span>his.#qt=i;<span class="cstat-no" title="statement not covered" >t</span>his.#Vt="none";<span class="cstat-no" title="statement not covered" >t</span>his.#Gt?.remove();<span class="cstat-no" title="statement not covered" >i</span>f(!t||!e)<span class="cstat-no" title="statement not covered" >return this.#Vt;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.#Zt(t);<span class="cstat-no" title="statement not covered" ></span>t=n.Util.makeHexColor(...s);c</span>onst a=<span class="cstat-no" title="statement not covered" >this.#Zt(e);<span class="cstat-no" title="statement not covered" ></span>e=n.Util.makeHexColor(...a);<span class="cstat-no" title="statement not covered" >t</span>his.#Yt.style.color="";<span class="cstat-no" title="statement not covered" >i</span>f("#000000"===t&amp;&amp;"#ffffff"===e||t===e)<span class="cstat-no" title="statement not covered" >return this.#Vt;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >new Array(256);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;=255;t++){const e=<span class="cstat-no" title="statement not covered" >t/255;<span class="cstat-no" title="statement not covered" ></span>r[t]=e&lt;=.03928?e/12.92:((e+.055)/1.055)**2.4}</span>c</span>onst o=<span class="cstat-no" title="statement not covered" >r.join(","),</span>l=<span class="cstat-no" title="statement not covered" >`g_${this.#e}_hcm_filter`,</span>c=<span class="cstat-no" title="statement not covered" >this.#$t=this.#Jt(l);<span class="cstat-no" title="statement not covered" ></span>this.#Qt(o,o,o,c);<span class="cstat-no" title="statement not covered" >t</span>his.#te(c);c</span>onst getSteps=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const i=<span class="cstat-no" title="statement not covered" >s[t]/255,</span>n=<span class="cstat-no" title="statement not covered" >a[t]/255,</span>r=<span class="cstat-no" title="statement not covered" >new Array(e+1);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;=e;t++)<span class="cstat-no" title="statement not covered" >r[t]=i+t/e*(n-i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r.join(",")}</span>;<span class="cstat-no" title="statement not covered" ></span>this.#Qt(getSteps(0,5),getSteps(1,5),getSteps(2,5),c);<span class="cstat-no" title="statement not covered" >t</span>his.#Vt=`url(#${l})`;<span class="cstat-no" title="statement not covered" >r</span>eturn this.#Vt}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightHCMFilter(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >`${t}-${e}-${i}-${s}`;<span class="cstat-no" title="statement not covered" ></span>if(this.#Xt===n)<span class="cstat-no" title="statement not covered" >return this.#Kt;<span class="cstat-no" title="statement not covered" >t</span></span>his.#Xt=n;<span class="cstat-no" title="statement not covered" >t</span>his.#Kt="none";<span class="cstat-no" title="statement not covered" >t</span>his.#$t?.remove();<span class="cstat-no" title="statement not covered" >i</span>f(!t||!e)<span class="cstat-no" title="statement not covered" >return this.#Kt;c</span></span>onst[a,r]=<span class="cstat-no" title="statement not covered" >[t,e].map(this.#Zt.bind(this));</span>let o=<span class="cstat-no" title="statement not covered" >Math.round(.2126*a[0]+.7152*a[1]+.0722*a[2]),</span>l=<span class="cstat-no" title="statement not covered" >Math.round(.2126*r[0]+.7152*r[1]+.0722*r[2]),</span>[c,h]=<span class="cstat-no" title="statement not covered" >[i,s].map(this.#Zt.bind(this));<span class="cstat-no" title="statement not covered" ></span>l&lt;o&amp;&amp;([o,l,c,h]=[l,o,h,c]);<span class="cstat-no" title="statement not covered" >t</span>his.#Yt.style.color="";c</span>onst getSteps=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{const s=<span class="cstat-no" title="statement not covered" >new Array(256),</span>n=<span class="cstat-no" title="statement not covered" >(l-o)/i,</span>a=<span class="cstat-no" title="statement not covered" >t/255,</span>r=<span class="cstat-no" title="statement not covered" >(e-t)/(255*i);</span>let c=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;=i;t++){const e=<span class="cstat-no" title="statement not covered" >Math.round(o+t*n),</span>i=<span class="cstat-no" title="statement not covered" >a+t*r;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >c;</span>t&lt;=e;t++)<span class="cstat-no" title="statement not covered" >s[t]=i;<span class="cstat-no" title="statement not covered" >c</span></span>=e+1}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let t=<span class="cstat-no" title="statement not covered" >c;</span>t&lt;256;t++)<span class="cstat-no" title="statement not covered" >s[t]=s[c-1];<span class="cstat-no" title="statement not covered" >r</span></span>eturn s.join(",")}</span>,</span>d=<span class="cstat-no" title="statement not covered" >`g_${this.#e}_hcm_highlight_filter`,</span>u=<span class="cstat-no" title="statement not covered" >this.#$t=this.#Jt(d);<span class="cstat-no" title="statement not covered" ></span>this.#te(u);<span class="cstat-no" title="statement not covered" >t</span>his.#Qt(getSteps(c[0],h[0],5),getSteps(c[1],h[1],5),getSteps(c[2],h[2],5),u);<span class="cstat-no" title="statement not covered" >t</span>his.#Kt=`url(#${d})`;<span class="cstat-no" title="statement not covered" >r</span>eturn this.#Kt}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(!t||!this.#Vt&amp;&amp;!this.#Kt){<span class="cstat-no" title="statement not covered" >if(this.#Ht){<span class="cstat-no" title="statement not covered" >this.#Ht.parentNode.parentNode.remove();<span class="cstat-no" title="statement not covered" >t</span>his.#Ht=null}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.#zt){<span class="cstat-no" title="statement not covered" >this.#zt.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#zt=null}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#U=0}</span>}</span>#te(t){const e=<span class="cstat-no" title="statement not covered" >this.#Wt.createElementNS(a,"feColorMatrix");<span class="cstat-no" title="statement not covered" ></span>e.setAttribute("type","matrix");<span class="cstat-no" title="statement not covered" >e</span>.setAttribute("values","0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");<span class="cstat-no" title="statement not covered" >t</span>.append(e)}</span>#Jt(t){const e=<span class="cstat-no" title="statement not covered" >this.#Wt.createElementNS(a,"filter");<span class="cstat-no" title="statement not covered" ></span>e.setAttribute("color-interpolation-filters","sRGB");<span class="cstat-no" title="statement not covered" >e</span>.setAttribute("id",t);<span class="cstat-no" title="statement not covered" >t</span>his.#Yt.append(e);<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>#ee(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.#Wt.createElementNS(a,e);<span class="cstat-no" title="statement not covered" ></span>s.setAttribute("type","discrete");<span class="cstat-no" title="statement not covered" >s</span>.setAttribute("tableValues",i);<span class="cstat-no" title="statement not covered" >t</span>.append(s)}</span>#Qt(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.#Wt.createElementNS(a,"feComponentTransfer");<span class="cstat-no" title="statement not covered" ></span>s.append(n);<span class="cstat-no" title="statement not covered" >t</span>his.#ee(n,"feFuncR",t);<span class="cstat-no" title="statement not covered" >t</span>his.#ee(n,"feFuncG",e);<span class="cstat-no" title="statement not covered" >t</span>his.#ee(n,"feFuncB",i)}</span>#Zt(t){<span class="cstat-no" title="statement not covered" >this.#Yt.style.color=t;<span class="cstat-no" title="statement not covered" >r</span>eturn getRGB(getComputedStyle(this.#Yt).getPropertyValue("color"))}</span>}<span class="cstat-no" title="statement not covered" >e.DOMFilterFactory=DOMFilterFactory;c</span>lass DOMCanvasFactory extends s.BaseCanvasFactory{<span class="fstat-no" title="function not covered" >co</span>nstructor({ownerDocument:t=<span class="branch-0 cbranch-no" title="branch not covered" >globalThis.document}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._document=t}<span class="fstat-no" title="function not covered" ></span>_c</span>reateCanvas(t,e){const i=<span class="cstat-no" title="statement not covered" >this._document.createElement("canvas");<span class="cstat-no" title="statement not covered" ></span>i.width=t;<span class="cstat-no" title="statement not covered" >i</span>.height=e;<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>}<span class="cstat-no" title="statement not covered" >e.DOMCanvasFactory=DOMCanvasFactory;a</span>sync function <span class="fstat-no" title="function not covered" >fetchData(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(isValidFetchUrl(t,document.baseURI)){const i=<span class="cstat-no" title="statement not covered" >await fetch(t);<span class="cstat-no" title="statement not covered" ></span>if(!i.ok)<span class="cstat-no" title="statement not covered" >throw new Error(i.statusText);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e?new Uint8Array(await i.arrayBuffer()):(0,n.stringToBytes)(await i.text())}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new Promise((<span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{const a=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest;<span class="cstat-no" title="statement not covered" ></span>a.open("GET",t,!0);<span class="cstat-no" title="statement not covered" >e</span>&amp;&amp;(a.responseType="arraybuffer");<span class="cstat-no" title="statement not covered" >a</span>.onreadystatechange=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(a.readyState===XMLHttpRequest.DONE){<span class="cstat-no" title="statement not covered" >if(200===a.status||0===a.status){let t;<span class="cstat-no" title="statement not covered" >e&amp;&amp;a.response?t=new Uint8Array(a.response):!e&amp;&amp;a.responseText&amp;&amp;(t=(0,n.stringToBytes)(a.responseText));<span class="cstat-no" title="statement not covered" >i</span>f(t){<span class="cstat-no" title="statement not covered" >i(t);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>(new Error(a.statusText))}</span>}</span>;<span class="cstat-no" title="statement not covered" >a</span>.send(null)}</span>))}</span>class DOMCMapReaderFactory extends s.BaseCMapReaderFactory{<span class="fstat-no" title="function not covered" >_f</span>etchData(t,e){<span class="cstat-no" title="statement not covered" >return fetchData(t,this.isCompressed).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{cMapData:t,compressionType:e})</span>))}</span>}<span class="cstat-no" title="statement not covered" >e.DOMCMapReaderFactory=DOMCMapReaderFactory;c</span>lass DOMStandardFontDataFactory extends s.BaseStandardFontDataFactory{<span class="fstat-no" title="function not covered" >_f</span>etchData(t){<span class="cstat-no" title="statement not covered" >return fetchData(t,!0)}</span>}<span class="cstat-no" title="statement not covered" >e.DOMStandardFontDataFactory=DOMStandardFontDataFactory;c</span>lass DOMSVGFactory extends s.BaseSVGFactory{<span class="fstat-no" title="function not covered" >_c</span>reateSVG(t){<span class="cstat-no" title="statement not covered" >return document.createElementNS(a,t)}</span>}<span class="cstat-no" title="statement not covered" >e.DOMSVGFactory=DOMSVGFactory;c</span>lass PageViewport{<span class="fstat-no" title="function not covered" >co</span>nstructor({viewBox:t,scale:e,rotation:i,offsetX:s=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>offsetY:n=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>dontFlip:a=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>){<span class="cstat-no" title="statement not covered" >this.viewBox=t;<span class="cstat-no" title="statement not covered" >t</span>his.scale=e;<span class="cstat-no" title="statement not covered" >t</span>his.rotation=i;<span class="cstat-no" title="statement not covered" >t</span>his.offsetX=s;<span class="cstat-no" title="statement not covered" >t</span>his.offsetY=n;c</span>onst r=<span class="cstat-no" title="statement not covered" >(t[2]+t[0])/2,</span>o=<span class="cstat-no" title="statement not covered" >(t[3]+t[1])/2;</span>let l,c,h,d,u,p,g,m;<span class="cstat-no" title="statement not covered" >(i%=360)&lt;0&amp;&amp;(i+=360);<span class="cstat-no" title="statement not covered" >s</span>witch(i){case 180:<span class="cstat-no" title="statement not covered" >l=-1;<span class="cstat-no" title="statement not covered" >c</span>=0;<span class="cstat-no" title="statement not covered" >h</span>=0;<span class="cstat-no" title="statement not covered" >d</span>=1;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 90:<span class="cstat-no" title="statement not covered" >l=0;<span class="cstat-no" title="statement not covered" >c</span>=1;<span class="cstat-no" title="statement not covered" >h</span>=1;<span class="cstat-no" title="statement not covered" >d</span>=0;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 270:<span class="cstat-no" title="statement not covered" >l=0;<span class="cstat-no" title="statement not covered" >c</span>=-1;<span class="cstat-no" title="statement not covered" >h</span>=-1;<span class="cstat-no" title="statement not covered" >d</span>=0;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 0:<span class="cstat-no" title="statement not covered" >l=1;<span class="cstat-no" title="statement not covered" >c</span>=0;<span class="cstat-no" title="statement not covered" >h</span>=0;<span class="cstat-no" title="statement not covered" >d</span>=-1;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(a){<span class="cstat-no" title="statement not covered" >h=-h;<span class="cstat-no" title="statement not covered" >d</span>=-d}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0===l){<span class="cstat-no" title="statement not covered" >u=Math.abs(o-t[1])*e+s;<span class="cstat-no" title="statement not covered" >p</span>=Math.abs(r-t[0])*e+n;<span class="cstat-no" title="statement not covered" >g</span>=(t[3]-t[1])*e;<span class="cstat-no" title="statement not covered" >m</span>=(t[2]-t[0])*e}</span>else{<span class="cstat-no" title="statement not covered" >u=Math.abs(r-t[0])*e+s;<span class="cstat-no" title="statement not covered" >p</span>=Math.abs(o-t[1])*e+n;<span class="cstat-no" title="statement not covered" >g</span>=(t[2]-t[0])*e;<span class="cstat-no" title="statement not covered" >m</span>=(t[3]-t[1])*e}<span class="cstat-no" title="statement not covered" ></span>t</span>his.transform=[l*e,c*e,h*e,d*e,u-l*e*r-h*e*o,p-c*e*r-d*e*o];<span class="cstat-no" title="statement not covered" >t</span>his.width=g;<span class="cstat-no" title="statement not covered" >t</span>his.height=m}<span class="fstat-no" title="function not covered" ></span>ge</span>t rawDims(){const{viewBox:t}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return(0,n.shadow)(this,"rawDims",{pageWidth:t[2]-t[0],pageHeight:t[3]-t[1],pageX:t[0],pageY:t[1]})}<span class="fstat-no" title="function not covered" ></span>cl</span>one({scale:t=<span class="branch-0 cbranch-no" title="branch not covered" >this.scale,</span>rotation:e=<span class="branch-0 cbranch-no" title="branch not covered" >this.rotation,</span>offsetX:i=<span class="branch-0 cbranch-no" title="branch not covered" >this.offsetX,</span>offsetY:s=<span class="branch-0 cbranch-no" title="branch not covered" >this.offsetY,</span>dontFlip:n=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return new PageViewport({viewBox:this.viewBox.slice(),scale:t,rotation:e,offsetX:i,offsetY:s,dontFlip:n})}<span class="fstat-no" title="function not covered" ></span>co</span>nvertToViewportPoint(t,e){<span class="cstat-no" title="statement not covered" >return n.Util.applyTransform([t,e],this.transform)}<span class="fstat-no" title="function not covered" ></span>co</span>nvertToViewportRectangle(t){const e=<span class="cstat-no" title="statement not covered" >n.Util.applyTransform([t[0],t[1]],this.transform),</span>i=<span class="cstat-no" title="statement not covered" >n.Util.applyTransform([t[2],t[3]],this.transform);<span class="cstat-no" title="statement not covered" ></span>return[e[0],e[1],i[0],i[1]]}<span class="fstat-no" title="function not covered" ></span>co</span>nvertToPdfPoint(t,e){<span class="cstat-no" title="statement not covered" >return n.Util.applyInverseTransform([t,e],this.transform)}</span>}<span class="cstat-no" title="statement not covered" >e.PageViewport=PageViewport;c</span>lass RenderingCancelledException extends n.BaseException{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >super(t,"RenderingCancelledException");<span class="cstat-no" title="statement not covered" >t</span>his.extraDelay=e}</span>}<span class="cstat-no" title="statement not covered" >e.RenderingCancelledException=RenderingCancelledException;f</span>unction <span class="fstat-no" title="function not covered" >isDataScheme(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.length;</span>let i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;i&lt;e&amp;&amp;""===t[i].trim();)<span class="cstat-no" title="statement not covered" >i++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn"data:"===t.substring(i,i+5).toLowerCase()}<span class="cstat-no" title="statement not covered" ></span>e.StatTimer=class StatTimer{started=<span class="cstat-no" title="statement not covered" >Object.create(null);</span>times=<span class="cstat-no" title="statement not covered" >[];<span class="fstat-no" title="function not covered" ></span>ti</span>me(t){<span class="cstat-no" title="statement not covered" >t in this.started&amp;&amp;(0,n.warn)(`Timer is already running for ${t}`);<span class="cstat-no" title="statement not covered" >t</span>his.started[t]=Date.now()}<span class="fstat-no" title="function not covered" ></span>ti</span>meEnd(t){<span class="cstat-no" title="statement not covered" >t in this.started||(0,n.warn)(`Timer has not been started for ${t}`);<span class="cstat-no" title="statement not covered" >t</span>his.times.push({name:t,start:this.started[t],end:Date.now()});<span class="cstat-no" title="statement not covered" >d</span>elete this.started[t]}<span class="fstat-no" title="function not covered" ></span>to</span>String(){const t=<span class="cstat-no" title="statement not covered" >[];</span>let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const{name:t}of this.times)<span class="cstat-no" title="statement not covered" >e=Math.max(t.length,e);<span class="cstat-no" title="statement not covered" >f</span></span>or(const{name:i,start:s,end:n}of this.times)<span class="cstat-no" title="statement not covered" >t.push(`${i.padEnd(e)} ${n-s}ms\n`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.join("")}</span>};f</span>unction <span class="fstat-no" title="function not covered" >isValidFetchUrl(</span>t,e){<span class="cstat-no" title="statement not covered" >try{const{protocol:i}=<span class="cstat-no" title="statement not covered" >e?new URL(t,e):new URL(t);<span class="cstat-no" title="statement not covered" ></span>return"http:"===i||"https:"===i}</span>catch{<span class="cstat-no" title="statement not covered" >return!1}</span>}</span>let r;<span class="cstat-no" title="statement not covered" >e.PDFDateString=class PDFDateString{<span class="fstat-no" title="function not covered" >st</span>atic toDateObject(t){<span class="cstat-no" title="statement not covered" >if(!t||"string"!=typeof t)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span></span>||=new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");c</span>onst e=<span class="cstat-no" title="statement not covered" >r.exec(t);<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >parseInt(e[1],10);</span>let s=<span class="cstat-no" title="statement not covered" >parseInt(e[2],10);<span class="cstat-no" title="statement not covered" ></span>s=s&gt;=1&amp;&amp;s&lt;=12?s-1:0;l</span>et n=<span class="cstat-no" title="statement not covered" >parseInt(e[3],10);<span class="cstat-no" title="statement not covered" ></span>n=n&gt;=1&amp;&amp;n&lt;=31?n:1;l</span>et a=<span class="cstat-no" title="statement not covered" >parseInt(e[4],10);<span class="cstat-no" title="statement not covered" ></span>a=a&gt;=0&amp;&amp;a&lt;=23?a:0;l</span>et o=<span class="cstat-no" title="statement not covered" >parseInt(e[5],10);<span class="cstat-no" title="statement not covered" ></span>o=o&gt;=0&amp;&amp;o&lt;=59?o:0;l</span>et l=<span class="cstat-no" title="statement not covered" >parseInt(e[6],10);<span class="cstat-no" title="statement not covered" ></span>l=l&gt;=0&amp;&amp;l&lt;=59?l:0;c</span>onst c=<span class="cstat-no" title="statement not covered" >e[7]||"Z";</span>let h=<span class="cstat-no" title="statement not covered" >parseInt(e[8],10);<span class="cstat-no" title="statement not covered" ></span>h=h&gt;=0&amp;&amp;h&lt;=23?h:0;l</span>et d=<span class="cstat-no" title="statement not covered" >parseInt(e[9],10)||0;<span class="cstat-no" title="statement not covered" ></span>d=d&gt;=0&amp;&amp;d&lt;=59?d:0;<span class="cstat-no" title="statement not covered" >i</span>f("-"===c){<span class="cstat-no" title="statement not covered" >a+=h;<span class="cstat-no" title="statement not covered" >o</span>+=d}</span>else <span class="cstat-no" title="statement not covered" >if("+"===c){<span class="cstat-no" title="statement not covered" >a-=h;<span class="cstat-no" title="statement not covered" >o</span>-=d}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn new Date(Date.UTC(i,s,n,a,o,l))}</span>};f</span>unction <span class="fstat-no" title="function not covered" >getRGB(</span>t){<span class="cstat-no" title="statement not covered" >if(t.startsWith("#")){const e=<span class="cstat-no" title="statement not covered" >parseInt(t.slice(1),16);<span class="cstat-no" title="statement not covered" ></span>return[(16711680&amp;e)&gt;&gt;16,(65280&amp;e)&gt;&gt;8,255&amp;e]}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.startsWith("rgb("))<span class="cstat-no" title="statement not covered" >return t.slice(4,-1).split(",").map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >parseInt(t))</span>);<span class="cstat-no" title="statement not covered" >i</span></span>f(t.startsWith("rgba("))<span class="cstat-no" title="statement not covered" >return t.slice(5,-1).split(",").map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >parseInt(t))</span>).slice(0,3);<span class="cstat-no" title="statement not covered" >(</span></span>0,n.warn)(`Not a valid color format: "${t}"`);<span class="cstat-no" title="statement not covered" >r</span>eturn[0,0,0]}</span>},<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.BaseStandardFontDataFactory=e.BaseSVGFactory=e.BaseFilterFactory=e.BaseCanvasFactory=e.BaseCMapReaderFactory=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1);</span>class BaseFilterFactory{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.constructor===BaseFilterFactory&amp;&amp;(0,s.unreachable)("Cannot initialize BaseFilterFactory.")}<span class="fstat-no" title="function not covered" ></span>ad</span>dFilter(t){<span class="cstat-no" title="statement not covered" >return"none"}<span class="fstat-no" title="function not covered" ></span>ad</span>dHCMFilter(t,e){<span class="cstat-no" title="statement not covered" >return"none"}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightHCMFilter(t,e,i,s){<span class="cstat-no" title="statement not covered" >return"none"}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{}}<span class="cstat-no" title="statement not covered" >e.BaseFilterFactory=BaseFilterFactory;c</span>lass BaseCanvasFactory{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.constructor===BaseCanvasFactory&amp;&amp;(0,s.unreachable)("Cannot initialize BaseCanvasFactory.")}<span class="fstat-no" title="function not covered" ></span>cr</span>eate(t,e){<span class="cstat-no" title="statement not covered" >if(t&lt;=0||e&lt;=0)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid canvas size");c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this._createCanvas(t,e);<span class="cstat-no" title="statement not covered" ></span>return{canvas:i,context:i.getContext("2d")}}<span class="fstat-no" title="function not covered" ></span>re</span>set(t,e,i){<span class="cstat-no" title="statement not covered" >if(!t.canvas)<span class="cstat-no" title="statement not covered" >throw new Error("Canvas is not specified");<span class="cstat-no" title="statement not covered" >i</span></span>f(e&lt;=0||i&lt;=0)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid canvas size");<span class="cstat-no" title="statement not covered" >t</span></span>.canvas.width=e;<span class="cstat-no" title="statement not covered" >t</span>.canvas.height=i}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(t){<span class="cstat-no" title="statement not covered" >if(!t.canvas)<span class="cstat-no" title="statement not covered" >throw new Error("Canvas is not specified");<span class="cstat-no" title="statement not covered" >t</span></span>.canvas.width=0;<span class="cstat-no" title="statement not covered" >t</span>.canvas.height=0;<span class="cstat-no" title="statement not covered" >t</span>.canvas=null;<span class="cstat-no" title="statement not covered" >t</span>.context=null}<span class="fstat-no" title="function not covered" ></span>_c</span>reateCanvas(t,e){<span class="cstat-no" title="statement not covered" >(0,s.unreachable)("Abstract method `_createCanvas` called.")}</span>}<span class="cstat-no" title="statement not covered" >e.BaseCanvasFactory=BaseCanvasFactory;c</span>lass BaseCMapReaderFactory{<span class="fstat-no" title="function not covered" >co</span>nstructor({baseUrl:t=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>isCompressed:e=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>){<span class="cstat-no" title="statement not covered" >this.constructor===BaseCMapReaderFactory&amp;&amp;(0,s.unreachable)("Cannot initialize BaseCMapReaderFactory.");<span class="cstat-no" title="statement not covered" >t</span>his.baseUrl=t;<span class="cstat-no" title="statement not covered" >t</span>his.isCompressed=e}<span class="fstat-no" title="function not covered" ></span>as</span>ync fetch({name:t}){<span class="cstat-no" title="statement not covered" >if(!this.baseUrl)<span class="cstat-no" title="statement not covered" >throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');<span class="cstat-no" title="statement not covered" >i</span></span>f(!t)<span class="cstat-no" title="statement not covered" >throw new Error("CMap name must be specified.");c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.baseUrl+t+(this.isCompressed?".bcmap":""),</span>i=<span class="cstat-no" title="statement not covered" >this.isCompressed?s.CMapCompressionType.BINARY:s.CMapCompressionType.NONE;<span class="cstat-no" title="statement not covered" ></span>return this._fetchData(e,i).catch((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >throw new Error(`Unable to load ${this.isCompressed?"binary ":""}CMap at: ${e}`)}</span>))}<span class="fstat-no" title="function not covered" ></span>_f</span>etchData(t,e){<span class="cstat-no" title="statement not covered" >(0,s.unreachable)("Abstract method `_fetchData` called.")}</span>}<span class="cstat-no" title="statement not covered" >e.BaseCMapReaderFactory=BaseCMapReaderFactory;c</span>lass BaseStandardFontDataFactory{<span class="fstat-no" title="function not covered" >co</span>nstructor({baseUrl:t=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>){<span class="cstat-no" title="statement not covered" >this.constructor===BaseStandardFontDataFactory&amp;&amp;(0,s.unreachable)("Cannot initialize BaseStandardFontDataFactory.");<span class="cstat-no" title="statement not covered" >t</span>his.baseUrl=t}<span class="fstat-no" title="function not covered" ></span>as</span>ync fetch({filename:t}){<span class="cstat-no" title="statement not covered" >if(!this.baseUrl)<span class="cstat-no" title="statement not covered" >throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');<span class="cstat-no" title="statement not covered" >i</span></span>f(!t)<span class="cstat-no" title="statement not covered" >throw new Error("Font filename must be specified.");c</span></span>onst e=<span class="cstat-no" title="statement not covered" >`${this.baseUrl}${t}`;<span class="cstat-no" title="statement not covered" ></span>return this._fetchData(e).catch((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >throw new Error(`Unable to load font data at: ${e}`)}</span>))}<span class="fstat-no" title="function not covered" ></span>_f</span>etchData(t){<span class="cstat-no" title="statement not covered" >(0,s.unreachable)("Abstract method `_fetchData` called.")}</span>}<span class="cstat-no" title="statement not covered" >e.BaseStandardFontDataFactory=BaseStandardFontDataFactory;c</span>lass BaseSVGFactory{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.constructor===BaseSVGFactory&amp;&amp;(0,s.unreachable)("Cannot initialize BaseSVGFactory.")}<span class="fstat-no" title="function not covered" ></span>cr</span>eate(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(t&lt;=0||e&lt;=0)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid SVG dimensions");c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this._createSVG("svg:svg");<span class="cstat-no" title="statement not covered" ></span>s.setAttribute("version","1.1");<span class="cstat-no" title="statement not covered" >i</span>f(!i){<span class="cstat-no" title="statement not covered" >s.setAttribute("width",`${t}px`);<span class="cstat-no" title="statement not covered" >s</span>.setAttribute("height",`${e}px`)}<span class="cstat-no" title="statement not covered" ></span>s</span>.setAttribute("preserveAspectRatio","none");<span class="cstat-no" title="statement not covered" >s</span>.setAttribute("viewBox",`0 0 ${t} ${e}`);<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>cr</span>eateElement(t){<span class="cstat-no" title="statement not covered" >if("string"!=typeof t)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid SVG element type");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._createSVG(t)}<span class="fstat-no" title="function not covered" ></span>_c</span>reateSVG(t){<span class="cstat-no" title="statement not covered" >(0,s.unreachable)("Abstract method `_createSVG` called.")}</span>}<span class="cstat-no" title="statement not covered" >e.BaseSVGFactory=BaseSVGFactory}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.MurmurHash3_64=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1);</span>const n=<span class="cstat-no" title="statement not covered" >3285377520,</span>a=<span class="cstat-no" title="statement not covered" >4294901760,</span>r=<span class="cstat-no" title="statement not covered" >65535;<span class="cstat-no" title="statement not covered" ></span>e.MurmurHash3_64=class MurmurHash3_64{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.h1=t?4294967295&amp;t:n;<span class="cstat-no" title="statement not covered" >t</span>his.h2=t?4294967295&amp;t:n}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){let e,i;<span class="cstat-no" title="statement not covered" >if("string"==typeof t){<span class="cstat-no" title="statement not covered" >e=new Uint8Array(2*t.length);<span class="cstat-no" title="statement not covered" >i</span>=0;<span class="cstat-no" title="statement not covered" >f</span>or(let s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>s&lt;n;s++){const n=<span class="cstat-no" title="statement not covered" >t.charCodeAt(s);<span class="cstat-no" title="statement not covered" ></span>if(n&lt;=255)<span class="cstat-no" title="statement not covered" >e[i++]=n;e</span>lse{<span class="cstat-no" title="statement not covered" >e[i++]=n&gt;&gt;&gt;8;<span class="cstat-no" title="statement not covered" >e</span>[i++]=255&amp;n}</span>}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(!(0,s.isArrayBuffer)(t))<span class="cstat-no" title="statement not covered" >throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");<span class="cstat-no" title="statement not covered" >e</span></span>=t.slice();<span class="cstat-no" title="statement not covered" >i</span>=e.byteLength}</span>c</span>onst n=<span class="cstat-no" title="statement not covered" >i&gt;&gt;2,</span>o=<span class="cstat-no" title="statement not covered" >i-4*n,</span>l=<span class="cstat-no" title="statement not covered" >new Uint32Array(e.buffer,0,n);</span>let c=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >0,</span>d=<span class="cstat-no" title="statement not covered" >this.h1,</span>u=<span class="cstat-no" title="statement not covered" >this.h2;</span>const p=<span class="cstat-no" title="statement not covered" >3432918353,</span>g=<span class="cstat-no" title="statement not covered" >461845907,</span>m=<span class="cstat-no" title="statement not covered" >11601,</span>f=<span class="cstat-no" title="statement not covered" >13715;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;n;t++)<span class="cstat-no" title="statement not covered" >if(1&amp;t){<span class="cstat-no" title="statement not covered" >c=l[t];<span class="cstat-no" title="statement not covered" >c</span>=c*p&amp;a|c*m&amp;r;<span class="cstat-no" title="statement not covered" >c</span>=c&lt;&lt;15|c&gt;&gt;&gt;17;<span class="cstat-no" title="statement not covered" >c</span>=c*g&amp;a|c*f&amp;r;<span class="cstat-no" title="statement not covered" >d</span>^=c;<span class="cstat-no" title="statement not covered" >d</span>=d&lt;&lt;13|d&gt;&gt;&gt;19;<span class="cstat-no" title="statement not covered" >d</span>=5*d+3864292196}</span>else{<span class="cstat-no" title="statement not covered" >h=l[t];<span class="cstat-no" title="statement not covered" >h</span>=h*p&amp;a|h*m&amp;r;<span class="cstat-no" title="statement not covered" >h</span>=h&lt;&lt;15|h&gt;&gt;&gt;17;<span class="cstat-no" title="statement not covered" >h</span>=h*g&amp;a|h*f&amp;r;<span class="cstat-no" title="statement not covered" >u</span>^=h;<span class="cstat-no" title="statement not covered" >u</span>=u&lt;&lt;13|u&gt;&gt;&gt;19;<span class="cstat-no" title="statement not covered" >u</span>=5*u+3864292196}<span class="cstat-no" title="statement not covered" ></span>c</span></span>=0;<span class="cstat-no" title="statement not covered" >s</span>witch(o){case 3:<span class="cstat-no" title="statement not covered" >c^=e[4*n+2]&lt;&lt;16;c</span>ase 2:<span class="cstat-no" title="statement not covered" >c^=e[4*n+1]&lt;&lt;8;c</span>ase 1:<span class="cstat-no" title="statement not covered" >c^=e[4*n];<span class="cstat-no" title="statement not covered" >c</span>=c*p&amp;a|c*m&amp;r;<span class="cstat-no" title="statement not covered" >c</span>=c&lt;&lt;15|c&gt;&gt;&gt;17;<span class="cstat-no" title="statement not covered" >c</span>=c*g&amp;a|c*f&amp;r;<span class="cstat-no" title="statement not covered" >1</span>&amp;n?d^=c:u^=c}<span class="cstat-no" title="statement not covered" ></span>t</span>his.h1=d;<span class="cstat-no" title="statement not covered" >t</span>his.h2=u}<span class="fstat-no" title="function not covered" ></span>he</span>xdigest(){let t=<span class="cstat-no" title="statement not covered" >this.h1,</span>e=<span class="cstat-no" title="statement not covered" >this.h2;<span class="cstat-no" title="statement not covered" ></span>t^=e&gt;&gt;&gt;1;<span class="cstat-no" title="statement not covered" >t</span>=3981806797*t&amp;a|36045*t&amp;r;<span class="cstat-no" title="statement not covered" >e</span>=4283543511*e&amp;a|(2950163797*(e&lt;&lt;16|t&gt;&gt;&gt;16)&amp;a)&gt;&gt;&gt;16;<span class="cstat-no" title="statement not covered" >t</span>^=e&gt;&gt;&gt;1;<span class="cstat-no" title="statement not covered" >t</span>=444984403*t&amp;a|60499*t&amp;r;<span class="cstat-no" title="statement not covered" >e</span>=3301882366*e&amp;a|(3120437893*(e&lt;&lt;16|t&gt;&gt;&gt;16)&amp;a)&gt;&gt;&gt;16;<span class="cstat-no" title="statement not covered" >t</span>^=e&gt;&gt;&gt;1;<span class="cstat-no" title="statement not covered" >r</span>eturn(t&gt;&gt;&gt;0).toString(16).padStart(8,"0")+(e&gt;&gt;&gt;0).toString(16).padStart(8,"0")}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.FontLoader=e.FontFaceObject=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1);<span class="cstat-no" title="statement not covered" ></span>e.FontLoader=class FontLoader{#ie=<span class="cstat-no" title="statement not covered" >new Set;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor({ownerDocument:t=<span class="branch-0 cbranch-no" title="branch not covered" >globalThis.document,</span>styleElement:e=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>){<span class="cstat-no" title="statement not covered" >this._document=t;<span class="cstat-no" title="statement not covered" >t</span>his.nativeFontFaces=new Set;<span class="cstat-no" title="statement not covered" >t</span>his.styleElement=null;<span class="cstat-no" title="statement not covered" >t</span>his.loadingRequests=[];<span class="cstat-no" title="statement not covered" >t</span>his.loadTestFontId=0}<span class="fstat-no" title="function not covered" ></span>ad</span>dNativeFontFace(t){<span class="cstat-no" title="statement not covered" >this.nativeFontFaces.add(t);<span class="cstat-no" title="statement not covered" >t</span>his._document.fonts.add(t)}<span class="fstat-no" title="function not covered" ></span>re</span>moveNativeFontFace(t){<span class="cstat-no" title="statement not covered" >this.nativeFontFaces.delete(t);<span class="cstat-no" title="statement not covered" >t</span>his._document.fonts.delete(t)}<span class="fstat-no" title="function not covered" ></span>in</span>sertRule(t){<span class="cstat-no" title="statement not covered" >if(!this.styleElement){<span class="cstat-no" title="statement not covered" >this.styleElement=this._document.createElement("style");<span class="cstat-no" title="statement not covered" >t</span>his._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement)}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >this.styleElement.sheet;<span class="cstat-no" title="statement not covered" ></span>e.insertRule(t,e.cssRules.length)}<span class="fstat-no" title="function not covered" ></span>cl</span>ear(){<span class="cstat-no" title="statement not covered" >for(const t of this.nativeFontFaces)<span class="cstat-no" title="statement not covered" >this._document.fonts.delete(t);<span class="cstat-no" title="statement not covered" >t</span></span>his.nativeFontFaces.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#ie.clear();<span class="cstat-no" title="statement not covered" >i</span>f(this.styleElement){<span class="cstat-no" title="statement not covered" >this.styleElement.remove();<span class="cstat-no" title="statement not covered" >t</span>his.styleElement=null}</span>}<span class="fstat-no" title="function not covered" ></span>as</span>ync loadSystemFont(t){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;!this.#ie.has(t.loadedName)){<span class="cstat-no" title="statement not covered" >(0,s.assert)(!this.disableFontFace,"loadSystemFont shouldn't be called when `disableFontFace` is set.");<span class="cstat-no" title="statement not covered" >i</span>f(this.isFontLoadingAPISupported){const{loadedName:e,src:i,style:n}=<span class="cstat-no" title="statement not covered" >t,</span>a=<span class="cstat-no" title="statement not covered" >new FontFace(e,i,n);<span class="cstat-no" title="statement not covered" ></span>this.addNativeFontFace(a);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >await a.load();<span class="cstat-no" title="statement not covered" >t</span>his.#ie.add(e)}</span>catch{<span class="cstat-no" title="statement not covered" >(0,s.warn)(`Cannot load system font: ${t.baseFontName}, installing it could help to improve PDF rendering.`);<span class="cstat-no" title="statement not covered" >t</span>his.removeNativeFontFace(a)}</span>}</span>else<span class="cstat-no" title="statement not covered" >(0,s.unreachable)("Not implemented: loadSystemFont without the Font Loading API.")}</span></span>}<span class="fstat-no" title="function not covered" ></span>as</span>ync bind(t){<span class="cstat-no" title="statement not covered" >if(t.attached||t.missingFile&amp;&amp;!t.systemFontInfo)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>.attached=!0;<span class="cstat-no" title="statement not covered" >i</span>f(t.systemFontInfo){<span class="cstat-no" title="statement not covered" >await this.loadSystemFont(t.systemFontInfo);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.isFontLoadingAPISupported){const e=<span class="cstat-no" title="statement not covered" >t.createNativeFontFace();<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >this.addNativeFontFace(e);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >await e.loaded}</span>catch(i){<span class="cstat-no" title="statement not covered" >(0,s.warn)(`Failed to load font '${e.family}': '${i}'.`);<span class="cstat-no" title="statement not covered" >t</span>.disableFontFace=!0;<span class="cstat-no" title="statement not covered" >t</span>hrow i}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >t.createFontFaceRule();<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >this.insertRule(e);<span class="cstat-no" title="statement not covered" >i</span>f(this.isSyncFontLoadingSupported)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >a</span></span>wait new Promise((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >this._queueLoadingCallback(e);<span class="cstat-no" title="statement not covered" ></span>this._prepareFontLoadEvent(t,i)}</span>))}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t isFontLoadingAPISupported(){const t=<span class="cstat-no" title="statement not covered" >!!this._document?.fonts;<span class="cstat-no" title="statement not covered" ></span>return(0,s.shadow)(this,"isFontLoadingAPISupported",t)}<span class="fstat-no" title="function not covered" ></span>ge</span>t isSyncFontLoadingSupported(){let t=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>(s.isNodeJS||"undefined"!=typeof navigator&amp;&amp;/Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent))&amp;&amp;(t=!0);<span class="cstat-no" title="statement not covered" >r</span>eturn(0,s.shadow)(this,"isSyncFontLoadingSupported",t)}<span class="fstat-no" title="function not covered" ></span>_q</span>ueueLoadingCallback(t){const{loadingRequests:e}=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >{done:!1,complete:function <span class="fstat-no" title="function not covered" >completeRequest(</span>){<span class="cstat-no" title="statement not covered" >(0,s.assert)(!i.done,"completeRequest() cannot be called twice.");<span class="cstat-no" title="statement not covered" >i</span>.done=!0;<span class="cstat-no" title="statement not covered" >f</span>or(;e.length&gt;0&amp;&amp;e[0].done;){const t=<span class="cstat-no" title="statement not covered" >e.shift();<span class="cstat-no" title="statement not covered" ></span>setTimeout(t.callback,0)}</span>}</span>,callback:t};<span class="cstat-no" title="statement not covered" ></span>e.push(i);<span class="cstat-no" title="statement not covered" >r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>ge</span>t _loadTestFont(){const t=<span class="cstat-no" title="statement not covered" >atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");<span class="cstat-no" title="statement not covered" ></span>return(0,s.shadow)(this,"_loadTestFont",t)}<span class="fstat-no" title="function not covered" ></span>_p</span>repareFontLoadEvent(t,e){function <span class="fstat-no" title="function not covered" >int32(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.charCodeAt(e)&lt;&lt;24|t.charCodeAt(e+1)&lt;&lt;16|t.charCodeAt(e+2)&lt;&lt;8|255&amp;t.charCodeAt(e+3)}</span>function <span class="fstat-no" title="function not covered" >spliceString(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return t.substring(0,e)+s+t.substring(e+i)}</span>let i,n;const a=<span class="cstat-no" title="statement not covered" >this._document.createElement("canvas");<span class="cstat-no" title="statement not covered" ></span>a.width=1;<span class="cstat-no" title="statement not covered" >a</span>.height=1;c</span>onst r=<span class="cstat-no" title="statement not covered" >a.getContext("2d");</span>let o=<span class="cstat-no" title="statement not covered" >0;</span>const l=<span class="cstat-no" title="statement not covered" >`lt${Date.now()}${this.loadTestFontId++}`;</span>let c=<span class="cstat-no" title="statement not covered" >this._loadTestFont;<span class="cstat-no" title="statement not covered" ></span>c=spliceString(c,976,l.length,l);c</span>onst h=<span class="cstat-no" title="statement not covered" >1482184792;</span>let d=<span class="cstat-no" title="statement not covered" >int32(c,16);<span class="cstat-no" title="statement not covered" ></span>for(i=0,n=l.length-3;i&lt;n;i+=4)<span class="cstat-no" title="statement not covered" >d=d-h+int32(l,i)|0;<span class="cstat-no" title="statement not covered" >i</span></span>&lt;l.length&amp;&amp;(d=d-h+int32(l+"XXX",i)|0);<span class="cstat-no" title="statement not covered" >c</span>=spliceString(c,16,4,(0,s.string32)(d));c</span>onst u=<span class="cstat-no" title="statement not covered" >`@font-face {font-family:"${l}";src:${`url(data:font/opentype;base64,${btoa(c)});`}}`;<span class="cstat-no" title="statement not covered" ></span>this.insertRule(u);c</span>onst p=<span class="cstat-no" title="statement not covered" >this._document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>p.style.visibility="hidden";<span class="cstat-no" title="statement not covered" >p</span>.style.width=p.style.height="10px";<span class="cstat-no" title="statement not covered" >p</span>.style.position="absolute";<span class="cstat-no" title="statement not covered" >p</span>.style.top=p.style.left="0px";<span class="cstat-no" title="statement not covered" >f</span>or(const e of[t.loadedName,l]){const t=<span class="cstat-no" title="statement not covered" >this._document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>t.textContent="Hi";<span class="cstat-no" title="statement not covered" >t</span>.style.fontFamily=e;<span class="cstat-no" title="statement not covered" >p</span>.append(t)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._document.body.append(p);<span class="cstat-no" title="statement not covered" >!</span>function <span class="fstat-no" title="function not covered" >isFontReady(</span>t,e){<span class="cstat-no" title="statement not covered" >if(++o&gt;30){<span class="cstat-no" title="statement not covered" >(0,s.warn)("Load test font never loaded.");<span class="cstat-no" title="statement not covered" >e</span>();<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>r</span>.font="30px "+t;<span class="cstat-no" title="statement not covered" >r</span>.fillText(".",0,20);<span class="cstat-no" title="statement not covered" >r</span>.getImageData(0,0,1,1).data[3]&gt;0?e():setTimeout(isFontReady.bind(null,t,e))}</span>(l,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >p.remove();<span class="cstat-no" title="statement not covered" >e</span>.complete()}</span>))}</span>};<span class="cstat-no" title="statement not covered" >e</span>.FontFaceObject=class FontFaceObject{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,{isEvalSupported:e=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>disableFontFace:i=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>ignoreErrors:s=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>inspectFont:n=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>){<span class="cstat-no" title="statement not covered" >this.compiledGlyphs=Object.create(null);<span class="cstat-no" title="statement not covered" >f</span>or(const e in t)<span class="cstat-no" title="statement not covered" >this[e]=t[e];<span class="cstat-no" title="statement not covered" >t</span></span>his.isEvalSupported=!1!==e;<span class="cstat-no" title="statement not covered" >t</span>his.disableFontFace=!0===i;<span class="cstat-no" title="statement not covered" >t</span>his.ignoreErrors=!0===s;<span class="cstat-no" title="statement not covered" >t</span>his._inspectFont=n}<span class="fstat-no" title="function not covered" ></span>cr</span>eateNativeFontFace(){<span class="cstat-no" title="statement not covered" >if(!this.data||this.disableFontFace)<span class="cstat-no" title="statement not covered" >return null;l</span></span>et t;<span class="cstat-no" title="statement not covered" >if(this.cssFontInfo){const e=<span class="cstat-no" title="statement not covered" >{weight:this.cssFontInfo.fontWeight};<span class="cstat-no" title="statement not covered" ></span>this.cssFontInfo.italicAngle&amp;&amp;(e.style=`oblique ${this.cssFontInfo.italicAngle}deg`);<span class="cstat-no" title="statement not covered" >t</span>=new FontFace(this.cssFontInfo.fontFamily,this.data,e)}</span>else <span class="cstat-no" title="statement not covered" >t=new FontFace(this.loadedName,this.data,{});<span class="cstat-no" title="statement not covered" >t</span></span>his._inspectFont?.(this);<span class="cstat-no" title="statement not covered" >r</span>eturn t}<span class="fstat-no" title="function not covered" ></span>cr</span>eateFontFaceRule(){<span class="cstat-no" title="statement not covered" >if(!this.data||this.disableFontFace)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >(0,s.bytesToString)(this.data),</span>e=<span class="cstat-no" title="statement not covered" >`url(data:${this.mimetype};base64,${btoa(t)});`;</span>let i;<span class="cstat-no" title="statement not covered" >if(this.cssFontInfo){let t=<span class="cstat-no" title="statement not covered" >`font-weight: ${this.cssFontInfo.fontWeight};`;<span class="cstat-no" title="statement not covered" ></span>this.cssFontInfo.italicAngle&amp;&amp;(t+=`font-style: oblique ${this.cssFontInfo.italicAngle}deg;`);<span class="cstat-no" title="statement not covered" >i</span>=`@font-face {font-family:"${this.cssFontInfo.fontFamily}";${t}src:${e}}`}</span>else <span class="cstat-no" title="statement not covered" >i=`@font-face {font-family:"${this.loadedName}";src:${e}}`;<span class="cstat-no" title="statement not covered" >t</span></span>his._inspectFont?.(this,e);<span class="cstat-no" title="statement not covered" >r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>ge</span>tPathGenerator(t,e){<span class="cstat-no" title="statement not covered" >if(void 0!==this.compiledGlyphs[e])<span class="cstat-no" title="statement not covered" >return this.compiledGlyphs[e];l</span></span>et i;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >i=t.get(this.loadedName+"_path_"+e)}</span>catch(t){<span class="cstat-no" title="statement not covered" >if(!this.ignoreErrors)<span class="cstat-no" title="statement not covered" >throw t;<span class="cstat-no" title="statement not covered" >(</span></span>0,s.warn)(`getPathGenerator - ignoring character: "${t}".`);<span class="cstat-no" title="statement not covered" >r</span>eturn this.compiledGlyphs[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.isEvalSupported&amp;&amp;s.FeatureTest.isEvalSupported){const t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const e of i){const i=<span class="cstat-no" title="statement not covered" >void 0!==e.args?e.args.join(","):"";<span class="cstat-no" title="statement not covered" ></span>t.push("c.",e.cmd,"(",i,");\n")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.compiledGlyphs[e]=new Function("c","size",t.join(""))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.compiledGlyphs[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(const s of i){<span class="cstat-no" title="statement not covered" >"scale"===s.cmd&amp;&amp;(s.args=[e,-e]);<span class="cstat-no" title="statement not covered" >t</span>[s.cmd].apply(t,s.args)}</span>}</span>}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.NodeStandardFontDataFactory=e.NodeFilterFactory=e.NodeCanvasFactory=e.NodeCMapReaderFactory=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(7);<span class="cstat-no" title="statement not covered" ></span>i(1);c</span>onst fetchData=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Promise((<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >require("fs").readFile(t,(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >!t&amp;&amp;s?e(new Uint8Array(s)):i(new Error(t))}</span>))}</span>))}</span>;</span>class NodeFilterFactory extends s.BaseFilterFactory{}<span class="cstat-no" title="statement not covered" >e.NodeFilterFactory=NodeFilterFactory;c</span>lass NodeCanvasFactory extends s.BaseCanvasFactory{<span class="fstat-no" title="function not covered" >_c</span>reateCanvas(t,e){<span class="cstat-no" title="statement not covered" >return require("canvas").createCanvas(t,e)}</span>}<span class="cstat-no" title="statement not covered" >e.NodeCanvasFactory=NodeCanvasFactory;c</span>lass NodeCMapReaderFactory extends s.BaseCMapReaderFactory{<span class="fstat-no" title="function not covered" >_f</span>etchData(t,e){<span class="cstat-no" title="statement not covered" >return fetchData(t).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{cMapData:t,compressionType:e})</span>))}</span>}<span class="cstat-no" title="statement not covered" >e.NodeCMapReaderFactory=NodeCMapReaderFactory;c</span>lass NodeStandardFontDataFactory extends s.BaseStandardFontDataFactory{<span class="fstat-no" title="function not covered" >_f</span>etchData(t){<span class="cstat-no" title="statement not covered" >return fetchData(t)}</span>}<span class="cstat-no" title="statement not covered" >e.NodeStandardFontDataFactory=NodeStandardFontDataFactory}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.CanvasGraphics=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(6),</span>a=<span class="cstat-no" title="statement not covered" >i(12),</span>r=<span class="cstat-no" title="statement not covered" >i(13);</span>const o=<span class="cstat-no" title="statement not covered" >4096,</span>l=<span class="cstat-no" title="statement not covered" >16;</span>class CachedCanvases{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.canvasFactory=t;<span class="cstat-no" title="statement not covered" >t</span>his.cache=Object.create(null)}<span class="fstat-no" title="function not covered" ></span>ge</span>tCanvas(t,e,i){let s;<span class="cstat-no" title="statement not covered" >if(void 0!==this.cache[t]){<span class="cstat-no" title="statement not covered" >s=this.cache[t];<span class="cstat-no" title="statement not covered" >t</span>his.canvasFactory.reset(s,e,i)}</span>else{<span class="cstat-no" title="statement not covered" >s=this.canvasFactory.create(e,i);<span class="cstat-no" title="statement not covered" >t</span>his.cache[t]=s}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>de</span>lete(t){<span class="cstat-no" title="statement not covered" >delete this.cache[t]}<span class="fstat-no" title="function not covered" ></span>cl</span>ear(){<span class="cstat-no" title="statement not covered" >for(const t in this.cache){const e=<span class="cstat-no" title="statement not covered" >this.cache[t];<span class="cstat-no" title="statement not covered" ></span>this.canvasFactory.destroy(e);<span class="cstat-no" title="statement not covered" >d</span>elete this.cache[t]}</span>}</span>}function <span class="fstat-no" title="function not covered" >drawImageAtIntegerCoords(</span>t,e,i,s,a,r,o,l,c,h){const[d,u,p,g,m,f]=<span class="cstat-no" title="statement not covered" >(0,n.getCurrentTransform)(t);<span class="cstat-no" title="statement not covered" ></span>if(0===u&amp;&amp;0===p){const n=<span class="cstat-no" title="statement not covered" >o*d+m,</span>b=<span class="cstat-no" title="statement not covered" >Math.round(n),</span>A=<span class="cstat-no" title="statement not covered" >l*g+f,</span>_=<span class="cstat-no" title="statement not covered" >Math.round(A),</span>v=<span class="cstat-no" title="statement not covered" >(o+c)*d+m,</span>y=<span class="cstat-no" title="statement not covered" >Math.abs(Math.round(v)-b)||1,</span>S=<span class="cstat-no" title="statement not covered" >(l+h)*g+f,</span>E=<span class="cstat-no" title="statement not covered" >Math.abs(Math.round(S)-_)||1;<span class="cstat-no" title="statement not covered" ></span>t.setTransform(Math.sign(d),0,0,Math.sign(g),b,_);<span class="cstat-no" title="statement not covered" >t</span>.drawImage(e,i,s,a,r,0,0,y,E);<span class="cstat-no" title="statement not covered" >t</span>.setTransform(d,u,p,g,m,f);<span class="cstat-no" title="statement not covered" >r</span>eturn[y,E]}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0===d&amp;&amp;0===g){const n=<span class="cstat-no" title="statement not covered" >l*p+m,</span>b=<span class="cstat-no" title="statement not covered" >Math.round(n),</span>A=<span class="cstat-no" title="statement not covered" >o*u+f,</span>_=<span class="cstat-no" title="statement not covered" >Math.round(A),</span>v=<span class="cstat-no" title="statement not covered" >(l+h)*p+m,</span>y=<span class="cstat-no" title="statement not covered" >Math.abs(Math.round(v)-b)||1,</span>S=<span class="cstat-no" title="statement not covered" >(o+c)*u+f,</span>E=<span class="cstat-no" title="statement not covered" >Math.abs(Math.round(S)-_)||1;<span class="cstat-no" title="statement not covered" ></span>t.setTransform(0,Math.sign(u),Math.sign(p),0,b,_);<span class="cstat-no" title="statement not covered" >t</span>.drawImage(e,i,s,a,r,0,0,E,y);<span class="cstat-no" title="statement not covered" >t</span>.setTransform(d,u,p,g,m,f);<span class="cstat-no" title="statement not covered" >r</span>eturn[E,y]}<span class="cstat-no" title="statement not covered" ></span>t</span>.drawImage(e,i,s,a,r,o,l,c,h);<span class="cstat-no" title="statement not covered" >r</span>eturn[Math.hypot(d,u)*c,Math.hypot(p,g)*h]}</span>class CanvasExtraState{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this.alphaIsShape=!1;<span class="cstat-no" title="statement not covered" >t</span>his.fontSize=0;<span class="cstat-no" title="statement not covered" >t</span>his.fontSizeScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.textMatrix=s.IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>his.textMatrixScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.fontMatrix=s.FONT_IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>his.leading=0;<span class="cstat-no" title="statement not covered" >t</span>his.x=0;<span class="cstat-no" title="statement not covered" >t</span>his.y=0;<span class="cstat-no" title="statement not covered" >t</span>his.lineX=0;<span class="cstat-no" title="statement not covered" >t</span>his.lineY=0;<span class="cstat-no" title="statement not covered" >t</span>his.charSpacing=0;<span class="cstat-no" title="statement not covered" >t</span>his.wordSpacing=0;<span class="cstat-no" title="statement not covered" >t</span>his.textHScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.textRenderingMode=s.TextRenderingMode.FILL;<span class="cstat-no" title="statement not covered" >t</span>his.textRise=0;<span class="cstat-no" title="statement not covered" >t</span>his.fillColor="#000000";<span class="cstat-no" title="statement not covered" >t</span>his.strokeColor="#000000";<span class="cstat-no" title="statement not covered" >t</span>his.patternFill=!1;<span class="cstat-no" title="statement not covered" >t</span>his.fillAlpha=1;<span class="cstat-no" title="statement not covered" >t</span>his.strokeAlpha=1;<span class="cstat-no" title="statement not covered" >t</span>his.lineWidth=1;<span class="cstat-no" title="statement not covered" >t</span>his.activeSMask=null;<span class="cstat-no" title="statement not covered" >t</span>his.transferMaps="none";<span class="cstat-no" title="statement not covered" >t</span>his.startNewPathAndClipBox([0,0,t,e])}<span class="fstat-no" title="function not covered" ></span>cl</span>one(){const t=<span class="cstat-no" title="statement not covered" >Object.create(this);<span class="cstat-no" title="statement not covered" ></span>t.clipBox=this.clipBox.slice();<span class="cstat-no" title="statement not covered" >r</span>eturn t}<span class="fstat-no" title="function not covered" ></span>se</span>tCurrentPoint(t,e){<span class="cstat-no" title="statement not covered" >this.x=t;<span class="cstat-no" title="statement not covered" >t</span>his.y=e}<span class="fstat-no" title="function not covered" ></span>up</span>datePathMinMax(t,e,i){<span class="cstat-no" title="statement not covered" >[e,i]=s.Util.applyTransform([e,i],t);<span class="cstat-no" title="statement not covered" >t</span>his.minX=Math.min(this.minX,e);<span class="cstat-no" title="statement not covered" >t</span>his.minY=Math.min(this.minY,i);<span class="cstat-no" title="statement not covered" >t</span>his.maxX=Math.max(this.maxX,e);<span class="cstat-no" title="statement not covered" >t</span>his.maxY=Math.max(this.maxY,i)}<span class="fstat-no" title="function not covered" ></span>up</span>dateRectMinMax(t,e){const i=<span class="cstat-no" title="statement not covered" >s.Util.applyTransform(e,t),</span>n=<span class="cstat-no" title="statement not covered" >s.Util.applyTransform(e.slice(2),t);<span class="cstat-no" title="statement not covered" ></span>this.minX=Math.min(this.minX,i[0],n[0]);<span class="cstat-no" title="statement not covered" >t</span>his.minY=Math.min(this.minY,i[1],n[1]);<span class="cstat-no" title="statement not covered" >t</span>his.maxX=Math.max(this.maxX,i[0],n[0]);<span class="cstat-no" title="statement not covered" >t</span>his.maxY=Math.max(this.maxY,i[1],n[1])}<span class="fstat-no" title="function not covered" ></span>up</span>dateScalingPathMinMax(t,e){<span class="cstat-no" title="statement not covered" >s.Util.scaleMinMax(t,e);<span class="cstat-no" title="statement not covered" >t</span>his.minX=Math.min(this.minX,e[0]);<span class="cstat-no" title="statement not covered" >t</span>his.maxX=Math.max(this.maxX,e[1]);<span class="cstat-no" title="statement not covered" >t</span>his.minY=Math.min(this.minY,e[2]);<span class="cstat-no" title="statement not covered" >t</span>his.maxY=Math.max(this.maxY,e[3])}<span class="fstat-no" title="function not covered" ></span>up</span>dateCurvePathMinMax(t,e,i,n,a,r,o,l,c,h){const d=<span class="cstat-no" title="statement not covered" >s.Util.bezierBoundingBox(e,i,n,a,r,o,l,c);<span class="cstat-no" title="statement not covered" ></span>if(h){<span class="cstat-no" title="statement not covered" >h[0]=Math.min(h[0],d[0],d[2]);<span class="cstat-no" title="statement not covered" >h</span>[1]=Math.max(h[1],d[0],d[2]);<span class="cstat-no" title="statement not covered" >h</span>[2]=Math.min(h[2],d[1],d[3]);<span class="cstat-no" title="statement not covered" >h</span>[3]=Math.max(h[3],d[1],d[3])}</span>else <span class="cstat-no" title="statement not covered" >this.updateRectMinMax(t,d)}<span class="fstat-no" title="function not covered" ></span></span>ge</span>tPathBoundingBox(t=<span class="branch-0 cbranch-no" title="branch not covered" >a.PathType.FILL,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{const i=<span class="cstat-no" title="statement not covered" >[this.minX,this.minY,this.maxX,this.maxY];<span class="cstat-no" title="statement not covered" ></span>if(t===a.PathType.STROKE){<span class="cstat-no" title="statement not covered" >e||(0,s.unreachable)("Stroke bounding box must include transform.");c</span>onst t=<span class="cstat-no" title="statement not covered" >s.Util.singularValueDecompose2dScale(e),</span>n=<span class="cstat-no" title="statement not covered" >t[0]*this.lineWidth/2,</span>a=<span class="cstat-no" title="statement not covered" >t[1]*this.lineWidth/2;<span class="cstat-no" title="statement not covered" ></span>i[0]-=n;<span class="cstat-no" title="statement not covered" >i</span>[1]-=a;<span class="cstat-no" title="statement not covered" >i</span>[2]+=n;<span class="cstat-no" title="statement not covered" >i</span>[3]+=a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>up</span>dateClipFromPath(){const t=<span class="cstat-no" title="statement not covered" >s.Util.intersect(this.clipBox,this.getPathBoundingBox());<span class="cstat-no" title="statement not covered" ></span>this.startNewPathAndClipBox(t||[0,0,0,0])}<span class="fstat-no" title="function not covered" ></span>is</span>EmptyClip(){<span class="cstat-no" title="statement not covered" >return this.minX===1/0}<span class="fstat-no" title="function not covered" ></span>st</span>artNewPathAndClipBox(t){<span class="cstat-no" title="statement not covered" >this.clipBox=t;<span class="cstat-no" title="statement not covered" >t</span>his.minX=1/0;<span class="cstat-no" title="statement not covered" >t</span>his.minY=1/0;<span class="cstat-no" title="statement not covered" >t</span>his.maxX=0;<span class="cstat-no" title="statement not covered" >t</span>his.maxY=0}<span class="fstat-no" title="function not covered" ></span>ge</span>tClippedPathBoundingBox(t=<span class="branch-0 cbranch-no" title="branch not covered" >a.PathType.FILL,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >return s.Util.intersect(this.clipBox,this.getPathBoundingBox(t,e))}</span>}function <span class="fstat-no" title="function not covered" >putBinaryImageData(</span>t,e){<span class="cstat-no" title="statement not covered" >if("undefined"!=typeof ImageData&amp;&amp;e instanceof ImageData){<span class="cstat-no" title="statement not covered" >t.putImageData(e,0,0);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >e.height,</span>n=<span class="cstat-no" title="statement not covered" >e.width,</span>a=<span class="cstat-no" title="statement not covered" >i%l,</span>r=<span class="cstat-no" title="statement not covered" >(i-a)/l,</span>o=<span class="cstat-no" title="statement not covered" >0===a?r:r+1,</span>c=<span class="cstat-no" title="statement not covered" >t.createImageData(n,l);</span>let h,d=<span class="cstat-no" title="statement not covered" >0;</span>const u=<span class="cstat-no" title="statement not covered" >e.data,</span>p=<span class="cstat-no" title="statement not covered" >c.data;</span>let g,m,f,b;<span class="cstat-no" title="statement not covered" >if(e.kind===s.ImageKind.GRAYSCALE_1BPP){const e=<span class="cstat-no" title="statement not covered" >u.byteLength,</span>i=<span class="cstat-no" title="statement not covered" >new Uint32Array(p.buffer,0,p.byteLength&gt;&gt;2),</span>b=<span class="cstat-no" title="statement not covered" >i.length,</span>A=<span class="cstat-no" title="statement not covered" >n+7&gt;&gt;3,</span>_=<span class="cstat-no" title="statement not covered" >4294967295,</span>v=<span class="cstat-no" title="statement not covered" >s.FeatureTest.isLittleEndian?4278190080:255;<span class="cstat-no" title="statement not covered" ></span>for(g=0;g&lt;o;g++){<span class="cstat-no" title="statement not covered" >f=g&lt;r?l:a;<span class="cstat-no" title="statement not covered" >h</span>=0;<span class="cstat-no" title="statement not covered" >f</span>or(m=0;m&lt;f;m++){const t=<span class="cstat-no" title="statement not covered" >e-d;</span>let s=<span class="cstat-no" title="statement not covered" >0;</span>const a=<span class="cstat-no" title="statement not covered" >t&gt;A?n:8*t-7,</span>r=<span class="cstat-no" title="statement not covered" >-8&amp;a;</span>let o=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;s&lt;r;s+=8){<span class="cstat-no" title="statement not covered" >l=u[d++];<span class="cstat-no" title="statement not covered" >i</span>[h++]=128&amp;l?_:v;<span class="cstat-no" title="statement not covered" >i</span>[h++]=64&amp;l?_:v;<span class="cstat-no" title="statement not covered" >i</span>[h++]=32&amp;l?_:v;<span class="cstat-no" title="statement not covered" >i</span>[h++]=16&amp;l?_:v;<span class="cstat-no" title="statement not covered" >i</span>[h++]=8&amp;l?_:v;<span class="cstat-no" title="statement not covered" >i</span>[h++]=4&amp;l?_:v;<span class="cstat-no" title="statement not covered" >i</span>[h++]=2&amp;l?_:v;<span class="cstat-no" title="statement not covered" >i</span>[h++]=1&amp;l?_:v}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;s&lt;a;s++){<span class="cstat-no" title="statement not covered" >if(0===o){<span class="cstat-no" title="statement not covered" >l=u[d++];<span class="cstat-no" title="statement not covered" >o</span>=128}<span class="cstat-no" title="statement not covered" ></span>i</span>[h++]=l&amp;o?_:v;<span class="cstat-no" title="statement not covered" >o</span>&gt;&gt;=1}</span>}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;h&lt;b;)<span class="cstat-no" title="statement not covered" >i[h++]=0;<span class="cstat-no" title="statement not covered" >t</span></span>.putImageData(c,0,g*l)}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(e.kind===s.ImageKind.RGBA_32BPP){<span class="cstat-no" title="statement not covered" >m=0;<span class="cstat-no" title="statement not covered" >b</span>=n*l*4;<span class="cstat-no" title="statement not covered" >f</span>or(g=0;g&lt;r;g++){<span class="cstat-no" title="statement not covered" >p.set(u.subarray(d,d+b));<span class="cstat-no" title="statement not covered" >d</span>+=b;<span class="cstat-no" title="statement not covered" >t</span>.putImageData(c,0,m);<span class="cstat-no" title="statement not covered" >m</span>+=l}<span class="cstat-no" title="statement not covered" ></span>i</span>f(g&lt;o){<span class="cstat-no" title="statement not covered" >b=n*a*4;<span class="cstat-no" title="statement not covered" >p</span>.set(u.subarray(d,d+b));<span class="cstat-no" title="statement not covered" >t</span>.putImageData(c,0,m)}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(e.kind!==s.ImageKind.RGB_24BPP)<span class="cstat-no" title="statement not covered" >throw new Error(`bad image kind: ${e.kind}`);<span class="cstat-no" title="statement not covered" >f</span></span>=l;<span class="cstat-no" title="statement not covered" >b</span>=n*f;<span class="cstat-no" title="statement not covered" >f</span>or(g=0;g&lt;o;g++){<span class="cstat-no" title="statement not covered" >if(g&gt;=r){<span class="cstat-no" title="statement not covered" >f=a;<span class="cstat-no" title="statement not covered" >b</span>=n*f}<span class="cstat-no" title="statement not covered" ></span>h</span>=0;<span class="cstat-no" title="statement not covered" >f</span>or(m=b;m--;){<span class="cstat-no" title="statement not covered" >p[h++]=u[d++];<span class="cstat-no" title="statement not covered" >p</span>[h++]=u[d++];<span class="cstat-no" title="statement not covered" >p</span>[h++]=u[d++];<span class="cstat-no" title="statement not covered" >p</span>[h++]=255}<span class="cstat-no" title="statement not covered" ></span>t</span>.putImageData(c,0,g*l)}</span>}</span>}</span></span>function <span class="fstat-no" title="function not covered" >putBinaryImageMask(</span>t,e){<span class="cstat-no" title="statement not covered" >if(e.bitmap){<span class="cstat-no" title="statement not covered" >t.drawImage(e.bitmap,0,0);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >e.height,</span>s=<span class="cstat-no" title="statement not covered" >e.width,</span>n=<span class="cstat-no" title="statement not covered" >i%l,</span>a=<span class="cstat-no" title="statement not covered" >(i-n)/l,</span>o=<span class="cstat-no" title="statement not covered" >0===n?a:a+1,</span>c=<span class="cstat-no" title="statement not covered" >t.createImageData(s,l);</span>let h=<span class="cstat-no" title="statement not covered" >0;</span>const d=<span class="cstat-no" title="statement not covered" >e.data,</span>u=<span class="cstat-no" title="statement not covered" >c.data;<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o;e++){const i=<span class="cstat-no" title="statement not covered" >e&lt;a?l:n;<span class="cstat-no" title="statement not covered" ></span>({srcPos:h}=(0,r.convertBlackAndWhiteToRGBA)({src:d,srcPos:h,dest:u,width:s,height:i,nonBlackColor:0}));<span class="cstat-no" title="statement not covered" >t</span>.putImageData(c,0,e*l)}</span>}</span>function <span class="fstat-no" title="function not covered" >copyCtxState(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >["strokeStyle","fillStyle","fillRule","globalAlpha","lineWidth","lineCap","lineJoin","miterLimit","globalCompositeOperation","font","filter"];<span class="cstat-no" title="statement not covered" ></span>for(const s of i)<span class="cstat-no" title="statement not covered" >void 0!==t[s]&amp;&amp;(e[s]=t[s]);<span class="cstat-no" title="statement not covered" >i</span></span>f(void 0!==t.setLineDash){<span class="cstat-no" title="statement not covered" >e.setLineDash(t.getLineDash());<span class="cstat-no" title="statement not covered" >e</span>.lineDashOffset=t.lineDashOffset}</span>}</span>function <span class="fstat-no" title="function not covered" >resetCtxToDefault(</span>t){<span class="cstat-no" title="statement not covered" >t.strokeStyle=t.fillStyle="#000000";<span class="cstat-no" title="statement not covered" >t</span>.fillRule="nonzero";<span class="cstat-no" title="statement not covered" >t</span>.globalAlpha=1;<span class="cstat-no" title="statement not covered" >t</span>.lineWidth=1;<span class="cstat-no" title="statement not covered" >t</span>.lineCap="butt";<span class="cstat-no" title="statement not covered" >t</span>.lineJoin="miter";<span class="cstat-no" title="statement not covered" >t</span>.miterLimit=10;<span class="cstat-no" title="statement not covered" >t</span>.globalCompositeOperation="source-over";<span class="cstat-no" title="statement not covered" >t</span>.font="10px sans-serif";<span class="cstat-no" title="statement not covered" >i</span>f(void 0!==t.setLineDash){<span class="cstat-no" title="statement not covered" >t.setLineDash([]);<span class="cstat-no" title="statement not covered" >t</span>.lineDashOffset=0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!s.isNodeJS){const{filter:e}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>"none"!==e&amp;&amp;""!==e&amp;&amp;(t.filter="none")}</span>}</span>function <span class="fstat-no" title="function not covered" >composeSMaskBackdrop(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >3;</span>a&lt;n;a+=4){const n=<span class="cstat-no" title="statement not covered" >t[a];<span class="cstat-no" title="statement not covered" ></span>if(0===n){<span class="cstat-no" title="statement not covered" >t[a-3]=e;<span class="cstat-no" title="statement not covered" >t</span>[a-2]=i;<span class="cstat-no" title="statement not covered" >t</span>[a-1]=s}</span>else <span class="cstat-no" title="statement not covered" >if(n&lt;255){const r=<span class="cstat-no" title="statement not covered" >255-n;<span class="cstat-no" title="statement not covered" ></span>t[a-3]=t[a-3]*n+e*r&gt;&gt;8;<span class="cstat-no" title="statement not covered" >t</span>[a-2]=t[a-2]*n+i*r&gt;&gt;8;<span class="cstat-no" title="statement not covered" >t</span>[a-1]=t[a-1]*n+s*r&gt;&gt;8}</span>}</span></span>}</span>function <span class="fstat-no" title="function not covered" >composeSMaskAlpha(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >3;</span>n&lt;s;n+=4){const s=<span class="cstat-no" title="statement not covered" >i?i[t[n]]:t[n];<span class="cstat-no" title="statement not covered" ></span>e[n]=e[n]*s*.00392156862745098|0}</span>}</span>function <span class="fstat-no" title="function not covered" >composeSMaskLuminosity(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >3;</span>n&lt;s;n+=4){const s=<span class="cstat-no" title="statement not covered" >77*t[n-3]+152*t[n-2]+28*t[n-1];<span class="cstat-no" title="statement not covered" ></span>e[n]=i?e[n]*i[s&gt;&gt;8]&gt;&gt;8:e[n]*s&gt;&gt;16}</span>}</span>function <span class="fstat-no" title="function not covered" >composeSMask(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >s[0],</span>a=<span class="cstat-no" title="statement not covered" >s[1],</span>r=<span class="cstat-no" title="statement not covered" >s[2]-n,</span>o=<span class="cstat-no" title="statement not covered" >s[3]-a;<span class="cstat-no" title="statement not covered" ></span>if(0!==r&amp;&amp;0!==o){<span class="cstat-no" title="statement not covered" >!function <span class="fstat-no" title="function not covered" >genericComposeSMask(</span>t,e,i,s,n,a,r,o,l,c,h){const d=<span class="cstat-no" title="statement not covered" >!!a,</span>u=<span class="cstat-no" title="statement not covered" >d?a[0]:0,</span>p=<span class="cstat-no" title="statement not covered" >d?a[1]:0,</span>g=<span class="cstat-no" title="statement not covered" >d?a[2]:0,</span>m=<span class="cstat-no" title="statement not covered" >"Luminosity"===n?composeSMaskLuminosity:composeSMaskAlpha,</span>f=<span class="cstat-no" title="statement not covered" >Math.min(s,Math.ceil(1048576/i));<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;s;n+=f){const a=<span class="cstat-no" title="statement not covered" >Math.min(f,s-n),</span>b=<span class="cstat-no" title="statement not covered" >t.getImageData(o-c,n+(l-h),i,a),</span>A=<span class="cstat-no" title="statement not covered" >e.getImageData(o,n+l,i,a);<span class="cstat-no" title="statement not covered" ></span>d&amp;&amp;composeSMaskBackdrop(b.data,u,p,g);<span class="cstat-no" title="statement not covered" >m</span>(b.data,A.data,r);<span class="cstat-no" title="statement not covered" >e</span>.putImageData(A,o,n+l)}</span>}</span>(e.context,i,r,o,e.subtype,e.backdrop,e.transferMap,n,a,e.offsetX,e.offsetY);<span class="cstat-no" title="statement not covered" >t</span>.save();<span class="cstat-no" title="statement not covered" >t</span>.globalAlpha=1;<span class="cstat-no" title="statement not covered" >t</span>.globalCompositeOperation="source-over";<span class="cstat-no" title="statement not covered" >t</span>.setTransform(1,0,0,1,0,0);<span class="cstat-no" title="statement not covered" >t</span>.drawImage(i.canvas,0,0);<span class="cstat-no" title="statement not covered" >t</span>.restore()}</span>}</span>function <span class="fstat-no" title="function not covered" >getImageSmoothingEnabled(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >s.Util.singularValueDecompose2dScale(t);<span class="cstat-no" title="statement not covered" ></span>i[0]=Math.fround(i[0]);<span class="cstat-no" title="statement not covered" >i</span>[1]=Math.fround(i[1]);c</span>onst a=<span class="cstat-no" title="statement not covered" >Math.fround((globalThis.devicePixelRatio||1)*n.PixelsPerInch.PDF_TO_CSS_UNITS);<span class="cstat-no" title="statement not covered" ></span>return void 0!==e?e:i[0]&lt;=a||i[1]&lt;=a}</span>const c=<span class="cstat-no" title="statement not covered" >["butt","round","square"],</span>h=<span class="cstat-no" title="statement not covered" >["miter","round","bevel"],</span>d=<span class="cstat-no" title="statement not covered" >{},</span>u=<span class="cstat-no" title="statement not covered" >{};</span>class CanvasGraphics{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i,s,n,{optionalContentConfig:a,markedContentStack:r=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>,o,l){<span class="cstat-no" title="statement not covered" >this.ctx=t;<span class="cstat-no" title="statement not covered" >t</span>his.current=new CanvasExtraState(this.ctx.canvas.width,this.ctx.canvas.height);<span class="cstat-no" title="statement not covered" >t</span>his.stateStack=[];<span class="cstat-no" title="statement not covered" >t</span>his.pendingClip=null;<span class="cstat-no" title="statement not covered" >t</span>his.pendingEOFill=!1;<span class="cstat-no" title="statement not covered" >t</span>his.res=null;<span class="cstat-no" title="statement not covered" >t</span>his.xobjs=null;<span class="cstat-no" title="statement not covered" >t</span>his.commonObjs=e;<span class="cstat-no" title="statement not covered" >t</span>his.objs=i;<span class="cstat-no" title="statement not covered" >t</span>his.canvasFactory=s;<span class="cstat-no" title="statement not covered" >t</span>his.filterFactory=n;<span class="cstat-no" title="statement not covered" >t</span>his.groupStack=[];<span class="cstat-no" title="statement not covered" >t</span>his.processingType3=null;<span class="cstat-no" title="statement not covered" >t</span>his.baseTransform=null;<span class="cstat-no" title="statement not covered" >t</span>his.baseTransformStack=[];<span class="cstat-no" title="statement not covered" >t</span>his.groupLevel=0;<span class="cstat-no" title="statement not covered" >t</span>his.smaskStack=[];<span class="cstat-no" title="statement not covered" >t</span>his.smaskCounter=0;<span class="cstat-no" title="statement not covered" >t</span>his.tempSMask=null;<span class="cstat-no" title="statement not covered" >t</span>his.suspendedCtx=null;<span class="cstat-no" title="statement not covered" >t</span>his.contentVisible=!0;<span class="cstat-no" title="statement not covered" >t</span>his.markedContentStack=r||[];<span class="cstat-no" title="statement not covered" >t</span>his.optionalContentConfig=a;<span class="cstat-no" title="statement not covered" >t</span>his.cachedCanvases=new CachedCanvases(this.canvasFactory);<span class="cstat-no" title="statement not covered" >t</span>his.cachedPatterns=new Map;<span class="cstat-no" title="statement not covered" >t</span>his.annotationCanvasMap=o;<span class="cstat-no" title="statement not covered" >t</span>his.viewportScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.outputScaleX=1;<span class="cstat-no" title="statement not covered" >t</span>his.outputScaleY=1;<span class="cstat-no" title="statement not covered" >t</span>his.pageColors=l;<span class="cstat-no" title="statement not covered" >t</span>his._cachedScaleForStroking=[-1,0];<span class="cstat-no" title="statement not covered" >t</span>his._cachedGetSinglePixelWidth=null;<span class="cstat-no" title="statement not covered" >t</span>his._cachedBitmapsMap=new Map}<span class="fstat-no" title="function not covered" ></span>ge</span>tObject(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >return"string"==typeof t?t.startsWith("g_")?this.commonObjs.get(t):this.objs.get(t):e}<span class="fstat-no" title="function not covered" ></span>be</span>ginDrawing({transform:t,viewport:e,transparency:i=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>background:s=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>){const a=<span class="cstat-no" title="statement not covered" >this.ctx.canvas.width,</span>r=<span class="cstat-no" title="statement not covered" >this.ctx.canvas.height,</span>o=<span class="cstat-no" title="statement not covered" >this.ctx.fillStyle;<span class="cstat-no" title="statement not covered" ></span>this.ctx.fillStyle=s||"#ffffff";<span class="cstat-no" title="statement not covered" >t</span>his.ctx.fillRect(0,0,a,r);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.fillStyle=o;<span class="cstat-no" title="statement not covered" >i</span>f(i){const t=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas("transparent",a,r);<span class="cstat-no" title="statement not covered" ></span>this.compositeCtx=this.ctx;<span class="cstat-no" title="statement not covered" >t</span>his.transparentCanvas=t.canvas;<span class="cstat-no" title="statement not covered" >t</span>his.ctx=t.context;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.save();<span class="cstat-no" title="statement not covered" >t</span>his.ctx.transform(...(0,n.getCurrentTransform)(this.compositeCtx))}<span class="cstat-no" title="statement not covered" ></span>t</span>his.ctx.save();<span class="cstat-no" title="statement not covered" >r</span>esetCtxToDefault(this.ctx);<span class="cstat-no" title="statement not covered" >i</span>f(t){<span class="cstat-no" title="statement not covered" >this.ctx.transform(...t);<span class="cstat-no" title="statement not covered" >t</span>his.outputScaleX=t[0];<span class="cstat-no" title="statement not covered" >t</span>his.outputScaleY=t[0]}<span class="cstat-no" title="statement not covered" ></span>t</span>his.ctx.transform(...e.transform);<span class="cstat-no" title="statement not covered" >t</span>his.viewportScale=e.scale;<span class="cstat-no" title="statement not covered" >t</span>his.baseTransform=(0,n.getCurrentTransform)(this.ctx)}<span class="fstat-no" title="function not covered" ></span>ex</span>ecuteOperatorList(t,e,i,n){const a=<span class="cstat-no" title="statement not covered" >t.argsArray,</span>r=<span class="cstat-no" title="statement not covered" >t.fnArray;</span>let o=<span class="cstat-no" title="statement not covered" >e||0;</span>const l=<span class="cstat-no" title="statement not covered" >a.length;<span class="cstat-no" title="statement not covered" ></span>if(l===o)<span class="cstat-no" title="statement not covered" >return o;c</span></span>onst c=<span class="cstat-no" title="statement not covered" >l-o&gt;10&amp;&amp;"function"==typeof i,</span>h=<span class="cstat-no" title="statement not covered" >c?Date.now()+15:0;</span>let d=<span class="cstat-no" title="statement not covered" >0;</span>const u=<span class="cstat-no" title="statement not covered" >this.commonObjs,</span>p=<span class="cstat-no" title="statement not covered" >this.objs;</span>let g;<span class="cstat-no" title="statement not covered" >for(;;){<span class="cstat-no" title="statement not covered" >if(void 0!==n&amp;&amp;o===n.nextBreakPoint){<span class="cstat-no" title="statement not covered" >n.breakIt(o,i);<span class="cstat-no" title="statement not covered" >r</span>eturn o}<span class="cstat-no" title="statement not covered" ></span>g</span>=r[o];<span class="cstat-no" title="statement not covered" >i</span>f(g!==s.OPS.dependency)<span class="cstat-no" title="statement not covered" >this[g].apply(this,a[o]);e</span>lse <span class="cstat-no" title="statement not covered" >for(const t of a[o]){const e=<span class="cstat-no" title="statement not covered" >t.startsWith("g_")?u:p;<span class="cstat-no" title="statement not covered" ></span>if(!e.has(t)){<span class="cstat-no" title="statement not covered" >e.get(t,i);<span class="cstat-no" title="statement not covered" >r</span>eturn o}</span>}<span class="cstat-no" title="statement not covered" ></span>o</span></span>++;<span class="cstat-no" title="statement not covered" >i</span>f(o===l)<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >i</span></span>f(c&amp;&amp;++d&gt;10){<span class="cstat-no" title="statement not covered" >if(Date.now()&gt;h){<span class="cstat-no" title="statement not covered" >i();<span class="cstat-no" title="statement not covered" >r</span>eturn o}<span class="cstat-no" title="statement not covered" ></span>d</span>=0}</span>}</span>}</span>#se(){<span class="cstat-no" title="statement not covered" >for(;this.stateStack.length||this.inSMaskMode;)<span class="cstat-no" title="statement not covered" >this.restore();<span class="cstat-no" title="statement not covered" >t</span></span>his.ctx.restore();<span class="cstat-no" title="statement not covered" >i</span>f(this.transparentCanvas){<span class="cstat-no" title="statement not covered" >this.ctx=this.compositeCtx;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.save();<span class="cstat-no" title="statement not covered" >t</span>his.ctx.setTransform(1,0,0,1,0,0);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.drawImage(this.transparentCanvas,0,0);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.restore();<span class="cstat-no" title="statement not covered" >t</span>his.transparentCanvas=null}</span>}<span class="fstat-no" title="function not covered" ></span>en</span>dDrawing(){<span class="cstat-no" title="statement not covered" >this.#se();<span class="cstat-no" title="statement not covered" >t</span>his.cachedCanvases.clear();<span class="cstat-no" title="statement not covered" >t</span>his.cachedPatterns.clear();<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._cachedBitmapsMap.values()){<span class="cstat-no" title="statement not covered" >for(const e of t.values())<span class="cstat-no" title="statement not covered" >"undefined"!=typeof HTMLCanvasElement&amp;&amp;e instanceof HTMLCanvasElement&amp;&amp;(e.width=e.height=0);<span class="cstat-no" title="statement not covered" >t</span></span>.clear()}<span class="cstat-no" title="statement not covered" ></span>t</span>his._cachedBitmapsMap.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#ne()}</span>#ne(){<span class="cstat-no" title="statement not covered" >if(this.pageColors){const t=<span class="cstat-no" title="statement not covered" >this.filterFactory.addHCMFilter(this.pageColors.foreground,this.pageColors.background);<span class="cstat-no" title="statement not covered" ></span>if("none"!==t){const e=<span class="cstat-no" title="statement not covered" >this.ctx.filter;<span class="cstat-no" title="statement not covered" ></span>this.ctx.filter=t;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.drawImage(this.ctx.canvas,0,0);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.filter=e}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>_s</span>caleImage(t,e){const i=<span class="cstat-no" title="statement not covered" >t.width,</span>s=<span class="cstat-no" title="statement not covered" >t.height;</span>let n,a,r=<span class="cstat-no" title="statement not covered" >Math.max(Math.hypot(e[0],e[1]),1),</span>o=<span class="cstat-no" title="statement not covered" >Math.max(Math.hypot(e[2],e[3]),1),</span>l=<span class="cstat-no" title="statement not covered" >i,</span>c=<span class="cstat-no" title="statement not covered" >s,</span>h=<span class="cstat-no" title="statement not covered" >"prescale1";<span class="cstat-no" title="statement not covered" ></span>for(;r&gt;2&amp;&amp;l&gt;1||o&gt;2&amp;&amp;c&gt;1;){let e=<span class="cstat-no" title="statement not covered" >l,</span>i=<span class="cstat-no" title="statement not covered" >c;<span class="cstat-no" title="statement not covered" ></span>if(r&gt;2&amp;&amp;l&gt;1){<span class="cstat-no" title="statement not covered" >e=l&gt;=16384?Math.floor(l/2)-1||1:Math.ceil(l/2);<span class="cstat-no" title="statement not covered" >r</span>/=l/e}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o&gt;2&amp;&amp;c&gt;1){<span class="cstat-no" title="statement not covered" >i=c&gt;=16384?Math.floor(c/2)-1||1:Math.ceil(c)/2;<span class="cstat-no" title="statement not covered" >o</span>/=c/i}<span class="cstat-no" title="statement not covered" ></span>n</span>=this.cachedCanvases.getCanvas(h,e,i);<span class="cstat-no" title="statement not covered" >a</span>=n.context;<span class="cstat-no" title="statement not covered" >a</span>.clearRect(0,0,e,i);<span class="cstat-no" title="statement not covered" >a</span>.drawImage(t,0,0,l,c,0,0,e,i);<span class="cstat-no" title="statement not covered" >t</span>=n.canvas;<span class="cstat-no" title="statement not covered" >l</span>=e;<span class="cstat-no" title="statement not covered" >c</span>=i;<span class="cstat-no" title="statement not covered" >h</span>="prescale1"===h?"prescale2":"prescale1"}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{img:t,paintWidth:l,paintHeight:c}}<span class="fstat-no" title="function not covered" ></span>_c</span>reateMaskCanvas(t){const e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>{width:i,height:r}=<span class="cstat-no" title="statement not covered" >t,</span>o=<span class="cstat-no" title="statement not covered" >this.current.fillColor,</span>l=<span class="cstat-no" title="statement not covered" >this.current.patternFill,</span>c=<span class="cstat-no" title="statement not covered" >(0,n.getCurrentTransform)(e);</span>let h,d,u,p;<span class="cstat-no" title="statement not covered" >if((t.bitmap||t.data)&amp;&amp;t.count&gt;1){const e=<span class="cstat-no" title="statement not covered" >t.bitmap||t.data.buffer;<span class="cstat-no" title="statement not covered" ></span>d=JSON.stringify(l?c:[c.slice(0,4),o]);<span class="cstat-no" title="statement not covered" >h</span>=this._cachedBitmapsMap.get(e);<span class="cstat-no" title="statement not covered" >i</span>f(!h){<span class="cstat-no" title="statement not covered" >h=new Map;<span class="cstat-no" title="statement not covered" >t</span>his._cachedBitmapsMap.set(e,h)}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >h.get(d);<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;!l){<span class="cstat-no" title="statement not covered" >return{canvas:i,offsetX:Math.round(Math.min(c[0],c[2])+c[4]),offsetY:Math.round(Math.min(c[1],c[3])+c[5])}}<span class="cstat-no" title="statement not covered" ></span>u</span>=i}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!u){<span class="cstat-no" title="statement not covered" >p=this.cachedCanvases.getCanvas("maskCanvas",i,r);<span class="cstat-no" title="statement not covered" >p</span>utBinaryImageMask(p.context,t)}</span>l</span>et g=<span class="cstat-no" title="statement not covered" >s.Util.transform(c,[1/i,0,0,-1/r,0,0]);<span class="cstat-no" title="statement not covered" ></span>g=s.Util.transform(g,[1,0,0,1,0,-r]);c</span>onst m=<span class="cstat-no" title="statement not covered" >s.Util.applyTransform([0,0],g),</span>f=<span class="cstat-no" title="statement not covered" >s.Util.applyTransform([i,r],g),</span>b=<span class="cstat-no" title="statement not covered" >s.Util.normalizeRect([m[0],m[1],f[0],f[1]]),</span>A=<span class="cstat-no" title="statement not covered" >Math.round(b[2]-b[0])||1,</span>_=<span class="cstat-no" title="statement not covered" >Math.round(b[3]-b[1])||1,</span>v=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas("fillCanvas",A,_),</span>y=<span class="cstat-no" title="statement not covered" >v.context,</span>S=<span class="cstat-no" title="statement not covered" >Math.min(m[0],f[0]),</span>E=<span class="cstat-no" title="statement not covered" >Math.min(m[1],f[1]);<span class="cstat-no" title="statement not covered" ></span>y.translate(-S,-E);<span class="cstat-no" title="statement not covered" >y</span>.transform(...g);<span class="cstat-no" title="statement not covered" >i</span>f(!u){<span class="cstat-no" title="statement not covered" >u=this._scaleImage(p.canvas,(0,n.getCurrentTransformInverse)(y));<span class="cstat-no" title="statement not covered" >u</span>=u.img;<span class="cstat-no" title="statement not covered" >h</span>&amp;&amp;l&amp;&amp;h.set(d,u)}<span class="cstat-no" title="statement not covered" ></span>y</span>.imageSmoothingEnabled=getImageSmoothingEnabled((0,n.getCurrentTransform)(y),t.interpolate);<span class="cstat-no" title="statement not covered" >d</span>rawImageAtIntegerCoords(y,u,0,0,u.width,u.height,0,0,i,r);<span class="cstat-no" title="statement not covered" >y</span>.globalCompositeOperation="source-in";c</span>onst x=<span class="cstat-no" title="statement not covered" >s.Util.transform((0,n.getCurrentTransformInverse)(y),[1,0,0,1,-S,-E]);<span class="cstat-no" title="statement not covered" ></span>y.fillStyle=l?o.getPattern(e,this,x,a.PathType.FILL):o;<span class="cstat-no" title="statement not covered" >y</span>.fillRect(0,0,i,r);<span class="cstat-no" title="statement not covered" >i</span>f(h&amp;&amp;!l){<span class="cstat-no" title="statement not covered" >this.cachedCanvases.delete("fillCanvas");<span class="cstat-no" title="statement not covered" >h</span>.set(d,v.canvas)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{canvas:v.canvas,offsetX:Math.round(S),offsetY:Math.round(E)}}<span class="fstat-no" title="function not covered" ></span>se</span>tLineWidth(t){<span class="cstat-no" title="statement not covered" >t!==this.current.lineWidth&amp;&amp;(this._cachedScaleForStroking[0]=-1);<span class="cstat-no" title="statement not covered" >t</span>his.current.lineWidth=t;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.lineWidth=t}<span class="fstat-no" title="function not covered" ></span>se</span>tLineCap(t){<span class="cstat-no" title="statement not covered" >this.ctx.lineCap=c[t]}<span class="fstat-no" title="function not covered" ></span>se</span>tLineJoin(t){<span class="cstat-no" title="statement not covered" >this.ctx.lineJoin=h[t]}<span class="fstat-no" title="function not covered" ></span>se</span>tMiterLimit(t){<span class="cstat-no" title="statement not covered" >this.ctx.miterLimit=t}<span class="fstat-no" title="function not covered" ></span>se</span>tDash(t,e){const i=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==i.setLineDash){<span class="cstat-no" title="statement not covered" >i.setLineDash(t);<span class="cstat-no" title="statement not covered" >i</span>.lineDashOffset=e}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tRenderingIntent(t){}<span class="fstat-no" title="function not covered" >se</span>tFlatness(t){}<span class="fstat-no" title="function not covered" >se</span>tGState(t){<span class="cstat-no" title="statement not covered" >for(const[e,i]of t)<span class="cstat-no" title="statement not covered" >switch(e){case"LW":<span class="cstat-no" title="statement not covered" >this.setLineWidth(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"LC":<span class="cstat-no" title="statement not covered" >this.setLineCap(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"LJ":<span class="cstat-no" title="statement not covered" >this.setLineJoin(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ML":<span class="cstat-no" title="statement not covered" >this.setMiterLimit(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"D":<span class="cstat-no" title="statement not covered" >this.setDash(i[0],i[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"RI":<span class="cstat-no" title="statement not covered" >this.setRenderingIntent(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"FL":<span class="cstat-no" title="statement not covered" >this.setFlatness(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"Font":<span class="cstat-no" title="statement not covered" >this.setFont(i[0],i[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"CA":<span class="cstat-no" title="statement not covered" >this.current.strokeAlpha=i;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ca":<span class="cstat-no" title="statement not covered" >this.current.fillAlpha=i;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.globalAlpha=i;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"BM":<span class="cstat-no" title="statement not covered" >this.ctx.globalCompositeOperation=i;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"SMask":<span class="cstat-no" title="statement not covered" >this.current.activeSMask=i?this.tempSMask:null;<span class="cstat-no" title="statement not covered" >t</span>his.tempSMask=null;<span class="cstat-no" title="statement not covered" >t</span>his.checkSMaskState();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"TR":<span class="cstat-no" title="statement not covered" >this.ctx.filter=this.current.transferMaps=this.filterFactory.addFilter(i)}</span>}<span class="fstat-no" title="function not covered" ></span></span>ge</span>t inSMaskMode(){<span class="cstat-no" title="statement not covered" >return!!this.suspendedCtx}<span class="fstat-no" title="function not covered" ></span>ch</span>eckSMaskState(){const t=<span class="cstat-no" title="statement not covered" >this.inSMaskMode;<span class="cstat-no" title="statement not covered" ></span>this.current.activeSMask&amp;&amp;!t?this.beginSMaskMode():!this.current.activeSMask&amp;&amp;t&amp;&amp;this.endSMaskMode()}<span class="fstat-no" title="function not covered" ></span>be</span>ginSMaskMode(){<span class="cstat-no" title="statement not covered" >if(this.inSMaskMode)<span class="cstat-no" title="statement not covered" >throw new Error("beginSMaskMode called while already in smask mode");c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.ctx.canvas.width,</span>e=<span class="cstat-no" title="statement not covered" >this.ctx.canvas.height,</span>i=<span class="cstat-no" title="statement not covered" >"smaskGroupAt"+this.groupLevel,</span>s=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas(i,t,e);<span class="cstat-no" title="statement not covered" ></span>this.suspendedCtx=this.ctx;<span class="cstat-no" title="statement not covered" >t</span>his.ctx=s.context;c</span>onst a=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>a.setTransform(...(0,n.getCurrentTransform)(this.suspendedCtx));<span class="cstat-no" title="statement not covered" >c</span>opyCtxState(this.suspendedCtx,a);<span class="cstat-no" title="statement not covered" >!</span>function <span class="fstat-no" title="function not covered" >mirrorContextOperations(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t._removeMirroring)<span class="cstat-no" title="statement not covered" >throw new Error("Context is already forwarding operations.");<span class="cstat-no" title="statement not covered" >t</span></span>.__originalSave=t.save;<span class="cstat-no" title="statement not covered" >t</span>.__originalRestore=t.restore;<span class="cstat-no" title="statement not covered" >t</span>.__originalRotate=t.rotate;<span class="cstat-no" title="statement not covered" >t</span>.__originalScale=t.scale;<span class="cstat-no" title="statement not covered" >t</span>.__originalTranslate=t.translate;<span class="cstat-no" title="statement not covered" >t</span>.__originalTransform=t.transform;<span class="cstat-no" title="statement not covered" >t</span>.__originalSetTransform=t.setTransform;<span class="cstat-no" title="statement not covered" >t</span>.__originalResetTransform=t.resetTransform;<span class="cstat-no" title="statement not covered" >t</span>.__originalClip=t.clip;<span class="cstat-no" title="statement not covered" >t</span>.__originalMoveTo=t.moveTo;<span class="cstat-no" title="statement not covered" >t</span>.__originalLineTo=t.lineTo;<span class="cstat-no" title="statement not covered" >t</span>.__originalBezierCurveTo=t.bezierCurveTo;<span class="cstat-no" title="statement not covered" >t</span>.__originalRect=t.rect;<span class="cstat-no" title="statement not covered" >t</span>.__originalClosePath=t.closePath;<span class="cstat-no" title="statement not covered" >t</span>.__originalBeginPath=t.beginPath;<span class="cstat-no" title="statement not covered" >t</span>._removeMirroring=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.save=t.__originalSave;<span class="cstat-no" title="statement not covered" >t</span>.restore=t.__originalRestore;<span class="cstat-no" title="statement not covered" >t</span>.rotate=t.__originalRotate;<span class="cstat-no" title="statement not covered" >t</span>.scale=t.__originalScale;<span class="cstat-no" title="statement not covered" >t</span>.translate=t.__originalTranslate;<span class="cstat-no" title="statement not covered" >t</span>.transform=t.__originalTransform;<span class="cstat-no" title="statement not covered" >t</span>.setTransform=t.__originalSetTransform;<span class="cstat-no" title="statement not covered" >t</span>.resetTransform=t.__originalResetTransform;<span class="cstat-no" title="statement not covered" >t</span>.clip=t.__originalClip;<span class="cstat-no" title="statement not covered" >t</span>.moveTo=t.__originalMoveTo;<span class="cstat-no" title="statement not covered" >t</span>.lineTo=t.__originalLineTo;<span class="cstat-no" title="statement not covered" >t</span>.bezierCurveTo=t.__originalBezierCurveTo;<span class="cstat-no" title="statement not covered" >t</span>.rect=t.__originalRect;<span class="cstat-no" title="statement not covered" >t</span>.closePath=t.__originalClosePath;<span class="cstat-no" title="statement not covered" >t</span>.beginPath=t.__originalBeginPath;<span class="cstat-no" title="statement not covered" >d</span>elete t._removeMirroring}</span>;<span class="cstat-no" title="statement not covered" >t</span>.save=function <span class="fstat-no" title="function not covered" >ctxSave(</span>){<span class="cstat-no" title="statement not covered" >e.save();<span class="cstat-no" title="statement not covered" >t</span>his.__originalSave()}</span>;<span class="cstat-no" title="statement not covered" >t</span>.restore=function <span class="fstat-no" title="function not covered" >ctxRestore(</span>){<span class="cstat-no" title="statement not covered" >e.restore();<span class="cstat-no" title="statement not covered" >t</span>his.__originalRestore()}</span>;<span class="cstat-no" title="statement not covered" >t</span>.translate=function <span class="fstat-no" title="function not covered" >ctxTranslate(</span>t,i){<span class="cstat-no" title="statement not covered" >e.translate(t,i);<span class="cstat-no" title="statement not covered" >t</span>his.__originalTranslate(t,i)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.scale=function <span class="fstat-no" title="function not covered" >ctxScale(</span>t,i){<span class="cstat-no" title="statement not covered" >e.scale(t,i);<span class="cstat-no" title="statement not covered" >t</span>his.__originalScale(t,i)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.transform=function <span class="fstat-no" title="function not covered" >ctxTransform(</span>t,i,s,n,a,r){<span class="cstat-no" title="statement not covered" >e.transform(t,i,s,n,a,r);<span class="cstat-no" title="statement not covered" >t</span>his.__originalTransform(t,i,s,n,a,r)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.setTransform=function <span class="fstat-no" title="function not covered" >ctxSetTransform(</span>t,i,s,n,a,r){<span class="cstat-no" title="statement not covered" >e.setTransform(t,i,s,n,a,r);<span class="cstat-no" title="statement not covered" >t</span>his.__originalSetTransform(t,i,s,n,a,r)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.resetTransform=function <span class="fstat-no" title="function not covered" >ctxResetTransform(</span>){<span class="cstat-no" title="statement not covered" >e.resetTransform();<span class="cstat-no" title="statement not covered" >t</span>his.__originalResetTransform()}</span>;<span class="cstat-no" title="statement not covered" >t</span>.rotate=function <span class="fstat-no" title="function not covered" >ctxRotate(</span>t){<span class="cstat-no" title="statement not covered" >e.rotate(t);<span class="cstat-no" title="statement not covered" >t</span>his.__originalRotate(t)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.clip=function <span class="fstat-no" title="function not covered" >ctxRotate(</span>t){<span class="cstat-no" title="statement not covered" >e.clip(t);<span class="cstat-no" title="statement not covered" >t</span>his.__originalClip(t)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.moveTo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >e.moveTo(t,i);<span class="cstat-no" title="statement not covered" >t</span>his.__originalMoveTo(t,i)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.lineTo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i){<span class="cstat-no" title="statement not covered" >e.lineTo(t,i);<span class="cstat-no" title="statement not covered" >t</span>his.__originalLineTo(t,i)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.bezierCurveTo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,s,n,a,r){<span class="cstat-no" title="statement not covered" >e.bezierCurveTo(t,i,s,n,a,r);<span class="cstat-no" title="statement not covered" >t</span>his.__originalBezierCurveTo(t,i,s,n,a,r)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.rect=<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,s,n){<span class="cstat-no" title="statement not covered" >e.rect(t,i,s,n);<span class="cstat-no" title="statement not covered" >t</span>his.__originalRect(t,i,s,n)}</span>;<span class="cstat-no" title="statement not covered" >t</span>.closePath=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.closePath();<span class="cstat-no" title="statement not covered" >t</span>his.__originalClosePath()}</span>;<span class="cstat-no" title="statement not covered" >t</span>.beginPath=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.beginPath();<span class="cstat-no" title="statement not covered" >t</span>his.__originalBeginPath()}</span>}</span>(a,this.suspendedCtx);<span class="cstat-no" title="statement not covered" >t</span>his.setGState([["BM","source-over"],["ca",1],["CA",1]])}<span class="fstat-no" title="function not covered" ></span>en</span>dSMaskMode(){<span class="cstat-no" title="statement not covered" >if(!this.inSMaskMode)<span class="cstat-no" title="statement not covered" >throw new Error("endSMaskMode called while not in smask mode");<span class="cstat-no" title="statement not covered" >t</span></span>his.ctx._removeMirroring();<span class="cstat-no" title="statement not covered" >c</span>opyCtxState(this.ctx,this.suspendedCtx);<span class="cstat-no" title="statement not covered" >t</span>his.ctx=this.suspendedCtx;<span class="cstat-no" title="statement not covered" >t</span>his.suspendedCtx=null}<span class="fstat-no" title="function not covered" ></span>co</span>mpose(t){<span class="cstat-no" title="statement not covered" >if(!this.current.activeSMask)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(t){<span class="cstat-no" title="statement not covered" >t[0]=Math.floor(t[0]);<span class="cstat-no" title="statement not covered" >t</span>[1]=Math.floor(t[1]);<span class="cstat-no" title="statement not covered" >t</span>[2]=Math.ceil(t[2]);<span class="cstat-no" title="statement not covered" >t</span>[3]=Math.ceil(t[3])}</span>else <span class="cstat-no" title="statement not covered" >t=[0,0,this.ctx.canvas.width,this.ctx.canvas.height];c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.current.activeSMask;<span class="cstat-no" title="statement not covered" ></span>composeSMask(this.suspendedCtx,e,this.ctx,t);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.save();<span class="cstat-no" title="statement not covered" >t</span>his.ctx.setTransform(1,0,0,1,0,0);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.clearRect(0,0,this.ctx.canvas.width,this.ctx.canvas.height);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.restore()}<span class="fstat-no" title="function not covered" ></span>sa</span>ve(){<span class="cstat-no" title="statement not covered" >if(this.inSMaskMode){<span class="cstat-no" title="statement not covered" >copyCtxState(this.ctx,this.suspendedCtx);<span class="cstat-no" title="statement not covered" >t</span>his.suspendedCtx.save()}</span>else <span class="cstat-no" title="statement not covered" >this.ctx.save();c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>this.stateStack.push(t);<span class="cstat-no" title="statement not covered" >t</span>his.current=t.clone()}<span class="fstat-no" title="function not covered" ></span>re</span>store(){<span class="cstat-no" title="statement not covered" >0===this.stateStack.length&amp;&amp;this.inSMaskMode&amp;&amp;this.endSMaskMode();<span class="cstat-no" title="statement not covered" >i</span>f(0!==this.stateStack.length){<span class="cstat-no" title="statement not covered" >this.current=this.stateStack.pop();<span class="cstat-no" title="statement not covered" >i</span>f(this.inSMaskMode){<span class="cstat-no" title="statement not covered" >this.suspendedCtx.restore();<span class="cstat-no" title="statement not covered" >c</span>opyCtxState(this.suspendedCtx,this.ctx)}</span>else <span class="cstat-no" title="statement not covered" >this.ctx.restore();<span class="cstat-no" title="statement not covered" >t</span></span>his.checkSMaskState();<span class="cstat-no" title="statement not covered" >t</span>his.pendingClip=null;<span class="cstat-no" title="statement not covered" >t</span>his._cachedScaleForStroking[0]=-1;<span class="cstat-no" title="statement not covered" >t</span>his._cachedGetSinglePixelWidth=null}</span>}<span class="fstat-no" title="function not covered" ></span>tr</span>ansform(t,e,i,s,n,a){<span class="cstat-no" title="statement not covered" >this.ctx.transform(t,e,i,s,n,a);<span class="cstat-no" title="statement not covered" >t</span>his._cachedScaleForStroking[0]=-1;<span class="cstat-no" title="statement not covered" >t</span>his._cachedGetSinglePixelWidth=null}<span class="fstat-no" title="function not covered" ></span>co</span>nstructPath(t,e,i){const a=<span class="cstat-no" title="statement not covered" >this.ctx,</span>r=<span class="cstat-no" title="statement not covered" >this.current;</span>let o,l,c=<span class="cstat-no" title="statement not covered" >r.x,</span>h=<span class="cstat-no" title="statement not covered" >r.y;</span>const d=<span class="cstat-no" title="statement not covered" >(0,n.getCurrentTransform)(a),</span>u=<span class="cstat-no" title="statement not covered" >0===d[0]&amp;&amp;0===d[3]||0===d[1]&amp;&amp;0===d[2],</span>p=<span class="cstat-no" title="statement not covered" >u?i.slice(0):null;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0,</span>g=<span class="cstat-no" title="statement not covered" >t.length;</span>i&lt;g;i++)<span class="cstat-no" title="statement not covered" >switch(0|t[i]){case s.OPS.rectangle:<span class="cstat-no" title="statement not covered" >c=e[n++];<span class="cstat-no" title="statement not covered" >h</span>=e[n++];c</span>onst t=<span class="cstat-no" title="statement not covered" >e[n++],</span>i=<span class="cstat-no" title="statement not covered" >e[n++],</span>g=<span class="cstat-no" title="statement not covered" >c+t,</span>m=<span class="cstat-no" title="statement not covered" >h+i;<span class="cstat-no" title="statement not covered" ></span>a.moveTo(c,h);<span class="cstat-no" title="statement not covered" >i</span>f(0===t||0===i)<span class="cstat-no" title="statement not covered" >a.lineTo(g,m);e</span>lse{<span class="cstat-no" title="statement not covered" >a.lineTo(g,h);<span class="cstat-no" title="statement not covered" >a</span>.lineTo(g,m);<span class="cstat-no" title="statement not covered" >a</span>.lineTo(c,m)}<span class="cstat-no" title="statement not covered" ></span>u</span>||r.updateRectMinMax(d,[c,h,g,m]);<span class="cstat-no" title="statement not covered" >a</span>.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.OPS.moveTo:<span class="cstat-no" title="statement not covered" >c=e[n++];<span class="cstat-no" title="statement not covered" >h</span>=e[n++];<span class="cstat-no" title="statement not covered" >a</span>.moveTo(c,h);<span class="cstat-no" title="statement not covered" >u</span>||r.updatePathMinMax(d,c,h);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.OPS.lineTo:<span class="cstat-no" title="statement not covered" >c=e[n++];<span class="cstat-no" title="statement not covered" >h</span>=e[n++];<span class="cstat-no" title="statement not covered" >a</span>.lineTo(c,h);<span class="cstat-no" title="statement not covered" >u</span>||r.updatePathMinMax(d,c,h);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.OPS.curveTo:<span class="cstat-no" title="statement not covered" >o=c;<span class="cstat-no" title="statement not covered" >l</span>=h;<span class="cstat-no" title="statement not covered" >c</span>=e[n+4];<span class="cstat-no" title="statement not covered" >h</span>=e[n+5];<span class="cstat-no" title="statement not covered" >a</span>.bezierCurveTo(e[n],e[n+1],e[n+2],e[n+3],c,h);<span class="cstat-no" title="statement not covered" >r</span>.updateCurvePathMinMax(d,o,l,e[n],e[n+1],e[n+2],e[n+3],c,h,p);<span class="cstat-no" title="statement not covered" >n</span>+=6;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.OPS.curveTo2:<span class="cstat-no" title="statement not covered" >o=c;<span class="cstat-no" title="statement not covered" >l</span>=h;<span class="cstat-no" title="statement not covered" >a</span>.bezierCurveTo(c,h,e[n],e[n+1],e[n+2],e[n+3]);<span class="cstat-no" title="statement not covered" >r</span>.updateCurvePathMinMax(d,o,l,c,h,e[n],e[n+1],e[n+2],e[n+3],p);<span class="cstat-no" title="statement not covered" >c</span>=e[n+2];<span class="cstat-no" title="statement not covered" >h</span>=e[n+3];<span class="cstat-no" title="statement not covered" >n</span>+=4;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.OPS.curveTo3:<span class="cstat-no" title="statement not covered" >o=c;<span class="cstat-no" title="statement not covered" >l</span>=h;<span class="cstat-no" title="statement not covered" >c</span>=e[n+2];<span class="cstat-no" title="statement not covered" >h</span>=e[n+3];<span class="cstat-no" title="statement not covered" >a</span>.bezierCurveTo(e[n],e[n+1],c,h,c,h);<span class="cstat-no" title="statement not covered" >r</span>.updateCurvePathMinMax(d,o,l,e[n],e[n+1],c,h,c,h,p);<span class="cstat-no" title="statement not covered" >n</span>+=4;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.OPS.closePath:<span class="cstat-no" title="statement not covered" >a.closePath()}<span class="cstat-no" title="statement not covered" ></span>u</span></span>&amp;&amp;r.updateScalingPathMinMax(d,p);<span class="cstat-no" title="statement not covered" >r</span>.setCurrentPoint(c,h)}<span class="fstat-no" title="function not covered" ></span>cl</span>osePath(){<span class="cstat-no" title="statement not covered" >this.ctx.closePath()}<span class="fstat-no" title="function not covered" ></span>st</span>roke(t=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{const e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>i=<span class="cstat-no" title="statement not covered" >this.current.strokeColor;<span class="cstat-no" title="statement not covered" ></span>e.globalAlpha=this.current.strokeAlpha;<span class="cstat-no" title="statement not covered" >i</span>f(this.contentVisible)<span class="cstat-no" title="statement not covered" >if("object"==typeof i&amp;&amp;i?.getPattern){<span class="cstat-no" title="statement not covered" >e.save();<span class="cstat-no" title="statement not covered" >e</span>.strokeStyle=i.getPattern(e,this,(0,n.getCurrentTransformInverse)(e),a.PathType.STROKE);<span class="cstat-no" title="statement not covered" >t</span>his.rescaleAndStroke(!1);<span class="cstat-no" title="statement not covered" >e</span>.restore()}</span>else <span class="cstat-no" title="statement not covered" >this.rescaleAndStroke(!0);<span class="cstat-no" title="statement not covered" >t</span></span></span>&amp;&amp;this.consumePath(this.current.getClippedPathBoundingBox());<span class="cstat-no" title="statement not covered" >e</span>.globalAlpha=this.current.fillAlpha}<span class="fstat-no" title="function not covered" ></span>cl</span>oseStroke(){<span class="cstat-no" title="statement not covered" >this.closePath();<span class="cstat-no" title="statement not covered" >t</span>his.stroke()}<span class="fstat-no" title="function not covered" ></span>fi</span>ll(t=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{const e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>i=<span class="cstat-no" title="statement not covered" >this.current.fillColor;</span>let s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(this.current.patternFill){<span class="cstat-no" title="statement not covered" >e.save();<span class="cstat-no" title="statement not covered" >e</span>.fillStyle=i.getPattern(e,this,(0,n.getCurrentTransformInverse)(e),a.PathType.FILL);<span class="cstat-no" title="statement not covered" >s</span>=!0}</span>c</span>onst r=<span class="cstat-no" title="statement not covered" >this.current.getClippedPathBoundingBox();<span class="cstat-no" title="statement not covered" ></span>if(this.contentVisible&amp;&amp;null!==r)<span class="cstat-no" title="statement not covered" >if(this.pendingEOFill){<span class="cstat-no" title="statement not covered" >e.fill("evenodd");<span class="cstat-no" title="statement not covered" >t</span>his.pendingEOFill=!1}</span>else <span class="cstat-no" title="statement not covered" >e.fill();<span class="cstat-no" title="statement not covered" >s</span></span></span>&amp;&amp;e.restore();<span class="cstat-no" title="statement not covered" >t</span>&amp;&amp;this.consumePath(r)}<span class="fstat-no" title="function not covered" ></span>eo</span>Fill(){<span class="cstat-no" title="statement not covered" >this.pendingEOFill=!0;<span class="cstat-no" title="statement not covered" >t</span>his.fill()}<span class="fstat-no" title="function not covered" ></span>fi</span>llStroke(){<span class="cstat-no" title="statement not covered" >this.fill(!1);<span class="cstat-no" title="statement not covered" >t</span>his.stroke(!1);<span class="cstat-no" title="statement not covered" >t</span>his.consumePath()}<span class="fstat-no" title="function not covered" ></span>eo</span>FillStroke(){<span class="cstat-no" title="statement not covered" >this.pendingEOFill=!0;<span class="cstat-no" title="statement not covered" >t</span>his.fillStroke()}<span class="fstat-no" title="function not covered" ></span>cl</span>oseFillStroke(){<span class="cstat-no" title="statement not covered" >this.closePath();<span class="cstat-no" title="statement not covered" >t</span>his.fillStroke()}<span class="fstat-no" title="function not covered" ></span>cl</span>oseEOFillStroke(){<span class="cstat-no" title="statement not covered" >this.pendingEOFill=!0;<span class="cstat-no" title="statement not covered" >t</span>his.closePath();<span class="cstat-no" title="statement not covered" >t</span>his.fillStroke()}<span class="fstat-no" title="function not covered" ></span>en</span>dPath(){<span class="cstat-no" title="statement not covered" >this.consumePath()}<span class="fstat-no" title="function not covered" ></span>cl</span>ip(){<span class="cstat-no" title="statement not covered" >this.pendingClip=d}<span class="fstat-no" title="function not covered" ></span>eo</span>Clip(){<span class="cstat-no" title="statement not covered" >this.pendingClip=u}<span class="fstat-no" title="function not covered" ></span>be</span>ginText(){<span class="cstat-no" title="statement not covered" >this.current.textMatrix=s.IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>his.current.textMatrixScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.current.x=this.current.lineX=0;<span class="cstat-no" title="statement not covered" >t</span>his.current.y=this.current.lineY=0}<span class="fstat-no" title="function not covered" ></span>en</span>dText(){const t=<span class="cstat-no" title="statement not covered" >this.pendingTextPaths,</span>e=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==t){<span class="cstat-no" title="statement not covered" >e.save();<span class="cstat-no" title="statement not covered" >e</span>.beginPath();<span class="cstat-no" title="statement not covered" >f</span>or(const i of t){<span class="cstat-no" title="statement not covered" >e.setTransform(...i.transform);<span class="cstat-no" title="statement not covered" >e</span>.translate(i.x,i.y);<span class="cstat-no" title="statement not covered" >i</span>.addToPath(e,i.fontSize)}<span class="cstat-no" title="statement not covered" ></span>e</span>.restore();<span class="cstat-no" title="statement not covered" >e</span>.clip();<span class="cstat-no" title="statement not covered" >e</span>.beginPath();<span class="cstat-no" title="statement not covered" >d</span>elete this.pendingTextPaths}</span>else <span class="cstat-no" title="statement not covered" >e.beginPath()}<span class="fstat-no" title="function not covered" ></span></span>se</span>tCharSpacing(t){<span class="cstat-no" title="statement not covered" >this.current.charSpacing=t}<span class="fstat-no" title="function not covered" ></span>se</span>tWordSpacing(t){<span class="cstat-no" title="statement not covered" >this.current.wordSpacing=t}<span class="fstat-no" title="function not covered" ></span>se</span>tHScale(t){<span class="cstat-no" title="statement not covered" >this.current.textHScale=t/100}<span class="fstat-no" title="function not covered" ></span>se</span>tLeading(t){<span class="cstat-no" title="statement not covered" >this.current.leading=-t}<span class="fstat-no" title="function not covered" ></span>se</span>tFont(t,e){const i=<span class="cstat-no" title="statement not covered" >this.commonObjs.get(t),</span>n=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >throw new Error(`Can't find font for ${t}`);<span class="cstat-no" title="statement not covered" >n</span></span>.fontMatrix=i.fontMatrix||s.FONT_IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >0</span>!==n.fontMatrix[0]&amp;&amp;0!==n.fontMatrix[3]||(0,s.warn)("Invalid font matrix for font "+t);<span class="cstat-no" title="statement not covered" >i</span>f(e&lt;0){<span class="cstat-no" title="statement not covered" >e=-e;<span class="cstat-no" title="statement not covered" >n</span>.fontDirection=-1}</span>else <span class="cstat-no" title="statement not covered" >n.fontDirection=1;<span class="cstat-no" title="statement not covered" >t</span></span>his.current.font=i;<span class="cstat-no" title="statement not covered" >t</span>his.current.fontSize=e;<span class="cstat-no" title="statement not covered" >i</span>f(i.isType3Font)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >i.loadedName||"sans-serif",</span>r=<span class="cstat-no" title="statement not covered" >i.systemFontInfo?.css||`"${a}", ${i.fallbackName}`;</span>let o=<span class="cstat-no" title="statement not covered" >"normal";<span class="cstat-no" title="statement not covered" ></span>i.black?o="900":i.bold&amp;&amp;(o="bold");c</span>onst l=<span class="cstat-no" title="statement not covered" >i.italic?"italic":"normal";</span>let c=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>e&lt;16?c=16:e&gt;100&amp;&amp;(c=100);<span class="cstat-no" title="statement not covered" >t</span>his.current.fontSizeScale=e/c;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.font=`${l} ${o} ${c}px ${r}`}<span class="fstat-no" title="function not covered" ></span>se</span>tTextRenderingMode(t){<span class="cstat-no" title="statement not covered" >this.current.textRenderingMode=t}<span class="fstat-no" title="function not covered" ></span>se</span>tTextRise(t){<span class="cstat-no" title="statement not covered" >this.current.textRise=t}<span class="fstat-no" title="function not covered" ></span>mo</span>veText(t,e){<span class="cstat-no" title="statement not covered" >this.current.x=this.current.lineX+=t;<span class="cstat-no" title="statement not covered" >t</span>his.current.y=this.current.lineY+=e}<span class="fstat-no" title="function not covered" ></span>se</span>tLeadingMoveText(t,e){<span class="cstat-no" title="statement not covered" >this.setLeading(-e);<span class="cstat-no" title="statement not covered" >t</span>his.moveText(t,e)}<span class="fstat-no" title="function not covered" ></span>se</span>tTextMatrix(t,e,i,s,n,a){<span class="cstat-no" title="statement not covered" >this.current.textMatrix=[t,e,i,s,n,a];<span class="cstat-no" title="statement not covered" >t</span>his.current.textMatrixScale=Math.hypot(t,e);<span class="cstat-no" title="statement not covered" >t</span>his.current.x=this.current.lineX=0;<span class="cstat-no" title="statement not covered" >t</span>his.current.y=this.current.lineY=0}<span class="fstat-no" title="function not covered" ></span>ne</span>xtLine(){<span class="cstat-no" title="statement not covered" >this.moveText(0,this.current.leading)}<span class="fstat-no" title="function not covered" ></span>pa</span>intChar(t,e,i,a){const r=<span class="cstat-no" title="statement not covered" >this.ctx,</span>o=<span class="cstat-no" title="statement not covered" >this.current,</span>l=<span class="cstat-no" title="statement not covered" >o.font,</span>c=<span class="cstat-no" title="statement not covered" >o.textRenderingMode,</span>h=<span class="cstat-no" title="statement not covered" >o.fontSize/o.fontSizeScale,</span>d=<span class="cstat-no" title="statement not covered" >c&amp;s.TextRenderingMode.FILL_STROKE_MASK,</span>u=<span class="cstat-no" title="statement not covered" >!!(c&amp;s.TextRenderingMode.ADD_TO_PATH_FLAG),</span>p=<span class="cstat-no" title="statement not covered" >o.patternFill&amp;&amp;!l.missingFile;</span>let g;<span class="cstat-no" title="statement not covered" >(l.disableFontFace||u||p)&amp;&amp;(g=l.getPathGenerator(this.commonObjs,t));<span class="cstat-no" title="statement not covered" >i</span>f(l.disableFontFace||p){<span class="cstat-no" title="statement not covered" >r.save();<span class="cstat-no" title="statement not covered" >r</span>.translate(e,i);<span class="cstat-no" title="statement not covered" >r</span>.beginPath();<span class="cstat-no" title="statement not covered" >g</span>(r,h);<span class="cstat-no" title="statement not covered" >a</span>&amp;&amp;r.setTransform(...a);<span class="cstat-no" title="statement not covered" >d</span>!==s.TextRenderingMode.FILL&amp;&amp;d!==s.TextRenderingMode.FILL_STROKE||r.fill();<span class="cstat-no" title="statement not covered" >d</span>!==s.TextRenderingMode.STROKE&amp;&amp;d!==s.TextRenderingMode.FILL_STROKE||r.stroke();<span class="cstat-no" title="statement not covered" >r</span>.restore()}</span>else{<span class="cstat-no" title="statement not covered" >d!==s.TextRenderingMode.FILL&amp;&amp;d!==s.TextRenderingMode.FILL_STROKE||r.fillText(t,e,i);<span class="cstat-no" title="statement not covered" >d</span>!==s.TextRenderingMode.STROKE&amp;&amp;d!==s.TextRenderingMode.FILL_STROKE||r.strokeText(t,e,i)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u){<span class="cstat-no" title="statement not covered" >(this.pendingTextPaths||=[]).push({transform:(0,n.getCurrentTransform)(r),x:e,y:i,fontSize:h,addToPath:g})}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t isFontSubpixelAAEnabled(){const{context:t}=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled",10,10);<span class="cstat-no" title="statement not covered" ></span>t.scale(1.5,1);<span class="cstat-no" title="statement not covered" >t</span>.fillText("I",0,10);c</span>onst e=<span class="cstat-no" title="statement not covered" >t.getImageData(0,0,10,10).data;</span>let i=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >3;</span>t&lt;e.length;t+=4)<span class="cstat-no" title="statement not covered" >if(e[t]&gt;0&amp;&amp;e[t]&lt;255){<span class="cstat-no" title="statement not covered" >i=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn(0,s.shadow)(this,"isFontSubpixelAAEnabled",i)}<span class="fstat-no" title="function not covered" ></span>sh</span>owText(t){const e=<span class="cstat-no" title="statement not covered" >this.current,</span>i=<span class="cstat-no" title="statement not covered" >e.font;<span class="cstat-no" title="statement not covered" ></span>if(i.isType3Font)<span class="cstat-no" title="statement not covered" >return this.showType3Text(t);c</span></span>onst r=<span class="cstat-no" title="statement not covered" >e.fontSize;<span class="cstat-no" title="statement not covered" ></span>if(0===r)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >this.ctx,</span>l=<span class="cstat-no" title="statement not covered" >e.fontSizeScale,</span>c=<span class="cstat-no" title="statement not covered" >e.charSpacing,</span>h=<span class="cstat-no" title="statement not covered" >e.wordSpacing,</span>d=<span class="cstat-no" title="statement not covered" >e.fontDirection,</span>u=<span class="cstat-no" title="statement not covered" >e.textHScale*d,</span>p=<span class="cstat-no" title="statement not covered" >t.length,</span>g=<span class="cstat-no" title="statement not covered" >i.vertical,</span>m=<span class="cstat-no" title="statement not covered" >g?1:-1,</span>f=<span class="cstat-no" title="statement not covered" >i.defaultVMetrics,</span>b=<span class="cstat-no" title="statement not covered" >r*e.fontMatrix[0],</span>A=<span class="cstat-no" title="statement not covered" >e.textRenderingMode===s.TextRenderingMode.FILL&amp;&amp;!i.disableFontFace&amp;&amp;!e.patternFill;<span class="cstat-no" title="statement not covered" ></span>o.save();<span class="cstat-no" title="statement not covered" >o</span>.transform(...e.textMatrix);<span class="cstat-no" title="statement not covered" >o</span>.translate(e.x,e.y+e.textRise);<span class="cstat-no" title="statement not covered" >d</span>&gt;0?o.scale(u,-1):o.scale(u,1);l</span>et _;<span class="cstat-no" title="statement not covered" >if(e.patternFill){<span class="cstat-no" title="statement not covered" >o.save();c</span>onst t=<span class="cstat-no" title="statement not covered" >e.fillColor.getPattern(o,this,(0,n.getCurrentTransformInverse)(o),a.PathType.FILL);<span class="cstat-no" title="statement not covered" ></span>_=(0,n.getCurrentTransform)(o);<span class="cstat-no" title="statement not covered" >o</span>.restore();<span class="cstat-no" title="statement not covered" >o</span>.fillStyle=t}</span>l</span>et v=<span class="cstat-no" title="statement not covered" >e.lineWidth;</span>const y=<span class="cstat-no" title="statement not covered" >e.textMatrixScale;<span class="cstat-no" title="statement not covered" ></span>if(0===y||0===v){const t=<span class="cstat-no" title="statement not covered" >e.textRenderingMode&amp;s.TextRenderingMode.FILL_STROKE_MASK;<span class="cstat-no" title="statement not covered" ></span>t!==s.TextRenderingMode.STROKE&amp;&amp;t!==s.TextRenderingMode.FILL_STROKE||(v=this.getSinglePixelWidth())}</span>else <span class="cstat-no" title="statement not covered" >v/=y;<span class="cstat-no" title="statement not covered" >i</span></span>f(1!==l){<span class="cstat-no" title="statement not covered" >o.scale(l,l);<span class="cstat-no" title="statement not covered" >v</span>/=l}<span class="cstat-no" title="statement not covered" ></span>o</span>.lineWidth=v;<span class="cstat-no" title="statement not covered" >i</span>f(i.isInvalidPDFjsFont){const i=<span class="cstat-no" title="statement not covered" >[];</span>let s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const e of t){<span class="cstat-no" title="statement not covered" >i.push(e.unicode);<span class="cstat-no" title="statement not covered" >s</span>+=e.width}<span class="cstat-no" title="statement not covered" ></span>o</span>.fillText(i.join(""),0,0);<span class="cstat-no" title="statement not covered" >e</span>.x+=s*b*u;<span class="cstat-no" title="statement not covered" >o</span>.restore();<span class="cstat-no" title="statement not covered" >t</span>his.compose();<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>l</span>et S,E=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(S=0;S&lt;p;++S){const e=<span class="cstat-no" title="statement not covered" >t[S];<span class="cstat-no" title="statement not covered" ></span>if("number"==typeof e){<span class="cstat-no" title="statement not covered" >E+=m*e*r/1e3;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et s=<span class="cstat-no" title="statement not covered" >!1;</span>const n=<span class="cstat-no" title="statement not covered" >(e.isSpace?h:0)+c,</span>a=<span class="cstat-no" title="statement not covered" >e.fontChar,</span>u=<span class="cstat-no" title="statement not covered" >e.accent;</span>let p,v,y=<span class="cstat-no" title="statement not covered" >e.width;<span class="cstat-no" title="statement not covered" ></span>if(g){const t=<span class="cstat-no" title="statement not covered" >e.vmetric||f,</span>i=<span class="cstat-no" title="statement not covered" >-(e.vmetric?t[1]:.5*y)*b,</span>s=<span class="cstat-no" title="statement not covered" >t[2]*b;<span class="cstat-no" title="statement not covered" ></span>y=t?-t[0]:y;<span class="cstat-no" title="statement not covered" >p</span>=i/l;<span class="cstat-no" title="statement not covered" >v</span>=(E+s)/l}</span>else{<span class="cstat-no" title="statement not covered" >p=E/l;<span class="cstat-no" title="statement not covered" >v</span>=0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i.remeasure&amp;&amp;y&gt;0){const t=<span class="cstat-no" title="statement not covered" >1e3*o.measureText(a).width/r*l;<span class="cstat-no" title="statement not covered" ></span>if(y&lt;t&amp;&amp;this.isFontSubpixelAAEnabled){const e=<span class="cstat-no" title="statement not covered" >y/t;<span class="cstat-no" title="statement not covered" ></span>s=!0;<span class="cstat-no" title="statement not covered" >o</span>.save();<span class="cstat-no" title="statement not covered" >o</span>.scale(e,1);<span class="cstat-no" title="statement not covered" >p</span>/=e}</span>else <span class="cstat-no" title="statement not covered" >y!==t&amp;&amp;(p+=(y-t)/2e3*r/l)}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(this.contentVisible&amp;&amp;(e.isInFont||i.missingFile))<span class="cstat-no" title="statement not covered" >if(A&amp;&amp;!u)<span class="cstat-no" title="statement not covered" >o.fillText(a,p,v);e</span>lse{<span class="cstat-no" title="statement not covered" >this.paintChar(a,p,v,_);<span class="cstat-no" title="statement not covered" >i</span>f(u){const t=<span class="cstat-no" title="statement not covered" >p+r*u.offset.x/l,</span>e=<span class="cstat-no" title="statement not covered" >v-r*u.offset.y/l;<span class="cstat-no" title="statement not covered" ></span>this.paintChar(u.fontChar,t,e,_)}</span>}<span class="cstat-no" title="statement not covered" ></span>E</span></span>+=g?y*b-n*d:y*b+n*d;<span class="cstat-no" title="statement not covered" >s</span>&amp;&amp;o.restore()}<span class="cstat-no" title="statement not covered" ></span>g</span>?e.y-=E:e.x+=E*u;<span class="cstat-no" title="statement not covered" >o</span>.restore();<span class="cstat-no" title="statement not covered" >t</span>his.compose()}<span class="fstat-no" title="function not covered" ></span>sh</span>owType3Text(t){const e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>i=<span class="cstat-no" title="statement not covered" >this.current,</span>n=<span class="cstat-no" title="statement not covered" >i.font,</span>a=<span class="cstat-no" title="statement not covered" >i.fontSize,</span>r=<span class="cstat-no" title="statement not covered" >i.fontDirection,</span>o=<span class="cstat-no" title="statement not covered" >n.vertical?1:-1,</span>l=<span class="cstat-no" title="statement not covered" >i.charSpacing,</span>c=<span class="cstat-no" title="statement not covered" >i.wordSpacing,</span>h=<span class="cstat-no" title="statement not covered" >i.textHScale*r,</span>d=<span class="cstat-no" title="statement not covered" >i.fontMatrix||s.FONT_IDENTITY_MATRIX,</span>u=<span class="cstat-no" title="statement not covered" >t.length;</span>let p,g,m,f;<span class="cstat-no" title="statement not covered" >if(!(i.textRenderingMode===s.TextRenderingMode.INVISIBLE)&amp;&amp;0!==a){<span class="cstat-no" title="statement not covered" >this._cachedScaleForStroking[0]=-1;<span class="cstat-no" title="statement not covered" >t</span>his._cachedGetSinglePixelWidth=null;<span class="cstat-no" title="statement not covered" >e</span>.save();<span class="cstat-no" title="statement not covered" >e</span>.transform(...i.textMatrix);<span class="cstat-no" title="statement not covered" >e</span>.translate(i.x,i.y);<span class="cstat-no" title="statement not covered" >e</span>.scale(h,r);<span class="cstat-no" title="statement not covered" >f</span>or(p=0;p&lt;u;++p){<span class="cstat-no" title="statement not covered" >g=t[p];<span class="cstat-no" title="statement not covered" >i</span>f("number"==typeof g){<span class="cstat-no" title="statement not covered" >f=o*g*a/1e3;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.translate(f,0);<span class="cstat-no" title="statement not covered" >i</span>.x+=f*h;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst r=<span class="cstat-no" title="statement not covered" >(g.isSpace?c:0)+l,</span>u=<span class="cstat-no" title="statement not covered" >n.charProcOperatorList[g.operatorListId];<span class="cstat-no" title="statement not covered" ></span>if(!u){<span class="cstat-no" title="statement not covered" >(0,s.warn)(`Type3 character "${g.operatorListId}" is not available.`);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.contentVisible){<span class="cstat-no" title="statement not covered" >this.processingType3=g;<span class="cstat-no" title="statement not covered" >t</span>his.save();<span class="cstat-no" title="statement not covered" >e</span>.scale(a,a);<span class="cstat-no" title="statement not covered" >e</span>.transform(...d);<span class="cstat-no" title="statement not covered" >t</span>his.executeOperatorList(u);<span class="cstat-no" title="statement not covered" >t</span>his.restore()}<span class="cstat-no" title="statement not covered" ></span>m</span>=s.Util.applyTransform([g.width,0],d)[0]*a+r;<span class="cstat-no" title="statement not covered" >e</span>.translate(m,0);<span class="cstat-no" title="statement not covered" >i</span>.x+=m*h}<span class="cstat-no" title="statement not covered" ></span>e</span>.restore();<span class="cstat-no" title="statement not covered" >t</span>his.processingType3=null}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tCharWidth(t,e){}<span class="fstat-no" title="function not covered" >se</span>tCharWidthAndBounds(t,e,i,s,n,a){<span class="cstat-no" title="statement not covered" >this.ctx.rect(i,s,n-i,a-s);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.clip();<span class="cstat-no" title="statement not covered" >t</span>his.endPath()}<span class="fstat-no" title="function not covered" ></span>ge</span>tColorN_Pattern(t){let e;<span class="cstat-no" title="statement not covered" >if("TilingPattern"===t[0]){const i=<span class="cstat-no" title="statement not covered" >t[1],</span>s=<span class="cstat-no" title="statement not covered" >this.baseTransform||(0,n.getCurrentTransform)(this.ctx),</span>r=<span class="cstat-no" title="statement not covered" >{createCanvasGraphics:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >new CanvasGraphics(t,this.commonObjs,this.objs,this.canvasFactory,this.filterFactory,{optionalContentConfig:this.optionalContentConfig,markedContentStack:this.markedContentStack})}</span>;<span class="cstat-no" title="statement not covered" ></span>e=new a.TilingPattern(t,i,this.ctx,r,s)}</span>else <span class="cstat-no" title="statement not covered" >e=this._getPattern(t[1],t[2]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>se</span>tStrokeColorN(){<span class="cstat-no" title="statement not covered" >this.current.strokeColor=this.getColorN_Pattern(arguments)}<span class="fstat-no" title="function not covered" ></span>se</span>tFillColorN(){<span class="cstat-no" title="statement not covered" >this.current.fillColor=this.getColorN_Pattern(arguments);<span class="cstat-no" title="statement not covered" >t</span>his.current.patternFill=!0}<span class="fstat-no" title="function not covered" ></span>se</span>tStrokeRGBColor(t,e,i){const n=<span class="cstat-no" title="statement not covered" >s.Util.makeHexColor(t,e,i);<span class="cstat-no" title="statement not covered" ></span>this.ctx.strokeStyle=n;<span class="cstat-no" title="statement not covered" >t</span>his.current.strokeColor=n}<span class="fstat-no" title="function not covered" ></span>se</span>tFillRGBColor(t,e,i){const n=<span class="cstat-no" title="statement not covered" >s.Util.makeHexColor(t,e,i);<span class="cstat-no" title="statement not covered" ></span>this.ctx.fillStyle=n;<span class="cstat-no" title="statement not covered" >t</span>his.current.fillColor=n;<span class="cstat-no" title="statement not covered" >t</span>his.current.patternFill=!1}<span class="fstat-no" title="function not covered" ></span>_g</span>etPattern(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{let i;<span class="cstat-no" title="statement not covered" >if(this.cachedPatterns.has(t))<span class="cstat-no" title="statement not covered" >i=this.cachedPatterns.get(t);e</span>lse{<span class="cstat-no" title="statement not covered" >i=(0,a.getShadingPattern)(this.getObject(t));<span class="cstat-no" title="statement not covered" >t</span>his.cachedPatterns.set(t,i)}<span class="cstat-no" title="statement not covered" ></span>e</span>&amp;&amp;(i.matrix=e);<span class="cstat-no" title="statement not covered" >r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>sh</span>adingFill(t){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>this.save();c</span>onst i=<span class="cstat-no" title="statement not covered" >this._getPattern(t);<span class="cstat-no" title="statement not covered" ></span>e.fillStyle=i.getPattern(e,this,(0,n.getCurrentTransformInverse)(e),a.PathType.SHADING);c</span>onst r=<span class="cstat-no" title="statement not covered" >(0,n.getCurrentTransformInverse)(e);<span class="cstat-no" title="statement not covered" ></span>if(r){const{width:t,height:i}=<span class="cstat-no" title="statement not covered" >e.canvas,</span>[n,a,o,l]=<span class="cstat-no" title="statement not covered" >s.Util.getAxialAlignedBoundingBox([0,0,t,i],r);<span class="cstat-no" title="statement not covered" ></span>this.ctx.fillRect(n,a,o-n,l-a)}</span>else <span class="cstat-no" title="statement not covered" >this.ctx.fillRect(-1e10,-1e10,2e10,2e10);<span class="cstat-no" title="statement not covered" >t</span></span>his.compose(this.current.getClippedPathBoundingBox());<span class="cstat-no" title="statement not covered" >t</span>his.restore()}<span class="fstat-no" title="function not covered" ></span>be</span>ginInlineImage(){<span class="cstat-no" title="statement not covered" >(0,s.unreachable)("Should not call beginInlineImage")}<span class="fstat-no" title="function not covered" ></span>be</span>ginImageData(){<span class="cstat-no" title="statement not covered" >(0,s.unreachable)("Should not call beginImageData")}<span class="fstat-no" title="function not covered" ></span>pa</span>intFormXObjectBegin(t,e){<span class="cstat-no" title="statement not covered" >if(this.contentVisible){<span class="cstat-no" title="statement not covered" >this.save();<span class="cstat-no" title="statement not covered" >t</span>his.baseTransformStack.push(this.baseTransform);<span class="cstat-no" title="statement not covered" >A</span>rray.isArray(t)&amp;&amp;6===t.length&amp;&amp;this.transform(...t);<span class="cstat-no" title="statement not covered" >t</span>his.baseTransform=(0,n.getCurrentTransform)(this.ctx);<span class="cstat-no" title="statement not covered" >i</span>f(e){const t=<span class="cstat-no" title="statement not covered" >e[2]-e[0],</span>i=<span class="cstat-no" title="statement not covered" >e[3]-e[1];<span class="cstat-no" title="statement not covered" ></span>this.ctx.rect(e[0],e[1],t,i);<span class="cstat-no" title="statement not covered" >t</span>his.current.updateRectMinMax((0,n.getCurrentTransform)(this.ctx),e);<span class="cstat-no" title="statement not covered" >t</span>his.clip();<span class="cstat-no" title="statement not covered" >t</span>his.endPath()}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>pa</span>intFormXObjectEnd(){<span class="cstat-no" title="statement not covered" >if(this.contentVisible){<span class="cstat-no" title="statement not covered" >this.restore();<span class="cstat-no" title="statement not covered" >t</span>his.baseTransform=this.baseTransformStack.pop()}</span>}<span class="fstat-no" title="function not covered" ></span>be</span>ginGroup(t){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.save();<span class="cstat-no" title="statement not covered" >i</span>f(this.inSMaskMode){<span class="cstat-no" title="statement not covered" >this.endSMaskMode();<span class="cstat-no" title="statement not covered" >t</span>his.current.activeSMask=null}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>t.isolated||(0,s.info)("TODO: Support non-isolated groups.");<span class="cstat-no" title="statement not covered" >t</span>.knockout&amp;&amp;(0,s.warn)("Knockout groups not supported.");c</span>onst i=<span class="cstat-no" title="statement not covered" >(0,n.getCurrentTransform)(e);<span class="cstat-no" title="statement not covered" ></span>t.matrix&amp;&amp;e.transform(...t.matrix);<span class="cstat-no" title="statement not covered" >i</span>f(!t.bbox)<span class="cstat-no" title="statement not covered" >throw new Error("Bounding box is required.");l</span></span>et a=<span class="cstat-no" title="statement not covered" >s.Util.getAxialAlignedBoundingBox(t.bbox,(0,n.getCurrentTransform)(e));</span>const r=<span class="cstat-no" title="statement not covered" >[0,0,e.canvas.width,e.canvas.height];<span class="cstat-no" title="statement not covered" ></span>a=s.Util.intersect(a,r)||[0,0,0,0];c</span>onst l=<span class="cstat-no" title="statement not covered" >Math.floor(a[0]),</span>c=<span class="cstat-no" title="statement not covered" >Math.floor(a[1]);</span>let h=<span class="cstat-no" title="statement not covered" >Math.max(Math.ceil(a[2])-l,1),</span>d=<span class="cstat-no" title="statement not covered" >Math.max(Math.ceil(a[3])-c,1),</span>u=<span class="cstat-no" title="statement not covered" >1,</span>p=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>if(h&gt;o){<span class="cstat-no" title="statement not covered" >u=h/o;<span class="cstat-no" title="statement not covered" >h</span>=o}<span class="cstat-no" title="statement not covered" ></span>i</span>f(d&gt;o){<span class="cstat-no" title="statement not covered" >p=d/o;<span class="cstat-no" title="statement not covered" >d</span>=o}<span class="cstat-no" title="statement not covered" ></span>t</span>his.current.startNewPathAndClipBox([0,0,h,d]);l</span>et g=<span class="cstat-no" title="statement not covered" >"groupAt"+this.groupLevel;<span class="cstat-no" title="statement not covered" ></span>t.smask&amp;&amp;(g+="_smask_"+this.smaskCounter++%2);c</span>onst m=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas(g,h,d),</span>f=<span class="cstat-no" title="statement not covered" >m.context;<span class="cstat-no" title="statement not covered" ></span>f.scale(1/u,1/p);<span class="cstat-no" title="statement not covered" >f</span>.translate(-l,-c);<span class="cstat-no" title="statement not covered" >f</span>.transform(...i);<span class="cstat-no" title="statement not covered" >i</span>f(t.smask)<span class="cstat-no" title="statement not covered" >this.smaskStack.push({canvas:m.canvas,context:f,offsetX:l,offsetY:c,scaleX:u,scaleY:p,subtype:t.smask.subtype,backdrop:t.smask.backdrop,transferMap:t.smask.transferMap||null,startTransformInverse:null});e</span>lse{<span class="cstat-no" title="statement not covered" >e.setTransform(1,0,0,1,0,0);<span class="cstat-no" title="statement not covered" >e</span>.translate(l,c);<span class="cstat-no" title="statement not covered" >e</span>.scale(u,p);<span class="cstat-no" title="statement not covered" >e</span>.save()}<span class="cstat-no" title="statement not covered" ></span>c</span>opyCtxState(e,f);<span class="cstat-no" title="statement not covered" >t</span>his.ctx=f;<span class="cstat-no" title="statement not covered" >t</span>his.setGState([["BM","source-over"],["ca",1],["CA",1]]);<span class="cstat-no" title="statement not covered" >t</span>his.groupStack.push(e);<span class="cstat-no" title="statement not covered" >t</span>his.groupLevel++}<span class="fstat-no" title="function not covered" ></span>en</span>dGroup(t){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.groupLevel--;c</span>onst e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>i=<span class="cstat-no" title="statement not covered" >this.groupStack.pop();<span class="cstat-no" title="statement not covered" ></span>this.ctx=i;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.imageSmoothingEnabled=!1;<span class="cstat-no" title="statement not covered" >i</span>f(t.smask){<span class="cstat-no" title="statement not covered" >this.tempSMask=this.smaskStack.pop();<span class="cstat-no" title="statement not covered" >t</span>his.restore()}</span>else{<span class="cstat-no" title="statement not covered" >this.ctx.restore();c</span>onst t=<span class="cstat-no" title="statement not covered" >(0,n.getCurrentTransform)(this.ctx);<span class="cstat-no" title="statement not covered" ></span>this.restore();<span class="cstat-no" title="statement not covered" >t</span>his.ctx.save();<span class="cstat-no" title="statement not covered" >t</span>his.ctx.setTransform(...t);c</span>onst i=<span class="cstat-no" title="statement not covered" >s.Util.getAxialAlignedBoundingBox([0,0,e.canvas.width,e.canvas.height],t);<span class="cstat-no" title="statement not covered" ></span>this.ctx.drawImage(e.canvas,0,0);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.restore();<span class="cstat-no" title="statement not covered" >t</span>his.compose(i)}</span>}<span class="fstat-no" title="function not covered" ></span>be</span>ginAnnotation(t,e,i,a,r){<span class="cstat-no" title="statement not covered" >this.#se();<span class="cstat-no" title="statement not covered" >r</span>esetCtxToDefault(this.ctx);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.save();<span class="cstat-no" title="statement not covered" >t</span>his.save();<span class="cstat-no" title="statement not covered" >t</span>his.baseTransform&amp;&amp;this.ctx.setTransform(...this.baseTransform);<span class="cstat-no" title="statement not covered" >i</span>f(Array.isArray(e)&amp;&amp;4===e.length){const a=<span class="cstat-no" title="statement not covered" >e[2]-e[0],</span>o=<span class="cstat-no" title="statement not covered" >e[3]-e[1];<span class="cstat-no" title="statement not covered" ></span>if(r&amp;&amp;this.annotationCanvasMap){<span class="cstat-no" title="statement not covered" >(i=i.slice())[4]-=e[0];<span class="cstat-no" title="statement not covered" >i</span>[5]-=e[1];<span class="cstat-no" title="statement not covered" >(</span>e=e.slice())[0]=e[1]=0;<span class="cstat-no" title="statement not covered" >e</span>[2]=a;<span class="cstat-no" title="statement not covered" >e</span>[3]=o;c</span>onst[r,l]=<span class="cstat-no" title="statement not covered" >s.Util.singularValueDecompose2dScale((0,n.getCurrentTransform)(this.ctx)),</span>{viewportScale:c}=<span class="cstat-no" title="statement not covered" >this,</span>h=<span class="cstat-no" title="statement not covered" >Math.ceil(a*this.outputScaleX*c),</span>d=<span class="cstat-no" title="statement not covered" >Math.ceil(o*this.outputScaleY*c);<span class="cstat-no" title="statement not covered" ></span>this.annotationCanvas=this.canvasFactory.create(h,d);c</span>onst{canvas:u,context:p}=<span class="cstat-no" title="statement not covered" >this.annotationCanvas;<span class="cstat-no" title="statement not covered" ></span>this.annotationCanvasMap.set(t,u);<span class="cstat-no" title="statement not covered" >t</span>his.annotationCanvas.savedCtx=this.ctx;<span class="cstat-no" title="statement not covered" >t</span>his.ctx=p;<span class="cstat-no" title="statement not covered" >t</span>his.ctx.save();<span class="cstat-no" title="statement not covered" >t</span>his.ctx.setTransform(r,0,0,-l,0,o*l);<span class="cstat-no" title="statement not covered" >r</span>esetCtxToDefault(this.ctx)}</span>else{<span class="cstat-no" title="statement not covered" >resetCtxToDefault(this.ctx);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.rect(e[0],e[1],a,o);<span class="cstat-no" title="statement not covered" >t</span>his.ctx.clip();<span class="cstat-no" title="statement not covered" >t</span>his.endPath()}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.current=new CanvasExtraState(this.ctx.canvas.width,this.ctx.canvas.height);<span class="cstat-no" title="statement not covered" >t</span>his.transform(...i);<span class="cstat-no" title="statement not covered" >t</span>his.transform(...a)}<span class="fstat-no" title="function not covered" ></span>en</span>dAnnotation(){<span class="cstat-no" title="statement not covered" >if(this.annotationCanvas){<span class="cstat-no" title="statement not covered" >this.ctx.restore();<span class="cstat-no" title="statement not covered" >t</span>his.#ne();<span class="cstat-no" title="statement not covered" >t</span>his.ctx=this.annotationCanvas.savedCtx;<span class="cstat-no" title="statement not covered" >d</span>elete this.annotationCanvas.savedCtx;<span class="cstat-no" title="statement not covered" >d</span>elete this.annotationCanvas}</span>}<span class="fstat-no" title="function not covered" ></span>pa</span>intImageMaskXObject(t){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t.count;<span class="cstat-no" title="statement not covered" ></span>(t=this.getObject(t.data,t)).count=e;c</span>onst i=<span class="cstat-no" title="statement not covered" >this.ctx,</span>s=<span class="cstat-no" title="statement not covered" >this.processingType3;<span class="cstat-no" title="statement not covered" ></span>if(s){<span class="cstat-no" title="statement not covered" >void 0===s.compiled&amp;&amp;(s.compiled=function <span class="fstat-no" title="function not covered" >compileType3Glyph(</span>t){const{width:e,height:i}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(e&gt;1e3||i&gt;1e3)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >new Uint8Array([0,2,4,0,1,0,5,4,8,10,0,8,0,2,1,0]),</span>n=<span class="cstat-no" title="statement not covered" >e+1;</span>let a,r,o,l=<span class="cstat-no" title="statement not covered" >new Uint8Array(n*(i+1));</span>const c=<span class="cstat-no" title="statement not covered" >e+7&amp;-8;</span>let h=<span class="cstat-no" title="statement not covered" >new Uint8Array(c*i),</span>d=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const e of t.data){let t=<span class="cstat-no" title="statement not covered" >128;<span class="cstat-no" title="statement not covered" ></span>for(;t&gt;0;){<span class="cstat-no" title="statement not covered" >h[d++]=e&amp;t?0:255;<span class="cstat-no" title="statement not covered" >t</span>&gt;&gt;=1}</span>}</span>l</span>et u=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>d=0;<span class="cstat-no" title="statement not covered" >i</span>f(0!==h[d]){<span class="cstat-no" title="statement not covered" >l[0]=1;<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>f</span>or(r=1;r&lt;e;r++){<span class="cstat-no" title="statement not covered" >if(h[d]!==h[d+1]){<span class="cstat-no" title="statement not covered" >l[r]=h[d]?2:1;<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>d</span>++}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0!==h[d]){<span class="cstat-no" title="statement not covered" >l[r]=2;<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>f</span>or(a=1;a&lt;i;a++){<span class="cstat-no" title="statement not covered" >d=a*c;<span class="cstat-no" title="statement not covered" >o</span>=a*n;<span class="cstat-no" title="statement not covered" >i</span>f(h[d-c]!==h[d]){<span class="cstat-no" title="statement not covered" >l[o]=h[d]?1:8;<span class="cstat-no" title="statement not covered" >+</span>+u}</span>l</span>et t=<span class="cstat-no" title="statement not covered" >(h[d]?4:0)+(h[d-c]?8:0);<span class="cstat-no" title="statement not covered" ></span>for(r=1;r&lt;e;r++){<span class="cstat-no" title="statement not covered" >t=(t&gt;&gt;2)+(h[d+1]?4:0)+(h[d-c+1]?8:0);<span class="cstat-no" title="statement not covered" >i</span>f(s[t]){<span class="cstat-no" title="statement not covered" >l[o+r]=s[t];<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>d</span>++}<span class="cstat-no" title="statement not covered" ></span>i</span>f(h[d-c]!==h[d]){<span class="cstat-no" title="statement not covered" >l[o+r]=h[d]?2:4;<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u&gt;1e3)<span class="cstat-no" title="statement not covered" >return null}<span class="cstat-no" title="statement not covered" ></span></span>d</span>=c*(i-1);<span class="cstat-no" title="statement not covered" >o</span>=a*n;<span class="cstat-no" title="statement not covered" >i</span>f(0!==h[d]){<span class="cstat-no" title="statement not covered" >l[o]=8;<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>f</span>or(r=1;r&lt;e;r++){<span class="cstat-no" title="statement not covered" >if(h[d]!==h[d+1]){<span class="cstat-no" title="statement not covered" >l[o+r]=h[d]?4:8;<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>d</span>++}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0!==h[d]){<span class="cstat-no" title="statement not covered" >l[o+r]=4;<span class="cstat-no" title="statement not covered" >+</span>+u}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u&gt;1e3)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst p=<span class="cstat-no" title="statement not covered" >new Int32Array([0,n,-1,0,-n,0,0,0,1]),</span>g=<span class="cstat-no" title="statement not covered" >new Path2D;<span class="cstat-no" title="statement not covered" ></span>for(a=0;u&amp;&amp;a&lt;=i;a++){let t=<span class="cstat-no" title="statement not covered" >a*n;</span>const i=<span class="cstat-no" title="statement not covered" >t+e;<span class="cstat-no" title="statement not covered" ></span>for(;t&lt;i&amp;&amp;!l[t];)<span class="cstat-no" title="statement not covered" >t++;<span class="cstat-no" title="statement not covered" >i</span></span>f(t===i)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >g</span></span>.moveTo(t%n,a);c</span>onst s=<span class="cstat-no" title="statement not covered" >t;</span>let r=<span class="cstat-no" title="statement not covered" >l[t];<span class="cstat-no" title="statement not covered" ></span>do{const e=<span class="cstat-no" title="statement not covered" >p[r];<span class="cstat-no" title="statement not covered" ></span>do{<span class="cstat-no" title="statement not covered" >t+=e}</span>while(!l[t]);c</span>onst i=<span class="cstat-no" title="statement not covered" >l[t];<span class="cstat-no" title="statement not covered" ></span>if(5!==i&amp;&amp;10!==i){<span class="cstat-no" title="statement not covered" >r=i;<span class="cstat-no" title="statement not covered" >l</span>[t]=0}</span>else{<span class="cstat-no" title="statement not covered" >r=i&amp;51*r&gt;&gt;4;<span class="cstat-no" title="statement not covered" >l</span>[t]&amp;=r&gt;&gt;2|r&lt;&lt;2}<span class="cstat-no" title="statement not covered" ></span>g</span>.lineTo(t%n,t/n|0);<span class="cstat-no" title="statement not covered" >l</span>[t]||--u}</span>while(s!==t);<span class="cstat-no" title="statement not covered" >-</span>-a}<span class="cstat-no" title="statement not covered" ></span>h</span>=null;<span class="cstat-no" title="statement not covered" >l</span>=null;<span class="cstat-no" title="statement not covered" >r</span>eturn <span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.save();<span class="cstat-no" title="statement not covered" >t</span>.scale(1/e,-1/i);<span class="cstat-no" title="statement not covered" >t</span>.translate(0,-i);<span class="cstat-no" title="statement not covered" >t</span>.fill(g);<span class="cstat-no" title="statement not covered" >t</span>.beginPath();<span class="cstat-no" title="statement not covered" >t</span>.restore()}</span>}</span>(t));<span class="cstat-no" title="statement not covered" >i</span>f(s.compiled){<span class="cstat-no" title="statement not covered" >s.compiled(i);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}</span>c</span>onst n=<span class="cstat-no" title="statement not covered" >this._createMaskCanvas(t),</span>a=<span class="cstat-no" title="statement not covered" >n.canvas;<span class="cstat-no" title="statement not covered" ></span>i.save();<span class="cstat-no" title="statement not covered" >i</span>.setTransform(1,0,0,1,0,0);<span class="cstat-no" title="statement not covered" >i</span>.drawImage(a,n.offsetX,n.offsetY);<span class="cstat-no" title="statement not covered" >i</span>.restore();<span class="cstat-no" title="statement not covered" >t</span>his.compose()}<span class="fstat-no" title="function not covered" ></span>pa</span>intImageMaskXObjectRepeat(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>a=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r,o){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>=this.getObject(t.data,t);c</span>onst l=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>l.save();c</span>onst c=<span class="cstat-no" title="statement not covered" >(0,n.getCurrentTransform)(l);<span class="cstat-no" title="statement not covered" ></span>l.transform(e,i,a,r,0,0);c</span>onst h=<span class="cstat-no" title="statement not covered" >this._createMaskCanvas(t);<span class="cstat-no" title="statement not covered" ></span>l.setTransform(1,0,0,1,h.offsetX-c[4],h.offsetY-c[5]);<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >o.length;</span>t&lt;n;t+=2){const n=<span class="cstat-no" title="statement not covered" >s.Util.transform(c,[e,i,a,r,o[t],o[t+1]]),</span>[d,u]=<span class="cstat-no" title="statement not covered" >s.Util.applyTransform([0,0],n);<span class="cstat-no" title="statement not covered" ></span>l.drawImage(h.canvas,d,u)}<span class="cstat-no" title="statement not covered" ></span>l</span>.restore();<span class="cstat-no" title="statement not covered" >t</span>his.compose()}<span class="fstat-no" title="function not covered" ></span>pa</span>intImageMaskXObjectGroup(t){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>i=<span class="cstat-no" title="statement not covered" >this.current.fillColor,</span>s=<span class="cstat-no" title="statement not covered" >this.current.patternFill;<span class="cstat-no" title="statement not covered" ></span>for(const r of t){const{data:t,width:o,height:l,transform:c}=<span class="cstat-no" title="statement not covered" >r,</span>h=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas("maskCanvas",o,l),</span>d=<span class="cstat-no" title="statement not covered" >h.context;<span class="cstat-no" title="statement not covered" ></span>d.save();<span class="cstat-no" title="statement not covered" >p</span>utBinaryImageMask(d,this.getObject(t,r));<span class="cstat-no" title="statement not covered" >d</span>.globalCompositeOperation="source-in";<span class="cstat-no" title="statement not covered" >d</span>.fillStyle=s?i.getPattern(d,this,(0,n.getCurrentTransformInverse)(e),a.PathType.FILL):i;<span class="cstat-no" title="statement not covered" >d</span>.fillRect(0,0,o,l);<span class="cstat-no" title="statement not covered" >d</span>.restore();<span class="cstat-no" title="statement not covered" >e</span>.save();<span class="cstat-no" title="statement not covered" >e</span>.transform(...c);<span class="cstat-no" title="statement not covered" >e</span>.scale(1,-1);<span class="cstat-no" title="statement not covered" >d</span>rawImageAtIntegerCoords(e,h.canvas,0,0,o,l,0,-1,1,1);<span class="cstat-no" title="statement not covered" >e</span>.restore()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.compose()}<span class="fstat-no" title="function not covered" ></span>pa</span>intImageXObject(t){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.getObject(t);<span class="cstat-no" title="statement not covered" ></span>e?this.paintInlineImageXObject(e):(0,s.warn)("Dependent image isn't ready yet")}<span class="fstat-no" title="function not covered" ></span>pa</span>intImageXObjectRepeat(t,e,i,n){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >this.getObject(t);<span class="cstat-no" title="statement not covered" ></span>if(!a){<span class="cstat-no" title="statement not covered" >(0,s.warn)("Dependent image isn't ready yet");<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst r=<span class="cstat-no" title="statement not covered" >a.width,</span>o=<span class="cstat-no" title="statement not covered" >a.height,</span>l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >n.length;</span>t&lt;s;t+=2)<span class="cstat-no" title="statement not covered" >l.push({transform:[e,0,0,i,n[t],n[t+1]],x:0,y:0,w:r,h:o});<span class="cstat-no" title="statement not covered" >t</span></span>his.paintInlineImageXObjectGroup(a,l)}<span class="fstat-no" title="function not covered" ></span>ap</span>plyTransferMapsToCanvas(t){<span class="cstat-no" title="statement not covered" >if("none"!==this.current.transferMaps){<span class="cstat-no" title="statement not covered" >t.filter=this.current.transferMaps;<span class="cstat-no" title="statement not covered" >t</span>.drawImage(t.canvas,0,0);<span class="cstat-no" title="statement not covered" >t</span>.filter="none"}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.canvas}<span class="fstat-no" title="function not covered" ></span>ap</span>plyTransferMapsToBitmap(t){<span class="cstat-no" title="statement not covered" >if("none"===this.current.transferMaps)<span class="cstat-no" title="statement not covered" >return t.bitmap;c</span></span>onst{bitmap:e,width:i,height:s}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas("inlineImage",i,s),</span>a=<span class="cstat-no" title="statement not covered" >n.context;<span class="cstat-no" title="statement not covered" ></span>a.filter=this.current.transferMaps;<span class="cstat-no" title="statement not covered" >a</span>.drawImage(e,0,0);<span class="cstat-no" title="statement not covered" >a</span>.filter="none";<span class="cstat-no" title="statement not covered" >r</span>eturn n.canvas}<span class="fstat-no" title="function not covered" ></span>pa</span>intInlineImageXObject(t){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t.width,</span>i=<span class="cstat-no" title="statement not covered" >t.height,</span>a=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>this.save();<span class="cstat-no" title="statement not covered" >i</span>f(!s.isNodeJS){const{filter:t}=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>"none"!==t&amp;&amp;""!==t&amp;&amp;(a.filter="none")}<span class="cstat-no" title="statement not covered" ></span>a</span>.scale(1/e,-1/i);l</span>et r;<span class="cstat-no" title="statement not covered" >if(t.bitmap)<span class="cstat-no" title="statement not covered" >r=this.applyTransferMapsToBitmap(t);e</span>lse <span class="cstat-no" title="statement not covered" >if("function"==typeof HTMLElement&amp;&amp;t instanceof HTMLElement||!t.data)<span class="cstat-no" title="statement not covered" >r=t;e</span>lse{const s=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas("inlineImage",e,i).context;<span class="cstat-no" title="statement not covered" ></span>putBinaryImageData(s,t);<span class="cstat-no" title="statement not covered" >r</span>=this.applyTransferMapsToCanvas(s)}</span>c</span></span>onst o=<span class="cstat-no" title="statement not covered" >this._scaleImage(r,(0,n.getCurrentTransformInverse)(a));<span class="cstat-no" title="statement not covered" ></span>a.imageSmoothingEnabled=getImageSmoothingEnabled((0,n.getCurrentTransform)(a),t.interpolate);<span class="cstat-no" title="statement not covered" >d</span>rawImageAtIntegerCoords(a,o.img,0,0,o.paintWidth,o.paintHeight,0,-i,e,i);<span class="cstat-no" title="statement not covered" >t</span>his.compose();<span class="cstat-no" title="statement not covered" >t</span>his.restore()}<span class="fstat-no" title="function not covered" ></span>pa</span>intInlineImageXObjectGroup(t,e){<span class="cstat-no" title="statement not covered" >if(!this.contentVisible)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.ctx;</span>let s;<span class="cstat-no" title="statement not covered" >if(t.bitmap)<span class="cstat-no" title="statement not covered" >s=t.bitmap;e</span>lse{const e=<span class="cstat-no" title="statement not covered" >t.width,</span>i=<span class="cstat-no" title="statement not covered" >t.height,</span>n=<span class="cstat-no" title="statement not covered" >this.cachedCanvases.getCanvas("inlineImage",e,i).context;<span class="cstat-no" title="statement not covered" ></span>putBinaryImageData(n,t);<span class="cstat-no" title="statement not covered" >s</span>=this.applyTransferMapsToCanvas(n)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const t of e){<span class="cstat-no" title="statement not covered" >i.save();<span class="cstat-no" title="statement not covered" >i</span>.transform(...t.transform);<span class="cstat-no" title="statement not covered" >i</span>.scale(1,-1);<span class="cstat-no" title="statement not covered" >d</span>rawImageAtIntegerCoords(i,s,t.x,t.y,t.w,t.h,0,-1,1,1);<span class="cstat-no" title="statement not covered" >i</span>.restore()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.compose()}<span class="fstat-no" title="function not covered" ></span>pa</span>intSolidColorImageMask(){<span class="cstat-no" title="statement not covered" >if(this.contentVisible){<span class="cstat-no" title="statement not covered" >this.ctx.fillRect(0,0,1,1);<span class="cstat-no" title="statement not covered" >t</span>his.compose()}</span>}<span class="fstat-no" title="function not covered" ></span>ma</span>rkPoint(t){}<span class="fstat-no" title="function not covered" >ma</span>rkPointProps(t,e){}<span class="fstat-no" title="function not covered" >be</span>ginMarkedContent(t){<span class="cstat-no" title="statement not covered" >this.markedContentStack.push({visible:!0})}<span class="fstat-no" title="function not covered" ></span>be</span>ginMarkedContentProps(t,e){<span class="cstat-no" title="statement not covered" >"OC"===t?this.markedContentStack.push({visible:this.optionalContentConfig.isVisible(e)}):this.markedContentStack.push({visible:!0});<span class="cstat-no" title="statement not covered" >t</span>his.contentVisible=this.isContentVisible()}<span class="fstat-no" title="function not covered" ></span>en</span>dMarkedContent(){<span class="cstat-no" title="statement not covered" >this.markedContentStack.pop();<span class="cstat-no" title="statement not covered" >t</span>his.contentVisible=this.isContentVisible()}<span class="fstat-no" title="function not covered" ></span>be</span>ginCompat(){}<span class="fstat-no" title="function not covered" >en</span>dCompat(){}<span class="fstat-no" title="function not covered" >co</span>nsumePath(t){const e=<span class="cstat-no" title="statement not covered" >this.current.isEmptyClip();<span class="cstat-no" title="statement not covered" ></span>this.pendingClip&amp;&amp;this.current.updateClipFromPath();<span class="cstat-no" title="statement not covered" >t</span>his.pendingClip||this.compose(t);c</span>onst i=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>if(this.pendingClip){<span class="cstat-no" title="statement not covered" >e||(this.pendingClip===u?i.clip("evenodd"):i.clip());<span class="cstat-no" title="statement not covered" >t</span>his.pendingClip=null}<span class="cstat-no" title="statement not covered" ></span>t</span>his.current.startNewPathAndClipBox(this.current.clipBox);<span class="cstat-no" title="statement not covered" >i</span>.beginPath()}<span class="fstat-no" title="function not covered" ></span>ge</span>tSinglePixelWidth(){<span class="cstat-no" title="statement not covered" >if(!this._cachedGetSinglePixelWidth){const t=<span class="cstat-no" title="statement not covered" >(0,n.getCurrentTransform)(this.ctx);<span class="cstat-no" title="statement not covered" ></span>if(0===t[1]&amp;&amp;0===t[2])<span class="cstat-no" title="statement not covered" >this._cachedGetSinglePixelWidth=1/Math.min(Math.abs(t[0]),Math.abs(t[3]));e</span>lse{const e=<span class="cstat-no" title="statement not covered" >Math.abs(t[0]*t[3]-t[2]*t[1]),</span>i=<span class="cstat-no" title="statement not covered" >Math.hypot(t[0],t[2]),</span>s=<span class="cstat-no" title="statement not covered" >Math.hypot(t[1],t[3]);<span class="cstat-no" title="statement not covered" ></span>this._cachedGetSinglePixelWidth=Math.max(i,s)/e}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._cachedGetSinglePixelWidth}<span class="fstat-no" title="function not covered" ></span>ge</span>tScaleForStroking(){<span class="cstat-no" title="statement not covered" >if(-1===this._cachedScaleForStroking[0]){const{lineWidth:t}=<span class="cstat-no" title="statement not covered" >this.current,</span>{a:e,b:i,c:s,d:n}=<span class="cstat-no" title="statement not covered" >this.ctx.getTransform();</span>let a,r;<span class="cstat-no" title="statement not covered" >if(0===i&amp;&amp;0===s){const i=<span class="cstat-no" title="statement not covered" >Math.abs(e),</span>s=<span class="cstat-no" title="statement not covered" >Math.abs(n);<span class="cstat-no" title="statement not covered" ></span>if(i===s)<span class="cstat-no" title="statement not covered" >if(0===t)<span class="cstat-no" title="statement not covered" >a=r=1/i;e</span>lse{const e=<span class="cstat-no" title="statement not covered" >i*t;<span class="cstat-no" title="statement not covered" ></span>a=r=e&lt;1?1/e:1}</span>e</span>lse <span class="cstat-no" title="statement not covered" >if(0===t){<span class="cstat-no" title="statement not covered" >a=1/i;<span class="cstat-no" title="statement not covered" >r</span>=1/s}</span>else{const e=<span class="cstat-no" title="statement not covered" >i*t,</span>n=<span class="cstat-no" title="statement not covered" >s*t;<span class="cstat-no" title="statement not covered" ></span>a=e&lt;1?1/e:1;<span class="cstat-no" title="statement not covered" >r</span>=n&lt;1?1/n:1}</span>}</span></span>else{const o=<span class="cstat-no" title="statement not covered" >Math.abs(e*n-i*s),</span>l=<span class="cstat-no" title="statement not covered" >Math.hypot(e,i),</span>c=<span class="cstat-no" title="statement not covered" >Math.hypot(s,n);<span class="cstat-no" title="statement not covered" ></span>if(0===t){<span class="cstat-no" title="statement not covered" >a=c/o;<span class="cstat-no" title="statement not covered" >r</span>=l/o}</span>else{const e=<span class="cstat-no" title="statement not covered" >t*o;<span class="cstat-no" title="statement not covered" ></span>a=c&gt;e?c/e:1;<span class="cstat-no" title="statement not covered" >r</span>=l&gt;e?l/e:1}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his._cachedScaleForStroking[0]=a;<span class="cstat-no" title="statement not covered" >t</span>his._cachedScaleForStroking[1]=r}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._cachedScaleForStroking}<span class="fstat-no" title="function not covered" ></span>re</span>scaleAndStroke(t){const{ctx:e}=<span class="cstat-no" title="statement not covered" >this,</span>{lineWidth:i}=<span class="cstat-no" title="statement not covered" >this.current,</span>[s,n]=<span class="cstat-no" title="statement not covered" >this.getScaleForStroking();<span class="cstat-no" title="statement not covered" ></span>e.lineWidth=i||1;<span class="cstat-no" title="statement not covered" >i</span>f(1===s&amp;&amp;1===n){<span class="cstat-no" title="statement not covered" >e.stroke();<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst a=<span class="cstat-no" title="statement not covered" >e.getLineDash();<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;e.save();<span class="cstat-no" title="statement not covered" >e</span>.scale(s,n);<span class="cstat-no" title="statement not covered" >i</span>f(a.length&gt;0){const t=<span class="cstat-no" title="statement not covered" >Math.max(s,n);<span class="cstat-no" title="statement not covered" ></span>e.setLineDash(a.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e/t)</span>));<span class="cstat-no" title="statement not covered" >e</span>.lineDashOffset/=t}<span class="cstat-no" title="statement not covered" ></span>e</span>.stroke();<span class="cstat-no" title="statement not covered" >t</span>&amp;&amp;e.restore()}<span class="fstat-no" title="function not covered" ></span>is</span>ContentVisible(){<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >this.markedContentStack.length-1;</span>t&gt;=0;t--)<span class="cstat-no" title="statement not covered" >if(!this.markedContentStack[t].visible)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>}<span class="cstat-no" title="statement not covered" >e.CanvasGraphics=CanvasGraphics;<span class="cstat-no" title="statement not covered" >f</span>or(const t in s.OPS)<span class="cstat-no" title="statement not covered" >void 0!==CanvasGraphics.prototype[t]&amp;&amp;(CanvasGraphics.prototype[s.OPS[t]]=CanvasGraphics.prototype[t])}</span></span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.TilingPattern=e.PathType=void 0;<span class="cstat-no" title="statement not covered" >e</span>.getShadingPattern=function <span class="fstat-no" title="function not covered" >getShadingPattern(</span>t){<span class="cstat-no" title="statement not covered" >switch(t[0]){case"RadialAxial":<span class="cstat-no" title="statement not covered" >return new RadialAxialShadingPattern(t);c</span>ase"Mesh":<span class="cstat-no" title="statement not covered" >return new MeshShadingPattern(t);c</span>ase"Dummy":<span class="cstat-no" title="statement not covered" >return new DummyShadingPattern}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new Error(`Unknown IR type: ${t[0]}`)}</span>;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(6);</span>const a=<span class="cstat-no" title="statement not covered" >{FILL:"Fill",STROKE:"Stroke",SHADING:"Shading"};<span class="cstat-no" title="statement not covered" ></span>e.PathType=a;f</span>unction <span class="fstat-no" title="function not covered" >applyBoundingBox(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >e[2]-e[0],</span>s=<span class="cstat-no" title="statement not covered" >e[3]-e[1],</span>n=<span class="cstat-no" title="statement not covered" >new Path2D;<span class="cstat-no" title="statement not covered" ></span>n.rect(e[0],e[1],i,s);<span class="cstat-no" title="statement not covered" >t</span>.clip(n)}</span>class BaseShadingPattern{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.constructor===BaseShadingPattern&amp;&amp;(0,s.unreachable)("Cannot initialize BaseShadingPattern.")}<span class="fstat-no" title="function not covered" ></span>ge</span>tPattern(){<span class="cstat-no" title="statement not covered" >(0,s.unreachable)("Abstract method `getPattern` called.")}</span>}class RadialAxialShadingPattern extends BaseShadingPattern{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._type=t[1];<span class="cstat-no" title="statement not covered" >t</span>his._bbox=t[2];<span class="cstat-no" title="statement not covered" >t</span>his._colorStops=t[3];<span class="cstat-no" title="statement not covered" >t</span>his._p0=t[4];<span class="cstat-no" title="statement not covered" >t</span>his._p1=t[5];<span class="cstat-no" title="statement not covered" >t</span>his._r0=t[6];<span class="cstat-no" title="statement not covered" >t</span>his._r1=t[7];<span class="cstat-no" title="statement not covered" >t</span>his.matrix=null}<span class="fstat-no" title="function not covered" ></span>_c</span>reateGradient(t){let e;<span class="cstat-no" title="statement not covered" >"axial"===this._type?e=t.createLinearGradient(this._p0[0],this._p0[1],this._p1[0],this._p1[1]):"radial"===this._type&amp;&amp;(e=t.createRadialGradient(this._p0[0],this._p0[1],this._r0,this._p1[0],this._p1[1],this._r1));<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._colorStops)<span class="cstat-no" title="statement not covered" >e.addColorStop(t[0],t[1]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>ge</span>tPattern(t,e,i,r){let o;<span class="cstat-no" title="statement not covered" >if(r===a.STROKE||r===a.FILL){const a=<span class="cstat-no" title="statement not covered" >e.current.getClippedPathBoundingBox(r,(0,n.getCurrentTransform)(t))||[0,0,0,0],</span>l=<span class="cstat-no" title="statement not covered" >Math.ceil(a[2]-a[0])||1,</span>c=<span class="cstat-no" title="statement not covered" >Math.ceil(a[3]-a[1])||1,</span>h=<span class="cstat-no" title="statement not covered" >e.cachedCanvases.getCanvas("pattern",l,c,!0),</span>d=<span class="cstat-no" title="statement not covered" >h.context;<span class="cstat-no" title="statement not covered" ></span>d.clearRect(0,0,d.canvas.width,d.canvas.height);<span class="cstat-no" title="statement not covered" >d</span>.beginPath();<span class="cstat-no" title="statement not covered" >d</span>.rect(0,0,d.canvas.width,d.canvas.height);<span class="cstat-no" title="statement not covered" >d</span>.translate(-a[0],-a[1]);<span class="cstat-no" title="statement not covered" >i</span>=s.Util.transform(i,[1,0,0,1,a[0],a[1]]);<span class="cstat-no" title="statement not covered" >d</span>.transform(...e.baseTransform);<span class="cstat-no" title="statement not covered" >t</span>his.matrix&amp;&amp;d.transform(...this.matrix);<span class="cstat-no" title="statement not covered" >a</span>pplyBoundingBox(d,this._bbox);<span class="cstat-no" title="statement not covered" >d</span>.fillStyle=this._createGradient(d);<span class="cstat-no" title="statement not covered" >d</span>.fill();<span class="cstat-no" title="statement not covered" >o</span>=t.createPattern(h.canvas,"no-repeat");c</span>onst u=<span class="cstat-no" title="statement not covered" >new DOMMatrix(i);<span class="cstat-no" title="statement not covered" ></span>o.setTransform(u)}</span>else{<span class="cstat-no" title="statement not covered" >applyBoundingBox(t,this._bbox);<span class="cstat-no" title="statement not covered" >o</span>=this._createGradient(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}</span>}function <span class="fstat-no" title="function not covered" >drawTriangle(</span>t,e,i,s,n,a,r,o){const l=<span class="cstat-no" title="statement not covered" >e.coords,</span>c=<span class="cstat-no" title="statement not covered" >e.colors,</span>h=<span class="cstat-no" title="statement not covered" >t.data,</span>d=<span class="cstat-no" title="statement not covered" >4*t.width;</span>let u;<span class="cstat-no" title="statement not covered" >if(l[i+1]&gt;l[s+1]){<span class="cstat-no" title="statement not covered" >u=i;<span class="cstat-no" title="statement not covered" >i</span>=s;<span class="cstat-no" title="statement not covered" >s</span>=u;<span class="cstat-no" title="statement not covered" >u</span>=a;<span class="cstat-no" title="statement not covered" >a</span>=r;<span class="cstat-no" title="statement not covered" >r</span>=u}<span class="cstat-no" title="statement not covered" ></span>i</span>f(l[s+1]&gt;l[n+1]){<span class="cstat-no" title="statement not covered" >u=s;<span class="cstat-no" title="statement not covered" >s</span>=n;<span class="cstat-no" title="statement not covered" >n</span>=u;<span class="cstat-no" title="statement not covered" >u</span>=r;<span class="cstat-no" title="statement not covered" >r</span>=o;<span class="cstat-no" title="statement not covered" >o</span>=u}<span class="cstat-no" title="statement not covered" ></span>i</span>f(l[i+1]&gt;l[s+1]){<span class="cstat-no" title="statement not covered" >u=i;<span class="cstat-no" title="statement not covered" >i</span>=s;<span class="cstat-no" title="statement not covered" >s</span>=u;<span class="cstat-no" title="statement not covered" >u</span>=a;<span class="cstat-no" title="statement not covered" >a</span>=r;<span class="cstat-no" title="statement not covered" >r</span>=u}</span>c</span>onst p=<span class="cstat-no" title="statement not covered" >(l[i]+e.offsetX)*e.scaleX,</span>g=<span class="cstat-no" title="statement not covered" >(l[i+1]+e.offsetY)*e.scaleY,</span>m=<span class="cstat-no" title="statement not covered" >(l[s]+e.offsetX)*e.scaleX,</span>f=<span class="cstat-no" title="statement not covered" >(l[s+1]+e.offsetY)*e.scaleY,</span>b=<span class="cstat-no" title="statement not covered" >(l[n]+e.offsetX)*e.scaleX,</span>A=<span class="cstat-no" title="statement not covered" >(l[n+1]+e.offsetY)*e.scaleY;<span class="cstat-no" title="statement not covered" ></span>if(g&gt;=A)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst _=<span class="cstat-no" title="statement not covered" >c[a],</span>v=<span class="cstat-no" title="statement not covered" >c[a+1],</span>y=<span class="cstat-no" title="statement not covered" >c[a+2],</span>S=<span class="cstat-no" title="statement not covered" >c[r],</span>E=<span class="cstat-no" title="statement not covered" >c[r+1],</span>x=<span class="cstat-no" title="statement not covered" >c[r+2],</span>w=<span class="cstat-no" title="statement not covered" >c[o],</span>C=<span class="cstat-no" title="statement not covered" >c[o+1],</span>T=<span class="cstat-no" title="statement not covered" >c[o+2],</span>P=<span class="cstat-no" title="statement not covered" >Math.round(g),</span>M=<span class="cstat-no" title="statement not covered" >Math.round(A);</span>let F,k,R,D,I,L,O,N;<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >P;</span>t&lt;=M;t++){<span class="cstat-no" title="statement not covered" >if(t&lt;f){const e=<span class="cstat-no" title="statement not covered" >t&lt;g?0:(g-t)/(g-f);<span class="cstat-no" title="statement not covered" ></span>F=p-(p-m)*e;<span class="cstat-no" title="statement not covered" >k</span>=_-(_-S)*e;<span class="cstat-no" title="statement not covered" >R</span>=v-(v-E)*e;<span class="cstat-no" title="statement not covered" >D</span>=y-(y-x)*e}</span>else{let e;<span class="cstat-no" title="statement not covered" >e=t&gt;A?1:f===A?0:(f-t)/(f-A);<span class="cstat-no" title="statement not covered" >F</span>=m-(m-b)*e;<span class="cstat-no" title="statement not covered" >k</span>=S-(S-w)*e;<span class="cstat-no" title="statement not covered" >R</span>=E-(E-C)*e;<span class="cstat-no" title="statement not covered" >D</span>=x-(x-T)*e}</span>l</span>et e;<span class="cstat-no" title="statement not covered" >e=t&lt;g?0:t&gt;A?1:(g-t)/(g-A);<span class="cstat-no" title="statement not covered" >I</span>=p-(p-b)*e;<span class="cstat-no" title="statement not covered" >L</span>=_-(_-w)*e;<span class="cstat-no" title="statement not covered" >O</span>=v-(v-C)*e;<span class="cstat-no" title="statement not covered" >N</span>=y-(y-T)*e;c</span>onst i=<span class="cstat-no" title="statement not covered" >Math.round(Math.min(F,I)),</span>s=<span class="cstat-no" title="statement not covered" >Math.round(Math.max(F,I));</span>let n=<span class="cstat-no" title="statement not covered" >d*t+4*i;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >i;</span>t&lt;=s;t++){<span class="cstat-no" title="statement not covered" >e=(F-t)/(F-I);<span class="cstat-no" title="statement not covered" >e</span>&lt;0?e=0:e&gt;1&amp;&amp;(e=1);<span class="cstat-no" title="statement not covered" >h</span>[n++]=k-(k-L)*e|0;<span class="cstat-no" title="statement not covered" >h</span>[n++]=R-(R-O)*e|0;<span class="cstat-no" title="statement not covered" >h</span>[n++]=D-(D-N)*e|0;<span class="cstat-no" title="statement not covered" >h</span>[n++]=255}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >drawFigure(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >e.coords,</span>n=<span class="cstat-no" title="statement not covered" >e.colors;</span>let a,r;<span class="cstat-no" title="statement not covered" >switch(e.type){case"lattice":const o=<span class="cstat-no" title="statement not covered" >e.verticesPerRow,</span>l=<span class="cstat-no" title="statement not covered" >Math.floor(s.length/o)-1,</span>c=<span class="cstat-no" title="statement not covered" >o-1;<span class="cstat-no" title="statement not covered" ></span>for(a=0;a&lt;l;a++){let e=<span class="cstat-no" title="statement not covered" >a*o;<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;c;a++,e++){<span class="cstat-no" title="statement not covered" >drawTriangle(t,i,s[e],s[e+1],s[e+o],n[e],n[e+1],n[e+o]);<span class="cstat-no" title="statement not covered" >d</span>rawTriangle(t,i,s[e+o+1],s[e+1],s[e+o],n[e+o+1],n[e+1],n[e+o])}</span>}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase"triangles":<span class="cstat-no" title="statement not covered" >for(a=0,r=s.length;a&lt;r;a+=3)<span class="cstat-no" title="statement not covered" >drawTriangle(t,i,s[a],s[a+1],s[a+2],n[a],n[a+1],n[a+2]);<span class="cstat-no" title="statement not covered" >b</span></span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("illegal figure")}</span>}</span>class MeshShadingPattern extends BaseShadingPattern{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his._coords=t[2];<span class="cstat-no" title="statement not covered" >t</span>his._colors=t[3];<span class="cstat-no" title="statement not covered" >t</span>his._figures=t[4];<span class="cstat-no" title="statement not covered" >t</span>his._bounds=t[5];<span class="cstat-no" title="statement not covered" >t</span>his._bbox=t[7];<span class="cstat-no" title="statement not covered" >t</span>his._background=t[8];<span class="cstat-no" title="statement not covered" >t</span>his.matrix=null}<span class="fstat-no" title="function not covered" ></span>_c</span>reateMeshCanvas(t,e,i){const s=<span class="cstat-no" title="statement not covered" >Math.floor(this._bounds[0]),</span>n=<span class="cstat-no" title="statement not covered" >Math.floor(this._bounds[1]),</span>a=<span class="cstat-no" title="statement not covered" >Math.ceil(this._bounds[2])-s,</span>r=<span class="cstat-no" title="statement not covered" >Math.ceil(this._bounds[3])-n,</span>o=<span class="cstat-no" title="statement not covered" >Math.min(Math.ceil(Math.abs(a*t[0]*1.1)),3e3),</span>l=<span class="cstat-no" title="statement not covered" >Math.min(Math.ceil(Math.abs(r*t[1]*1.1)),3e3),</span>c=<span class="cstat-no" title="statement not covered" >a/o,</span>h=<span class="cstat-no" title="statement not covered" >r/l,</span>d=<span class="cstat-no" title="statement not covered" >{coords:this._coords,colors:this._colors,offsetX:-s,offsetY:-n,scaleX:1/c,scaleY:1/h},</span>u=<span class="cstat-no" title="statement not covered" >o+4,</span>p=<span class="cstat-no" title="statement not covered" >l+4,</span>g=<span class="cstat-no" title="statement not covered" >i.getCanvas("mesh",u,p,!1),</span>m=<span class="cstat-no" title="statement not covered" >g.context,</span>f=<span class="cstat-no" title="statement not covered" >m.createImageData(o,l);<span class="cstat-no" title="statement not covered" ></span>if(e){const t=<span class="cstat-no" title="statement not covered" >f.data;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>i&lt;s;i+=4){<span class="cstat-no" title="statement not covered" >t[i]=e[0];<span class="cstat-no" title="statement not covered" >t</span>[i+1]=e[1];<span class="cstat-no" title="statement not covered" >t</span>[i+2]=e[2];<span class="cstat-no" title="statement not covered" >t</span>[i+3]=255}</span>}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const t of this._figures)<span class="cstat-no" title="statement not covered" >drawFigure(f,t,d);<span class="cstat-no" title="statement not covered" >m</span></span>.putImageData(f,2,2);<span class="cstat-no" title="statement not covered" >r</span>eturn{canvas:g.canvas,offsetX:s-2*c,offsetY:n-2*h,scaleX:c,scaleY:h}}<span class="fstat-no" title="function not covered" ></span>ge</span>tPattern(t,e,i,r){<span class="cstat-no" title="statement not covered" >applyBoundingBox(t,this._bbox);l</span>et o;<span class="cstat-no" title="statement not covered" >if(r===a.SHADING)<span class="cstat-no" title="statement not covered" >o=s.Util.singularValueDecompose2dScale((0,n.getCurrentTransform)(t));e</span>lse{<span class="cstat-no" title="statement not covered" >o=s.Util.singularValueDecompose2dScale(e.baseTransform);<span class="cstat-no" title="statement not covered" >i</span>f(this.matrix){const t=<span class="cstat-no" title="statement not covered" >s.Util.singularValueDecompose2dScale(this.matrix);<span class="cstat-no" title="statement not covered" ></span>o=[o[0]*t[0],o[1]*t[1]]}</span>}</span>c</span>onst l=<span class="cstat-no" title="statement not covered" >this._createMeshCanvas(o,r===a.SHADING?null:this._background,e.cachedCanvases);<span class="cstat-no" title="statement not covered" ></span>if(r!==a.SHADING){<span class="cstat-no" title="statement not covered" >t.setTransform(...e.baseTransform);<span class="cstat-no" title="statement not covered" >t</span>his.matrix&amp;&amp;t.transform(...this.matrix)}<span class="cstat-no" title="statement not covered" ></span>t</span>.translate(l.offsetX,l.offsetY);<span class="cstat-no" title="statement not covered" >t</span>.scale(l.scaleX,l.scaleY);<span class="cstat-no" title="statement not covered" >r</span>eturn t.createPattern(l.canvas,"no-repeat")}</span>}class DummyShadingPattern extends BaseShadingPattern{<span class="fstat-no" title="function not covered" >ge</span>tPattern(){<span class="cstat-no" title="statement not covered" >return"hotpink"}</span>}const r=<span class="cstat-no" title="statement not covered" >1,</span>o=<span class="cstat-no" title="statement not covered" >2;</span>class TilingPattern{static MAX_PATTERN_SIZE=<span class="cstat-no" title="statement not covered" >3e3;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e,i,s,n){<span class="cstat-no" title="statement not covered" >this.operatorList=t[2];<span class="cstat-no" title="statement not covered" >t</span>his.matrix=t[3]||[1,0,0,1,0,0];<span class="cstat-no" title="statement not covered" >t</span>his.bbox=t[4];<span class="cstat-no" title="statement not covered" >t</span>his.xstep=t[5];<span class="cstat-no" title="statement not covered" >t</span>his.ystep=t[6];<span class="cstat-no" title="statement not covered" >t</span>his.paintType=t[7];<span class="cstat-no" title="statement not covered" >t</span>his.tilingType=t[8];<span class="cstat-no" title="statement not covered" >t</span>his.color=e;<span class="cstat-no" title="statement not covered" >t</span>his.ctx=i;<span class="cstat-no" title="statement not covered" >t</span>his.canvasGraphicsFactory=s;<span class="cstat-no" title="statement not covered" >t</span>his.baseTransform=n}<span class="fstat-no" title="function not covered" ></span>cr</span>eatePatternCanvas(t){const e=<span class="cstat-no" title="statement not covered" >this.operatorList,</span>i=<span class="cstat-no" title="statement not covered" >this.bbox,</span>a=<span class="cstat-no" title="statement not covered" >this.xstep,</span>r=<span class="cstat-no" title="statement not covered" >this.ystep,</span>o=<span class="cstat-no" title="statement not covered" >this.paintType,</span>l=<span class="cstat-no" title="statement not covered" >this.tilingType,</span>c=<span class="cstat-no" title="statement not covered" >this.color,</span>h=<span class="cstat-no" title="statement not covered" >this.canvasGraphicsFactory;<span class="cstat-no" title="statement not covered" ></span>(0,s.info)("TilingType: "+l);c</span>onst d=<span class="cstat-no" title="statement not covered" >i[0],</span>u=<span class="cstat-no" title="statement not covered" >i[1],</span>p=<span class="cstat-no" title="statement not covered" >i[2],</span>g=<span class="cstat-no" title="statement not covered" >i[3],</span>m=<span class="cstat-no" title="statement not covered" >s.Util.singularValueDecompose2dScale(this.matrix),</span>f=<span class="cstat-no" title="statement not covered" >s.Util.singularValueDecompose2dScale(this.baseTransform),</span>b=<span class="cstat-no" title="statement not covered" >[m[0]*f[0],m[1]*f[1]],</span>A=<span class="cstat-no" title="statement not covered" >this.getSizeAndScale(a,this.ctx.canvas.width,b[0]),</span>_=<span class="cstat-no" title="statement not covered" >this.getSizeAndScale(r,this.ctx.canvas.height,b[1]),</span>v=<span class="cstat-no" title="statement not covered" >t.cachedCanvases.getCanvas("pattern",A.size,_.size,!0),</span>y=<span class="cstat-no" title="statement not covered" >v.context,</span>S=<span class="cstat-no" title="statement not covered" >h.createCanvasGraphics(y);<span class="cstat-no" title="statement not covered" ></span>S.groupLevel=t.groupLevel;<span class="cstat-no" title="statement not covered" >t</span>his.setFillAndStrokeStyleToContext(S,o,c);l</span>et E=<span class="cstat-no" title="statement not covered" >d,</span>x=<span class="cstat-no" title="statement not covered" >u,</span>w=<span class="cstat-no" title="statement not covered" >p,</span>C=<span class="cstat-no" title="statement not covered" >g;<span class="cstat-no" title="statement not covered" ></span>if(d&lt;0){<span class="cstat-no" title="statement not covered" >E=0;<span class="cstat-no" title="statement not covered" >w</span>+=Math.abs(d)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u&lt;0){<span class="cstat-no" title="statement not covered" >x=0;<span class="cstat-no" title="statement not covered" >C</span>+=Math.abs(u)}<span class="cstat-no" title="statement not covered" ></span>y</span>.translate(-A.scale*E,-_.scale*x);<span class="cstat-no" title="statement not covered" >S</span>.transform(A.scale,0,0,_.scale,0,0);<span class="cstat-no" title="statement not covered" >y</span>.save();<span class="cstat-no" title="statement not covered" >t</span>his.clipBbox(S,E,x,w,C);<span class="cstat-no" title="statement not covered" >S</span>.baseTransform=(0,n.getCurrentTransform)(S.ctx);<span class="cstat-no" title="statement not covered" >S</span>.executeOperatorList(e);<span class="cstat-no" title="statement not covered" >S</span>.endDrawing();<span class="cstat-no" title="statement not covered" >r</span>eturn{canvas:v.canvas,scaleX:A.scale,scaleY:_.scale,offsetX:E,offsetY:x}}<span class="fstat-no" title="function not covered" ></span>ge</span>tSizeAndScale(t,e,i){<span class="cstat-no" title="statement not covered" >t=Math.abs(t);c</span>onst s=<span class="cstat-no" title="statement not covered" >Math.max(TilingPattern.MAX_PATTERN_SIZE,e);</span>let n=<span class="cstat-no" title="statement not covered" >Math.ceil(t*i);<span class="cstat-no" title="statement not covered" ></span>n&gt;=s?n=s:i=n/t;<span class="cstat-no" title="statement not covered" >r</span>eturn{scale:i,size:n}}<span class="fstat-no" title="function not covered" ></span>cl</span>ipBbox(t,e,i,s,a){const r=<span class="cstat-no" title="statement not covered" >s-e,</span>o=<span class="cstat-no" title="statement not covered" >a-i;<span class="cstat-no" title="statement not covered" ></span>t.ctx.rect(e,i,r,o);<span class="cstat-no" title="statement not covered" >t</span>.current.updateRectMinMax((0,n.getCurrentTransform)(t.ctx),[e,i,s,a]);<span class="cstat-no" title="statement not covered" >t</span>.clip();<span class="cstat-no" title="statement not covered" >t</span>.endPath()}<span class="fstat-no" title="function not covered" ></span>se</span>tFillAndStrokeStyleToContext(t,e,i){const n=<span class="cstat-no" title="statement not covered" >t.ctx,</span>a=<span class="cstat-no" title="statement not covered" >t.current;<span class="cstat-no" title="statement not covered" ></span>switch(e){case r:const t=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>n.fillStyle=t.fillStyle;<span class="cstat-no" title="statement not covered" >n</span>.strokeStyle=t.strokeStyle;<span class="cstat-no" title="statement not covered" >a</span>.fillColor=t.fillStyle;<span class="cstat-no" title="statement not covered" >a</span>.strokeColor=t.strokeStyle;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase o:const l=<span class="cstat-no" title="statement not covered" >s.Util.makeHexColor(i[0],i[1],i[2]);<span class="cstat-no" title="statement not covered" ></span>n.fillStyle=l;<span class="cstat-no" title="statement not covered" >n</span>.strokeStyle=l;<span class="cstat-no" title="statement not covered" >a</span>.fillColor=l;<span class="cstat-no" title="statement not covered" >a</span>.strokeColor=l;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new s.FormatError(`Unsupported paint type: ${e}`)}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tPattern(t,e,i,n){let r=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(n!==a.SHADING){<span class="cstat-no" title="statement not covered" >r=s.Util.transform(r,e.baseTransform);<span class="cstat-no" title="statement not covered" >t</span>his.matrix&amp;&amp;(r=s.Util.transform(r,this.matrix))}</span>c</span>onst o=<span class="cstat-no" title="statement not covered" >this.createPatternCanvas(e);</span>let l=<span class="cstat-no" title="statement not covered" >new DOMMatrix(r);<span class="cstat-no" title="statement not covered" ></span>l=l.translate(o.offsetX,o.offsetY);<span class="cstat-no" title="statement not covered" >l</span>=l.scale(1/o.scaleX,1/o.scaleY);c</span>onst c=<span class="cstat-no" title="statement not covered" >t.createPattern(o.canvas,"repeat");<span class="cstat-no" title="statement not covered" ></span>c.setTransform(l);<span class="cstat-no" title="statement not covered" >r</span>eturn c}</span>}<span class="cstat-no" title="statement not covered" >e.TilingPattern=TilingPattern}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.convertBlackAndWhiteToRGBA=convertBlackAndWhiteToRGBA;<span class="cstat-no" title="statement not covered" >e</span>.convertToRGBA=function <span class="fstat-no" title="function not covered" >convertToRGBA(</span>t){<span class="cstat-no" title="statement not covered" >switch(t.kind){case s.ImageKind.GRAYSCALE_1BPP:<span class="cstat-no" title="statement not covered" >return convertBlackAndWhiteToRGBA(t);c</span>ase s.ImageKind.RGB_24BPP:<span class="cstat-no" title="statement not covered" >return function <span class="fstat-no" title="function not covered" >convertRGBToRGBA(</span>{src:t,srcPos:e=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>dest:i,destPos:n=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>width:a,height:r}){let o=<span class="cstat-no" title="statement not covered" >0;</span>const l=<span class="cstat-no" title="statement not covered" >t.length&gt;&gt;2,</span>c=<span class="cstat-no" title="statement not covered" >new Uint32Array(t.buffer,e,l);<span class="cstat-no" title="statement not covered" ></span>if(s.FeatureTest.isLittleEndian){<span class="cstat-no" title="statement not covered" >for(;o&lt;l-2;o+=3,n+=4){const t=<span class="cstat-no" title="statement not covered" >c[o],</span>e=<span class="cstat-no" title="statement not covered" >c[o+1],</span>s=<span class="cstat-no" title="statement not covered" >c[o+2];<span class="cstat-no" title="statement not covered" ></span>i[n]=4278190080|t;<span class="cstat-no" title="statement not covered" >i</span>[n+1]=t&gt;&gt;&gt;24|e&lt;&lt;8|4278190080;<span class="cstat-no" title="statement not covered" >i</span>[n+2]=e&gt;&gt;&gt;16|s&lt;&lt;16|4278190080;<span class="cstat-no" title="statement not covered" >i</span>[n+3]=s&gt;&gt;&gt;8|4278190080}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let e=<span class="cstat-no" title="statement not covered" >4*o,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;s;e+=3)<span class="cstat-no" title="statement not covered" >i[n++]=t[e]|t[e+1]&lt;&lt;8|t[e+2]&lt;&lt;16|4278190080}</span></span>else{<span class="cstat-no" title="statement not covered" >for(;o&lt;l-2;o+=3,n+=4){const t=<span class="cstat-no" title="statement not covered" >c[o],</span>e=<span class="cstat-no" title="statement not covered" >c[o+1],</span>s=<span class="cstat-no" title="statement not covered" >c[o+2];<span class="cstat-no" title="statement not covered" ></span>i[n]=255|t;<span class="cstat-no" title="statement not covered" >i</span>[n+1]=t&lt;&lt;24|e&gt;&gt;&gt;8|255;<span class="cstat-no" title="statement not covered" >i</span>[n+2]=e&lt;&lt;16|s&gt;&gt;&gt;16|255;<span class="cstat-no" title="statement not covered" >i</span>[n+3]=s&lt;&lt;8|255}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let e=<span class="cstat-no" title="statement not covered" >4*o,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;s;e+=3)<span class="cstat-no" title="statement not covered" >i[n++]=t[e]&lt;&lt;24|t[e+1]&lt;&lt;16|t[e+2]&lt;&lt;8|255}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{srcPos:e,destPos:n}}</span>(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}</span>;<span class="cstat-no" title="statement not covered" >e</span>.grayToRGBA=function <span class="fstat-no" title="function not covered" >grayToRGBA(</span>t,e){<span class="cstat-no" title="statement not covered" >if(s.FeatureTest.isLittleEndian)<span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>i&lt;s;i++)<span class="cstat-no" title="statement not covered" >e[i]=65793*t[i]|4278190080;e</span></span>lse <span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>i&lt;s;i++)<span class="cstat-no" title="statement not covered" >e[i]=16843008*t[i]|255}</span></span></span>;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1);</span>function <span class="fstat-no" title="function not covered" >convertBlackAndWhiteToRGBA(</span>{src:t,srcPos:e=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>dest:i,width:n,height:a,nonBlackColor:r=<span class="branch-0 cbranch-no" title="branch not covered" >4294967295,</span>inverseDecode:o=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>){const l=<span class="cstat-no" title="statement not covered" >s.FeatureTest.isLittleEndian?4278190080:255,</span>[c,h]=<span class="cstat-no" title="statement not covered" >o?[r,l]:[l,r],</span>d=<span class="cstat-no" title="statement not covered" >n&gt;&gt;3,</span>u=<span class="cstat-no" title="statement not covered" >7&amp;n,</span>p=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>i=new Uint32Array(i.buffer);l</span>et g=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;a;s++){<span class="cstat-no" title="statement not covered" >for(const s=<span class="cstat-no" title="statement not covered" >e+d;</span>e&lt;s;e++){const s=<span class="cstat-no" title="statement not covered" >e&lt;p?t[e]:255;<span class="cstat-no" title="statement not covered" ></span>i[g++]=128&amp;s?h:c;<span class="cstat-no" title="statement not covered" >i</span>[g++]=64&amp;s?h:c;<span class="cstat-no" title="statement not covered" >i</span>[g++]=32&amp;s?h:c;<span class="cstat-no" title="statement not covered" >i</span>[g++]=16&amp;s?h:c;<span class="cstat-no" title="statement not covered" >i</span>[g++]=8&amp;s?h:c;<span class="cstat-no" title="statement not covered" >i</span>[g++]=4&amp;s?h:c;<span class="cstat-no" title="statement not covered" >i</span>[g++]=2&amp;s?h:c;<span class="cstat-no" title="statement not covered" >i</span>[g++]=1&amp;s?h:c}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0===u)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >e&lt;p?t[e++]:255;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;u;t++)<span class="cstat-no" title="statement not covered" >i[g++]=s&amp;1&lt;&lt;7-t?h:c}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{srcPos:e,destPos:g}}</span>},<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.GlobalWorkerOptions=void 0;c</span>onst i=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>e.GlobalWorkerOptions=i;<span class="cstat-no" title="statement not covered" >i</span>.workerPort=null;<span class="cstat-no" title="statement not covered" >i</span>.workerSrc=""}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.MessageHandler=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1);</span>const n=<span class="cstat-no" title="statement not covered" >1,</span>a=<span class="cstat-no" title="statement not covered" >2,</span>r=<span class="cstat-no" title="statement not covered" >1,</span>o=<span class="cstat-no" title="statement not covered" >2,</span>l=<span class="cstat-no" title="statement not covered" >3,</span>c=<span class="cstat-no" title="statement not covered" >4,</span>h=<span class="cstat-no" title="statement not covered" >5,</span>d=<span class="cstat-no" title="statement not covered" >6,</span>u=<span class="cstat-no" title="statement not covered" >7,</span>p=<span class="cstat-no" title="statement not covered" >8;</span>function <span class="fstat-no" title="function not covered" >wrapReason(</span>t){<span class="cstat-no" title="statement not covered" >t instanceof Error||"object"==typeof t&amp;&amp;null!==t||(0,s.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');<span class="cstat-no" title="statement not covered" >s</span>witch(t.name){case"AbortException":<span class="cstat-no" title="statement not covered" >return new s.AbortException(t.message);c</span>ase"MissingPDFException":<span class="cstat-no" title="statement not covered" >return new s.MissingPDFException(t.message);c</span>ase"PasswordException":<span class="cstat-no" title="statement not covered" >return new s.PasswordException(t.message,t.code);c</span>ase"UnexpectedResponseException":<span class="cstat-no" title="statement not covered" >return new s.UnexpectedResponseException(t.message,t.status);c</span>ase"UnknownErrorException":<span class="cstat-no" title="statement not covered" >return new s.UnknownErrorException(t.message,t.details);d</span>efault:<span class="cstat-no" title="statement not covered" >return new s.UnknownErrorException(t.message,t.toString())}</span>}<span class="cstat-no" title="statement not covered" ></span>e.MessageHandler=class MessageHandler{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i){<span class="cstat-no" title="statement not covered" >this.sourceName=t;<span class="cstat-no" title="statement not covered" >t</span>his.targetName=e;<span class="cstat-no" title="statement not covered" >t</span>his.comObj=i;<span class="cstat-no" title="statement not covered" >t</span>his.callbackId=1;<span class="cstat-no" title="statement not covered" >t</span>his.streamId=1;<span class="cstat-no" title="statement not covered" >t</span>his.streamSinks=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his.streamControllers=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his.callbackCapabilities=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his.actionHandler=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his._onComObjOnMessage=<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t.data;<span class="cstat-no" title="statement not covered" ></span>if(e.targetName!==this.sourceName)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.stream){<span class="cstat-no" title="statement not covered" >this.#ae(e);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.callback){const t=<span class="cstat-no" title="statement not covered" >e.callbackId,</span>i=<span class="cstat-no" title="statement not covered" >this.callbackCapabilities[t];<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >throw new Error(`Cannot resolve callback ${t}`);<span class="cstat-no" title="statement not covered" >d</span></span>elete this.callbackCapabilities[t];<span class="cstat-no" title="statement not covered" >i</span>f(e.callback===n)<span class="cstat-no" title="statement not covered" >i.resolve(e.data);e</span>lse{<span class="cstat-no" title="statement not covered" >if(e.callback!==a)<span class="cstat-no" title="statement not covered" >throw new Error("Unexpected callback case");<span class="cstat-no" title="statement not covered" >i</span></span>.reject(wrapReason(e.reason))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn}</span>c</span>onst s=<span class="cstat-no" title="statement not covered" >this.actionHandler[e.action];<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >throw new Error(`Unknown action from worker: ${e.action}`);<span class="cstat-no" title="statement not covered" >i</span></span>f(e.callbackId){const t=<span class="cstat-no" title="statement not covered" >this.sourceName,</span>r=<span class="cstat-no" title="statement not covered" >e.sourceName;<span class="cstat-no" title="statement not covered" ></span>new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t(s(e.data))}</span>)).then((<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >i.postMessage({sourceName:t,targetName:r,callback:n,callbackId:e.callbackId,data:s})}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >i.postMessage({sourceName:t,targetName:r,callback:a,callbackId:e.callbackId,reason:wrapReason(s)})}</span>))}</span>else <span class="cstat-no" title="statement not covered" >e.streamId?this.#re(e):s(e.data)}</span></span>;<span class="cstat-no" title="statement not covered" >i</span>.addEventListener("message",this._onComObjOnMessage)}<span class="fstat-no" title="function not covered" ></span>on</span>(t,e){const i=<span class="cstat-no" title="statement not covered" >this.actionHandler;<span class="cstat-no" title="statement not covered" ></span>if(i[t])<span class="cstat-no" title="statement not covered" >throw new Error(`There is already an actionName called "${t}"`);<span class="cstat-no" title="statement not covered" >i</span></span>[t]=e}<span class="fstat-no" title="function not covered" ></span>se</span>nd(t,e,i){<span class="cstat-no" title="statement not covered" >this.comObj.postMessage({sourceName:this.sourceName,targetName:this.targetName,action:t,data:e},i)}<span class="fstat-no" title="function not covered" ></span>se</span>ndWithPromise(t,e,i){const n=<span class="cstat-no" title="statement not covered" >this.callbackId++,</span>a=<span class="cstat-no" title="statement not covered" >new s.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this.callbackCapabilities[n]=a;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >this.comObj.postMessage({sourceName:this.sourceName,targetName:this.targetName,action:t,callbackId:n,data:e},i)}</span>catch(t){<span class="cstat-no" title="statement not covered" >a.reject(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a.promise}<span class="fstat-no" title="function not covered" ></span>se</span>ndWithStream(t,e,i,n){const a=<span class="cstat-no" title="statement not covered" >this.streamId++,</span>o=<span class="cstat-no" title="statement not covered" >this.sourceName,</span>l=<span class="cstat-no" title="statement not covered" >this.targetName,</span>c=<span class="cstat-no" title="statement not covered" >this.comObj;<span class="cstat-no" title="statement not covered" ></span>return new ReadableStream({start:<span class="fstat-no" title="function not covered" >i=</span>&gt;{const r=<span class="cstat-no" title="statement not covered" >new s.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this.streamControllers[a]={controller:i,startCall:r,pullCall:null,cancelCall:null,isClosed:!1};<span class="cstat-no" title="statement not covered" >c</span>.postMessage({sourceName:o,targetName:l,action:t,streamId:a,data:e,desiredSize:i.desiredSize},n);<span class="cstat-no" title="statement not covered" >r</span>eturn r.promise}</span>,pull:<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >new s.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this.streamControllers[a].pullCall=e;<span class="cstat-no" title="statement not covered" >c</span>.postMessage({sourceName:o,targetName:l,stream:d,streamId:a,desiredSize:t.desiredSize});<span class="cstat-no" title="statement not covered" >r</span>eturn e.promise}</span>,cancel:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >(0,s.assert)(t instanceof Error,"cancel must have a valid reason");c</span>onst e=<span class="cstat-no" title="statement not covered" >new s.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this.streamControllers[a].cancelCall=e;<span class="cstat-no" title="statement not covered" >t</span>his.streamControllers[a].isClosed=!0;<span class="cstat-no" title="statement not covered" >c</span>.postMessage({sourceName:o,targetName:l,stream:r,streamId:a,reason:wrapReason(t)});<span class="cstat-no" title="statement not covered" >r</span>eturn e.promise}</span>},i)}</span>#re(t){const e=<span class="cstat-no" title="statement not covered" >t.streamId,</span>i=<span class="cstat-no" title="statement not covered" >this.sourceName,</span>n=<span class="cstat-no" title="statement not covered" >t.sourceName,</span>a=<span class="cstat-no" title="statement not covered" >this.comObj,</span>r=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >this.actionHandler[t.action],</span>d=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >en</span>queue(t,r=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>o){<span class="cstat-no" title="statement not covered" >if(this.isCancelled)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst l=<span class="cstat-no" title="statement not covered" >this.desiredSize;<span class="cstat-no" title="statement not covered" ></span>this.desiredSize-=r;<span class="cstat-no" title="statement not covered" >i</span>f(l&gt;0&amp;&amp;this.desiredSize&lt;=0){<span class="cstat-no" title="statement not covered" >this.sinkCapability=new s.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his.ready=this.sinkCapability.promise}<span class="cstat-no" title="statement not covered" ></span>a</span>.postMessage({sourceName:i,targetName:n,stream:c,streamId:e,chunk:t},o)}</span>,<span class="fstat-no" title="function not covered" >cl</span>ose(){<span class="cstat-no" title="statement not covered" >if(!this.isCancelled){<span class="cstat-no" title="statement not covered" >this.isCancelled=!0;<span class="cstat-no" title="statement not covered" >a</span>.postMessage({sourceName:i,targetName:n,stream:l,streamId:e});<span class="cstat-no" title="statement not covered" >d</span>elete r.streamSinks[e]}</span>}</span>,<span class="fstat-no" title="function not covered" >er</span>ror(t){<span class="cstat-no" title="statement not covered" >(0,s.assert)(t instanceof Error,"error must have a valid reason");<span class="cstat-no" title="statement not covered" >i</span>f(!this.isCancelled){<span class="cstat-no" title="statement not covered" >this.isCancelled=!0;<span class="cstat-no" title="statement not covered" >a</span>.postMessage({sourceName:i,targetName:n,stream:h,streamId:e,reason:wrapReason(t)})}</span>}</span>,sinkCapability:new s.PromiseCapability,onPull:null,onCancel:null,isCancelled:!1,desiredSize:t.desiredSize,ready:null};<span class="cstat-no" title="statement not covered" ></span>d.sinkCapability.resolve();<span class="cstat-no" title="statement not covered" >d</span>.ready=d.sinkCapability.promise;<span class="cstat-no" title="statement not covered" >t</span>his.streamSinks[e]=d;<span class="cstat-no" title="statement not covered" >n</span>ew Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e(o(t.data,d))}</span>)).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a.postMessage({sourceName:i,targetName:n,stream:p,streamId:e,success:!0})}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a.postMessage({sourceName:i,targetName:n,stream:p,streamId:e,reason:wrapReason(t)})}</span>))}</span>#ae(t){const e=<span class="cstat-no" title="statement not covered" >t.streamId,</span>i=<span class="cstat-no" title="statement not covered" >this.sourceName,</span>n=<span class="cstat-no" title="statement not covered" >t.sourceName,</span>a=<span class="cstat-no" title="statement not covered" >this.comObj,</span>g=<span class="cstat-no" title="statement not covered" >this.streamControllers[e],</span>m=<span class="cstat-no" title="statement not covered" >this.streamSinks[e];<span class="cstat-no" title="statement not covered" ></span>switch(t.stream){case p:<span class="cstat-no" title="statement not covered" >t.success?g.startCall.resolve():g.startCall.reject(wrapReason(t.reason));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase u:<span class="cstat-no" title="statement not covered" >t.success?g.pullCall.resolve():g.pullCall.reject(wrapReason(t.reason));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase d:<span class="cstat-no" title="statement not covered" >if(!m){<span class="cstat-no" title="statement not covered" >a.postMessage({sourceName:i,targetName:n,stream:u,streamId:e,success:!0});<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>m</span>.desiredSize&lt;=0&amp;&amp;t.desiredSize&gt;0&amp;&amp;m.sinkCapability.resolve();<span class="cstat-no" title="statement not covered" >m</span>.desiredSize=t.desiredSize;<span class="cstat-no" title="statement not covered" >n</span>ew Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t(m.onPull?.())}</span>)).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a.postMessage({sourceName:i,targetName:n,stream:u,streamId:e,success:!0})}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a.postMessage({sourceName:i,targetName:n,stream:u,streamId:e,reason:wrapReason(t)})}</span>));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase c:<span class="cstat-no" title="statement not covered" >(0,s.assert)(g,"enqueue should have stream controller");<span class="cstat-no" title="statement not covered" >i</span>f(g.isClosed)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >g</span></span>.controller.enqueue(t.chunk);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase l:<span class="cstat-no" title="statement not covered" >(0,s.assert)(g,"close should have stream controller");<span class="cstat-no" title="statement not covered" >i</span>f(g.isClosed)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >g</span></span>.isClosed=!0;<span class="cstat-no" title="statement not covered" >g</span>.controller.close();<span class="cstat-no" title="statement not covered" >t</span>his.#oe(g,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase h:<span class="cstat-no" title="statement not covered" >(0,s.assert)(g,"error should have stream controller");<span class="cstat-no" title="statement not covered" >g</span>.controller.error(wrapReason(t.reason));<span class="cstat-no" title="statement not covered" >t</span>his.#oe(g,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase o:<span class="cstat-no" title="statement not covered" >t.success?g.cancelCall.resolve():g.cancelCall.reject(wrapReason(t.reason));<span class="cstat-no" title="statement not covered" >t</span>his.#oe(g,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase r:<span class="cstat-no" title="statement not covered" >if(!m)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >n</span></span>ew Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e(m.onCancel?.(wrapReason(t.reason)))}</span>)).then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a.postMessage({sourceName:i,targetName:n,stream:o,streamId:e,success:!0})}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a.postMessage({sourceName:i,targetName:n,stream:o,streamId:e,reason:wrapReason(t)})}</span>));<span class="cstat-no" title="statement not covered" >m</span>.sinkCapability.reject(wrapReason(t.reason));<span class="cstat-no" title="statement not covered" >m</span>.isCancelled=!0;<span class="cstat-no" title="statement not covered" >d</span>elete this.streamSinks[e];<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("Unexpected stream case")}</span>}</span>async#oe(t,e){<span class="cstat-no" title="statement not covered" >await Promise.allSettled([t.startCall?.promise,t.pullCall?.promise,t.cancelCall?.promise]);<span class="cstat-no" title="statement not covered" >d</span>elete this.streamControllers[e]}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.comObj.removeEventListener("message",this._onComObjOnMessage)}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.Metadata=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1);<span class="cstat-no" title="statement not covered" ></span>e.Metadata=class Metadata{#le;#ce;<span class="fstat-no" title="function not covered" >co</span>nstructor({parsedData:t,rawData:e}){<span class="cstat-no" title="statement not covered" >this.#le=t;<span class="cstat-no" title="statement not covered" >t</span>his.#ce=e}<span class="fstat-no" title="function not covered" ></span>ge</span>tRaw(){<span class="cstat-no" title="statement not covered" >return this.#ce}<span class="fstat-no" title="function not covered" ></span>ge</span>t(t){<span class="cstat-no" title="statement not covered" >return this.#le.get(t)??null}<span class="fstat-no" title="function not covered" ></span>ge</span>tAll(){<span class="cstat-no" title="statement not covered" >return(0,s.objectFromMap)(this.#le)}<span class="fstat-no" title="function not covered" ></span>ha</span>s(t){<span class="cstat-no" title="statement not covered" >return this.#le.has(t)}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.OptionalContentConfig=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(8);</span>const a=<span class="cstat-no" title="statement not covered" >Symbol("INTERNAL");</span>class OptionalContentGroup{#he=<span class="cstat-no" title="statement not covered" >!0;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this.name=t;<span class="cstat-no" title="statement not covered" >t</span>his.intent=e}<span class="fstat-no" title="function not covered" ></span>ge</span>t visible(){<span class="cstat-no" title="statement not covered" >return this.#he}<span class="fstat-no" title="function not covered" ></span>_s</span>etVisible(t,e){<span class="cstat-no" title="statement not covered" >t!==a&amp;&amp;(0,s.unreachable)("Internal method `_setVisible` called.");<span class="cstat-no" title="statement not covered" >t</span>his.#he=e}</span>}<span class="cstat-no" title="statement not covered" >e.OptionalContentConfig=class OptionalContentConfig{#de=<span class="cstat-no" title="statement not covered" >null;</span>#ue=<span class="cstat-no" title="statement not covered" >new Map;</span>#pe=<span class="cstat-no" title="statement not covered" >null;</span>#ge=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.name=null;<span class="cstat-no" title="statement not covered" >t</span>his.creator=null;<span class="cstat-no" title="statement not covered" >i</span>f(null!==t){<span class="cstat-no" title="statement not covered" >this.name=t.name;<span class="cstat-no" title="statement not covered" >t</span>his.creator=t.creator;<span class="cstat-no" title="statement not covered" >t</span>his.#ge=t.order;<span class="cstat-no" title="statement not covered" >f</span>or(const e of t.groups)<span class="cstat-no" title="statement not covered" >this.#ue.set(e.id,new OptionalContentGroup(e.name,e.intent));<span class="cstat-no" title="statement not covered" >i</span></span>f("OFF"===t.baseState)<span class="cstat-no" title="statement not covered" >for(const t of this.#ue.values())<span class="cstat-no" title="statement not covered" >t._setVisible(a,!1);<span class="cstat-no" title="statement not covered" >f</span></span></span>or(const e of t.on)<span class="cstat-no" title="statement not covered" >this.#ue.get(e)._setVisible(a,!0);<span class="cstat-no" title="statement not covered" >f</span></span>or(const e of t.off)<span class="cstat-no" title="statement not covered" >this.#ue.get(e)._setVisible(a,!1);<span class="cstat-no" title="statement not covered" >t</span></span>his.#pe=this.getHash()}</span>}</span>#me(t){const e=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>if(e&lt;2)<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >t[0];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >1;</span>n&lt;e;n++){const e=<span class="cstat-no" title="statement not covered" >t[n];</span>let a;<span class="cstat-no" title="statement not covered" >if(Array.isArray(e))<span class="cstat-no" title="statement not covered" >a=this.#me(e);e</span>lse{<span class="cstat-no" title="statement not covered" >if(!this.#ue.has(e)){<span class="cstat-no" title="statement not covered" >(0,s.warn)(`Optional content group not found: ${e}`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>a</span>=this.#ue.get(e).visible}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(i){case"And":<span class="cstat-no" title="statement not covered" >if(!a)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >b</span></span>reak;c</span>ase"Or":<span class="cstat-no" title="statement not covered" >if(a)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >b</span></span>reak;c</span>ase"Not":<span class="cstat-no" title="statement not covered" >return!a;d</span>efault:<span class="cstat-no" title="statement not covered" >return!0}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn"And"===i}<span class="fstat-no" title="function not covered" ></span>is</span>Visible(t){<span class="cstat-no" title="statement not covered" >if(0===this.#ue.size)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(!t){<span class="cstat-no" title="statement not covered" >(0,s.warn)("Optional content group not defined.");<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f("OCG"===t.type){<span class="cstat-no" title="statement not covered" >if(!this.#ue.has(t.id)){<span class="cstat-no" title="statement not covered" >(0,s.warn)(`Optional content group not found: ${t.id}`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.#ue.get(t.id).visible}<span class="cstat-no" title="statement not covered" ></span>i</span>f("OCMD"===t.type){<span class="cstat-no" title="statement not covered" >if(t.expression)<span class="cstat-no" title="statement not covered" >return this.#me(t.expression);<span class="cstat-no" title="statement not covered" >i</span></span>f(!t.policy||"AnyOn"===t.policy){<span class="cstat-no" title="statement not covered" >for(const e of t.ids){<span class="cstat-no" title="statement not covered" >if(!this.#ue.has(e)){<span class="cstat-no" title="statement not covered" >(0,s.warn)(`Optional content group not found: ${e}`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.#ue.get(e).visible)<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}<span class="cstat-no" title="statement not covered" ></span>i</span>f("AllOn"===t.policy){<span class="cstat-no" title="statement not covered" >for(const e of t.ids){<span class="cstat-no" title="statement not covered" >if(!this.#ue.has(e)){<span class="cstat-no" title="statement not covered" >(0,s.warn)(`Optional content group not found: ${e}`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this.#ue.get(e).visible)<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f("AnyOff"===t.policy){<span class="cstat-no" title="statement not covered" >for(const e of t.ids){<span class="cstat-no" title="statement not covered" >if(!this.#ue.has(e)){<span class="cstat-no" title="statement not covered" >(0,s.warn)(`Optional content group not found: ${e}`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this.#ue.get(e).visible)<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}<span class="cstat-no" title="statement not covered" ></span>i</span>f("AllOff"===t.policy){<span class="cstat-no" title="statement not covered" >for(const e of t.ids){<span class="cstat-no" title="statement not covered" >if(!this.#ue.has(e)){<span class="cstat-no" title="statement not covered" >(0,s.warn)(`Optional content group not found: ${e}`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.#ue.get(e).visible)<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>(</span>0,s.warn)(`Unknown optional content policy ${t.policy}.`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>(</span>0,s.warn)(`Unknown group type ${t.type}.`);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="fstat-no" title="function not covered" ></span>se</span>tVisibility(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >if(this.#ue.has(t)){<span class="cstat-no" title="statement not covered" >this.#ue.get(t)._setVisible(a,!!e);<span class="cstat-no" title="statement not covered" >t</span>his.#de=null}</span>else<span class="cstat-no" title="statement not covered" >(0,s.warn)(`Optional content group not found: ${t}`)}<span class="fstat-no" title="function not covered" ></span></span>ge</span>t hasInitialVisibility(){<span class="cstat-no" title="statement not covered" >return null===this.#pe||this.getHash()===this.#pe}<span class="fstat-no" title="function not covered" ></span>ge</span>tOrder(){<span class="cstat-no" title="statement not covered" >return this.#ue.size?this.#ge?this.#ge.slice():[...this.#ue.keys()]:null}<span class="fstat-no" title="function not covered" ></span>ge</span>tGroups(){<span class="cstat-no" title="statement not covered" >return this.#ue.size&gt;0?(0,s.objectFromMap)(this.#ue):null}<span class="fstat-no" title="function not covered" ></span>ge</span>tGroup(t){<span class="cstat-no" title="statement not covered" >return this.#ue.get(t)||null}<span class="fstat-no" title="function not covered" ></span>ge</span>tHash(){<span class="cstat-no" title="statement not covered" >if(null!==this.#de)<span class="cstat-no" title="statement not covered" >return this.#de;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >new n.MurmurHash3_64;<span class="cstat-no" title="statement not covered" ></span>for(const[e,i]of this.#ue)<span class="cstat-no" title="statement not covered" >t.update(`${e}:${i.visible}`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.#de=t.hexdigest()}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.PDFDataTransportStream=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(6);<span class="cstat-no" title="statement not covered" ></span>e.PDFDataTransportStream=class PDFDataTransportStream{<span class="fstat-no" title="function not covered" >co</span>nstructor({length:t,initialData:e,progressiveDone:i=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>contentDispositionFilename:n=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>disableRange:a=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>disableStream:r=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>,o){<span class="cstat-no" title="statement not covered" >(0,s.assert)(o,'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');<span class="cstat-no" title="statement not covered" >t</span>his._queuedChunks=[];<span class="cstat-no" title="statement not covered" >t</span>his._progressiveDone=i;<span class="cstat-no" title="statement not covered" >t</span>his._contentDispositionFilename=n;<span class="cstat-no" title="statement not covered" >i</span>f(e?.length&gt;0){const t=<span class="cstat-no" title="statement not covered" >e instanceof Uint8Array&amp;&amp;e.byteLength===e.buffer.byteLength?e.buffer:new Uint8Array(e).buffer;<span class="cstat-no" title="statement not covered" ></span>this._queuedChunks.push(t)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._pdfDataRangeTransport=o;<span class="cstat-no" title="statement not covered" >t</span>his._isStreamingSupported=!r;<span class="cstat-no" title="statement not covered" >t</span>his._isRangeSupported=!a;<span class="cstat-no" title="statement not covered" >t</span>his._contentLength=t;<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=null;<span class="cstat-no" title="statement not covered" >t</span>his._rangeReaders=[];<span class="cstat-no" title="statement not covered" >t</span>his._pdfDataRangeTransport.addRangeListener((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this._onReceiveData({begin:t,chunk:e})}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._pdfDataRangeTransport.addProgressListener((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this._onProgress({loaded:t,total:e})}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._pdfDataRangeTransport.addProgressiveReadListener((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._onReceiveData({chunk:t})}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._pdfDataRangeTransport.addProgressiveDoneListener((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._onProgressiveDone()}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._pdfDataRangeTransport.transportReady()}<span class="fstat-no" title="function not covered" ></span>_o</span>nReceiveData({begin:t,chunk:e}){const i=<span class="cstat-no" title="statement not covered" >e instanceof Uint8Array&amp;&amp;e.byteLength===e.buffer.byteLength?e.buffer:new Uint8Array(e).buffer;<span class="cstat-no" title="statement not covered" ></span>if(void 0===t)<span class="cstat-no" title="statement not covered" >this._fullRequestReader?this._fullRequestReader._enqueue(i):this._queuedChunks.push(i);e</span>lse{const e=<span class="cstat-no" title="statement not covered" >this._rangeReaders.some((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(e._begin!==t)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >e</span></span>._enqueue(i);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}</span>));<span class="cstat-no" title="statement not covered" ></span>(0,s.assert)(e,"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.")}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t _progressiveDataLength(){<span class="cstat-no" title="statement not covered" >return this._fullRequestReader?._loaded??0}<span class="fstat-no" title="function not covered" ></span>_o</span>nProgress(t){<span class="cstat-no" title="statement not covered" >void 0===t.total?this._rangeReaders[0]?.onProgress?.({loaded:t.loaded}):this._fullRequestReader?.onProgress?.({loaded:t.loaded,total:t.total})}<span class="fstat-no" title="function not covered" ></span>_o</span>nProgressiveDone(){<span class="cstat-no" title="statement not covered" >this._fullRequestReader?.progressiveDone();<span class="cstat-no" title="statement not covered" >t</span>his._progressiveDone=!0}<span class="fstat-no" title="function not covered" ></span>_r</span>emoveRangeReader(t){const e=<span class="cstat-no" title="statement not covered" >this._rangeReaders.indexOf(t);<span class="cstat-no" title="statement not covered" ></span>e&gt;=0&amp;&amp;this._rangeReaders.splice(e,1)}<span class="fstat-no" title="function not covered" ></span>ge</span>tFullReader(){<span class="cstat-no" title="statement not covered" >(0,s.assert)(!this._fullRequestReader,"PDFDataTransportStream.getFullReader can only be called once.");c</span>onst t=<span class="cstat-no" title="statement not covered" >this._queuedChunks;<span class="cstat-no" title="statement not covered" ></span>this._queuedChunks=null;<span class="cstat-no" title="statement not covered" >r</span>eturn new PDFDataTransportStreamReader(this,t,this._progressiveDone,this._contentDispositionFilename)}<span class="fstat-no" title="function not covered" ></span>ge</span>tRangeReader(t,e){<span class="cstat-no" title="statement not covered" >if(e&lt;=this._progressiveDataLength)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >new PDFDataTransportStreamRangeReader(this,t,e);<span class="cstat-no" title="statement not covered" ></span>this._pdfDataRangeTransport.requestDataRange(t,e);<span class="cstat-no" title="statement not covered" >t</span>his._rangeReaders.push(i);<span class="cstat-no" title="statement not covered" >r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>ca</span>ncelAllRequests(t){<span class="cstat-no" title="statement not covered" >this._fullRequestReader?.cancel(t);<span class="cstat-no" title="statement not covered" >f</span>or(const e of this._rangeReaders.slice(0))<span class="cstat-no" title="statement not covered" >e.cancel(t);<span class="cstat-no" title="statement not covered" >t</span></span>his._pdfDataRangeTransport.abort()}</span>};c</span>lass PDFDataTransportStreamReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >this._stream=t;<span class="cstat-no" title="statement not covered" >t</span>his._done=i||!1;<span class="cstat-no" title="statement not covered" >t</span>his._filename=(0,n.isPdfFile)(s)?s:null;<span class="cstat-no" title="statement not covered" >t</span>his._queuedChunks=e||[];<span class="cstat-no" title="statement not covered" >t</span>his._loaded=0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._queuedChunks)<span class="cstat-no" title="statement not covered" >this._loaded+=t.byteLength;<span class="cstat-no" title="statement not covered" >t</span></span>his._requests=[];<span class="cstat-no" title="statement not covered" >t</span>his._headersReady=Promise.resolve();<span class="cstat-no" title="statement not covered" >t</span>._fullRequestReader=this;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null}<span class="fstat-no" title="function not covered" ></span>_e</span>nqueue(t){<span class="cstat-no" title="statement not covered" >if(!this._done){<span class="cstat-no" title="statement not covered" >if(this._requests.length&gt;0){<span class="cstat-no" title="statement not covered" >this._requests.shift().resolve({value:t,done:!1})}</span>else <span class="cstat-no" title="statement not covered" >this._queuedChunks.push(t);<span class="cstat-no" title="statement not covered" >t</span></span>his._loaded+=t.byteLength}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t headersReady(){<span class="cstat-no" title="statement not covered" >return this._headersReady}<span class="fstat-no" title="function not covered" ></span>ge</span>t filename(){<span class="cstat-no" title="statement not covered" >return this._filename}<span class="fstat-no" title="function not covered" ></span>ge</span>t isRangeSupported(){<span class="cstat-no" title="statement not covered" >return this._stream._isRangeSupported}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return this._stream._isStreamingSupported}<span class="fstat-no" title="function not covered" ></span>ge</span>t contentLength(){<span class="cstat-no" title="statement not covered" >return this._stream._contentLength}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >if(this._queuedChunks.length&gt;0){<span class="cstat-no" title="statement not covered" >return{value:this._queuedChunks.shift(),done:!1}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this._done)<span class="cstat-no" title="statement not covered" >return{value:void 0,done:!0};c</span></span>onst t=<span class="cstat-no" title="statement not covered" >new s.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this._requests.push(t);<span class="cstat-no" title="statement not covered" >r</span>eturn t.promise}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._done=!0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.resolve({value:void 0,done:!0});<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0}<span class="fstat-no" title="function not covered" ></span>pr</span>ogressiveDone(){<span class="cstat-no" title="statement not covered" >this._done||(this._done=!0)}</span>}class PDFDataTransportStreamRangeReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i){<span class="cstat-no" title="statement not covered" >this._stream=t;<span class="cstat-no" title="statement not covered" >t</span>his._begin=e;<span class="cstat-no" title="statement not covered" >t</span>his._end=i;<span class="cstat-no" title="statement not covered" >t</span>his._queuedChunk=null;<span class="cstat-no" title="statement not covered" >t</span>his._requests=[];<span class="cstat-no" title="statement not covered" >t</span>his._done=!1;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null}<span class="fstat-no" title="function not covered" ></span>_e</span>nqueue(t){<span class="cstat-no" title="statement not covered" >if(!this._done){<span class="cstat-no" title="statement not covered" >if(0===this._requests.length)<span class="cstat-no" title="statement not covered" >this._queuedChunk=t;e</span>lse{<span class="cstat-no" title="statement not covered" >this._requests.shift().resolve({value:t,done:!1});<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.resolve({value:void 0,done:!0});<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0}<span class="cstat-no" title="statement not covered" ></span>t</span>his._done=!0;<span class="cstat-no" title="statement not covered" >t</span>his._stream._removeRangeReader(this)}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >if(this._queuedChunk){const t=<span class="cstat-no" title="statement not covered" >this._queuedChunk;<span class="cstat-no" title="statement not covered" ></span>this._queuedChunk=null;<span class="cstat-no" title="statement not covered" >r</span>eturn{value:t,done:!1}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this._done)<span class="cstat-no" title="statement not covered" >return{value:void 0,done:!0};c</span></span>onst t=<span class="cstat-no" title="statement not covered" >new s.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this._requests.push(t);<span class="cstat-no" title="statement not covered" >r</span>eturn t.promise}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._done=!0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.resolve({value:void 0,done:!0});<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0;<span class="cstat-no" title="statement not covered" >t</span>his._stream._removeRangeReader(this)}</span>}},<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.PDFFetchStream=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(20);</span>function <span class="fstat-no" title="function not covered" >createFetchOptions(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return{method:"GET",headers:t,signal:i.signal,mode:"cors",credentials:e?"include":"same-origin",redirect:"follow"}}</span>function <span class="fstat-no" title="function not covered" >createHeaders(</span>t){const e=<span class="cstat-no" title="statement not covered" >new Headers;<span class="cstat-no" title="statement not covered" ></span>for(const i in t){const s=<span class="cstat-no" title="statement not covered" >t[i];<span class="cstat-no" title="statement not covered" ></span>void 0!==s&amp;&amp;e.append(i,s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >getArrayBuffer(</span>t){<span class="cstat-no" title="statement not covered" >if(t instanceof Uint8Array)<span class="cstat-no" title="statement not covered" >return t.buffer;<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof ArrayBuffer)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >(</span></span>0,s.warn)(`getArrayBuffer - unexpected data format: ${t}`);<span class="cstat-no" title="statement not covered" >r</span>eturn new Uint8Array(t).buffer}<span class="cstat-no" title="statement not covered" ></span>e.PDFFetchStream=class PDFFetchStream{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.source=t;<span class="cstat-no" title="statement not covered" >t</span>his.isHttp=/^https?:/i.test(t.url);<span class="cstat-no" title="statement not covered" >t</span>his.httpHeaders=this.isHttp&amp;&amp;t.httpHeaders||{};<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=null;<span class="cstat-no" title="statement not covered" >t</span>his._rangeRequestReaders=[]}<span class="fstat-no" title="function not covered" ></span>ge</span>t _progressiveDataLength(){<span class="cstat-no" title="statement not covered" >return this._fullRequestReader?._loaded??0}<span class="fstat-no" title="function not covered" ></span>ge</span>tFullReader(){<span class="cstat-no" title="statement not covered" >(0,s.assert)(!this._fullRequestReader,"PDFFetchStream.getFullReader can only be called once.");<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=new PDFFetchStreamReader(this);<span class="cstat-no" title="statement not covered" >r</span>eturn this._fullRequestReader}<span class="fstat-no" title="function not covered" ></span>ge</span>tRangeReader(t,e){<span class="cstat-no" title="statement not covered" >if(e&lt;=this._progressiveDataLength)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >new PDFFetchStreamRangeReader(this,t,e);<span class="cstat-no" title="statement not covered" ></span>this._rangeRequestReaders.push(i);<span class="cstat-no" title="statement not covered" >r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>ca</span>ncelAllRequests(t){<span class="cstat-no" title="statement not covered" >this._fullRequestReader?.cancel(t);<span class="cstat-no" title="statement not covered" >f</span>or(const e of this._rangeRequestReaders.slice(0))<span class="cstat-no" title="statement not covered" >e.cancel(t)}</span></span>};c</span>lass PDFFetchStreamReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this._stream=t;<span class="cstat-no" title="statement not covered" >t</span>his._reader=null;<span class="cstat-no" title="statement not covered" >t</span>his._loaded=0;<span class="cstat-no" title="statement not covered" >t</span>his._filename=null;c</span>onst e=<span class="cstat-no" title="statement not covered" >t.source;<span class="cstat-no" title="statement not covered" ></span>this._withCredentials=e.withCredentials||!1;<span class="cstat-no" title="statement not covered" >t</span>his._contentLength=e.length;<span class="cstat-no" title="statement not covered" >t</span>his._headersCapability=new s.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his._disableRange=e.disableRange||!1;<span class="cstat-no" title="statement not covered" >t</span>his._rangeChunkSize=e.rangeChunkSize;<span class="cstat-no" title="statement not covered" >t</span>his._rangeChunkSize||this._disableRange||(this._disableRange=!0);<span class="cstat-no" title="statement not covered" >t</span>his._abortController=new AbortController;<span class="cstat-no" title="statement not covered" >t</span>his._isStreamingSupported=!e.disableStream;<span class="cstat-no" title="statement not covered" >t</span>his._isRangeSupported=!e.disableRange;<span class="cstat-no" title="statement not covered" >t</span>his._headers=createHeaders(this._stream.httpHeaders);c</span>onst i=<span class="cstat-no" title="statement not covered" >e.url;<span class="cstat-no" title="statement not covered" ></span>fetch(i,createFetchOptions(this._headers,this._withCredentials,this._abortController)).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!(0,n.validateResponseStatus)(t.status))<span class="cstat-no" title="statement not covered" >throw(0,n.createResponseStatusError)(t.status,i);<span class="cstat-no" title="statement not covered" >t</span></span>his._reader=t.body.getReader();<span class="cstat-no" title="statement not covered" >t</span>his._headersCapability.resolve();c</span>onst getResponseHeader=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.headers.get(e),</span></span>{allowRangeRequests:e,suggestedLength:a}=<span class="cstat-no" title="statement not covered" >(0,n.validateRangeRequestCapabilities)({getResponseHeader:getResponseHeader,isHttp:this._stream.isHttp,rangeChunkSize:this._rangeChunkSize,disableRange:this._disableRange});<span class="cstat-no" title="statement not covered" ></span>this._isRangeSupported=e;<span class="cstat-no" title="statement not covered" >t</span>his._contentLength=a||this._contentLength;<span class="cstat-no" title="statement not covered" >t</span>his._filename=(0,n.extractFilenameFromHeader)(getResponseHeader);<span class="cstat-no" title="statement not covered" >!</span>this._isStreamingSupported&amp;&amp;this._isRangeSupported&amp;&amp;this.cancel(new s.AbortException("Streaming is disabled."))}</span>)).catch(this._headersCapability.reject);<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null}<span class="fstat-no" title="function not covered" ></span>ge</span>t headersReady(){<span class="cstat-no" title="statement not covered" >return this._headersCapability.promise}<span class="fstat-no" title="function not covered" ></span>ge</span>t filename(){<span class="cstat-no" title="statement not covered" >return this._filename}<span class="fstat-no" title="function not covered" ></span>ge</span>t contentLength(){<span class="cstat-no" title="statement not covered" >return this._contentLength}<span class="fstat-no" title="function not covered" ></span>ge</span>t isRangeSupported(){<span class="cstat-no" title="statement not covered" >return this._isRangeSupported}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return this._isStreamingSupported}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >await this._headersCapability.promise;c</span>onst{value:t,done:e}=<span class="cstat-no" title="statement not covered" >await this._reader.read();<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return{value:t,done:e};<span class="cstat-no" title="statement not covered" >t</span></span>his._loaded+=t.byteLength;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress?.({loaded:this._loaded,total:this._contentLength});<span class="cstat-no" title="statement not covered" >r</span>eturn{value:getArrayBuffer(t),done:!1}}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._reader?.cancel(t);<span class="cstat-no" title="statement not covered" >t</span>his._abortController.abort()}</span>}class PDFFetchStreamRangeReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i){<span class="cstat-no" title="statement not covered" >this._stream=t;<span class="cstat-no" title="statement not covered" >t</span>his._reader=null;<span class="cstat-no" title="statement not covered" >t</span>his._loaded=0;c</span>onst a=<span class="cstat-no" title="statement not covered" >t.source;<span class="cstat-no" title="statement not covered" ></span>this._withCredentials=a.withCredentials||!1;<span class="cstat-no" title="statement not covered" >t</span>his._readCapability=new s.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his._isStreamingSupported=!a.disableStream;<span class="cstat-no" title="statement not covered" >t</span>his._abortController=new AbortController;<span class="cstat-no" title="statement not covered" >t</span>his._headers=createHeaders(this._stream.httpHeaders);<span class="cstat-no" title="statement not covered" >t</span>his._headers.append("Range",`bytes=${e}-${i-1}`);c</span>onst r=<span class="cstat-no" title="statement not covered" >a.url;<span class="cstat-no" title="statement not covered" ></span>fetch(r,createFetchOptions(this._headers,this._withCredentials,this._abortController)).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!(0,n.validateResponseStatus)(t.status))<span class="cstat-no" title="statement not covered" >throw(0,n.createResponseStatusError)(t.status,r);<span class="cstat-no" title="statement not covered" >t</span></span>his._readCapability.resolve();<span class="cstat-no" title="statement not covered" >t</span>his._reader=t.body.getReader()}</span>)).catch(this._readCapability.reject);<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return this._isStreamingSupported}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >await this._readCapability.promise;c</span>onst{value:t,done:e}=<span class="cstat-no" title="statement not covered" >await this._reader.read();<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return{value:t,done:e};<span class="cstat-no" title="statement not covered" >t</span></span>his._loaded+=t.byteLength;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress?.({loaded:this._loaded});<span class="cstat-no" title="statement not covered" >r</span>eturn{value:getArrayBuffer(t),done:!1}}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._reader?.cancel(t);<span class="cstat-no" title="statement not covered" >t</span>his._abortController.abort()}</span>}},<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.createResponseStatusError=function <span class="fstat-no" title="function not covered" >createResponseStatusError(</span>t,e){<span class="cstat-no" title="statement not covered" >if(404===t||0===t&amp;&amp;e.startsWith("file:"))<span class="cstat-no" title="statement not covered" >return new s.MissingPDFException('Missing PDF "'+e+'".');<span class="cstat-no" title="statement not covered" >r</span></span>eturn new s.UnexpectedResponseException(`Unexpected server response (${t}) while retrieving PDF "${e}".`,t)}</span>;<span class="cstat-no" title="statement not covered" >e</span>.extractFilenameFromHeader=function <span class="fstat-no" title="function not covered" >extractFilenameFromHeader(</span>t){const e=<span class="cstat-no" title="statement not covered" >t("Content-Disposition");<span class="cstat-no" title="statement not covered" ></span>if(e){let t=<span class="cstat-no" title="statement not covered" >(0,n.getFilenameFromContentDispositionHeader)(e);<span class="cstat-no" title="statement not covered" ></span>if(t.includes("%"))<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t=decodeURIComponent(t)}</span>catch{}<span class="cstat-no" title="statement not covered" >i</span></span>f((0,a.isPdfFile)(t))<span class="cstat-no" title="statement not covered" >return t}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn null}</span>;<span class="cstat-no" title="statement not covered" >e</span>.validateRangeRequestCapabilities=function <span class="fstat-no" title="function not covered" >validateRangeRequestCapabilities(</span>{getResponseHeader:t,isHttp:e,rangeChunkSize:i,disableRange:s}){const n=<span class="cstat-no" title="statement not covered" >{allowRangeRequests:!1,suggestedLength:void 0},</span>a=<span class="cstat-no" title="statement not covered" >parseInt(t("Content-Length"),10);<span class="cstat-no" title="statement not covered" ></span>if(!Number.isInteger(a))<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >n</span></span>.suggestedLength=a;<span class="cstat-no" title="statement not covered" >i</span>f(a&lt;=2*i)<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >i</span></span>f(s||!e)<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >i</span></span>f("bytes"!==t("Accept-Ranges"))<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >i</span></span>f("identity"!==(t("Content-Encoding")||"identity"))<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >n</span></span>.allowRangeRequests=!0;<span class="cstat-no" title="statement not covered" >r</span>eturn n}</span>;<span class="cstat-no" title="statement not covered" >e</span>.validateResponseStatus=function <span class="fstat-no" title="function not covered" >validateResponseStatus(</span>t){<span class="cstat-no" title="statement not covered" >return 200===t||206===t}</span>;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(21),</span>a=<span class="cstat-no" title="statement not covered" >i(6)}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.getFilenameFromContentDispositionHeader=function <span class="fstat-no" title="function not covered" >getFilenameFromContentDispositionHeader(</span>t){let e=<span class="cstat-no" title="statement not covered" >!0,</span>i=<span class="cstat-no" title="statement not covered" >toParamRegExp("filename\\*","i").exec(t);<span class="cstat-no" title="statement not covered" ></span>if(i){<span class="cstat-no" title="statement not covered" >i=i[1];l</span>et t=<span class="cstat-no" title="statement not covered" >rfc2616unquote(i);<span class="cstat-no" title="statement not covered" ></span>t=unescape(t);<span class="cstat-no" title="statement not covered" >t</span>=rfc5987decode(t);<span class="cstat-no" title="statement not covered" >t</span>=rfc2047decode(t);<span class="cstat-no" title="statement not covered" >r</span>eturn fixupEncoding(t)}<span class="cstat-no" title="statement not covered" ></span>i</span>=function <span class="fstat-no" title="function not covered" >rfc2231getparam(</span>t){const e=<span class="cstat-no" title="statement not covered" >[];</span>let i;const s=<span class="cstat-no" title="statement not covered" >toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)","ig");<span class="cstat-no" title="statement not covered" ></span>for(;null!==(i=s.exec(t));){let[,t,s,n]=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>t=parseInt(t,10);<span class="cstat-no" title="statement not covered" >i</span>f(t in e){<span class="cstat-no" title="statement not covered" >if(0===t)<span class="cstat-no" title="statement not covered" >break}</span></span>else <span class="cstat-no" title="statement not covered" >e[t]=[s,n]}</span></span>c</span>onst n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;e.length&amp;&amp;t in e;++t){let[i,s]=<span class="cstat-no" title="statement not covered" >e[t];<span class="cstat-no" title="statement not covered" ></span>s=rfc2616unquote(s);<span class="cstat-no" title="statement not covered" >i</span>f(i){<span class="cstat-no" title="statement not covered" >s=unescape(s);<span class="cstat-no" title="statement not covered" >0</span>===t&amp;&amp;(s=rfc5987decode(s))}<span class="cstat-no" title="statement not covered" ></span>n</span>.push(s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n.join("")}</span>(t);<span class="cstat-no" title="statement not covered" >i</span>f(i){<span class="cstat-no" title="statement not covered" >return fixupEncoding(rfc2047decode(i))}<span class="cstat-no" title="statement not covered" ></span>i</span>=toParamRegExp("filename","i").exec(t);<span class="cstat-no" title="statement not covered" >i</span>f(i){<span class="cstat-no" title="statement not covered" >i=i[1];l</span>et t=<span class="cstat-no" title="statement not covered" >rfc2616unquote(i);<span class="cstat-no" title="statement not covered" ></span>t=rfc2047decode(t);<span class="cstat-no" title="statement not covered" >r</span>eturn fixupEncoding(t)}</span>f</span>unction <span class="fstat-no" title="function not covered" >toParamRegExp(</span>t,e){<span class="cstat-no" title="statement not covered" >return new RegExp("(?:^|;)\\s*"+t+'\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)',e)}</span>function <span class="fstat-no" title="function not covered" >textdecode(</span>t,i){<span class="cstat-no" title="statement not covered" >if(t){<span class="cstat-no" title="statement not covered" >if(!/^[\x00-\xFF]+$/.test(i))<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >t</span></span>ry{const n=<span class="cstat-no" title="statement not covered" >new TextDecoder(t,{fatal:!0}),</span>a=<span class="cstat-no" title="statement not covered" >(0,s.stringToBytes)(i);<span class="cstat-no" title="statement not covered" ></span>i=n.decode(a);<span class="cstat-no" title="statement not covered" >e</span>=!1}</span>catch{}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>function <span class="fstat-no" title="function not covered" >fixupEncoding(</span>t){<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;/[\x80-\xff]/.test(t)){<span class="cstat-no" title="statement not covered" >t=textdecode("utf-8",t);<span class="cstat-no" title="statement not covered" >e</span>&amp;&amp;(t=textdecode("iso-8859-1",t))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >rfc2616unquote(</span>t){<span class="cstat-no" title="statement not covered" >if(t.startsWith('"')){const e=<span class="cstat-no" title="statement not covered" >t.slice(1).split('\\"');<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;e.length;++t){const i=<span class="cstat-no" title="statement not covered" >e[t].indexOf('"');<span class="cstat-no" title="statement not covered" ></span>if(-1!==i){<span class="cstat-no" title="statement not covered" >e[t]=e[t].slice(0,i);<span class="cstat-no" title="statement not covered" >e</span>.length=t+1}<span class="cstat-no" title="statement not covered" ></span>e</span>[t]=e[t].replaceAll(/\\(.)/g,"$1")}<span class="cstat-no" title="statement not covered" ></span>t</span>=e.join('"')}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >rfc5987decode(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.indexOf("'");<span class="cstat-no" title="statement not covered" ></span>if(-1===e)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >r</span></span>eturn textdecode(t.slice(0,e),t.slice(e+1).replace(/^[^']*'/,""))}</span>function <span class="fstat-no" title="function not covered" >rfc2047decode(</span>t){<span class="cstat-no" title="statement not covered" >return!t.startsWith("=?")||/[\x00-\x19\x80-\xff]/.test(t)?t:t.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){<span class="cstat-no" title="statement not covered" >if("q"===i||"Q"===i)<span class="cstat-no" title="statement not covered" >return textdecode(e,s=(s=s.replaceAll("_"," ")).replaceAll(/=([0-9a-fA-F]{2})/g,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return String.fromCharCode(parseInt(e,16))}</span>)));<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >s=atob(s)}</span>catch{}<span class="cstat-no" title="statement not covered" >r</span>eturn textdecode(e,s)}</span>))}<span class="cstat-no" title="statement not covered" ></span>return""}</span>;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1)}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.PDFNetworkStream=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(20);</span>class NetworkManager{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this.url=t;<span class="cstat-no" title="statement not covered" >t</span>his.isHttp=/^https?:/i.test(t);<span class="cstat-no" title="statement not covered" >t</span>his.httpHeaders=this.isHttp&amp;&amp;e.httpHeaders||Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his.withCredentials=e.withCredentials||!1;<span class="cstat-no" title="statement not covered" >t</span>his.currXhrId=0;<span class="cstat-no" title="statement not covered" >t</span>his.pendingRequests=Object.create(null)}<span class="fstat-no" title="function not covered" ></span>re</span>questRange(t,e,i){const s=<span class="cstat-no" title="statement not covered" >{begin:t,end:e};<span class="cstat-no" title="statement not covered" ></span>for(const t in i)<span class="cstat-no" title="statement not covered" >s[t]=i[t];<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.request(s)}<span class="fstat-no" title="function not covered" ></span>re</span>questFull(t){<span class="cstat-no" title="statement not covered" >return this.request(t)}<span class="fstat-no" title="function not covered" ></span>re</span>quest(t){const e=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest,</span>i=<span class="cstat-no" title="statement not covered" >this.currXhrId++,</span>s=<span class="cstat-no" title="statement not covered" >this.pendingRequests[i]={xhr:e};<span class="cstat-no" title="statement not covered" ></span>e.open("GET",this.url);<span class="cstat-no" title="statement not covered" >e</span>.withCredentials=this.withCredentials;<span class="cstat-no" title="statement not covered" >f</span>or(const t in this.httpHeaders){const i=<span class="cstat-no" title="statement not covered" >this.httpHeaders[t];<span class="cstat-no" title="statement not covered" ></span>void 0!==i&amp;&amp;e.setRequestHeader(t,i)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.isHttp&amp;&amp;"begin"in t&amp;&amp;"end"in t){<span class="cstat-no" title="statement not covered" >e.setRequestHeader("Range",`bytes=${t.begin}-${t.end-1}`);<span class="cstat-no" title="statement not covered" >s</span>.expectedStatus=206}</span>else <span class="cstat-no" title="statement not covered" >s.expectedStatus=200;<span class="cstat-no" title="statement not covered" >e</span></span>.responseType="arraybuffer";<span class="cstat-no" title="statement not covered" >t</span>.onError&amp;&amp;(e.onerror=<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.onError(e.status)}</span>);<span class="cstat-no" title="statement not covered" >e</span>.onreadystatechange=this.onStateChange.bind(this,i);<span class="cstat-no" title="statement not covered" >e</span>.onprogress=this.onProgress.bind(this,i);<span class="cstat-no" title="statement not covered" >s</span>.onHeadersReceived=t.onHeadersReceived;<span class="cstat-no" title="statement not covered" >s</span>.onDone=t.onDone;<span class="cstat-no" title="statement not covered" >s</span>.onError=t.onError;<span class="cstat-no" title="statement not covered" >s</span>.onProgress=t.onProgress;<span class="cstat-no" title="statement not covered" >e</span>.send(null);<span class="cstat-no" title="statement not covered" >r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>on</span>Progress(t,e){const i=<span class="cstat-no" title="statement not covered" >this.pendingRequests[t];<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;i.onProgress?.(e)}<span class="fstat-no" title="function not covered" ></span>on</span>StateChange(t,e){const i=<span class="cstat-no" title="statement not covered" >this.pendingRequests[t];<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >i.xhr;<span class="cstat-no" title="statement not covered" ></span>if(n.readyState&gt;=2&amp;&amp;i.onHeadersReceived){<span class="cstat-no" title="statement not covered" >i.onHeadersReceived();<span class="cstat-no" title="statement not covered" >d</span>elete i.onHeadersReceived}<span class="cstat-no" title="statement not covered" ></span>i</span>f(4!==n.readyState)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!(t in this.pendingRequests))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >d</span></span>elete this.pendingRequests[t];<span class="cstat-no" title="statement not covered" >i</span>f(0===n.status&amp;&amp;this.isHttp){<span class="cstat-no" title="statement not covered" >i.onError?.(n.status);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst a=<span class="cstat-no" title="statement not covered" >n.status||200;<span class="cstat-no" title="statement not covered" ></span>if(!(200===a&amp;&amp;206===i.expectedStatus)&amp;&amp;a!==i.expectedStatus){<span class="cstat-no" title="statement not covered" >i.onError?.(n.status);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst r=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >getArrayBuffer(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.response;<span class="cstat-no" title="statement not covered" ></span>return"string"!=typeof e?e:(0,s.stringToBytes)(e).buffer}</span>(n);<span class="cstat-no" title="statement not covered" ></span>if(206===a){const t=<span class="cstat-no" title="statement not covered" >n.getResponseHeader("Content-Range"),</span>e=<span class="cstat-no" title="statement not covered" >/bytes (\d+)-(\d+)\/(\d+)/.exec(t);<span class="cstat-no" title="statement not covered" ></span>i.onDone({begin:parseInt(e[1],10),chunk:r})}</span>else <span class="cstat-no" title="statement not covered" >r?i.onDone({begin:0,chunk:r}):i.onError?.(n.status)}<span class="fstat-no" title="function not covered" ></span></span>ge</span>tRequestXhr(t){<span class="cstat-no" title="statement not covered" >return this.pendingRequests[t].xhr}<span class="fstat-no" title="function not covered" ></span>is</span>PendingRequest(t){<span class="cstat-no" title="statement not covered" >return t in this.pendingRequests}<span class="fstat-no" title="function not covered" ></span>ab</span>ortRequest(t){const e=<span class="cstat-no" title="statement not covered" >this.pendingRequests[t].xhr;<span class="cstat-no" title="statement not covered" ></span>delete this.pendingRequests[t];<span class="cstat-no" title="statement not covered" >e</span>.abort()}</span>}<span class="cstat-no" title="statement not covered" >e.PDFNetworkStream=class PDFNetworkStream{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this._source=t;<span class="cstat-no" title="statement not covered" >t</span>his._manager=new NetworkManager(t.url,{httpHeaders:t.httpHeaders,withCredentials:t.withCredentials});<span class="cstat-no" title="statement not covered" >t</span>his._rangeChunkSize=t.rangeChunkSize;<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=null;<span class="cstat-no" title="statement not covered" >t</span>his._rangeRequestReaders=[]}<span class="fstat-no" title="function not covered" ></span>_o</span>nRangeRequestReaderClosed(t){const e=<span class="cstat-no" title="statement not covered" >this._rangeRequestReaders.indexOf(t);<span class="cstat-no" title="statement not covered" ></span>e&gt;=0&amp;&amp;this._rangeRequestReaders.splice(e,1)}<span class="fstat-no" title="function not covered" ></span>ge</span>tFullReader(){<span class="cstat-no" title="statement not covered" >(0,s.assert)(!this._fullRequestReader,"PDFNetworkStream.getFullReader can only be called once.");<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=new PDFNetworkStreamFullRequestReader(this._manager,this._source);<span class="cstat-no" title="statement not covered" >r</span>eturn this._fullRequestReader}<span class="fstat-no" title="function not covered" ></span>ge</span>tRangeReader(t,e){const i=<span class="cstat-no" title="statement not covered" >new PDFNetworkStreamRangeRequestReader(this._manager,t,e);<span class="cstat-no" title="statement not covered" ></span>i.onClosed=this._onRangeRequestReaderClosed.bind(this);<span class="cstat-no" title="statement not covered" >t</span>his._rangeRequestReaders.push(i);<span class="cstat-no" title="statement not covered" >r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>ca</span>ncelAllRequests(t){<span class="cstat-no" title="statement not covered" >this._fullRequestReader?.cancel(t);<span class="cstat-no" title="statement not covered" >f</span>or(const e of this._rangeRequestReaders.slice(0))<span class="cstat-no" title="statement not covered" >e.cancel(t)}</span></span>};c</span>lass PDFNetworkStreamFullRequestReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this._manager=t;c</span>onst i=<span class="cstat-no" title="statement not covered" >{onHeadersReceived:this._onHeadersReceived.bind(this),onDone:this._onDone.bind(this),onError:this._onError.bind(this),onProgress:this._onProgress.bind(this)};<span class="cstat-no" title="statement not covered" ></span>this._url=e.url;<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestId=t.requestFull(i);<span class="cstat-no" title="statement not covered" >t</span>his._headersReceivedCapability=new s.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his._disableRange=e.disableRange||!1;<span class="cstat-no" title="statement not covered" >t</span>his._contentLength=e.length;<span class="cstat-no" title="statement not covered" >t</span>his._rangeChunkSize=e.rangeChunkSize;<span class="cstat-no" title="statement not covered" >t</span>his._rangeChunkSize||this._disableRange||(this._disableRange=!0);<span class="cstat-no" title="statement not covered" >t</span>his._isStreamingSupported=!1;<span class="cstat-no" title="statement not covered" >t</span>his._isRangeSupported=!1;<span class="cstat-no" title="statement not covered" >t</span>his._cachedChunks=[];<span class="cstat-no" title="statement not covered" >t</span>his._requests=[];<span class="cstat-no" title="statement not covered" >t</span>his._done=!1;<span class="cstat-no" title="statement not covered" >t</span>his._storedError=void 0;<span class="cstat-no" title="statement not covered" >t</span>his._filename=null;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null}<span class="fstat-no" title="function not covered" ></span>_o</span>nHeadersReceived(){const t=<span class="cstat-no" title="statement not covered" >this._fullRequestId,</span>e=<span class="cstat-no" title="statement not covered" >this._manager.getRequestXhr(t),</span>getResponseHeader=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e.getResponseHeader(t),</span></span>{allowRangeRequests:i,suggestedLength:s}=<span class="cstat-no" title="statement not covered" >(0,n.validateRangeRequestCapabilities)({getResponseHeader:getResponseHeader,isHttp:this._manager.isHttp,rangeChunkSize:this._rangeChunkSize,disableRange:this._disableRange});<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(this._isRangeSupported=!0);<span class="cstat-no" title="statement not covered" >t</span>his._contentLength=s||this._contentLength;<span class="cstat-no" title="statement not covered" >t</span>his._filename=(0,n.extractFilenameFromHeader)(getResponseHeader);<span class="cstat-no" title="statement not covered" >t</span>his._isRangeSupported&amp;&amp;this._manager.abortRequest(t);<span class="cstat-no" title="statement not covered" >t</span>his._headersReceivedCapability.resolve()}<span class="fstat-no" title="function not covered" ></span>_o</span>nDone(t){<span class="cstat-no" title="statement not covered" >if(t)<span class="cstat-no" title="statement not covered" >if(this._requests.length&gt;0){<span class="cstat-no" title="statement not covered" >this._requests.shift().resolve({value:t.chunk,done:!1})}</span>else <span class="cstat-no" title="statement not covered" >this._cachedChunks.push(t.chunk);<span class="cstat-no" title="statement not covered" >t</span></span></span>his._done=!0;<span class="cstat-no" title="statement not covered" >i</span>f(!(this._cachedChunks.length&gt;0)){<span class="cstat-no" title="statement not covered" >for(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.resolve({value:void 0,done:!0});<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0}</span>}<span class="fstat-no" title="function not covered" ></span>_o</span>nError(t){<span class="cstat-no" title="statement not covered" >this._storedError=(0,n.createResponseStatusError)(t,this._url);<span class="cstat-no" title="statement not covered" >t</span>his._headersReceivedCapability.reject(this._storedError);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.reject(this._storedError);<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0;<span class="cstat-no" title="statement not covered" >t</span>his._cachedChunks.length=0}<span class="fstat-no" title="function not covered" ></span>_o</span>nProgress(t){<span class="cstat-no" title="statement not covered" >this.onProgress?.({loaded:t.loaded,total:t.lengthComputable?t.total:this._contentLength})}<span class="fstat-no" title="function not covered" ></span>ge</span>t filename(){<span class="cstat-no" title="statement not covered" >return this._filename}<span class="fstat-no" title="function not covered" ></span>ge</span>t isRangeSupported(){<span class="cstat-no" title="statement not covered" >return this._isRangeSupported}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return this._isStreamingSupported}<span class="fstat-no" title="function not covered" ></span>ge</span>t contentLength(){<span class="cstat-no" title="statement not covered" >return this._contentLength}<span class="fstat-no" title="function not covered" ></span>ge</span>t headersReady(){<span class="cstat-no" title="statement not covered" >return this._headersReceivedCapability.promise}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >if(this._storedError)<span class="cstat-no" title="statement not covered" >throw this._storedError;<span class="cstat-no" title="statement not covered" >i</span></span>f(this._cachedChunks.length&gt;0){<span class="cstat-no" title="statement not covered" >return{value:this._cachedChunks.shift(),done:!1}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this._done)<span class="cstat-no" title="statement not covered" >return{value:void 0,done:!0};c</span></span>onst t=<span class="cstat-no" title="statement not covered" >new s.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this._requests.push(t);<span class="cstat-no" title="statement not covered" >r</span>eturn t.promise}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._done=!0;<span class="cstat-no" title="statement not covered" >t</span>his._headersReceivedCapability.reject(t);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.resolve({value:void 0,done:!0});<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0;<span class="cstat-no" title="statement not covered" >t</span>his._manager.isPendingRequest(this._fullRequestId)&amp;&amp;this._manager.abortRequest(this._fullRequestId);<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=null}</span>}class PDFNetworkStreamRangeRequestReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i){<span class="cstat-no" title="statement not covered" >this._manager=t;c</span>onst s=<span class="cstat-no" title="statement not covered" >{onDone:this._onDone.bind(this),onError:this._onError.bind(this),onProgress:this._onProgress.bind(this)};<span class="cstat-no" title="statement not covered" ></span>this._url=t.url;<span class="cstat-no" title="statement not covered" >t</span>his._requestId=t.requestRange(e,i,s);<span class="cstat-no" title="statement not covered" >t</span>his._requests=[];<span class="cstat-no" title="statement not covered" >t</span>his._queuedChunk=null;<span class="cstat-no" title="statement not covered" >t</span>his._done=!1;<span class="cstat-no" title="statement not covered" >t</span>his._storedError=void 0;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null;<span class="cstat-no" title="statement not covered" >t</span>his.onClosed=null}<span class="fstat-no" title="function not covered" ></span>_c</span>lose(){<span class="cstat-no" title="statement not covered" >this.onClosed?.(this)}<span class="fstat-no" title="function not covered" ></span>_o</span>nDone(t){const e=<span class="cstat-no" title="statement not covered" >t.chunk;<span class="cstat-no" title="statement not covered" ></span>if(this._requests.length&gt;0){<span class="cstat-no" title="statement not covered" >this._requests.shift().resolve({value:e,done:!1})}</span>else <span class="cstat-no" title="statement not covered" >this._queuedChunk=e;<span class="cstat-no" title="statement not covered" >t</span></span>his._done=!0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.resolve({value:void 0,done:!0});<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0;<span class="cstat-no" title="statement not covered" >t</span>his._close()}<span class="fstat-no" title="function not covered" ></span>_o</span>nError(t){<span class="cstat-no" title="statement not covered" >this._storedError=(0,n.createResponseStatusError)(t,this._url);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.reject(this._storedError);<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0;<span class="cstat-no" title="statement not covered" >t</span>his._queuedChunk=null}<span class="fstat-no" title="function not covered" ></span>_o</span>nProgress(t){<span class="cstat-no" title="statement not covered" >this.isStreamingSupported||this.onProgress?.({loaded:t.loaded})}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >if(this._storedError)<span class="cstat-no" title="statement not covered" >throw this._storedError;<span class="cstat-no" title="statement not covered" >i</span></span>f(null!==this._queuedChunk){const t=<span class="cstat-no" title="statement not covered" >this._queuedChunk;<span class="cstat-no" title="statement not covered" ></span>this._queuedChunk=null;<span class="cstat-no" title="statement not covered" >r</span>eturn{value:t,done:!1}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this._done)<span class="cstat-no" title="statement not covered" >return{value:void 0,done:!0};c</span></span>onst t=<span class="cstat-no" title="statement not covered" >new s.PromiseCapability;<span class="cstat-no" title="statement not covered" ></span>this._requests.push(t);<span class="cstat-no" title="statement not covered" >r</span>eturn t.promise}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._done=!0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this._requests)<span class="cstat-no" title="statement not covered" >t.resolve({value:void 0,done:!0});<span class="cstat-no" title="statement not covered" >t</span></span>his._requests.length=0;<span class="cstat-no" title="statement not covered" >t</span>his._manager.isPendingRequest(this._requestId)&amp;&amp;this._manager.abortRequest(this._requestId);<span class="cstat-no" title="statement not covered" >t</span>his._close()}</span>}},<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.PDFNodeStream=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(20);</span>const a=<span class="cstat-no" title="statement not covered" >/^file:\/\/\/[a-zA-Z]:\//;<span class="cstat-no" title="statement not covered" ></span>e.PDFNodeStream=class PDFNodeStream{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.source=t;<span class="cstat-no" title="statement not covered" >t</span>his.url=function <span class="fstat-no" title="function not covered" >parseUrl(</span>t){const e=<span class="cstat-no" title="statement not covered" >require("url"),</span>i=<span class="cstat-no" title="statement not covered" >e.parse(t);<span class="cstat-no" title="statement not covered" ></span>if("file:"===i.protocol||i.host)<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >i</span></span>f(/^[a-z]:[/\\]/i.test(t))<span class="cstat-no" title="statement not covered" >return e.parse(`file:///${t}`);<span class="cstat-no" title="statement not covered" >i</span></span>.host||(i.protocol="file:");<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>(t.url);<span class="cstat-no" title="statement not covered" >t</span>his.isHttp="http:"===this.url.protocol||"https:"===this.url.protocol;<span class="cstat-no" title="statement not covered" >t</span>his.isFsUrl="file:"===this.url.protocol;<span class="cstat-no" title="statement not covered" >t</span>his.httpHeaders=this.isHttp&amp;&amp;t.httpHeaders||{};<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=null;<span class="cstat-no" title="statement not covered" >t</span>his._rangeRequestReaders=[]}<span class="fstat-no" title="function not covered" ></span>ge</span>t _progressiveDataLength(){<span class="cstat-no" title="statement not covered" >return this._fullRequestReader?._loaded??0}<span class="fstat-no" title="function not covered" ></span>ge</span>tFullReader(){<span class="cstat-no" title="statement not covered" >(0,s.assert)(!this._fullRequestReader,"PDFNodeStream.getFullReader can only be called once.");<span class="cstat-no" title="statement not covered" >t</span>his._fullRequestReader=this.isFsUrl?new PDFNodeStreamFsFullReader(this):new PDFNodeStreamFullReader(this);<span class="cstat-no" title="statement not covered" >r</span>eturn this._fullRequestReader}<span class="fstat-no" title="function not covered" ></span>ge</span>tRangeReader(t,e){<span class="cstat-no" title="statement not covered" >if(e&lt;=this._progressiveDataLength)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.isFsUrl?new PDFNodeStreamFsRangeReader(this,t,e):new PDFNodeStreamRangeReader(this,t,e);<span class="cstat-no" title="statement not covered" ></span>this._rangeRequestReaders.push(i);<span class="cstat-no" title="statement not covered" >r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>ca</span>ncelAllRequests(t){<span class="cstat-no" title="statement not covered" >this._fullRequestReader?.cancel(t);<span class="cstat-no" title="statement not covered" >f</span>or(const e of this._rangeRequestReaders.slice(0))<span class="cstat-no" title="statement not covered" >e.cancel(t)}</span></span>};c</span>lass BaseFullReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this._url=t.url;<span class="cstat-no" title="statement not covered" >t</span>his._done=!1;<span class="cstat-no" title="statement not covered" >t</span>his._storedError=null;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null;c</span>onst e=<span class="cstat-no" title="statement not covered" >t.source;<span class="cstat-no" title="statement not covered" ></span>this._contentLength=e.length;<span class="cstat-no" title="statement not covered" >t</span>his._loaded=0;<span class="cstat-no" title="statement not covered" >t</span>his._filename=null;<span class="cstat-no" title="statement not covered" >t</span>his._disableRange=e.disableRange||!1;<span class="cstat-no" title="statement not covered" >t</span>his._rangeChunkSize=e.rangeChunkSize;<span class="cstat-no" title="statement not covered" >t</span>his._rangeChunkSize||this._disableRange||(this._disableRange=!0);<span class="cstat-no" title="statement not covered" >t</span>his._isStreamingSupported=!e.disableStream;<span class="cstat-no" title="statement not covered" >t</span>his._isRangeSupported=!e.disableRange;<span class="cstat-no" title="statement not covered" >t</span>his._readableStream=null;<span class="cstat-no" title="statement not covered" >t</span>his._readCapability=new s.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his._headersCapability=new s.PromiseCapability}<span class="fstat-no" title="function not covered" ></span>ge</span>t headersReady(){<span class="cstat-no" title="statement not covered" >return this._headersCapability.promise}<span class="fstat-no" title="function not covered" ></span>ge</span>t filename(){<span class="cstat-no" title="statement not covered" >return this._filename}<span class="fstat-no" title="function not covered" ></span>ge</span>t contentLength(){<span class="cstat-no" title="statement not covered" >return this._contentLength}<span class="fstat-no" title="function not covered" ></span>ge</span>t isRangeSupported(){<span class="cstat-no" title="statement not covered" >return this._isRangeSupported}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return this._isStreamingSupported}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >await this._readCapability.promise;<span class="cstat-no" title="statement not covered" >i</span>f(this._done)<span class="cstat-no" title="statement not covered" >return{value:void 0,done:!0};<span class="cstat-no" title="statement not covered" >i</span></span>f(this._storedError)<span class="cstat-no" title="statement not covered" >throw this._storedError;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this._readableStream.read();<span class="cstat-no" title="statement not covered" ></span>if(null===t){<span class="cstat-no" title="statement not covered" >this._readCapability=new s.PromiseCapability;<span class="cstat-no" title="statement not covered" >r</span>eturn this.read()}<span class="cstat-no" title="statement not covered" ></span>t</span>his._loaded+=t.length;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress?.({loaded:this._loaded,total:this._contentLength});<span class="cstat-no" title="statement not covered" >r</span>eturn{value:new Uint8Array(t).buffer,done:!1}}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._readableStream?this._readableStream.destroy(t):this._error(t)}<span class="fstat-no" title="function not covered" ></span>_e</span>rror(t){<span class="cstat-no" title="statement not covered" >this._storedError=t;<span class="cstat-no" title="statement not covered" >t</span>his._readCapability.resolve()}<span class="fstat-no" title="function not covered" ></span>_s</span>etReadableStream(t){<span class="cstat-no" title="statement not covered" >this._readableStream=t;<span class="cstat-no" title="statement not covered" >t</span>.on("readable",(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._readCapability.resolve()}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("end",(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.destroy();<span class="cstat-no" title="statement not covered" >t</span>his._done=!0;<span class="cstat-no" title="statement not covered" >t</span>his._readCapability.resolve()}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("error",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._error(t)}</span>));<span class="cstat-no" title="statement not covered" >!</span>this._isStreamingSupported&amp;&amp;this._isRangeSupported&amp;&amp;this._error(new s.AbortException("streaming is disabled"));<span class="cstat-no" title="statement not covered" >t</span>his._storedError&amp;&amp;this._readableStream.destroy(this._storedError)}</span>}class BaseRangeReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this._url=t.url;<span class="cstat-no" title="statement not covered" >t</span>his._done=!1;<span class="cstat-no" title="statement not covered" >t</span>his._storedError=null;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress=null;<span class="cstat-no" title="statement not covered" >t</span>his._loaded=0;<span class="cstat-no" title="statement not covered" >t</span>his._readableStream=null;<span class="cstat-no" title="statement not covered" >t</span>his._readCapability=new s.PromiseCapability;c</span>onst e=<span class="cstat-no" title="statement not covered" >t.source;<span class="cstat-no" title="statement not covered" ></span>this._isStreamingSupported=!e.disableStream}<span class="fstat-no" title="function not covered" ></span>ge</span>t isStreamingSupported(){<span class="cstat-no" title="statement not covered" >return this._isStreamingSupported}<span class="fstat-no" title="function not covered" ></span>as</span>ync read(){<span class="cstat-no" title="statement not covered" >await this._readCapability.promise;<span class="cstat-no" title="statement not covered" >i</span>f(this._done)<span class="cstat-no" title="statement not covered" >return{value:void 0,done:!0};<span class="cstat-no" title="statement not covered" >i</span></span>f(this._storedError)<span class="cstat-no" title="statement not covered" >throw this._storedError;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this._readableStream.read();<span class="cstat-no" title="statement not covered" ></span>if(null===t){<span class="cstat-no" title="statement not covered" >this._readCapability=new s.PromiseCapability;<span class="cstat-no" title="statement not covered" >r</span>eturn this.read()}<span class="cstat-no" title="statement not covered" ></span>t</span>his._loaded+=t.length;<span class="cstat-no" title="statement not covered" >t</span>his.onProgress?.({loaded:this._loaded});<span class="cstat-no" title="statement not covered" >r</span>eturn{value:new Uint8Array(t).buffer,done:!1}}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(t){<span class="cstat-no" title="statement not covered" >this._readableStream?this._readableStream.destroy(t):this._error(t)}<span class="fstat-no" title="function not covered" ></span>_e</span>rror(t){<span class="cstat-no" title="statement not covered" >this._storedError=t;<span class="cstat-no" title="statement not covered" >t</span>his._readCapability.resolve()}<span class="fstat-no" title="function not covered" ></span>_s</span>etReadableStream(t){<span class="cstat-no" title="statement not covered" >this._readableStream=t;<span class="cstat-no" title="statement not covered" >t</span>.on("readable",(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._readCapability.resolve()}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("end",(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.destroy();<span class="cstat-no" title="statement not covered" >t</span>his._done=!0;<span class="cstat-no" title="statement not covered" >t</span>his._readCapability.resolve()}</span>));<span class="cstat-no" title="statement not covered" >t</span>.on("error",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._error(t)}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._storedError&amp;&amp;this._readableStream.destroy(this._storedError)}</span>}function <span class="fstat-no" title="function not covered" >createRequestOptions(</span>t,e){<span class="cstat-no" title="statement not covered" >return{protocol:t.protocol,auth:t.auth,host:t.hostname,port:t.port,path:t.path,method:"GET",headers:e}}</span>class PDFNodeStreamFullReader extends BaseFullReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t);c</span>onst handleResponse=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(404===e.statusCode){const t=<span class="cstat-no" title="statement not covered" >new s.MissingPDFException(`Missing PDF "${this._url}".`);<span class="cstat-no" title="statement not covered" ></span>this._storedError=t;<span class="cstat-no" title="statement not covered" >t</span>his._headersCapability.reject(t);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his._headersCapability.resolve();<span class="cstat-no" title="statement not covered" >t</span>his._setReadableStream(e);c</span>onst getResponseHeader=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this._readableStream.headers[t.toLowerCase()],</span></span>{allowRangeRequests:i,suggestedLength:a}=<span class="cstat-no" title="statement not covered" >(0,n.validateRangeRequestCapabilities)({getResponseHeader:getResponseHeader,isHttp:t.isHttp,rangeChunkSize:this._rangeChunkSize,disableRange:this._disableRange});<span class="cstat-no" title="statement not covered" ></span>this._isRangeSupported=i;<span class="cstat-no" title="statement not covered" >t</span>his._contentLength=a||this._contentLength;<span class="cstat-no" title="statement not covered" >t</span>his._filename=(0,n.extractFilenameFromHeader)(getResponseHeader)}</span>;<span class="cstat-no" title="statement not covered" ></span>this._request=null;<span class="cstat-no" title="statement not covered" >i</span>f("http:"===this._url.protocol){const e=<span class="cstat-no" title="statement not covered" >require("http");<span class="cstat-no" title="statement not covered" ></span>this._request=e.request(createRequestOptions(this._url,t.httpHeaders),handleResponse)}</span>else{const e=<span class="cstat-no" title="statement not covered" >require("https");<span class="cstat-no" title="statement not covered" ></span>this._request=e.request(createRequestOptions(this._url,t.httpHeaders),handleResponse)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._request.on("error",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._storedError=t;<span class="cstat-no" title="statement not covered" >t</span>his._headersCapability.reject(t)}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._request.end()}</span>}class PDFNodeStreamRangeReader extends BaseRangeReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i){<span class="cstat-no" title="statement not covered" >super(t);<span class="cstat-no" title="statement not covered" >t</span>his._httpHeaders={};<span class="cstat-no" title="statement not covered" >f</span>or(const e in t.httpHeaders){const i=<span class="cstat-no" title="statement not covered" >t.httpHeaders[e];<span class="cstat-no" title="statement not covered" ></span>void 0!==i&amp;&amp;(this._httpHeaders[e]=i)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._httpHeaders.Range=`bytes=${e}-${i-1}`;c</span>onst handleResponse=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(404!==t.statusCode)<span class="cstat-no" title="statement not covered" >this._setReadableStream(t);e</span>lse{const t=<span class="cstat-no" title="statement not covered" >new s.MissingPDFException(`Missing PDF "${this._url}".`);<span class="cstat-no" title="statement not covered" ></span>this._storedError=t}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>this._request=null;<span class="cstat-no" title="statement not covered" >i</span>f("http:"===this._url.protocol){const t=<span class="cstat-no" title="statement not covered" >require("http");<span class="cstat-no" title="statement not covered" ></span>this._request=t.request(createRequestOptions(this._url,this._httpHeaders),handleResponse)}</span>else{const t=<span class="cstat-no" title="statement not covered" >require("https");<span class="cstat-no" title="statement not covered" ></span>this._request=t.request(createRequestOptions(this._url,this._httpHeaders),handleResponse)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._request.on("error",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._storedError=t}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._request.end()}</span>}class PDFNodeStreamFsFullReader extends BaseFullReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t);l</span>et e=<span class="cstat-no" title="statement not covered" >decodeURIComponent(this._url.path);<span class="cstat-no" title="statement not covered" ></span>a.test(this._url.href)&amp;&amp;(e=e.replace(/^\//,""));c</span>onst i=<span class="cstat-no" title="statement not covered" >require("fs");<span class="cstat-no" title="statement not covered" ></span>i.lstat(e,(<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >if(t){<span class="cstat-no" title="statement not covered" >"ENOENT"===t.code&amp;&amp;(t=new s.MissingPDFException(`Missing PDF "${e}".`));<span class="cstat-no" title="statement not covered" >t</span>his._storedError=t;<span class="cstat-no" title="statement not covered" >t</span>his._headersCapability.reject(t)}</span>else{<span class="cstat-no" title="statement not covered" >this._contentLength=n.size;<span class="cstat-no" title="statement not covered" >t</span>his._setReadableStream(i.createReadStream(e));<span class="cstat-no" title="statement not covered" >t</span>his._headersCapability.resolve()}</span>}</span>))}</span>}class PDFNodeStreamFsRangeReader extends BaseRangeReader{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i){<span class="cstat-no" title="statement not covered" >super(t);l</span>et s=<span class="cstat-no" title="statement not covered" >decodeURIComponent(this._url.path);<span class="cstat-no" title="statement not covered" ></span>a.test(this._url.href)&amp;&amp;(s=s.replace(/^\//,""));c</span>onst n=<span class="cstat-no" title="statement not covered" >require("fs");<span class="cstat-no" title="statement not covered" ></span>this._setReadableStream(n.createReadStream(s,{start:e,end:i-1}))}</span>}},<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.SVGGraphics=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(6),</span>n=<span class="cstat-no" title="statement not covered" >i(1);</span>const a=<span class="cstat-no" title="statement not covered" >"normal",</span>r=<span class="cstat-no" title="statement not covered" >"normal",</span>o=<span class="cstat-no" title="statement not covered" >"#000000",</span>l=<span class="cstat-no" title="statement not covered" >["butt","round","square"],</span>c=<span class="cstat-no" title="statement not covered" >["miter","round","bevel"],</span>createObjectURL=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >"",</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(URL.createObjectURL&amp;&amp;"undefined"!=typeof Blob&amp;&amp;!i)<span class="cstat-no" title="statement not covered" >return URL.createObjectURL(new Blob([t],{type:e}));c</span></span>onst s=<span class="cstat-no" title="statement not covered" >"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";</span>let n=<span class="cstat-no" title="statement not covered" >`data:${e};base64,`;<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;i;e+=3){const a=<span class="cstat-no" title="statement not covered" >255&amp;t[e],</span>r=<span class="cstat-no" title="statement not covered" >255&amp;t[e+1],</span>o=<span class="cstat-no" title="statement not covered" >255&amp;t[e+2];<span class="cstat-no" title="statement not covered" ></span>n+=s[a&gt;&gt;2]+s[(3&amp;a)&lt;&lt;4|r&gt;&gt;4]+s[e+1&lt;i?(15&amp;r)&lt;&lt;2|o&gt;&gt;6:64]+s[e+2&lt;i?63&amp;o:64]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>,</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){const t=<span class="cstat-no" title="statement not covered" >new Uint8Array([137,80,78,71,13,10,26,10]),</span>e=<span class="cstat-no" title="statement not covered" >new Int32Array(256);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;256;t++){let i=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;8;t++)<span class="cstat-no" title="statement not covered" >i=1&amp;i?3988292384^i&gt;&gt;1&amp;2147483647:i&gt;&gt;1&amp;2147483647;<span class="cstat-no" title="statement not covered" >e</span></span>[t]=i}</span>f</span>unction <span class="fstat-no" title="function not covered" >writePngChunk(</span>t,i,s,n){let a=<span class="cstat-no" title="statement not covered" >n;</span>const r=<span class="cstat-no" title="statement not covered" >i.length;<span class="cstat-no" title="statement not covered" ></span>s[a]=r&gt;&gt;24&amp;255;<span class="cstat-no" title="statement not covered" >s</span>[a+1]=r&gt;&gt;16&amp;255;<span class="cstat-no" title="statement not covered" >s</span>[a+2]=r&gt;&gt;8&amp;255;<span class="cstat-no" title="statement not covered" >s</span>[a+3]=255&amp;r;<span class="cstat-no" title="statement not covered" >a</span>+=4;<span class="cstat-no" title="statement not covered" >s</span>[a]=255&amp;t.charCodeAt(0);<span class="cstat-no" title="statement not covered" >s</span>[a+1]=255&amp;t.charCodeAt(1);<span class="cstat-no" title="statement not covered" >s</span>[a+2]=255&amp;t.charCodeAt(2);<span class="cstat-no" title="statement not covered" >s</span>[a+3]=255&amp;t.charCodeAt(3);<span class="cstat-no" title="statement not covered" >a</span>+=4;<span class="cstat-no" title="statement not covered" >s</span>.set(i,a);<span class="cstat-no" title="statement not covered" >a</span>+=i.length;c</span>onst o=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >crc32(</span>t,i,s){let n=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >i;</span>a&lt;s;a++){const i=<span class="cstat-no" title="statement not covered" >255&amp;(n^t[a]);<span class="cstat-no" title="statement not covered" ></span>n=n&gt;&gt;&gt;8^e[i]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn-1^n}</span>(s,n+4,a);<span class="cstat-no" title="statement not covered" ></span>s[a]=o&gt;&gt;24&amp;255;<span class="cstat-no" title="statement not covered" >s</span>[a+1]=o&gt;&gt;16&amp;255;<span class="cstat-no" title="statement not covered" >s</span>[a+2]=o&gt;&gt;8&amp;255;<span class="cstat-no" title="statement not covered" >s</span>[a+3]=255&amp;o}</span>function <span class="fstat-no" title="function not covered" >deflateSyncUncompressed(</span>t){let e=<span class="cstat-no" title="statement not covered" >t.length;</span>const i=<span class="cstat-no" title="statement not covered" >65535,</span>s=<span class="cstat-no" title="statement not covered" >Math.ceil(e/i),</span>n=<span class="cstat-no" title="statement not covered" >new Uint8Array(2+e+5*s+4);</span>let a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>n[a++]=120;<span class="cstat-no" title="statement not covered" >n</span>[a++]=156;l</span>et r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;e&gt;i;){<span class="cstat-no" title="statement not covered" >n[a++]=0;<span class="cstat-no" title="statement not covered" >n</span>[a++]=255;<span class="cstat-no" title="statement not covered" >n</span>[a++]=255;<span class="cstat-no" title="statement not covered" >n</span>[a++]=0;<span class="cstat-no" title="statement not covered" >n</span>[a++]=0;<span class="cstat-no" title="statement not covered" >n</span>.set(t.subarray(r,r+i),a);<span class="cstat-no" title="statement not covered" >a</span>+=i;<span class="cstat-no" title="statement not covered" >r</span>+=i;<span class="cstat-no" title="statement not covered" >e</span>-=i}<span class="cstat-no" title="statement not covered" ></span>n</span>[a++]=1;<span class="cstat-no" title="statement not covered" >n</span>[a++]=255&amp;e;<span class="cstat-no" title="statement not covered" >n</span>[a++]=e&gt;&gt;8&amp;255;<span class="cstat-no" title="statement not covered" >n</span>[a++]=255&amp;~e;<span class="cstat-no" title="statement not covered" >n</span>[a++]=(65535&amp;~e)&gt;&gt;8&amp;255;<span class="cstat-no" title="statement not covered" >n</span>.set(t.subarray(r),a);<span class="cstat-no" title="statement not covered" >a</span>+=t.length-r;c</span>onst o=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >adler32(</span>t,e,i){let s=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >e;</span>a&lt;i;++a){<span class="cstat-no" title="statement not covered" >s=(s+(255&amp;t[a]))%65521;<span class="cstat-no" title="statement not covered" >n</span>=(n+s)%65521}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n&lt;&lt;16|s}</span>(t,0,t.length);<span class="cstat-no" title="statement not covered" ></span>n[a++]=o&gt;&gt;24&amp;255;<span class="cstat-no" title="statement not covered" >n</span>[a++]=o&gt;&gt;16&amp;255;<span class="cstat-no" title="statement not covered" >n</span>[a++]=o&gt;&gt;8&amp;255;<span class="cstat-no" title="statement not covered" >n</span>[a++]=255&amp;o;<span class="cstat-no" title="statement not covered" >r</span>eturn n}</span>function <span class="fstat-no" title="function not covered" >encode(</span>e,i,s,a){const r=<span class="cstat-no" title="statement not covered" >e.width,</span>o=<span class="cstat-no" title="statement not covered" >e.height;</span>let l,c,h;const d=<span class="cstat-no" title="statement not covered" >e.data;<span class="cstat-no" title="statement not covered" ></span>switch(i){case n.ImageKind.GRAYSCALE_1BPP:<span class="cstat-no" title="statement not covered" >c=0;<span class="cstat-no" title="statement not covered" >l</span>=1;<span class="cstat-no" title="statement not covered" >h</span>=r+7&gt;&gt;3;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.ImageKind.RGB_24BPP:<span class="cstat-no" title="statement not covered" >c=2;<span class="cstat-no" title="statement not covered" >l</span>=8;<span class="cstat-no" title="statement not covered" >h</span>=3*r;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.ImageKind.RGBA_32BPP:<span class="cstat-no" title="statement not covered" >c=6;<span class="cstat-no" title="statement not covered" >l</span>=8;<span class="cstat-no" title="statement not covered" >h</span>=4*r;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("invalid format")}</span>c</span>onst u=<span class="cstat-no" title="statement not covered" >new Uint8Array((1+h)*o);</span>let p=<span class="cstat-no" title="statement not covered" >0,</span>g=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;o;++t){<span class="cstat-no" title="statement not covered" >u[p++]=0;<span class="cstat-no" title="statement not covered" >u</span>.set(d.subarray(g,g+h),p);<span class="cstat-no" title="statement not covered" >g</span>+=h;<span class="cstat-no" title="statement not covered" >p</span>+=h}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i===n.ImageKind.GRAYSCALE_1BPP&amp;&amp;a){<span class="cstat-no" title="statement not covered" >p=0;<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;o;t++){<span class="cstat-no" title="statement not covered" >p++;<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;h;t++)<span class="cstat-no" title="statement not covered" >u[p++]^=255}</span></span>}</span>c</span>onst m=<span class="cstat-no" title="statement not covered" >new Uint8Array([r&gt;&gt;24&amp;255,r&gt;&gt;16&amp;255,r&gt;&gt;8&amp;255,255&amp;r,o&gt;&gt;24&amp;255,o&gt;&gt;16&amp;255,o&gt;&gt;8&amp;255,255&amp;o,l,c,0,0,0]),</span>f=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >deflateSync(</span>t){<span class="cstat-no" title="statement not covered" >if(!n.isNodeJS)<span class="cstat-no" title="statement not covered" >return deflateSyncUncompressed(t);<span class="cstat-no" title="statement not covered" >t</span></span>ry{const e=<span class="cstat-no" title="statement not covered" >parseInt(process.versions.node)&gt;=8?t:Buffer.from(t),</span>i=<span class="cstat-no" title="statement not covered" >require("zlib").deflateSync(e,{level:9});<span class="cstat-no" title="statement not covered" ></span>return i instanceof Uint8Array?i:new Uint8Array(i)}</span>catch(t){<span class="cstat-no" title="statement not covered" >(0,n.warn)("Not compressing PNG because zlib.deflateSync is unavailable: "+t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn deflateSyncUncompressed(t)}</span>(u),</span>b=<span class="cstat-no" title="statement not covered" >t.length+36+m.length+f.length,</span>A=<span class="cstat-no" title="statement not covered" >new Uint8Array(b);</span>let _=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>A.set(t,_);<span class="cstat-no" title="statement not covered" >_</span>+=t.length;<span class="cstat-no" title="statement not covered" >w</span>ritePngChunk("IHDR",m,A,_);<span class="cstat-no" title="statement not covered" >_</span>+=12+m.length;<span class="cstat-no" title="statement not covered" >w</span>ritePngChunk("IDATA",f,A,_);<span class="cstat-no" title="statement not covered" >_</span>+=12+f.length;<span class="cstat-no" title="statement not covered" >w</span>ritePngChunk("IEND",new Uint8Array(0),A,_);<span class="cstat-no" title="statement not covered" >r</span>eturn createObjectURL(A,"image/png",s)}<span class="cstat-no" title="statement not covered" ></span>return function <span class="fstat-no" title="function not covered" >convertImgDataToPng(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return encode(t,void 0===t.kind?n.ImageKind.GRAYSCALE_1BPP:t.kind,e,i)}</span>}</span>();</span>class SVGExtraState{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.fontSizeScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.fontWeight=r;<span class="cstat-no" title="statement not covered" >t</span>his.fontSize=0;<span class="cstat-no" title="statement not covered" >t</span>his.textMatrix=n.IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>his.fontMatrix=n.FONT_IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>his.leading=0;<span class="cstat-no" title="statement not covered" >t</span>his.textRenderingMode=n.TextRenderingMode.FILL;<span class="cstat-no" title="statement not covered" >t</span>his.textMatrixScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.x=0;<span class="cstat-no" title="statement not covered" >t</span>his.y=0;<span class="cstat-no" title="statement not covered" >t</span>his.lineX=0;<span class="cstat-no" title="statement not covered" >t</span>his.lineY=0;<span class="cstat-no" title="statement not covered" >t</span>his.charSpacing=0;<span class="cstat-no" title="statement not covered" >t</span>his.wordSpacing=0;<span class="cstat-no" title="statement not covered" >t</span>his.textHScale=1;<span class="cstat-no" title="statement not covered" >t</span>his.textRise=0;<span class="cstat-no" title="statement not covered" >t</span>his.fillColor=o;<span class="cstat-no" title="statement not covered" >t</span>his.strokeColor="#000000";<span class="cstat-no" title="statement not covered" >t</span>his.fillAlpha=1;<span class="cstat-no" title="statement not covered" >t</span>his.strokeAlpha=1;<span class="cstat-no" title="statement not covered" >t</span>his.lineWidth=1;<span class="cstat-no" title="statement not covered" >t</span>his.lineJoin="";<span class="cstat-no" title="statement not covered" >t</span>his.lineCap="";<span class="cstat-no" title="statement not covered" >t</span>his.miterLimit=0;<span class="cstat-no" title="statement not covered" >t</span>his.dashArray=[];<span class="cstat-no" title="statement not covered" >t</span>his.dashPhase=0;<span class="cstat-no" title="statement not covered" >t</span>his.dependencies=[];<span class="cstat-no" title="statement not covered" >t</span>his.activeClipUrl=null;<span class="cstat-no" title="statement not covered" >t</span>his.clipGroup=null;<span class="cstat-no" title="statement not covered" >t</span>his.maskId=""}<span class="fstat-no" title="function not covered" ></span>cl</span>one(){<span class="cstat-no" title="statement not covered" >return Object.create(this)}<span class="fstat-no" title="function not covered" ></span>se</span>tCurrentPoint(t,e){<span class="cstat-no" title="statement not covered" >this.x=t;<span class="cstat-no" title="statement not covered" >t</span>his.y=e}</span>}function <span class="fstat-no" title="function not covered" >pf(</span>t){<span class="cstat-no" title="statement not covered" >if(Number.isInteger(t))<span class="cstat-no" title="statement not covered" >return t.toString();c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t.toFixed(10);</span>let i=<span class="cstat-no" title="statement not covered" >e.length-1;<span class="cstat-no" title="statement not covered" ></span>if("0"!==e[i])<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >d</span></span>o{<span class="cstat-no" title="statement not covered" >i--}</span>while("0"===e[i]);<span class="cstat-no" title="statement not covered" >r</span>eturn e.substring(0,"."===e[i]?i:i+1)}</span>function <span class="fstat-no" title="function not covered" >pm(</span>t){<span class="cstat-no" title="statement not covered" >if(0===t[4]&amp;&amp;0===t[5]){<span class="cstat-no" title="statement not covered" >if(0===t[1]&amp;&amp;0===t[2])<span class="cstat-no" title="statement not covered" >return 1===t[0]&amp;&amp;1===t[3]?"":`scale(${pf(t[0])} ${pf(t[3])})`;<span class="cstat-no" title="statement not covered" >i</span></span>f(t[0]===t[3]&amp;&amp;t[1]===-t[2]){<span class="cstat-no" title="statement not covered" >return`rotate(${pf(180*Math.acos(t[0])/Math.PI)})`}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(1===t[0]&amp;&amp;0===t[1]&amp;&amp;0===t[2]&amp;&amp;1===t[3])<span class="cstat-no" title="statement not covered" >return`translate(${pf(t[4])} ${pf(t[5])})`;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn`matrix(${pf(t[0])} ${pf(t[1])} ${pf(t[2])} ${pf(t[3])} ${pf(t[4])} ${pf(t[5])})`}</span>let d=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >0,</span>p=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>e.SVGGraphics=class SVGGraphics{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >(0,s.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future.");<span class="cstat-no" title="statement not covered" >t</span>his.svgFactory=new s.DOMSVGFactory;<span class="cstat-no" title="statement not covered" >t</span>his.current=new SVGExtraState;<span class="cstat-no" title="statement not covered" >t</span>his.transformMatrix=n.IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>his.transformStack=[];<span class="cstat-no" title="statement not covered" >t</span>his.extraStack=[];<span class="cstat-no" title="statement not covered" >t</span>his.commonObjs=t;<span class="cstat-no" title="statement not covered" >t</span>his.objs=e;<span class="cstat-no" title="statement not covered" >t</span>his.pendingClip=null;<span class="cstat-no" title="statement not covered" >t</span>his.pendingEOFill=!1;<span class="cstat-no" title="statement not covered" >t</span>his.embedFonts=!1;<span class="cstat-no" title="statement not covered" >t</span>his.embeddedFonts=Object.create(null);<span class="cstat-no" title="statement not covered" >t</span>his.cssStyle=null;<span class="cstat-no" title="statement not covered" >t</span>his.forceDataSchema=!!i;<span class="cstat-no" title="statement not covered" >t</span>his._operatorIdMapping=[];<span class="cstat-no" title="statement not covered" >f</span>or(const t in n.OPS)<span class="cstat-no" title="statement not covered" >this._operatorIdMapping[n.OPS[t]]=t}<span class="fstat-no" title="function not covered" ></span></span>ge</span>tObject(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >return"string"==typeof t?t.startsWith("g_")?this.commonObjs.get(t):this.objs.get(t):e}<span class="fstat-no" title="function not covered" ></span>sa</span>ve(){<span class="cstat-no" title="statement not covered" >this.transformStack.push(this.transformMatrix);c</span>onst t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>this.extraStack.push(t);<span class="cstat-no" title="statement not covered" >t</span>his.current=t.clone()}<span class="fstat-no" title="function not covered" ></span>re</span>store(){<span class="cstat-no" title="statement not covered" >this.transformMatrix=this.transformStack.pop();<span class="cstat-no" title="statement not covered" >t</span>his.current=this.extraStack.pop();<span class="cstat-no" title="statement not covered" >t</span>his.pendingClip=null;<span class="cstat-no" title="statement not covered" >t</span>his.tgrp=null}<span class="fstat-no" title="function not covered" ></span>gr</span>oup(t){<span class="cstat-no" title="statement not covered" >this.save();<span class="cstat-no" title="statement not covered" >t</span>his.executeOpTree(t);<span class="cstat-no" title="statement not covered" >t</span>his.restore()}<span class="fstat-no" title="function not covered" ></span>lo</span>adDependencies(t){const e=<span class="cstat-no" title="statement not covered" >t.fnArray,</span>i=<span class="cstat-no" title="statement not covered" >t.argsArray;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >e.length;</span>t&lt;s;t++)<span class="cstat-no" title="statement not covered" >if(e[t]===n.OPS.dependency)<span class="cstat-no" title="statement not covered" >for(const e of i[t]){const t=<span class="cstat-no" title="statement not covered" >e.startsWith("g_")?this.commonObjs:this.objs,</span>i=<span class="cstat-no" title="statement not covered" >new Promise((<span class="fstat-no" title="function not covered" >i=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.get(e,i)}</span>));<span class="cstat-no" title="statement not covered" ></span>this.current.dependencies.push(i)}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn Promise.all(this.current.dependencies)}<span class="fstat-no" title="function not covered" ></span>tr</span>ansform(t,e,i,s,a,r){const o=<span class="cstat-no" title="statement not covered" >[t,e,i,s,a,r];<span class="cstat-no" title="statement not covered" ></span>this.transformMatrix=n.Util.transform(this.transformMatrix,o);<span class="cstat-no" title="statement not covered" >t</span>his.tgrp=null}<span class="fstat-no" title="function not covered" ></span>ge</span>tSVG(t,e){<span class="cstat-no" title="statement not covered" >this.viewport=e;c</span>onst i=<span class="cstat-no" title="statement not covered" >this._initialize(e);<span class="cstat-no" title="statement not covered" ></span>return this.loadDependencies(t).then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.transformMatrix=n.IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>his.executeOpTree(this.convertOpList(t));<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>))}<span class="fstat-no" title="function not covered" ></span>co</span>nvertOpList(t){const e=<span class="cstat-no" title="statement not covered" >this._operatorIdMapping,</span>i=<span class="cstat-no" title="statement not covered" >t.argsArray,</span>s=<span class="cstat-no" title="statement not covered" >t.fnArray,</span>n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >s.length;</span>t&lt;a;t++){const a=<span class="cstat-no" title="statement not covered" >s[t];<span class="cstat-no" title="statement not covered" ></span>n.push({fnId:a,fn:e[a],args:i[t]})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn function <span class="fstat-no" title="function not covered" >opListToTree(</span>t){let e=<span class="cstat-no" title="statement not covered" >[];</span>const i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const s of t)<span class="cstat-no" title="statement not covered" >if("save"!==s.fn)<span class="cstat-no" title="statement not covered" >"restore"===s.fn?e=i.pop():e.push(s);e</span>lse{<span class="cstat-no" title="statement not covered" >e.push({fnId:92,fn:"group",items:[]});<span class="cstat-no" title="statement not covered" >i</span>.push(e);<span class="cstat-no" title="statement not covered" >e</span>=e.at(-1).items}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn e}</span>(n)}<span class="fstat-no" title="function not covered" ></span>ex</span>ecuteOpTree(t){<span class="cstat-no" title="statement not covered" >for(const e of t){const t=<span class="cstat-no" title="statement not covered" >e.fn,</span>i=<span class="cstat-no" title="statement not covered" >e.fnId,</span>s=<span class="cstat-no" title="statement not covered" >e.args;<span class="cstat-no" title="statement not covered" ></span>switch(0|i){case n.OPS.beginText:<span class="cstat-no" title="statement not covered" >this.beginText();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.dependency:<span class="cstat-no" title="statement not covered" >break;c</span>ase n.OPS.setLeading:<span class="cstat-no" title="statement not covered" >this.setLeading(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setLeadingMoveText:<span class="cstat-no" title="statement not covered" >this.setLeadingMoveText(s[0],s[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setFont:<span class="cstat-no" title="statement not covered" >this.setFont(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.showText:case n.OPS.showSpacedText:<span class="cstat-no" title="statement not covered" >this.showText(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.endText:<span class="cstat-no" title="statement not covered" >this.endText();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.moveText:<span class="cstat-no" title="statement not covered" >this.moveText(s[0],s[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setCharSpacing:<span class="cstat-no" title="statement not covered" >this.setCharSpacing(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setWordSpacing:<span class="cstat-no" title="statement not covered" >this.setWordSpacing(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setHScale:<span class="cstat-no" title="statement not covered" >this.setHScale(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setTextMatrix:<span class="cstat-no" title="statement not covered" >this.setTextMatrix(s[0],s[1],s[2],s[3],s[4],s[5]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setTextRise:<span class="cstat-no" title="statement not covered" >this.setTextRise(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setTextRenderingMode:<span class="cstat-no" title="statement not covered" >this.setTextRenderingMode(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setLineWidth:<span class="cstat-no" title="statement not covered" >this.setLineWidth(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setLineJoin:<span class="cstat-no" title="statement not covered" >this.setLineJoin(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setLineCap:<span class="cstat-no" title="statement not covered" >this.setLineCap(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setMiterLimit:<span class="cstat-no" title="statement not covered" >this.setMiterLimit(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setFillRGBColor:<span class="cstat-no" title="statement not covered" >this.setFillRGBColor(s[0],s[1],s[2]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setStrokeRGBColor:<span class="cstat-no" title="statement not covered" >this.setStrokeRGBColor(s[0],s[1],s[2]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setStrokeColorN:<span class="cstat-no" title="statement not covered" >this.setStrokeColorN(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setFillColorN:<span class="cstat-no" title="statement not covered" >this.setFillColorN(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.shadingFill:<span class="cstat-no" title="statement not covered" >this.shadingFill(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setDash:<span class="cstat-no" title="statement not covered" >this.setDash(s[0],s[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setRenderingIntent:<span class="cstat-no" title="statement not covered" >this.setRenderingIntent(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setFlatness:<span class="cstat-no" title="statement not covered" >this.setFlatness(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.setGState:<span class="cstat-no" title="statement not covered" >this.setGState(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.fill:<span class="cstat-no" title="statement not covered" >this.fill();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.eoFill:<span class="cstat-no" title="statement not covered" >this.eoFill();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.stroke:<span class="cstat-no" title="statement not covered" >this.stroke();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.fillStroke:<span class="cstat-no" title="statement not covered" >this.fillStroke();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.eoFillStroke:<span class="cstat-no" title="statement not covered" >this.eoFillStroke();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.clip:<span class="cstat-no" title="statement not covered" >this.clip("nonzero");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.eoClip:<span class="cstat-no" title="statement not covered" >this.clip("evenodd");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.paintSolidColorImageMask:<span class="cstat-no" title="statement not covered" >this.paintSolidColorImageMask();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.paintImageXObject:<span class="cstat-no" title="statement not covered" >this.paintImageXObject(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.paintInlineImageXObject:<span class="cstat-no" title="statement not covered" >this.paintInlineImageXObject(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.paintImageMaskXObject:<span class="cstat-no" title="statement not covered" >this.paintImageMaskXObject(s[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.paintFormXObjectBegin:<span class="cstat-no" title="statement not covered" >this.paintFormXObjectBegin(s[0],s[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.paintFormXObjectEnd:<span class="cstat-no" title="statement not covered" >this.paintFormXObjectEnd();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.closePath:<span class="cstat-no" title="statement not covered" >this.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.closeStroke:<span class="cstat-no" title="statement not covered" >this.closeStroke();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.closeFillStroke:<span class="cstat-no" title="statement not covered" >this.closeFillStroke();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.closeEOFillStroke:<span class="cstat-no" title="statement not covered" >this.closeEOFillStroke();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.nextLine:<span class="cstat-no" title="statement not covered" >this.nextLine();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.transform:<span class="cstat-no" title="statement not covered" >this.transform(s[0],s[1],s[2],s[3],s[4],s[5]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.constructPath:<span class="cstat-no" title="statement not covered" >this.constructPath(s[0],s[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.endPath:<span class="cstat-no" title="statement not covered" >this.endPath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 92:<span class="cstat-no" title="statement not covered" >this.group(e.items);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >(0,n.warn)(`Unimplemented operator ${t}`)}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tWordSpacing(t){<span class="cstat-no" title="statement not covered" >this.current.wordSpacing=t}<span class="fstat-no" title="function not covered" ></span>se</span>tCharSpacing(t){<span class="cstat-no" title="statement not covered" >this.current.charSpacing=t}<span class="fstat-no" title="function not covered" ></span>ne</span>xtLine(){<span class="cstat-no" title="statement not covered" >this.moveText(0,this.current.leading)}<span class="fstat-no" title="function not covered" ></span>se</span>tTextMatrix(t,e,i,s,n,a){const r=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>r.textMatrix=r.lineMatrix=[t,e,i,s,n,a];<span class="cstat-no" title="statement not covered" >r</span>.textMatrixScale=Math.hypot(t,e);<span class="cstat-no" title="statement not covered" >r</span>.x=r.lineX=0;<span class="cstat-no" title="statement not covered" >r</span>.y=r.lineY=0;<span class="cstat-no" title="statement not covered" >r</span>.xcoords=[];<span class="cstat-no" title="statement not covered" >r</span>.ycoords=[];<span class="cstat-no" title="statement not covered" >r</span>.tspan=this.svgFactory.createElement("svg:tspan");<span class="cstat-no" title="statement not covered" >r</span>.tspan.setAttributeNS(null,"font-family",r.fontFamily);<span class="cstat-no" title="statement not covered" >r</span>.tspan.setAttributeNS(null,"font-size",`${pf(r.fontSize)}px`);<span class="cstat-no" title="statement not covered" >r</span>.tspan.setAttributeNS(null,"y",pf(-r.y));<span class="cstat-no" title="statement not covered" >r</span>.txtElement=this.svgFactory.createElement("svg:text");<span class="cstat-no" title="statement not covered" >r</span>.txtElement.append(r.tspan)}<span class="fstat-no" title="function not covered" ></span>be</span>ginText(){const t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>t.x=t.lineX=0;<span class="cstat-no" title="statement not covered" >t</span>.y=t.lineY=0;<span class="cstat-no" title="statement not covered" >t</span>.textMatrix=n.IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>.lineMatrix=n.IDENTITY_MATRIX;<span class="cstat-no" title="statement not covered" >t</span>.textMatrixScale=1;<span class="cstat-no" title="statement not covered" >t</span>.tspan=this.svgFactory.createElement("svg:tspan");<span class="cstat-no" title="statement not covered" >t</span>.txtElement=this.svgFactory.createElement("svg:text");<span class="cstat-no" title="statement not covered" >t</span>.txtgrp=this.svgFactory.createElement("svg:g");<span class="cstat-no" title="statement not covered" >t</span>.xcoords=[];<span class="cstat-no" title="statement not covered" >t</span>.ycoords=[]}<span class="fstat-no" title="function not covered" ></span>mo</span>veText(t,e){const i=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>i.x=i.lineX+=t;<span class="cstat-no" title="statement not covered" >i</span>.y=i.lineY+=e;<span class="cstat-no" title="statement not covered" >i</span>.xcoords=[];<span class="cstat-no" title="statement not covered" >i</span>.ycoords=[];<span class="cstat-no" title="statement not covered" >i</span>.tspan=this.svgFactory.createElement("svg:tspan");<span class="cstat-no" title="statement not covered" >i</span>.tspan.setAttributeNS(null,"font-family",i.fontFamily);<span class="cstat-no" title="statement not covered" >i</span>.tspan.setAttributeNS(null,"font-size",`${pf(i.fontSize)}px`);<span class="cstat-no" title="statement not covered" >i</span>.tspan.setAttributeNS(null,"y",pf(-i.y))}<span class="fstat-no" title="function not covered" ></span>sh</span>owText(t){const e=<span class="cstat-no" title="statement not covered" >this.current,</span>i=<span class="cstat-no" title="statement not covered" >e.font,</span>s=<span class="cstat-no" title="statement not covered" >e.fontSize;<span class="cstat-no" title="statement not covered" ></span>if(0===s)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst l=<span class="cstat-no" title="statement not covered" >e.fontSizeScale,</span>c=<span class="cstat-no" title="statement not covered" >e.charSpacing,</span>h=<span class="cstat-no" title="statement not covered" >e.wordSpacing,</span>d=<span class="cstat-no" title="statement not covered" >e.fontDirection,</span>u=<span class="cstat-no" title="statement not covered" >e.textHScale*d,</span>p=<span class="cstat-no" title="statement not covered" >i.vertical,</span>g=<span class="cstat-no" title="statement not covered" >p?1:-1,</span>m=<span class="cstat-no" title="statement not covered" >i.defaultVMetrics,</span>f=<span class="cstat-no" title="statement not covered" >s*e.fontMatrix[0];</span>let b=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const n of t){<span class="cstat-no" title="statement not covered" >if(null===n){<span class="cstat-no" title="statement not covered" >b+=d*h;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("number"==typeof n){<span class="cstat-no" title="statement not covered" >b+=g*n*s/1e3;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst t=<span class="cstat-no" title="statement not covered" >(n.isSpace?h:0)+c,</span>a=<span class="cstat-no" title="statement not covered" >n.fontChar;</span>let r,o,u=<span class="cstat-no" title="statement not covered" >n.width;<span class="cstat-no" title="statement not covered" ></span>if(p){let t;const e=<span class="cstat-no" title="statement not covered" >n.vmetric||m;<span class="cstat-no" title="statement not covered" ></span>t=n.vmetric?e[1]:.5*u;<span class="cstat-no" title="statement not covered" >t</span>=-t*f;c</span>onst i=<span class="cstat-no" title="statement not covered" >e[2]*f;<span class="cstat-no" title="statement not covered" ></span>u=e?-e[0]:u;<span class="cstat-no" title="statement not covered" >r</span>=t/l;<span class="cstat-no" title="statement not covered" >o</span>=(b+i)/l}</span>else{<span class="cstat-no" title="statement not covered" >r=b/l;<span class="cstat-no" title="statement not covered" >o</span>=0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n.isInFont||i.missingFile){<span class="cstat-no" title="statement not covered" >e.xcoords.push(e.x+r);<span class="cstat-no" title="statement not covered" >p</span>&amp;&amp;e.ycoords.push(-e.y+o);<span class="cstat-no" title="statement not covered" >e</span>.tspan.textContent+=a}<span class="cstat-no" title="statement not covered" ></span>b</span>+=p?u*f-t*d:u*f+t*d}<span class="cstat-no" title="statement not covered" ></span>e</span>.tspan.setAttributeNS(null,"x",e.xcoords.map(pf).join(" "));<span class="cstat-no" title="statement not covered" >p</span>?e.tspan.setAttributeNS(null,"y",e.ycoords.map(pf).join(" ")):e.tspan.setAttributeNS(null,"y",pf(-e.y));<span class="cstat-no" title="statement not covered" >p</span>?e.y-=b:e.x+=b*u;<span class="cstat-no" title="statement not covered" >e</span>.tspan.setAttributeNS(null,"font-family",e.fontFamily);<span class="cstat-no" title="statement not covered" >e</span>.tspan.setAttributeNS(null,"font-size",`${pf(e.fontSize)}px`);<span class="cstat-no" title="statement not covered" >e</span>.fontStyle!==a&amp;&amp;e.tspan.setAttributeNS(null,"font-style",e.fontStyle);<span class="cstat-no" title="statement not covered" >e</span>.fontWeight!==r&amp;&amp;e.tspan.setAttributeNS(null,"font-weight",e.fontWeight);c</span>onst A=<span class="cstat-no" title="statement not covered" >e.textRenderingMode&amp;n.TextRenderingMode.FILL_STROKE_MASK;<span class="cstat-no" title="statement not covered" ></span>if(A===n.TextRenderingMode.FILL||A===n.TextRenderingMode.FILL_STROKE){<span class="cstat-no" title="statement not covered" >e.fillColor!==o&amp;&amp;e.tspan.setAttributeNS(null,"fill",e.fillColor);<span class="cstat-no" title="statement not covered" >e</span>.fillAlpha&lt;1&amp;&amp;e.tspan.setAttributeNS(null,"fill-opacity",e.fillAlpha)}</span>else <span class="cstat-no" title="statement not covered" >e.textRenderingMode===n.TextRenderingMode.ADD_TO_PATH?e.tspan.setAttributeNS(null,"fill","transparent"):e.tspan.setAttributeNS(null,"fill","none");<span class="cstat-no" title="statement not covered" >i</span></span>f(A===n.TextRenderingMode.STROKE||A===n.TextRenderingMode.FILL_STROKE){const t=<span class="cstat-no" title="statement not covered" >1/(e.textMatrixScale||1);<span class="cstat-no" title="statement not covered" ></span>this._setStrokeAttributes(e.tspan,t)}</span>l</span>et _=<span class="cstat-no" title="statement not covered" >e.textMatrix;<span class="cstat-no" title="statement not covered" ></span>if(0!==e.textRise){<span class="cstat-no" title="statement not covered" >_=_.slice();<span class="cstat-no" title="statement not covered" >_</span>[5]+=e.textRise}<span class="cstat-no" title="statement not covered" ></span>e</span>.txtElement.setAttributeNS(null,"transform",`${pm(_)} scale(${pf(u)}, -1)`);<span class="cstat-no" title="statement not covered" >e</span>.txtElement.setAttributeNS("http://www.w3.org/XML/1998/namespace","xml:space","preserve");<span class="cstat-no" title="statement not covered" >e</span>.txtElement.append(e.tspan);<span class="cstat-no" title="statement not covered" >e</span>.txtgrp.append(e.txtElement);<span class="cstat-no" title="statement not covered" >t</span>his._ensureTransformGroup().append(e.txtElement)}<span class="fstat-no" title="function not covered" ></span>se</span>tLeadingMoveText(t,e){<span class="cstat-no" title="statement not covered" >this.setLeading(-e);<span class="cstat-no" title="statement not covered" >t</span>his.moveText(t,e)}<span class="fstat-no" title="function not covered" ></span>ad</span>dFontStyle(t){<span class="cstat-no" title="statement not covered" >if(!t.data)<span class="cstat-no" title="statement not covered" >throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.cssStyle){<span class="cstat-no" title="statement not covered" >this.cssStyle=this.svgFactory.createElement("svg:style");<span class="cstat-no" title="statement not covered" >t</span>his.cssStyle.setAttributeNS(null,"type","text/css");<span class="cstat-no" title="statement not covered" >t</span>his.defs.append(this.cssStyle)}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >createObjectURL(t.data,t.mimetype,this.forceDataSchema);<span class="cstat-no" title="statement not covered" ></span>this.cssStyle.textContent+=`@font-face { font-family: "${t.loadedName}"; src: url(${e}); }\n`}<span class="fstat-no" title="function not covered" ></span>se</span>tFont(t){const e=<span class="cstat-no" title="statement not covered" >this.current,</span>i=<span class="cstat-no" title="statement not covered" >this.commonObjs.get(t[0]);</span>let s=<span class="cstat-no" title="statement not covered" >t[1];<span class="cstat-no" title="statement not covered" ></span>e.font=i;<span class="cstat-no" title="statement not covered" >i</span>f(this.embedFonts&amp;&amp;!i.missingFile&amp;&amp;!this.embeddedFonts[i.loadedName]){<span class="cstat-no" title="statement not covered" >this.addFontStyle(i);<span class="cstat-no" title="statement not covered" >t</span>his.embeddedFonts[i.loadedName]=i}<span class="cstat-no" title="statement not covered" ></span>e</span>.fontMatrix=i.fontMatrix||n.FONT_IDENTITY_MATRIX;l</span>et a=<span class="cstat-no" title="statement not covered" >"normal";<span class="cstat-no" title="statement not covered" ></span>i.black?a="900":i.bold&amp;&amp;(a="bold");c</span>onst r=<span class="cstat-no" title="statement not covered" >i.italic?"italic":"normal";<span class="cstat-no" title="statement not covered" ></span>if(s&lt;0){<span class="cstat-no" title="statement not covered" >s=-s;<span class="cstat-no" title="statement not covered" >e</span>.fontDirection=-1}</span>else <span class="cstat-no" title="statement not covered" >e.fontDirection=1;<span class="cstat-no" title="statement not covered" >e</span></span>.fontSize=s;<span class="cstat-no" title="statement not covered" >e</span>.fontFamily=i.loadedName;<span class="cstat-no" title="statement not covered" >e</span>.fontWeight=a;<span class="cstat-no" title="statement not covered" >e</span>.fontStyle=r;<span class="cstat-no" title="statement not covered" >e</span>.tspan=this.svgFactory.createElement("svg:tspan");<span class="cstat-no" title="statement not covered" >e</span>.tspan.setAttributeNS(null,"y",pf(-e.y));<span class="cstat-no" title="statement not covered" >e</span>.xcoords=[];<span class="cstat-no" title="statement not covered" >e</span>.ycoords=[]}<span class="fstat-no" title="function not covered" ></span>en</span>dText(){const t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>if(t.textRenderingMode&amp;n.TextRenderingMode.ADD_TO_PATH_FLAG&amp;&amp;t.txtElement?.hasChildNodes()){<span class="cstat-no" title="statement not covered" >t.element=t.txtElement;<span class="cstat-no" title="statement not covered" >t</span>his.clip("nonzero");<span class="cstat-no" title="statement not covered" >t</span>his.endPath()}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tLineWidth(t){<span class="cstat-no" title="statement not covered" >t&gt;0&amp;&amp;(this.current.lineWidth=t)}<span class="fstat-no" title="function not covered" ></span>se</span>tLineCap(t){<span class="cstat-no" title="statement not covered" >this.current.lineCap=l[t]}<span class="fstat-no" title="function not covered" ></span>se</span>tLineJoin(t){<span class="cstat-no" title="statement not covered" >this.current.lineJoin=c[t]}<span class="fstat-no" title="function not covered" ></span>se</span>tMiterLimit(t){<span class="cstat-no" title="statement not covered" >this.current.miterLimit=t}<span class="fstat-no" title="function not covered" ></span>se</span>tStrokeAlpha(t){<span class="cstat-no" title="statement not covered" >this.current.strokeAlpha=t}<span class="fstat-no" title="function not covered" ></span>se</span>tStrokeRGBColor(t,e,i){<span class="cstat-no" title="statement not covered" >this.current.strokeColor=n.Util.makeHexColor(t,e,i)}<span class="fstat-no" title="function not covered" ></span>se</span>tFillAlpha(t){<span class="cstat-no" title="statement not covered" >this.current.fillAlpha=t}<span class="fstat-no" title="function not covered" ></span>se</span>tFillRGBColor(t,e,i){<span class="cstat-no" title="statement not covered" >this.current.fillColor=n.Util.makeHexColor(t,e,i);<span class="cstat-no" title="statement not covered" >t</span>his.current.tspan=this.svgFactory.createElement("svg:tspan");<span class="cstat-no" title="statement not covered" >t</span>his.current.xcoords=[];<span class="cstat-no" title="statement not covered" >t</span>his.current.ycoords=[]}<span class="fstat-no" title="function not covered" ></span>se</span>tStrokeColorN(t){<span class="cstat-no" title="statement not covered" >this.current.strokeColor=this._makeColorN_Pattern(t)}<span class="fstat-no" title="function not covered" ></span>se</span>tFillColorN(t){<span class="cstat-no" title="statement not covered" >this.current.fillColor=this._makeColorN_Pattern(t)}<span class="fstat-no" title="function not covered" ></span>sh</span>adingFill(t){const{width:e,height:i}=<span class="cstat-no" title="statement not covered" >this.viewport,</span>s=<span class="cstat-no" title="statement not covered" >n.Util.inverseTransform(this.transformMatrix),</span>[a,r,o,l]=<span class="cstat-no" title="statement not covered" >n.Util.getAxialAlignedBoundingBox([0,0,e,i],s),</span>c=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:rect");<span class="cstat-no" title="statement not covered" ></span>c.setAttributeNS(null,"x",a);<span class="cstat-no" title="statement not covered" >c</span>.setAttributeNS(null,"y",r);<span class="cstat-no" title="statement not covered" >c</span>.setAttributeNS(null,"width",o-a);<span class="cstat-no" title="statement not covered" >c</span>.setAttributeNS(null,"height",l-r);<span class="cstat-no" title="statement not covered" >c</span>.setAttributeNS(null,"fill",this._makeShadingPattern(t));<span class="cstat-no" title="statement not covered" >t</span>his.current.fillAlpha&lt;1&amp;&amp;c.setAttributeNS(null,"fill-opacity",this.current.fillAlpha);<span class="cstat-no" title="statement not covered" >t</span>his._ensureTransformGroup().append(c)}<span class="fstat-no" title="function not covered" ></span>_m</span>akeColorN_Pattern(t){<span class="cstat-no" title="statement not covered" >return"TilingPattern"===t[0]?this._makeTilingPattern(t):this._makeShadingPattern(t)}<span class="fstat-no" title="function not covered" ></span>_m</span>akeTilingPattern(t){const e=<span class="cstat-no" title="statement not covered" >t[1],</span>i=<span class="cstat-no" title="statement not covered" >t[2],</span>s=<span class="cstat-no" title="statement not covered" >t[3]||n.IDENTITY_MATRIX,</span>[a,r,o,l]=<span class="cstat-no" title="statement not covered" >t[4],</span>c=<span class="cstat-no" title="statement not covered" >t[5],</span>h=<span class="cstat-no" title="statement not covered" >t[6],</span>d=<span class="cstat-no" title="statement not covered" >t[7],</span>u=<span class="cstat-no" title="statement not covered" >"shading"+p++,</span>[g,m,f,b]=<span class="cstat-no" title="statement not covered" >n.Util.normalizeRect([...n.Util.applyTransform([a,r],s),...n.Util.applyTransform([o,l],s)]),</span>[A,_]=<span class="cstat-no" title="statement not covered" >n.Util.singularValueDecompose2dScale(s),</span>v=<span class="cstat-no" title="statement not covered" >c*A,</span>y=<span class="cstat-no" title="statement not covered" >h*_,</span>S=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:pattern");<span class="cstat-no" title="statement not covered" ></span>S.setAttributeNS(null,"id",u);<span class="cstat-no" title="statement not covered" >S</span>.setAttributeNS(null,"patternUnits","userSpaceOnUse");<span class="cstat-no" title="statement not covered" >S</span>.setAttributeNS(null,"width",v);<span class="cstat-no" title="statement not covered" >S</span>.setAttributeNS(null,"height",y);<span class="cstat-no" title="statement not covered" >S</span>.setAttributeNS(null,"x",`${g}`);<span class="cstat-no" title="statement not covered" >S</span>.setAttributeNS(null,"y",`${m}`);c</span>onst E=<span class="cstat-no" title="statement not covered" >this.svg,</span>x=<span class="cstat-no" title="statement not covered" >this.transformMatrix,</span>w=<span class="cstat-no" title="statement not covered" >this.current.fillColor,</span>C=<span class="cstat-no" title="statement not covered" >this.current.strokeColor,</span>T=<span class="cstat-no" title="statement not covered" >this.svgFactory.create(f-g,b-m);<span class="cstat-no" title="statement not covered" ></span>this.svg=T;<span class="cstat-no" title="statement not covered" >t</span>his.transformMatrix=s;<span class="cstat-no" title="statement not covered" >i</span>f(2===d){const t=<span class="cstat-no" title="statement not covered" >n.Util.makeHexColor(...e);<span class="cstat-no" title="statement not covered" ></span>this.current.fillColor=t;<span class="cstat-no" title="statement not covered" >t</span>his.current.strokeColor=t}<span class="cstat-no" title="statement not covered" ></span>t</span>his.executeOpTree(this.convertOpList(i));<span class="cstat-no" title="statement not covered" >t</span>his.svg=E;<span class="cstat-no" title="statement not covered" >t</span>his.transformMatrix=x;<span class="cstat-no" title="statement not covered" >t</span>his.current.fillColor=w;<span class="cstat-no" title="statement not covered" >t</span>his.current.strokeColor=C;<span class="cstat-no" title="statement not covered" >S</span>.append(T.childNodes[0]);<span class="cstat-no" title="statement not covered" >t</span>his.defs.append(S);<span class="cstat-no" title="statement not covered" >r</span>eturn`url(#${u})`}<span class="fstat-no" title="function not covered" ></span>_m</span>akeShadingPattern(t){<span class="cstat-no" title="statement not covered" >"string"==typeof t&amp;&amp;(t=this.objs.get(t));<span class="cstat-no" title="statement not covered" >s</span>witch(t[0]){case"RadialAxial":const e=<span class="cstat-no" title="statement not covered" >"shading"+p++,</span>i=<span class="cstat-no" title="statement not covered" >t[3];</span>let s;<span class="cstat-no" title="statement not covered" >switch(t[1]){case"axial":const i=<span class="cstat-no" title="statement not covered" >t[4],</span>n=<span class="cstat-no" title="statement not covered" >t[5];<span class="cstat-no" title="statement not covered" ></span>s=this.svgFactory.createElement("svg:linearGradient");<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"id",e);<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"gradientUnits","userSpaceOnUse");<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"x1",i[0]);<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"y1",i[1]);<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"x2",n[0]);<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"y2",n[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"radial":const a=<span class="cstat-no" title="statement not covered" >t[4],</span>r=<span class="cstat-no" title="statement not covered" >t[5],</span>o=<span class="cstat-no" title="statement not covered" >t[6],</span>l=<span class="cstat-no" title="statement not covered" >t[7];<span class="cstat-no" title="statement not covered" ></span>s=this.svgFactory.createElement("svg:radialGradient");<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"id",e);<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"gradientUnits","userSpaceOnUse");<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"cx",r[0]);<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"cy",r[1]);<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"r",l);<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"fx",a[0]);<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"fy",a[1]);<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"fr",o);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error(`Unknown RadialAxial type: ${t[1]}`)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const t of i){const e=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:stop");<span class="cstat-no" title="statement not covered" ></span>e.setAttributeNS(null,"offset",t[0]);<span class="cstat-no" title="statement not covered" >e</span>.setAttributeNS(null,"stop-color",t[1]);<span class="cstat-no" title="statement not covered" >s</span>.append(e)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.defs.append(s);<span class="cstat-no" title="statement not covered" >r</span>eturn`url(#${e})`;c</span>ase"Mesh":<span class="cstat-no" title="statement not covered" >(0,n.warn)("Unimplemented pattern Mesh");<span class="cstat-no" title="statement not covered" >r</span>eturn null;c</span>ase"Dummy":<span class="cstat-no" title="statement not covered" >return"hotpink";d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error(`Unknown IR type: ${t[0]}`)}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tDash(t,e){<span class="cstat-no" title="statement not covered" >this.current.dashArray=t;<span class="cstat-no" title="statement not covered" >t</span>his.current.dashPhase=e}<span class="fstat-no" title="function not covered" ></span>co</span>nstructPath(t,e){const i=<span class="cstat-no" title="statement not covered" >this.current;</span>let s=<span class="cstat-no" title="statement not covered" >i.x,</span>a=<span class="cstat-no" title="statement not covered" >i.y,</span>r=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const i of t)<span class="cstat-no" title="statement not covered" >switch(0|i){case n.OPS.rectangle:<span class="cstat-no" title="statement not covered" >s=e[o++];<span class="cstat-no" title="statement not covered" >a</span>=e[o++];c</span>onst t=<span class="cstat-no" title="statement not covered" >s+e[o++],</span>i=<span class="cstat-no" title="statement not covered" >a+e[o++];<span class="cstat-no" title="statement not covered" ></span>r.push("M",pf(s),pf(a),"L",pf(t),pf(a),"L",pf(t),pf(i),"L",pf(s),pf(i),"Z");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.moveTo:<span class="cstat-no" title="statement not covered" >s=e[o++];<span class="cstat-no" title="statement not covered" >a</span>=e[o++];<span class="cstat-no" title="statement not covered" >r</span>.push("M",pf(s),pf(a));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.lineTo:<span class="cstat-no" title="statement not covered" >s=e[o++];<span class="cstat-no" title="statement not covered" >a</span>=e[o++];<span class="cstat-no" title="statement not covered" >r</span>.push("L",pf(s),pf(a));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.curveTo:<span class="cstat-no" title="statement not covered" >s=e[o+4];<span class="cstat-no" title="statement not covered" >a</span>=e[o+5];<span class="cstat-no" title="statement not covered" >r</span>.push("C",pf(e[o]),pf(e[o+1]),pf(e[o+2]),pf(e[o+3]),pf(s),pf(a));<span class="cstat-no" title="statement not covered" >o</span>+=6;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.curveTo2:<span class="cstat-no" title="statement not covered" >r.push("C",pf(s),pf(a),pf(e[o]),pf(e[o+1]),pf(e[o+2]),pf(e[o+3]));<span class="cstat-no" title="statement not covered" >s</span>=e[o+2];<span class="cstat-no" title="statement not covered" >a</span>=e[o+3];<span class="cstat-no" title="statement not covered" >o</span>+=4;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.curveTo3:<span class="cstat-no" title="statement not covered" >s=e[o+2];<span class="cstat-no" title="statement not covered" >a</span>=e[o+3];<span class="cstat-no" title="statement not covered" >r</span>.push("C",pf(e[o]),pf(e[o+1]),pf(s),pf(a),pf(s),pf(a));<span class="cstat-no" title="statement not covered" >o</span>+=4;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase n.OPS.closePath:<span class="cstat-no" title="statement not covered" >r.push("Z")}<span class="cstat-no" title="statement not covered" ></span>r</span></span>=r.join(" ");<span class="cstat-no" title="statement not covered" >i</span>f(i.path&amp;&amp;t.length&gt;0&amp;&amp;t[0]!==n.OPS.rectangle&amp;&amp;t[0]!==n.OPS.moveTo)<span class="cstat-no" title="statement not covered" >r=i.path.getAttributeNS(null,"d")+r;e</span>lse{<span class="cstat-no" title="statement not covered" >i.path=this.svgFactory.createElement("svg:path");<span class="cstat-no" title="statement not covered" >t</span>his._ensureTransformGroup().append(i.path)}<span class="cstat-no" title="statement not covered" ></span>i</span>.path.setAttributeNS(null,"d",r);<span class="cstat-no" title="statement not covered" >i</span>.path.setAttributeNS(null,"fill","none");<span class="cstat-no" title="statement not covered" >i</span>.element=i.path;<span class="cstat-no" title="statement not covered" >i</span>.setCurrentPoint(s,a)}<span class="fstat-no" title="function not covered" ></span>en</span>dPath(){const t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>t.path=null;<span class="cstat-no" title="statement not covered" >i</span>f(!this.pendingClip)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!t.element){<span class="cstat-no" title="statement not covered" >this.pendingClip=null;<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >"clippath"+d++,</span>i=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:clipPath");<span class="cstat-no" title="statement not covered" ></span>i.setAttributeNS(null,"id",e);<span class="cstat-no" title="statement not covered" >i</span>.setAttributeNS(null,"transform",pm(this.transformMatrix));c</span>onst s=<span class="cstat-no" title="statement not covered" >t.element.cloneNode(!0);<span class="cstat-no" title="statement not covered" ></span>"evenodd"===this.pendingClip?s.setAttributeNS(null,"clip-rule","evenodd"):s.setAttributeNS(null,"clip-rule","nonzero");<span class="cstat-no" title="statement not covered" >t</span>his.pendingClip=null;<span class="cstat-no" title="statement not covered" >i</span>.append(s);<span class="cstat-no" title="statement not covered" >t</span>his.defs.append(i);<span class="cstat-no" title="statement not covered" >i</span>f(t.activeClipUrl){<span class="cstat-no" title="statement not covered" >t.clipGroup=null;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.extraStack)<span class="cstat-no" title="statement not covered" >t.clipGroup=null;<span class="cstat-no" title="statement not covered" >i</span></span>.setAttributeNS(null,"clip-path",t.activeClipUrl)}<span class="cstat-no" title="statement not covered" ></span>t</span>.activeClipUrl=`url(#${e})`;<span class="cstat-no" title="statement not covered" >t</span>his.tgrp=null}<span class="fstat-no" title="function not covered" ></span>cl</span>ip(t){<span class="cstat-no" title="statement not covered" >this.pendingClip=t}<span class="fstat-no" title="function not covered" ></span>cl</span>osePath(){const t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>if(t.path){const e=<span class="cstat-no" title="statement not covered" >`${t.path.getAttributeNS(null,"d")}Z`;<span class="cstat-no" title="statement not covered" ></span>t.path.setAttributeNS(null,"d",e)}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tLeading(t){<span class="cstat-no" title="statement not covered" >this.current.leading=-t}<span class="fstat-no" title="function not covered" ></span>se</span>tTextRise(t){<span class="cstat-no" title="statement not covered" >this.current.textRise=t}<span class="fstat-no" title="function not covered" ></span>se</span>tTextRenderingMode(t){<span class="cstat-no" title="statement not covered" >this.current.textRenderingMode=t}<span class="fstat-no" title="function not covered" ></span>se</span>tHScale(t){<span class="cstat-no" title="statement not covered" >this.current.textHScale=t/100}<span class="fstat-no" title="function not covered" ></span>se</span>tRenderingIntent(t){}<span class="fstat-no" title="function not covered" >se</span>tFlatness(t){}<span class="fstat-no" title="function not covered" >se</span>tGState(t){<span class="cstat-no" title="statement not covered" >for(const[e,i]of t)<span class="cstat-no" title="statement not covered" >switch(e){case"LW":<span class="cstat-no" title="statement not covered" >this.setLineWidth(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"LC":<span class="cstat-no" title="statement not covered" >this.setLineCap(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"LJ":<span class="cstat-no" title="statement not covered" >this.setLineJoin(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ML":<span class="cstat-no" title="statement not covered" >this.setMiterLimit(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"D":<span class="cstat-no" title="statement not covered" >this.setDash(i[0],i[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"RI":<span class="cstat-no" title="statement not covered" >this.setRenderingIntent(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"FL":<span class="cstat-no" title="statement not covered" >this.setFlatness(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"Font":<span class="cstat-no" title="statement not covered" >this.setFont(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"CA":<span class="cstat-no" title="statement not covered" >this.setStrokeAlpha(i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ca":<span class="cstat-no" title="statement not covered" >this.setFillAlpha(i);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >(0,n.warn)(`Unimplemented graphic state operator ${e}`)}</span>}<span class="fstat-no" title="function not covered" ></span></span>fi</span>ll(){const t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>if(t.element){<span class="cstat-no" title="statement not covered" >t.element.setAttributeNS(null,"fill",t.fillColor);<span class="cstat-no" title="statement not covered" >t</span>.element.setAttributeNS(null,"fill-opacity",t.fillAlpha);<span class="cstat-no" title="statement not covered" >t</span>his.endPath()}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>roke(){const t=<span class="cstat-no" title="statement not covered" >this.current;<span class="cstat-no" title="statement not covered" ></span>if(t.element){<span class="cstat-no" title="statement not covered" >this._setStrokeAttributes(t.element);<span class="cstat-no" title="statement not covered" >t</span>.element.setAttributeNS(null,"fill","none");<span class="cstat-no" title="statement not covered" >t</span>his.endPath()}</span>}<span class="fstat-no" title="function not covered" ></span>_s</span>etStrokeAttributes(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{const i=<span class="cstat-no" title="statement not covered" >this.current;</span>let s=<span class="cstat-no" title="statement not covered" >i.dashArray;<span class="cstat-no" title="statement not covered" ></span>1!==e&amp;&amp;s.length&gt;0&amp;&amp;(s=s.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e*t}</span>)));<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke",i.strokeColor);<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke-opacity",i.strokeAlpha);<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke-miterlimit",pf(i.miterLimit));<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke-linecap",i.lineCap);<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke-linejoin",i.lineJoin);<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke-width",pf(e*i.lineWidth)+"px");<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke-dasharray",s.map(pf).join(" "));<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"stroke-dashoffset",pf(e*i.dashPhase)+"px")}<span class="fstat-no" title="function not covered" ></span>eo</span>Fill(){<span class="cstat-no" title="statement not covered" >this.current.element?.setAttributeNS(null,"fill-rule","evenodd");<span class="cstat-no" title="statement not covered" >t</span>his.fill()}<span class="fstat-no" title="function not covered" ></span>fi</span>llStroke(){<span class="cstat-no" title="statement not covered" >this.stroke();<span class="cstat-no" title="statement not covered" >t</span>his.fill()}<span class="fstat-no" title="function not covered" ></span>eo</span>FillStroke(){<span class="cstat-no" title="statement not covered" >this.current.element?.setAttributeNS(null,"fill-rule","evenodd");<span class="cstat-no" title="statement not covered" >t</span>his.fillStroke()}<span class="fstat-no" title="function not covered" ></span>cl</span>oseStroke(){<span class="cstat-no" title="statement not covered" >this.closePath();<span class="cstat-no" title="statement not covered" >t</span>his.stroke()}<span class="fstat-no" title="function not covered" ></span>cl</span>oseFillStroke(){<span class="cstat-no" title="statement not covered" >this.closePath();<span class="cstat-no" title="statement not covered" >t</span>his.fillStroke()}<span class="fstat-no" title="function not covered" ></span>cl</span>oseEOFillStroke(){<span class="cstat-no" title="statement not covered" >this.closePath();<span class="cstat-no" title="statement not covered" >t</span>his.eoFillStroke()}<span class="fstat-no" title="function not covered" ></span>pa</span>intSolidColorImageMask(){const t=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:rect");<span class="cstat-no" title="statement not covered" ></span>t.setAttributeNS(null,"x","0");<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"y","0");<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"width","1px");<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"height","1px");<span class="cstat-no" title="statement not covered" >t</span>.setAttributeNS(null,"fill",this.current.fillColor);<span class="cstat-no" title="statement not covered" >t</span>his._ensureTransformGroup().append(t)}<span class="fstat-no" title="function not covered" ></span>pa</span>intImageXObject(t){const e=<span class="cstat-no" title="statement not covered" >this.getObject(t);<span class="cstat-no" title="statement not covered" ></span>e?this.paintInlineImageXObject(e):(0,n.warn)(`Dependent image with object ID ${t} is not ready yet`)}<span class="fstat-no" title="function not covered" ></span>pa</span>intInlineImageXObject(t,e){const i=<span class="cstat-no" title="statement not covered" >t.width,</span>s=<span class="cstat-no" title="statement not covered" >t.height,</span>n=<span class="cstat-no" title="statement not covered" >h(t,this.forceDataSchema,!!e),</span>a=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:rect");<span class="cstat-no" title="statement not covered" ></span>a.setAttributeNS(null,"x","0");<span class="cstat-no" title="statement not covered" >a</span>.setAttributeNS(null,"y","0");<span class="cstat-no" title="statement not covered" >a</span>.setAttributeNS(null,"width",pf(i));<span class="cstat-no" title="statement not covered" >a</span>.setAttributeNS(null,"height",pf(s));<span class="cstat-no" title="statement not covered" >t</span>his.current.element=a;<span class="cstat-no" title="statement not covered" >t</span>his.clip("nonzero");c</span>onst r=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:image");<span class="cstat-no" title="statement not covered" ></span>r.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",n);<span class="cstat-no" title="statement not covered" >r</span>.setAttributeNS(null,"x","0");<span class="cstat-no" title="statement not covered" >r</span>.setAttributeNS(null,"y",pf(-s));<span class="cstat-no" title="statement not covered" >r</span>.setAttributeNS(null,"width",pf(i)+"px");<span class="cstat-no" title="statement not covered" >r</span>.setAttributeNS(null,"height",pf(s)+"px");<span class="cstat-no" title="statement not covered" >r</span>.setAttributeNS(null,"transform",`scale(${pf(1/i)} ${pf(-1/s)})`);<span class="cstat-no" title="statement not covered" >e</span>?e.append(r):this._ensureTransformGroup().append(r)}<span class="fstat-no" title="function not covered" ></span>pa</span>intImageMaskXObject(t){const e=<span class="cstat-no" title="statement not covered" >this.getObject(t.data,t);<span class="cstat-no" title="statement not covered" ></span>if(e.bitmap){<span class="cstat-no" title="statement not covered" >(0,n.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >this.current,</span>s=<span class="cstat-no" title="statement not covered" >e.width,</span>a=<span class="cstat-no" title="statement not covered" >e.height,</span>r=<span class="cstat-no" title="statement not covered" >i.fillColor;<span class="cstat-no" title="statement not covered" ></span>i.maskId="mask"+u++;c</span>onst o=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:mask");<span class="cstat-no" title="statement not covered" ></span>o.setAttributeNS(null,"id",i.maskId);c</span>onst l=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:rect");<span class="cstat-no" title="statement not covered" ></span>l.setAttributeNS(null,"x","0");<span class="cstat-no" title="statement not covered" >l</span>.setAttributeNS(null,"y","0");<span class="cstat-no" title="statement not covered" >l</span>.setAttributeNS(null,"width",pf(s));<span class="cstat-no" title="statement not covered" >l</span>.setAttributeNS(null,"height",pf(a));<span class="cstat-no" title="statement not covered" >l</span>.setAttributeNS(null,"fill",r);<span class="cstat-no" title="statement not covered" >l</span>.setAttributeNS(null,"mask",`url(#${i.maskId})`);<span class="cstat-no" title="statement not covered" >t</span>his.defs.append(o);<span class="cstat-no" title="statement not covered" >t</span>his._ensureTransformGroup().append(l);<span class="cstat-no" title="statement not covered" >t</span>his.paintInlineImageXObject(e,o)}<span class="fstat-no" title="function not covered" ></span>pa</span>intFormXObjectBegin(t,e){<span class="cstat-no" title="statement not covered" >Array.isArray(t)&amp;&amp;6===t.length&amp;&amp;this.transform(t[0],t[1],t[2],t[3],t[4],t[5]);<span class="cstat-no" title="statement not covered" >i</span>f(e){const t=<span class="cstat-no" title="statement not covered" >e[2]-e[0],</span>i=<span class="cstat-no" title="statement not covered" >e[3]-e[1],</span>s=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:rect");<span class="cstat-no" title="statement not covered" ></span>s.setAttributeNS(null,"x",e[0]);<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"y",e[1]);<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"width",pf(t));<span class="cstat-no" title="statement not covered" >s</span>.setAttributeNS(null,"height",pf(i));<span class="cstat-no" title="statement not covered" >t</span>his.current.element=s;<span class="cstat-no" title="statement not covered" >t</span>his.clip("nonzero");<span class="cstat-no" title="statement not covered" >t</span>his.endPath()}</span>}<span class="fstat-no" title="function not covered" ></span>pa</span>intFormXObjectEnd(){}<span class="fstat-no" title="function not covered" >_i</span>nitialize(t){const e=<span class="cstat-no" title="statement not covered" >this.svgFactory.create(t.width,t.height),</span>i=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:defs");<span class="cstat-no" title="statement not covered" ></span>e.append(i);<span class="cstat-no" title="statement not covered" >t</span>his.defs=i;c</span>onst s=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:g");<span class="cstat-no" title="statement not covered" ></span>s.setAttributeNS(null,"transform",pm(t.transform));<span class="cstat-no" title="statement not covered" >e</span>.append(s);<span class="cstat-no" title="statement not covered" >t</span>his.svg=s;<span class="cstat-no" title="statement not covered" >r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>_e</span>nsureClipGroup(){<span class="cstat-no" title="statement not covered" >if(!this.current.clipGroup){const t=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement("svg:g");<span class="cstat-no" title="statement not covered" ></span>t.setAttributeNS(null,"clip-path",this.current.activeClipUrl);<span class="cstat-no" title="statement not covered" >t</span>his.svg.append(t);<span class="cstat-no" title="statement not covered" >t</span>his.current.clipGroup=t}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.current.clipGroup}<span class="fstat-no" title="function not covered" ></span>_e</span>nsureTransformGroup(){<span class="cstat-no" title="statement not covered" >if(!this.tgrp){<span class="cstat-no" title="statement not covered" >this.tgrp=this.svgFactory.createElement("svg:g");<span class="cstat-no" title="statement not covered" >t</span>his.tgrp.setAttributeNS(null,"transform",pm(this.transformMatrix));<span class="cstat-no" title="statement not covered" >t</span>his.current.activeClipUrl?this._ensureClipGroup().append(this.tgrp):this.svg.append(this.tgrp)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.tgrp}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.XfaText=void 0;c</span>lass XfaText{<span class="fstat-no" title="function not covered" >st</span>atic textContent(t){const e=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >{items:e,styles:Object.create(null)};<span class="cstat-no" title="statement not covered" ></span>!function <span class="fstat-no" title="function not covered" >walk(</span>t){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return;l</span></span>et i=<span class="cstat-no" title="statement not covered" >null;</span>const s=<span class="cstat-no" title="statement not covered" >t.name;<span class="cstat-no" title="statement not covered" ></span>if("#text"===s)<span class="cstat-no" title="statement not covered" >i=t.value;e</span>lse{<span class="cstat-no" title="statement not covered" >if(!XfaText.shouldBuildText(s))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>?.attributes?.textContent?i=t.attributes.textContent:t.value&amp;&amp;(i=t.value)}<span class="cstat-no" title="statement not covered" ></span>n</span>ull!==i&amp;&amp;e.push({str:i});<span class="cstat-no" title="statement not covered" >i</span>f(t.children)<span class="cstat-no" title="statement not covered" >for(const e of t.children)<span class="cstat-no" title="statement not covered" >walk(e)}</span></span></span>(t);<span class="cstat-no" title="statement not covered" >r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>st</span>atic shouldBuildText(t){<span class="cstat-no" title="statement not covered" >return!("textarea"===t||"input"===t||"option"===t||"select"===t)}</span>}<span class="cstat-no" title="statement not covered" >e.XfaText=XfaText}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.TextLayerRenderTask=void 0;<span class="cstat-no" title="statement not covered" >e</span>.renderTextLayer=function <span class="fstat-no" title="function not covered" >renderTextLayer(</span>t){<span class="cstat-no" title="statement not covered" >if(!t.textContentSource&amp;&amp;(t.textContent||t.textContentStream)){<span class="cstat-no" title="statement not covered" >(0,n.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead.");<span class="cstat-no" title="statement not covered" >t</span>.textContentSource=t.textContent||t.textContentStream}</span>c</span>onst{container:e,viewport:i}=<span class="cstat-no" title="statement not covered" >t,</span>s=<span class="cstat-no" title="statement not covered" >getComputedStyle(e),</span>a=<span class="cstat-no" title="statement not covered" >s.getPropertyValue("visibility"),</span>r=<span class="cstat-no" title="statement not covered" >parseFloat(s.getPropertyValue("--scale-factor"));<span class="cstat-no" title="statement not covered" ></span>"visible"===a&amp;&amp;(!r||Math.abs(r-i.scale)&gt;1e-5)&amp;&amp;console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");c</span>onst o=<span class="cstat-no" title="statement not covered" >new TextLayerRenderTask(t);<span class="cstat-no" title="statement not covered" ></span>o._render();<span class="cstat-no" title="statement not covered" >r</span>eturn o}</span>;<span class="cstat-no" title="statement not covered" >e</span>.updateTextLayer=function <span class="fstat-no" title="function not covered" >updateTextLayer(</span>{container:t,viewport:e,textDivs:i,textDivProperties:s,isOffscreenCanvasSupported:a,mustRotate:r=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>mustRescale:o=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>){<span class="cstat-no" title="statement not covered" >r&amp;&amp;(0,n.setLayerDimensions)(t,{rotation:e.rotation});<span class="cstat-no" title="statement not covered" >i</span>f(o){const t=<span class="cstat-no" title="statement not covered" >getCtx(0,a),</span>n=<span class="cstat-no" title="statement not covered" >{prevFontSize:null,prevFontFamily:null,div:null,scale:e.scale*(globalThis.devicePixelRatio||1),properties:null,ctx:t};<span class="cstat-no" title="statement not covered" ></span>for(const t of i){<span class="cstat-no" title="statement not covered" >n.properties=s.get(t);<span class="cstat-no" title="statement not covered" >n</span>.div=t;<span class="cstat-no" title="statement not covered" >l</span>ayout(n)}</span>}</span>}</span>;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(6);</span>const a=<span class="cstat-no" title="statement not covered" >30,</span>r=<span class="cstat-no" title="statement not covered" >.8,</span>o=<span class="cstat-no" title="statement not covered" >new Map;</span>function <span class="fstat-no" title="function not covered" >getCtx(</span>t,e){let i;<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;s.FeatureTest.isOffscreenCanvasSupported)<span class="cstat-no" title="statement not covered" >i=new OffscreenCanvas(t,t).getContext("2d",{alpha:!1});e</span>lse{const e=<span class="cstat-no" title="statement not covered" >document.createElement("canvas");<span class="cstat-no" title="statement not covered" ></span>e.width=e.height=t;<span class="cstat-no" title="statement not covered" >i</span>=e.getContext("2d",{alpha:!1})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>function <span class="fstat-no" title="function not covered" >appendText(</span>t,e,i){const n=<span class="cstat-no" title="statement not covered" >document.createElement("span"),</span>l=<span class="cstat-no" title="statement not covered" >{angle:0,canvasWidth:0,hasText:""!==e.str,hasEOL:e.hasEOL,fontSize:0};<span class="cstat-no" title="statement not covered" ></span>t._textDivs.push(n);c</span>onst c=<span class="cstat-no" title="statement not covered" >s.Util.transform(t._transform,e.transform);</span>let h=<span class="cstat-no" title="statement not covered" >Math.atan2(c[1],c[0]);</span>const d=<span class="cstat-no" title="statement not covered" >i[e.fontName];<span class="cstat-no" title="statement not covered" ></span>d.vertical&amp;&amp;(h+=Math.PI/2);c</span>onst u=<span class="cstat-no" title="statement not covered" >Math.hypot(c[2],c[3]),</span>p=<span class="cstat-no" title="statement not covered" >u*function <span class="fstat-no" title="function not covered" >getAscent(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >o.get(t);<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >return i;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >getCtx(a,e);<span class="cstat-no" title="statement not covered" ></span>s.font=`${a}px ${t}`;c</span>onst n=<span class="cstat-no" title="statement not covered" >s.measureText("");</span>let l=<span class="cstat-no" title="statement not covered" >n.fontBoundingBoxAscent,</span>c=<span class="cstat-no" title="statement not covered" >Math.abs(n.fontBoundingBoxDescent);<span class="cstat-no" title="statement not covered" ></span>if(l){const e=<span class="cstat-no" title="statement not covered" >l/(l+c);<span class="cstat-no" title="statement not covered" ></span>o.set(t,e);<span class="cstat-no" title="statement not covered" >s</span>.canvas.width=s.canvas.height=0;<span class="cstat-no" title="statement not covered" >r</span>eturn e}<span class="cstat-no" title="statement not covered" ></span>s</span>.strokeStyle="red";<span class="cstat-no" title="statement not covered" >s</span>.clearRect(0,0,a,a);<span class="cstat-no" title="statement not covered" >s</span>.strokeText("g",0,0);l</span>et h=<span class="cstat-no" title="statement not covered" >s.getImageData(0,0,a,a).data;<span class="cstat-no" title="statement not covered" ></span>c=0;<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >h.length-1-3;</span>t&gt;=0;t-=4)<span class="cstat-no" title="statement not covered" >if(h[t]&gt;0){<span class="cstat-no" title="statement not covered" >c=Math.ceil(t/4/a);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>s</span></span>.clearRect(0,0,a,a);<span class="cstat-no" title="statement not covered" >s</span>.strokeText("A",0,a);<span class="cstat-no" title="statement not covered" >h</span>=s.getImageData(0,0,a,a).data;<span class="cstat-no" title="statement not covered" >l</span>=0;<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >h.length;</span>t&lt;e;t+=4)<span class="cstat-no" title="statement not covered" >if(h[t]&gt;0){<span class="cstat-no" title="statement not covered" >l=a-Math.floor(t/4/a);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>s</span></span>.canvas.width=s.canvas.height=0;<span class="cstat-no" title="statement not covered" >i</span>f(l){const e=<span class="cstat-no" title="statement not covered" >l/(l+c);<span class="cstat-no" title="statement not covered" ></span>o.set(t,e);<span class="cstat-no" title="statement not covered" >r</span>eturn e}<span class="cstat-no" title="statement not covered" ></span>o</span>.set(t,r);<span class="cstat-no" title="statement not covered" >r</span>eturn r}</span>(d.fontFamily,t._isOffscreenCanvasSupported);</span>let g,m;<span class="cstat-no" title="statement not covered" >if(0===h){<span class="cstat-no" title="statement not covered" >g=c[4];<span class="cstat-no" title="statement not covered" >m</span>=c[5]-p}</span>else{<span class="cstat-no" title="statement not covered" >g=c[4]+p*Math.sin(h);<span class="cstat-no" title="statement not covered" >m</span>=c[5]-p*Math.cos(h)}</span>c</span>onst f=<span class="cstat-no" title="statement not covered" >"calc(var(--scale-factor)*",</span>b=<span class="cstat-no" title="statement not covered" >n.style;<span class="cstat-no" title="statement not covered" ></span>if(t._container===t._rootContainer){<span class="cstat-no" title="statement not covered" >b.left=`${(100*g/t._pageWidth).toFixed(2)}%`;<span class="cstat-no" title="statement not covered" >b</span>.top=`${(100*m/t._pageHeight).toFixed(2)}%`}</span>else{<span class="cstat-no" title="statement not covered" >b.left=`${f}${g.toFixed(2)}px)`;<span class="cstat-no" title="statement not covered" >b</span>.top=`${f}${m.toFixed(2)}px)`}<span class="cstat-no" title="statement not covered" ></span>b</span>.fontSize=`${f}${u.toFixed(2)}px)`;<span class="cstat-no" title="statement not covered" >b</span>.fontFamily=d.fontFamily;<span class="cstat-no" title="statement not covered" >l</span>.fontSize=u;<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("role","presentation");<span class="cstat-no" title="statement not covered" >n</span>.textContent=e.str;<span class="cstat-no" title="statement not covered" >n</span>.dir=e.dir;<span class="cstat-no" title="statement not covered" >t</span>._fontInspectorEnabled&amp;&amp;(n.dataset.fontName=e.fontName);<span class="cstat-no" title="statement not covered" >0</span>!==h&amp;&amp;(l.angle=h*(180/Math.PI));l</span>et A=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(e.str.length&gt;1)<span class="cstat-no" title="statement not covered" >A=!0;e</span>lse <span class="cstat-no" title="statement not covered" >if(" "!==e.str&amp;&amp;e.transform[0]!==e.transform[3]){const t=<span class="cstat-no" title="statement not covered" >Math.abs(e.transform[0]),</span>i=<span class="cstat-no" title="statement not covered" >Math.abs(e.transform[3]);<span class="cstat-no" title="statement not covered" ></span>t!==i&amp;&amp;Math.max(t,i)/Math.min(t,i)&gt;1.5&amp;&amp;(A=!0)}<span class="cstat-no" title="statement not covered" ></span>A</span></span>&amp;&amp;(l.canvasWidth=d.vertical?e.height:e.width);<span class="cstat-no" title="statement not covered" >t</span>._textDivProperties.set(n,l);<span class="cstat-no" title="statement not covered" >t</span>._isReadableStream&amp;&amp;t._layoutText(n)}</span>function <span class="fstat-no" title="function not covered" >layout(</span>t){const{div:e,scale:i,properties:s,ctx:n,prevFontSize:a,prevFontFamily:r}=<span class="cstat-no" title="statement not covered" >t,</span>{style:o}=<span class="cstat-no" title="statement not covered" >e;</span>let l=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if(0!==s.canvasWidth&amp;&amp;s.hasText){const{fontFamily:c}=<span class="cstat-no" title="statement not covered" >o,</span>{canvasWidth:h,fontSize:d}=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if(a!==d||r!==c){<span class="cstat-no" title="statement not covered" >n.font=`${d*i}px ${c}`;<span class="cstat-no" title="statement not covered" >t</span>.prevFontSize=d;<span class="cstat-no" title="statement not covered" >t</span>.prevFontFamily=c}</span>c</span>onst{width:u}=<span class="cstat-no" title="statement not covered" >n.measureText(e.textContent);<span class="cstat-no" title="statement not covered" ></span>u&gt;0&amp;&amp;(l=`scaleX(${h*i/u})`)}<span class="cstat-no" title="statement not covered" ></span>0</span>!==s.angle&amp;&amp;(l=`rotate(${s.angle}deg) ${l}`);<span class="cstat-no" title="statement not covered" >l</span>.length&gt;0&amp;&amp;(o.transform=l)}</span>class TextLayerRenderTask{<span class="fstat-no" title="function not covered" >co</span>nstructor({textContentSource:t,container:e,viewport:i,textDivs:a,textDivProperties:r,textContentItemsStr:o,isOffscreenCanvasSupported:l}){<span class="cstat-no" title="statement not covered" >this._textContentSource=t;<span class="cstat-no" title="statement not covered" >t</span>his._isReadableStream=t instanceof ReadableStream;<span class="cstat-no" title="statement not covered" >t</span>his._container=this._rootContainer=e;<span class="cstat-no" title="statement not covered" >t</span>his._textDivs=a||[];<span class="cstat-no" title="statement not covered" >t</span>his._textContentItemsStr=o||[];<span class="cstat-no" title="statement not covered" >t</span>his._isOffscreenCanvasSupported=l;<span class="cstat-no" title="statement not covered" >t</span>his._fontInspectorEnabled=!!globalThis.FontInspector?.enabled;<span class="cstat-no" title="statement not covered" >t</span>his._reader=null;<span class="cstat-no" title="statement not covered" >t</span>his._textDivProperties=r||new WeakMap;<span class="cstat-no" title="statement not covered" >t</span>his._canceled=!1;<span class="cstat-no" title="statement not covered" >t</span>his._capability=new s.PromiseCapability;<span class="cstat-no" title="statement not covered" >t</span>his._layoutTextParams={prevFontSize:null,prevFontFamily:null,div:null,scale:i.scale*(globalThis.devicePixelRatio||1),properties:null,ctx:getCtx(0,l)};c</span>onst{pageWidth:c,pageHeight:h,pageX:d,pageY:u}=<span class="cstat-no" title="statement not covered" >i.rawDims;<span class="cstat-no" title="statement not covered" ></span>this._transform=[1,0,0,-1,-d,u+h];<span class="cstat-no" title="statement not covered" >t</span>his._pageWidth=c;<span class="cstat-no" title="statement not covered" >t</span>his._pageHeight=h;<span class="cstat-no" title="statement not covered" >(</span>0,n.setLayerDimensions)(e,i);<span class="cstat-no" title="statement not covered" >t</span>his._capability.promise.finally((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._layoutTextParams=null}</span>)).catch((<span class="fstat-no" title="function not covered" >()</span>=&gt;{}))}<span class="fstat-no" title="function not covered" ></span>ge</span>t promise(){<span class="cstat-no" title="statement not covered" >return this._capability.promise}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(){<span class="cstat-no" title="statement not covered" >this._canceled=!0;<span class="cstat-no" title="statement not covered" >i</span>f(this._reader){<span class="cstat-no" title="statement not covered" >this._reader.cancel(new s.AbortException("TextLayer task cancelled.")).catch((<span class="fstat-no" title="function not covered" >()</span>=&gt;{}));<span class="cstat-no" title="statement not covered" >t</span>his._reader=null}<span class="cstat-no" title="statement not covered" ></span>t</span>his._capability.reject(new s.AbortException("TextLayer task cancelled."))}<span class="fstat-no" title="function not covered" ></span>_p</span>rocessItems(t,e){<span class="cstat-no" title="statement not covered" >for(const i of t)<span class="cstat-no" title="statement not covered" >if(void 0!==i.str){<span class="cstat-no" title="statement not covered" >this._textContentItemsStr.push(i.str);<span class="cstat-no" title="statement not covered" >a</span>ppendText(this,i,e)}</span>else <span class="cstat-no" title="statement not covered" >if("beginMarkedContentProps"===i.type||"beginMarkedContent"===i.type){const t=<span class="cstat-no" title="statement not covered" >this._container;<span class="cstat-no" title="statement not covered" ></span>this._container=document.createElement("span");<span class="cstat-no" title="statement not covered" >t</span>his._container.classList.add("markedContent");<span class="cstat-no" title="statement not covered" >n</span>ull!==i.id&amp;&amp;this._container.setAttribute("id",`${i.id}`);<span class="cstat-no" title="statement not covered" >t</span>.append(this._container)}</span>else<span class="cstat-no" title="statement not covered" >"endMarkedContent"===i.type&amp;&amp;(this._container=this._container.parentNode)}<span class="fstat-no" title="function not covered" ></span></span></span></span>_l</span>ayoutText(t){const e=<span class="cstat-no" title="statement not covered" >this._layoutTextParams.properties=this._textDivProperties.get(t);<span class="cstat-no" title="statement not covered" ></span>this._layoutTextParams.div=t;<span class="cstat-no" title="statement not covered" >l</span>ayout(this._layoutTextParams);<span class="cstat-no" title="statement not covered" >e</span>.hasText&amp;&amp;this._container.append(t);<span class="cstat-no" title="statement not covered" >i</span>f(e.hasEOL){const t=<span class="cstat-no" title="statement not covered" >document.createElement("br");<span class="cstat-no" title="statement not covered" ></span>t.setAttribute("role","presentation");<span class="cstat-no" title="statement not covered" >t</span>his._container.append(t)}</span>}<span class="fstat-no" title="function not covered" ></span>_r</span>ender(){const t=<span class="cstat-no" title="statement not covered" >new s.PromiseCapability;</span>let e=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>if(this._isReadableStream){const pump=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._reader.read().then((<span class="fstat-no" title="function not covered" >({</span>value:i,done:s})=&gt;{<span class="cstat-no" title="statement not covered" >if(s)<span class="cstat-no" title="statement not covered" >t.resolve();e</span>lse{<span class="cstat-no" title="statement not covered" >Object.assign(e,i.styles);<span class="cstat-no" title="statement not covered" >t</span>his._processItems(i.items,e);<span class="cstat-no" title="statement not covered" >p</span>ump()}</span>}</span>),t.reject)}</span>;<span class="cstat-no" title="statement not covered" ></span>this._reader=this._textContentSource.getReader();<span class="cstat-no" title="statement not covered" >p</span>ump()}</span>else{<span class="cstat-no" title="statement not covered" >if(!this._textContentSource)<span class="cstat-no" title="statement not covered" >throw new Error('No "textContentSource" parameter specified.');{</span></span>const{items:e,styles:i}=<span class="cstat-no" title="statement not covered" >this._textContentSource;<span class="cstat-no" title="statement not covered" ></span>this._processItems(e,i);<span class="cstat-no" title="statement not covered" >t</span>.resolve()}</span>}<span class="cstat-no" title="statement not covered" >t</span>.promise.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e=null;<span class="cstat-no" title="statement not covered" >!</span>function <span class="fstat-no" title="function not covered" >render(</span>t){<span class="cstat-no" title="statement not covered" >if(t._canceled)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t._textDivs,</span>i=<span class="cstat-no" title="statement not covered" >t._capability;<span class="cstat-no" title="statement not covered" ></span>if(e.length&gt;1e5)<span class="cstat-no" title="statement not covered" >i.resolve();e</span>lse{<span class="cstat-no" title="statement not covered" >if(!t._isReadableStream)<span class="cstat-no" title="statement not covered" >for(const i of e)<span class="cstat-no" title="statement not covered" >t._layoutText(i);<span class="cstat-no" title="statement not covered" >i</span></span></span>.resolve()}</span>}</span>(this)}</span>),this._capability.reject)}</span>}<span class="cstat-no" title="statement not covered" >e.TextLayerRenderTask=TextLayerRenderTask}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.AnnotationEditorLayer=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(4),</span>a=<span class="cstat-no" title="statement not covered" >i(28),</span>r=<span class="cstat-no" title="statement not covered" >i(33),</span>o=<span class="cstat-no" title="statement not covered" >i(6),</span>l=<span class="cstat-no" title="statement not covered" >i(34);</span>class AnnotationEditorLayer{#fe;#be=<span class="cstat-no" title="statement not covered" >!1;</span>#Ae=<span class="cstat-no" title="statement not covered" >null;</span>#_e=<span class="cstat-no" title="statement not covered" >this.pointerup.bind(this);</span>#ve=<span class="cstat-no" title="statement not covered" >this.pointerdown.bind(this);</span>#ye=<span class="cstat-no" title="statement not covered" >new Map;</span>#Se=<span class="cstat-no" title="statement not covered" >!1;</span>#Ee=<span class="cstat-no" title="statement not covered" >!1;</span>#xe=<span class="cstat-no" title="statement not covered" >!1;</span>#we;static _initialized=<span class="cstat-no" title="statement not covered" >!1;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor({uiManager:t,pageIndex:e,div:i,accessibilityManager:s,annotationLayer:n,viewport:o,l10n:c}){const h=<span class="cstat-no" title="statement not covered" >[a.FreeTextEditor,r.InkEditor,l.StampEditor];<span class="cstat-no" title="statement not covered" ></span>if(!AnnotationEditorLayer._initialized){<span class="cstat-no" title="statement not covered" >AnnotationEditorLayer._initialized=!0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of h)<span class="cstat-no" title="statement not covered" >t.initialize(c)}<span class="cstat-no" title="statement not covered" ></span></span>t</span>.registerEditorTypes(h);<span class="cstat-no" title="statement not covered" >t</span>his.#we=t;<span class="cstat-no" title="statement not covered" >t</span>his.pageIndex=e;<span class="cstat-no" title="statement not covered" >t</span>his.div=i;<span class="cstat-no" title="statement not covered" >t</span>his.#fe=s;<span class="cstat-no" title="statement not covered" >t</span>his.#Ae=n;<span class="cstat-no" title="statement not covered" >t</span>his.viewport=o;<span class="cstat-no" title="statement not covered" >t</span>his.#we.addLayer(this)}<span class="fstat-no" title="function not covered" ></span>ge</span>t isEmpty(){<span class="cstat-no" title="statement not covered" >return 0===this.#ye.size}<span class="fstat-no" title="function not covered" ></span>up</span>dateToolbar(t){<span class="cstat-no" title="statement not covered" >this.#we.updateToolbar(t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateMode(t=<span class="branch-0 cbranch-no" title="branch not covered" >this.#we.getMode())</span>{<span class="cstat-no" title="statement not covered" >this.#Ce();<span class="cstat-no" title="statement not covered" >i</span>f(t===s.AnnotationEditorType.INK){<span class="cstat-no" title="statement not covered" >this.addInkEditorIfNeeded(!1);<span class="cstat-no" title="statement not covered" >t</span>his.disableClick()}</span>else <span class="cstat-no" title="statement not covered" >this.enableClick();<span class="cstat-no" title="statement not covered" >i</span></span>f(t!==s.AnnotationEditorType.NONE){<span class="cstat-no" title="statement not covered" >this.div.classList.toggle("freeTextEditing",t===s.AnnotationEditorType.FREETEXT);<span class="cstat-no" title="statement not covered" >t</span>his.div.classList.toggle("inkEditing",t===s.AnnotationEditorType.INK);<span class="cstat-no" title="statement not covered" >t</span>his.div.classList.toggle("stampEditing",t===s.AnnotationEditorType.STAMP);<span class="cstat-no" title="statement not covered" >t</span>his.div.hidden=!1}</span>}<span class="fstat-no" title="function not covered" ></span>ad</span>dInkEditorIfNeeded(t){<span class="cstat-no" title="statement not covered" >if(!t&amp;&amp;this.#we.getMode()!==s.AnnotationEditorType.INK)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!t)<span class="cstat-no" title="statement not covered" >for(const t of this.#ye.values())<span class="cstat-no" title="statement not covered" >if(t.isEmpty()){<span class="cstat-no" title="statement not covered" >t.setInBackground();<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span></span></span>his.#Te({offsetX:0,offsetY:0},!1).setInBackground()}<span class="fstat-no" title="function not covered" ></span>se</span>tEditingState(t){<span class="cstat-no" title="statement not covered" >this.#we.setEditingState(t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dCommands(t){<span class="cstat-no" title="statement not covered" >this.#we.addCommands(t)}<span class="fstat-no" title="function not covered" ></span>en</span>able(){<span class="cstat-no" title="statement not covered" >this.div.style.pointerEvents="auto";c</span>onst t=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>for(const e of this.#ye.values()){<span class="cstat-no" title="statement not covered" >e.enableEditing();<span class="cstat-no" title="statement not covered" >e</span>.annotationElementId&amp;&amp;t.add(e.annotationElementId)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this.#Ae)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.#Ae.getEditableAnnotations();<span class="cstat-no" title="statement not covered" ></span>for(const i of e){<span class="cstat-no" title="statement not covered" >i.hide();<span class="cstat-no" title="statement not covered" >i</span>f(this.#we.isDeletedAnnotationElement(i.data.id))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.has(i.data.id))<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.deserialize(i);<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >this.addOrRebuild(e);<span class="cstat-no" title="statement not covered" >e</span>.enableEditing()}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>di</span>sable(){<span class="cstat-no" title="statement not covered" >this.#xe=!0;<span class="cstat-no" title="statement not covered" >t</span>his.div.style.pointerEvents="none";c</span>onst t=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>for(const e of this.#ye.values()){<span class="cstat-no" title="statement not covered" >e.disableEditing();<span class="cstat-no" title="statement not covered" >i</span>f(e.annotationElementId&amp;&amp;null===e.serialize()){<span class="cstat-no" title="statement not covered" >this.getEditableAnnotation(e.annotationElementId)?.show();<span class="cstat-no" title="statement not covered" >e</span>.remove()}</span>else <span class="cstat-no" title="statement not covered" >t.add(e.annotationElementId)}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(this.#Ae){const e=<span class="cstat-no" title="statement not covered" >this.#Ae.getEditableAnnotations();<span class="cstat-no" title="statement not covered" ></span>for(const i of e){const{id:e}=<span class="cstat-no" title="statement not covered" >i.data;<span class="cstat-no" title="statement not covered" ></span>t.has(e)||this.#we.isDeletedAnnotationElement(e)||i.show()}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#Ce();<span class="cstat-no" title="statement not covered" >t</span>his.isEmpty&amp;&amp;(this.div.hidden=!0);<span class="cstat-no" title="statement not covered" >t</span>his.#xe=!1}<span class="fstat-no" title="function not covered" ></span>ge</span>tEditableAnnotation(t){<span class="cstat-no" title="statement not covered" >return this.#Ae?.getEditableAnnotation(t)||null}<span class="fstat-no" title="function not covered" ></span>se</span>tActiveEditor(t){<span class="cstat-no" title="statement not covered" >this.#we.getActive()!==t&amp;&amp;this.#we.setActiveEditor(t)}<span class="fstat-no" title="function not covered" ></span>en</span>ableClick(){<span class="cstat-no" title="statement not covered" >this.div.addEventListener("pointerdown",this.#ve);<span class="cstat-no" title="statement not covered" >t</span>his.div.addEventListener("pointerup",this.#_e)}<span class="fstat-no" title="function not covered" ></span>di</span>sableClick(){<span class="cstat-no" title="statement not covered" >this.div.removeEventListener("pointerdown",this.#ve);<span class="cstat-no" title="statement not covered" >t</span>his.div.removeEventListener("pointerup",this.#_e)}<span class="fstat-no" title="function not covered" ></span>at</span>tach(t){<span class="cstat-no" title="statement not covered" >this.#ye.set(t.id,t);c</span>onst{annotationElementId:e}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;this.#we.isDeletedAnnotationElement(e)&amp;&amp;this.#we.removeDeletedAnnotationElement(t)}<span class="fstat-no" title="function not covered" ></span>de</span>tach(t){<span class="cstat-no" title="statement not covered" >this.#ye.delete(t.id);<span class="cstat-no" title="statement not covered" >t</span>his.#fe?.removePointerInTextLayer(t.contentDiv);<span class="cstat-no" title="statement not covered" >!</span>this.#xe&amp;&amp;t.annotationElementId&amp;&amp;this.#we.addDeletedAnnotationElement(t)}<span class="fstat-no" title="function not covered" ></span>re</span>move(t){<span class="cstat-no" title="statement not covered" >this.detach(t);<span class="cstat-no" title="statement not covered" >t</span>his.#we.removeEditor(t);<span class="cstat-no" title="statement not covered" >t</span>.div.contains(document.activeElement)&amp;&amp;setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.#we.focusMainContainer()}</span>),0);<span class="cstat-no" title="statement not covered" >t</span>.div.remove();<span class="cstat-no" title="statement not covered" >t</span>.isAttachedToDOM=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#Ee||this.addInkEditorIfNeeded(!1)}<span class="fstat-no" title="function not covered" ></span>ch</span>angeParent(t){<span class="cstat-no" title="statement not covered" >if(t.parent!==this){<span class="cstat-no" title="statement not covered" >if(t.annotationElementId){<span class="cstat-no" title="statement not covered" >this.#we.addDeletedAnnotationElement(t.annotationElementId);<span class="cstat-no" title="statement not covered" >n</span>.AnnotationEditor.deleteAnnotationElement(t);<span class="cstat-no" title="statement not covered" >t</span>.annotationElementId=null}<span class="cstat-no" title="statement not covered" ></span>t</span>his.attach(t);<span class="cstat-no" title="statement not covered" >t</span>.parent?.detach(t);<span class="cstat-no" title="statement not covered" >t</span>.setParent(this);<span class="cstat-no" title="statement not covered" >i</span>f(t.div&amp;&amp;t.isAttachedToDOM){<span class="cstat-no" title="statement not covered" >t.div.remove();<span class="cstat-no" title="statement not covered" >t</span>his.div.append(t.div)}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>ad</span>d(t){<span class="cstat-no" title="statement not covered" >this.changeParent(t);<span class="cstat-no" title="statement not covered" >t</span>his.#we.addEditor(t);<span class="cstat-no" title="statement not covered" >t</span>his.attach(t);<span class="cstat-no" title="statement not covered" >i</span>f(!t.isAttachedToDOM){const e=<span class="cstat-no" title="statement not covered" >t.render();<span class="cstat-no" title="statement not covered" ></span>this.div.append(e);<span class="cstat-no" title="statement not covered" >t</span>.isAttachedToDOM=!0}<span class="cstat-no" title="statement not covered" ></span>t</span>his.moveEditorInDOM(t);<span class="cstat-no" title="statement not covered" >t</span>.onceAdded();<span class="cstat-no" title="statement not covered" >t</span>his.#we.addToAnnotationStorage(t)}<span class="fstat-no" title="function not covered" ></span>mo</span>veEditorInDOM(t){<span class="cstat-no" title="statement not covered" >if(!t.isAttachedToDOM)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{activeElement:e}=<span class="cstat-no" title="statement not covered" >document;<span class="cstat-no" title="statement not covered" ></span>if(t.div.contains(e)){<span class="cstat-no" title="statement not covered" >t._focusEventsAllowed=!1;<span class="cstat-no" title="statement not covered" >s</span>etTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.div.addEventListener("focusin",(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t._focusEventsAllowed=!0}</span>),{once:!0});<span class="cstat-no" title="statement not covered" >e</span>.focus()}</span>),0)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#fe?.moveElementInDOM(this.div,t.div,t.contentDiv,!0)}<span class="fstat-no" title="function not covered" ></span>ad</span>dOrRebuild(t){<span class="cstat-no" title="statement not covered" >t.needsToBeRebuilt()?t.rebuild():this.add(t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dUndoableEditor(t){<span class="cstat-no" title="statement not covered" >this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t._uiManager.rebuild(t),</span>undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.remove()}</span>,mustExec:!1})}<span class="fstat-no" title="function not covered" ></span>ge</span>tNextId(){<span class="cstat-no" title="statement not covered" >return this.#we.getId()}</span>#Pe(t){<span class="cstat-no" title="statement not covered" >switch(this.#we.getMode()){case s.AnnotationEditorType.FREETEXT:<span class="cstat-no" title="statement not covered" >return new a.FreeTextEditor(t);c</span>ase s.AnnotationEditorType.INK:<span class="cstat-no" title="statement not covered" >return new r.InkEditor(t);c</span>ase s.AnnotationEditorType.STAMP:<span class="cstat-no" title="statement not covered" >return new l.StampEditor(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}<span class="fstat-no" title="function not covered" ></span>pa</span>steEditor(t,e){<span class="cstat-no" title="statement not covered" >this.#we.updateToolbar(t);<span class="cstat-no" title="statement not covered" >t</span>his.#we.updateMode(t);c</span>onst{offsetX:i,offsetY:s}=<span class="cstat-no" title="statement not covered" >this.#Me(),</span>n=<span class="cstat-no" title="statement not covered" >this.getNextId(),</span>a=<span class="cstat-no" title="statement not covered" >this.#Pe({parent:this,id:n,x:i,y:s,uiManager:this.#we,isCentered:!0,...e});<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;this.add(a)}<span class="fstat-no" title="function not covered" ></span>de</span>serialize(t){<span class="cstat-no" title="statement not covered" >switch(t.annotationType??t.annotationEditorType){case s.AnnotationEditorType.FREETEXT:<span class="cstat-no" title="statement not covered" >return a.FreeTextEditor.deserialize(t,this,this.#we);c</span>ase s.AnnotationEditorType.INK:<span class="cstat-no" title="statement not covered" >return r.InkEditor.deserialize(t,this,this.#we);c</span>ase s.AnnotationEditorType.STAMP:<span class="cstat-no" title="statement not covered" >return l.StampEditor.deserialize(t,this,this.#we)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}</span>#Te(t,e){const i=<span class="cstat-no" title="statement not covered" >this.getNextId(),</span>s=<span class="cstat-no" title="statement not covered" >this.#Pe({parent:this,id:i,x:t.offsetX,y:t.offsetY,uiManager:this.#we,isCentered:e});<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;this.add(s);<span class="cstat-no" title="statement not covered" >r</span>eturn s}</span>#Me(){const{x:t,y:e,width:i,height:s}=<span class="cstat-no" title="statement not covered" >this.div.getBoundingClientRect(),</span>n=<span class="cstat-no" title="statement not covered" >Math.max(0,t),</span>a=<span class="cstat-no" title="statement not covered" >Math.max(0,e),</span>r=<span class="cstat-no" title="statement not covered" >(n+Math.min(window.innerWidth,t+i))/2-t,</span>o=<span class="cstat-no" title="statement not covered" >(a+Math.min(window.innerHeight,e+s))/2-e,</span>[l,c]=<span class="cstat-no" title="statement not covered" >this.viewport.rotation%180==0?[r,o]:[o,r];<span class="cstat-no" title="statement not covered" ></span>return{offsetX:l,offsetY:c}}<span class="fstat-no" title="function not covered" ></span>ad</span>dNewEditor(){<span class="cstat-no" title="statement not covered" >this.#Te(this.#Me(),!0)}<span class="fstat-no" title="function not covered" ></span>se</span>tSelected(t){<span class="cstat-no" title="statement not covered" >this.#we.setSelected(t)}<span class="fstat-no" title="function not covered" ></span>to</span>ggleSelected(t){<span class="cstat-no" title="statement not covered" >this.#we.toggleSelected(t)}<span class="fstat-no" title="function not covered" ></span>is</span>Selected(t){<span class="cstat-no" title="statement not covered" >return this.#we.isSelected(t)}<span class="fstat-no" title="function not covered" ></span>un</span>select(t){<span class="cstat-no" title="statement not covered" >this.#we.unselect(t)}<span class="fstat-no" title="function not covered" ></span>po</span>interup(t){const{isMac:e}=<span class="cstat-no" title="statement not covered" >s.FeatureTest.platform;<span class="cstat-no" title="statement not covered" ></span>if(!(0!==t.button||t.ctrlKey&amp;&amp;e)&amp;&amp;t.target===this.div&amp;&amp;this.#Se){<span class="cstat-no" title="statement not covered" >this.#Se=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#be?this.#we.getMode()!==s.AnnotationEditorType.STAMP?this.#Te(t,!1):this.#we.unselectAll():this.#be=!0}</span>}<span class="fstat-no" title="function not covered" ></span>po</span>interdown(t){<span class="cstat-no" title="statement not covered" >if(this.#Se){<span class="cstat-no" title="statement not covered" >this.#Se=!1;<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst{isMac:e}=<span class="cstat-no" title="statement not covered" >s.FeatureTest.platform;<span class="cstat-no" title="statement not covered" ></span>if(0!==t.button||t.ctrlKey&amp;&amp;e)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.target!==this.div)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.#Se=!0;c</span>onst i=<span class="cstat-no" title="statement not covered" >this.#we.getActive();<span class="cstat-no" title="statement not covered" ></span>this.#be=!i||i.isEmpty()}<span class="fstat-no" title="function not covered" ></span>fi</span>ndNewParent(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.#we.findParent(e,i);<span class="cstat-no" title="statement not covered" ></span>if(null===s||s===this)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >s</span></span>.changeParent(t);<span class="cstat-no" title="statement not covered" >r</span>eturn!0}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.#we.getActive()?.parent===this&amp;&amp;this.#we.setActiveEditor(null);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#ye.values()){<span class="cstat-no" title="statement not covered" >this.#fe?.removePointerInTextLayer(t.contentDiv);<span class="cstat-no" title="statement not covered" >t</span>.setParent(null);<span class="cstat-no" title="statement not covered" >t</span>.isAttachedToDOM=!1;<span class="cstat-no" title="statement not covered" >t</span>.div.remove()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.div=null;<span class="cstat-no" title="statement not covered" >t</span>his.#ye.clear();<span class="cstat-no" title="statement not covered" >t</span>his.#we.removeLayer(this)}</span>#Ce(){<span class="cstat-no" title="statement not covered" >this.#Ee=!0;<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#ye.values())<span class="cstat-no" title="statement not covered" >t.isEmpty()&amp;&amp;t.remove();<span class="cstat-no" title="statement not covered" >t</span></span>his.#Ee=!1}<span class="fstat-no" title="function not covered" ></span>re</span>nder({viewport:t}){<span class="cstat-no" title="statement not covered" >this.viewport=t;<span class="cstat-no" title="statement not covered" >(</span>0,o.setLayerDimensions)(this.div,t);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.#we.getEditors(this.pageIndex))<span class="cstat-no" title="statement not covered" >this.add(t);<span class="cstat-no" title="statement not covered" >t</span></span>his.updateMode()}<span class="fstat-no" title="function not covered" ></span>up</span>date({viewport:t}){<span class="cstat-no" title="statement not covered" >this.#we.commitOrRemove();<span class="cstat-no" title="statement not covered" >t</span>his.viewport=t;<span class="cstat-no" title="statement not covered" >(</span>0,o.setLayerDimensions)(this.div,{rotation:t.rotation});<span class="cstat-no" title="statement not covered" >t</span>his.updateMode()}<span class="fstat-no" title="function not covered" ></span>ge</span>t pageDimensions(){const{pageWidth:t,pageHeight:e}=<span class="cstat-no" title="statement not covered" >this.viewport.rawDims;<span class="cstat-no" title="statement not covered" ></span>return[t,e]}</span>}<span class="cstat-no" title="statement not covered" >e.AnnotationEditorLayer=AnnotationEditorLayer}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.FreeTextEditor=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(5),</span>a=<span class="cstat-no" title="statement not covered" >i(4),</span>r=<span class="cstat-no" title="statement not covered" >i(29);</span>class FreeTextEditor extends a.AnnotationEditor{#Fe=<span class="cstat-no" title="statement not covered" >this.editorDivBlur.bind(this);</span>#ke=<span class="cstat-no" title="statement not covered" >this.editorDivFocus.bind(this);</span>#Re=<span class="cstat-no" title="statement not covered" >this.editorDivInput.bind(this);</span>#De=<span class="cstat-no" title="statement not covered" >this.editorDivKeydown.bind(this);</span>#Ie;#Le=<span class="cstat-no" title="statement not covered" >"";</span>#Oe=<span class="cstat-no" title="statement not covered" >`${this.id}-editor`;</span>#Ne;#Be=<span class="cstat-no" title="statement not covered" >null;</span>static _freeTextDefaultContent=<span class="cstat-no" title="statement not covered" >"";</span>static _l10nPromise;static _internalPadding=<span class="cstat-no" title="statement not covered" >0;</span>static _defaultColor=<span class="cstat-no" title="statement not covered" >null;</span>static _defaultFontSize=<span class="cstat-no" title="statement not covered" >10;<span class="fstat-no" title="function not covered" ></span>st</span>atic get _keyboardManager(){const t=<span class="cstat-no" title="statement not covered" >FreeTextEditor.prototype,</span>arrowChecker=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.isEmpty(),</span></span>e=<span class="cstat-no" title="statement not covered" >n.AnnotationEditorUIManager.TRANSLATE_SMALL,</span>i=<span class="cstat-no" title="statement not covered" >n.AnnotationEditorUIManager.TRANSLATE_BIG;<span class="cstat-no" title="statement not covered" ></span>return(0,s.shadow)(this,"_keyboardManager",new n.KeyboardManager([[["ctrl+s","mac+meta+s","ctrl+p","mac+meta+p"],t.commitOrRemove,{bubbles:!0}],[["ctrl+Enter","mac+meta+Enter","Escape","mac+Escape"],t.commitOrRemove],[["ArrowLeft","mac+ArrowLeft"],t._translateEmpty,{args:[-e,0],checker:arrowChecker}],[["ctrl+ArrowLeft","mac+shift+ArrowLeft"],t._translateEmpty,{args:[-i,0],checker:arrowChecker}],[["ArrowRight","mac+ArrowRight"],t._translateEmpty,{args:[e,0],checker:arrowChecker}],[["ctrl+ArrowRight","mac+shift+ArrowRight"],t._translateEmpty,{args:[i,0],checker:arrowChecker}],[["ArrowUp","mac+ArrowUp"],t._translateEmpty,{args:[0,-e],checker:arrowChecker}],[["ctrl+ArrowUp","mac+shift+ArrowUp"],t._translateEmpty,{args:[0,-i],checker:arrowChecker}],[["ArrowDown","mac+ArrowDown"],t._translateEmpty,{args:[0,e],checker:arrowChecker}],[["ctrl+ArrowDown","mac+shift+ArrowDown"],t._translateEmpty,{args:[0,i],checker:arrowChecker}]]))}</span>static _type=<span class="cstat-no" title="statement not covered" >"freetext";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super({...t,name:"freeTextEditor"});<span class="cstat-no" title="statement not covered" >t</span>his.#Ie=t.color||FreeTextEditor._defaultColor||a.AnnotationEditor._defaultLineColor;<span class="cstat-no" title="statement not covered" >t</span>his.#Ne=t.fontSize||FreeTextEditor._defaultFontSize}<span class="fstat-no" title="function not covered" ></span>st</span>atic initialize(t){<span class="cstat-no" title="statement not covered" >this._l10nPromise=new Map(["free_text2_default_content","editor_free_text2_aria_label"].map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >[e,t.get(e)])</span>));c</span>onst e=<span class="cstat-no" title="statement not covered" >getComputedStyle(document.documentElement);<span class="cstat-no" title="statement not covered" ></span>this._internalPadding=parseFloat(e.getPropertyValue("--freetext-padding"))}<span class="fstat-no" title="function not covered" ></span>st</span>atic updateDefaultParams(t,e){<span class="cstat-no" title="statement not covered" >switch(t){case s.AnnotationEditorParamsType.FREETEXT_SIZE:<span class="cstat-no" title="statement not covered" >FreeTextEditor._defaultFontSize=e;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.AnnotationEditorParamsType.FREETEXT_COLOR:<span class="cstat-no" title="statement not covered" >FreeTextEditor._defaultColor=e}</span>}<span class="fstat-no" title="function not covered" ></span>up</span>dateParams(t,e){<span class="cstat-no" title="statement not covered" >switch(t){case s.AnnotationEditorParamsType.FREETEXT_SIZE:<span class="cstat-no" title="statement not covered" >this.#Ue(e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.AnnotationEditorParamsType.FREETEXT_COLOR:<span class="cstat-no" title="statement not covered" >this.#je(e)}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>atic get defaultPropertiesToUpdate(){<span class="cstat-no" title="statement not covered" >return[[s.AnnotationEditorParamsType.FREETEXT_SIZE,FreeTextEditor._defaultFontSize],[s.AnnotationEditorParamsType.FREETEXT_COLOR,FreeTextEditor._defaultColor||a.AnnotationEditor._defaultLineColor]]}<span class="fstat-no" title="function not covered" ></span>ge</span>t propertiesToUpdate(){<span class="cstat-no" title="statement not covered" >return[[s.AnnotationEditorParamsType.FREETEXT_SIZE,this.#Ne],[s.AnnotationEditorParamsType.FREETEXT_COLOR,this.#Ie]]}</span>#Ue(t){const setFontsize=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.editorDiv.style.fontSize=`calc(${t}px * var(--scale-factor))`;<span class="cstat-no" title="statement not covered" >t</span>his.translate(0,-(t-this.#Ne)*this.parentScale);<span class="cstat-no" title="statement not covered" >t</span>his.#Ne=t;<span class="cstat-no" title="statement not covered" >t</span>his.#ze()}</span>,</span>e=<span class="cstat-no" title="statement not covered" >this.#Ne;<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >setFontsize(t)}</span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >setFontsize(e)}</span>,mustExec:!0,type:s.AnnotationEditorParamsType.FREETEXT_SIZE,overwriteIfSameType:!0,keepUndo:!0})}</span>#je(t){const e=<span class="cstat-no" title="statement not covered" >this.#Ie;<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.#Ie=this.editorDiv.style.color=t}</span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.#Ie=this.editorDiv.style.color=e}</span>,mustExec:!0,type:s.AnnotationEditorParamsType.FREETEXT_COLOR,overwriteIfSameType:!0,keepUndo:!0})}<span class="fstat-no" title="function not covered" ></span>_t</span>ranslateEmpty(t,e){<span class="cstat-no" title="statement not covered" >this._uiManager.translateSelectedEditors(t,e,!0)}<span class="fstat-no" title="function not covered" ></span>ge</span>tInitialTranslation(){const t=<span class="cstat-no" title="statement not covered" >this.parentScale;<span class="cstat-no" title="statement not covered" ></span>return[-FreeTextEditor._internalPadding*t,-(FreeTextEditor._internalPadding+this.#Ne)*t]}<span class="fstat-no" title="function not covered" ></span>re</span>build(){<span class="cstat-no" title="statement not covered" >if(this.parent){<span class="cstat-no" title="statement not covered" >super.rebuild();<span class="cstat-no" title="statement not covered" >n</span>ull!==this.div&amp;&amp;(this.isAttachedToDOM||this.parent.add(this))}</span>}<span class="fstat-no" title="function not covered" ></span>en</span>ableEditMode(){<span class="cstat-no" title="statement not covered" >if(!this.isInEditMode()){<span class="cstat-no" title="statement not covered" >this.parent.setEditingState(!1);<span class="cstat-no" title="statement not covered" >t</span>his.parent.updateToolbar(s.AnnotationEditorType.FREETEXT);<span class="cstat-no" title="statement not covered" >s</span>uper.enableEditMode();<span class="cstat-no" title="statement not covered" >t</span>his.overlayDiv.classList.remove("enabled");<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.contentEditable=!0;<span class="cstat-no" title="statement not covered" >t</span>his._isDraggable=!1;<span class="cstat-no" title="statement not covered" >t</span>his.div.removeAttribute("aria-activedescendant");<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.addEventListener("keydown",this.#De);<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.addEventListener("focus",this.#ke);<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.addEventListener("blur",this.#Fe);<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.addEventListener("input",this.#Re)}</span>}<span class="fstat-no" title="function not covered" ></span>di</span>sableEditMode(){<span class="cstat-no" title="statement not covered" >if(this.isInEditMode()){<span class="cstat-no" title="statement not covered" >this.parent.setEditingState(!0);<span class="cstat-no" title="statement not covered" >s</span>uper.disableEditMode();<span class="cstat-no" title="statement not covered" >t</span>his.overlayDiv.classList.add("enabled");<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.contentEditable=!1;<span class="cstat-no" title="statement not covered" >t</span>his.div.setAttribute("aria-activedescendant",this.#Oe);<span class="cstat-no" title="statement not covered" >t</span>his._isDraggable=!0;<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.removeEventListener("keydown",this.#De);<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.removeEventListener("focus",this.#ke);<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.removeEventListener("blur",this.#Fe);<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.removeEventListener("input",this.#Re);<span class="cstat-no" title="statement not covered" >t</span>his.div.focus({preventScroll:!0});<span class="cstat-no" title="statement not covered" >t</span>his.isEditing=!1;<span class="cstat-no" title="statement not covered" >t</span>his.parent.div.classList.add("freeTextEditing")}</span>}<span class="fstat-no" title="function not covered" ></span>fo</span>cusin(t){<span class="cstat-no" title="statement not covered" >if(this._focusEventsAllowed){<span class="cstat-no" title="statement not covered" >super.focusin(t);<span class="cstat-no" title="statement not covered" >t</span>.target!==this.editorDiv&amp;&amp;this.editorDiv.focus()}</span>}<span class="fstat-no" title="function not covered" ></span>on</span>ceAdded(){<span class="cstat-no" title="statement not covered" >if(this.width)<span class="cstat-no" title="statement not covered" >this.#He();e</span>lse{<span class="cstat-no" title="statement not covered" >this.enableEditMode();<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.focus();<span class="cstat-no" title="statement not covered" >t</span>his._initialOptions?.isCentered&amp;&amp;this.center();<span class="cstat-no" title="statement not covered" >t</span>his._initialOptions=null}</span>}<span class="fstat-no" title="function not covered" ></span>is</span>Empty(){<span class="cstat-no" title="statement not covered" >return!this.editorDiv||""===this.editorDiv.innerText.trim()}<span class="fstat-no" title="function not covered" ></span>re</span>move(){<span class="cstat-no" title="statement not covered" >this.isEditing=!1;<span class="cstat-no" title="statement not covered" >i</span>f(this.parent){<span class="cstat-no" title="statement not covered" >this.parent.setEditingState(!0);<span class="cstat-no" title="statement not covered" >t</span>his.parent.div.classList.add("freeTextEditing")}<span class="cstat-no" title="statement not covered" ></span>s</span>uper.remove()}</span>#We(){const t=<span class="cstat-no" title="statement not covered" >this.editorDiv.getElementsByTagName("div");<span class="cstat-no" title="statement not covered" ></span>if(0===t.length)<span class="cstat-no" title="statement not covered" >return this.editorDiv.innerText;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const i of t)<span class="cstat-no" title="statement not covered" >e.push(i.innerText.replace(/\r\n?|\n/,""));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.join("\n")}</span>#ze(){const[t,e]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;</span>let i;<span class="cstat-no" title="statement not covered" >if(this.isAttachedToDOM)<span class="cstat-no" title="statement not covered" >i=this.div.getBoundingClientRect();e</span>lse{const{currentLayer:t,div:e}=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >e.style.display;<span class="cstat-no" title="statement not covered" ></span>e.style.display="hidden";<span class="cstat-no" title="statement not covered" >t</span>.div.append(this.div);<span class="cstat-no" title="statement not covered" >i</span>=e.getBoundingClientRect();<span class="cstat-no" title="statement not covered" >e</span>.remove();<span class="cstat-no" title="statement not covered" >e</span>.style.display=s}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.rotation%180==this.parentRotation%180){<span class="cstat-no" title="statement not covered" >this.width=i.width/t;<span class="cstat-no" title="statement not covered" >t</span>his.height=i.height/e}</span>else{<span class="cstat-no" title="statement not covered" >this.width=i.height/t;<span class="cstat-no" title="statement not covered" >t</span>his.height=i.width/e}<span class="cstat-no" title="statement not covered" ></span>t</span>his.fixAndSetPosition()}<span class="fstat-no" title="function not covered" ></span>co</span>mmit(){<span class="cstat-no" title="statement not covered" >if(!this.isInEditMode())<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >s</span></span>uper.commit();<span class="cstat-no" title="statement not covered" >t</span>his.disableEditMode();c</span>onst t=<span class="cstat-no" title="statement not covered" >this.#Le,</span>e=<span class="cstat-no" title="statement not covered" >this.#Le=this.#We().trimEnd();<span class="cstat-no" title="statement not covered" ></span>if(t===e)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst setText=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.#Le=t;<span class="cstat-no" title="statement not covered" >i</span>f(t){<span class="cstat-no" title="statement not covered" >this.#Ge();<span class="cstat-no" title="statement not covered" >t</span>his._uiManager.rebuild(this);<span class="cstat-no" title="statement not covered" >t</span>his.#ze()}</span>else <span class="cstat-no" title="statement not covered" >this.remove()}</span></span>;<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >setText(e)}</span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >setText(t)}</span>,mustExec:!1});<span class="cstat-no" title="statement not covered" >t</span>his.#ze()}<span class="fstat-no" title="function not covered" ></span>sh</span>ouldGetKeyboardEvents(){<span class="cstat-no" title="statement not covered" >return this.isInEditMode()}<span class="fstat-no" title="function not covered" ></span>en</span>terInEditMode(){<span class="cstat-no" title="statement not covered" >this.enableEditMode();<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.focus()}<span class="fstat-no" title="function not covered" ></span>db</span>lclick(t){<span class="cstat-no" title="statement not covered" >this.enterInEditMode()}<span class="fstat-no" title="function not covered" ></span>ke</span>ydown(t){<span class="cstat-no" title="statement not covered" >if(t.target===this.div&amp;&amp;"Enter"===t.key){<span class="cstat-no" title="statement not covered" >this.enterInEditMode();<span class="cstat-no" title="statement not covered" >t</span>.preventDefault()}</span>}<span class="fstat-no" title="function not covered" ></span>ed</span>itorDivKeydown(t){<span class="cstat-no" title="statement not covered" >FreeTextEditor._keyboardManager.exec(this,t)}<span class="fstat-no" title="function not covered" ></span>ed</span>itorDivFocus(t){<span class="cstat-no" title="statement not covered" >this.isEditing=!0}<span class="fstat-no" title="function not covered" ></span>ed</span>itorDivBlur(t){<span class="cstat-no" title="statement not covered" >this.isEditing=!1}<span class="fstat-no" title="function not covered" ></span>ed</span>itorDivInput(t){<span class="cstat-no" title="statement not covered" >this.parent.div.classList.toggle("freeTextEditing",this.isEmpty())}<span class="fstat-no" title="function not covered" ></span>di</span>sableEditing(){<span class="cstat-no" title="statement not covered" >this.editorDiv.setAttribute("role","comment");<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.removeAttribute("aria-multiline")}<span class="fstat-no" title="function not covered" ></span>en</span>ableEditing(){<span class="cstat-no" title="statement not covered" >this.editorDiv.setAttribute("role","textbox");<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.setAttribute("aria-multiline",!0)}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >if(this.div)<span class="cstat-no" title="statement not covered" >return this.div;l</span></span>et t,e;<span class="cstat-no" title="statement not covered" >if(this.width){<span class="cstat-no" title="statement not covered" >t=this.x;<span class="cstat-no" title="statement not covered" >e</span>=this.y}<span class="cstat-no" title="statement not covered" ></span>s</span>uper.render();<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv=document.createElement("div");<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.className="internal";<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.setAttribute("id",this.#Oe);<span class="cstat-no" title="statement not covered" >t</span>his.enableEditing();<span class="cstat-no" title="statement not covered" >F</span>reeTextEditor._l10nPromise.get("editor_free_text2_aria_label").then((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.editorDiv?.setAttribute("aria-label",t))</span>);<span class="cstat-no" title="statement not covered" >F</span>reeTextEditor._l10nPromise.get("free_text2_default_content").then((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.editorDiv?.setAttribute("default-content",t))</span>);<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.contentEditable=!0;c</span>onst{style:i}=<span class="cstat-no" title="statement not covered" >this.editorDiv;<span class="cstat-no" title="statement not covered" ></span>i.fontSize=`calc(${this.#Ne}px * var(--scale-factor))`;<span class="cstat-no" title="statement not covered" >i</span>.color=this.#Ie;<span class="cstat-no" title="statement not covered" >t</span>his.div.append(this.editorDiv);<span class="cstat-no" title="statement not covered" >t</span>his.overlayDiv=document.createElement("div");<span class="cstat-no" title="statement not covered" >t</span>his.overlayDiv.classList.add("overlay","enabled");<span class="cstat-no" title="statement not covered" >t</span>his.div.append(this.overlayDiv);<span class="cstat-no" title="statement not covered" >(</span>0,n.bindEvents)(this,this.div,["dblclick","keydown"]);<span class="cstat-no" title="statement not covered" >i</span>f(this.width){const[i,s]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>if(this.annotationElementId){const{position:n}=<span class="cstat-no" title="statement not covered" >this.#Be;</span>let[a,r]=<span class="cstat-no" title="statement not covered" >this.getInitialTranslation();<span class="cstat-no" title="statement not covered" ></span>[a,r]=this.pageTranslationToScreen(a,r);c</span>onst[o,l]=<span class="cstat-no" title="statement not covered" >this.pageDimensions,</span>[c,h]=<span class="cstat-no" title="statement not covered" >this.pageTranslation;</span>let d,u;<span class="cstat-no" title="statement not covered" >switch(this.rotation){case 0:<span class="cstat-no" title="statement not covered" >d=t+(n[0]-c)/o;<span class="cstat-no" title="statement not covered" >u</span>=e+this.height-(n[1]-h)/l;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 90:<span class="cstat-no" title="statement not covered" >d=t+(n[0]-c)/o;<span class="cstat-no" title="statement not covered" >u</span>=e-(n[1]-h)/l;<span class="cstat-no" title="statement not covered" >[</span>a,r]=[r,-a];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 180:<span class="cstat-no" title="statement not covered" >d=t-this.width+(n[0]-c)/o;<span class="cstat-no" title="statement not covered" >u</span>=e-(n[1]-h)/l;<span class="cstat-no" title="statement not covered" >[</span>a,r]=[-a,-r];<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 270:<span class="cstat-no" title="statement not covered" >d=t+(n[0]-c-this.height*l)/o;<span class="cstat-no" title="statement not covered" >u</span>=e+(n[1]-h-this.width*o)/l;<span class="cstat-no" title="statement not covered" >[</span>a,r]=[-r,a]}<span class="cstat-no" title="statement not covered" ></span>t</span>his.setAt(d*i,u*s,a,r)}</span>else <span class="cstat-no" title="statement not covered" >this.setAt(t*i,e*s,this.width*i,this.height*s);<span class="cstat-no" title="statement not covered" >t</span></span>his.#Ge();<span class="cstat-no" title="statement not covered" >t</span>his._isDraggable=!0;<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.contentEditable=!1}</span>else{<span class="cstat-no" title="statement not covered" >this._isDraggable=!1;<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.contentEditable=!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.div}</span>#Ge(){<span class="cstat-no" title="statement not covered" >this.editorDiv.replaceChildren();<span class="cstat-no" title="statement not covered" >i</span>f(this.#Le)<span class="cstat-no" title="statement not covered" >for(const t of this.#Le.split("\n")){const e=<span class="cstat-no" title="statement not covered" >document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>e.append(t?document.createTextNode(t):document.createElement("br"));<span class="cstat-no" title="statement not covered" >t</span>his.editorDiv.append(e)}</span>}<span class="fstat-no" title="function not covered" ></span></span>ge</span>t contentDiv(){<span class="cstat-no" title="statement not covered" >return this.editorDiv}<span class="fstat-no" title="function not covered" ></span>st</span>atic deserialize(t,e,i){let n=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(t instanceof r.FreeTextAnnotationElement){const{data:{defaultAppearanceData:{fontSize:e,fontColor:i},rect:a,rotation:r,id:o},textContent:l,textPosition:c,parent:{page:{pageNumber:h}}}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(!l||0===l.length)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >n</span></span>=t={annotationType:s.AnnotationEditorType.FREETEXT,color:Array.from(i),fontSize:e,value:l.join("\n"),position:c,pageIndex:h-1,rect:a,rotation:r,id:o,deleted:!1}}</span>c</span>onst a=<span class="cstat-no" title="statement not covered" >super.deserialize(t,e,i);<span class="cstat-no" title="statement not covered" ></span>a.#Ne=t.fontSize;<span class="cstat-no" title="statement not covered" >a</span>.#Ie=s.Util.makeHexColor(...t.color);<span class="cstat-no" title="statement not covered" >a</span>.#Le=t.value;<span class="cstat-no" title="statement not covered" >a</span>.annotationElementId=t.id||null;<span class="cstat-no" title="statement not covered" >a</span>.#Be=n;<span class="cstat-no" title="statement not covered" >r</span>eturn a}<span class="fstat-no" title="function not covered" ></span>se</span>rialize(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(this.isEmpty())<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.deleted)<span class="cstat-no" title="statement not covered" >return{pageIndex:this.pageIndex,id:this.annotationElementId,deleted:!0};c</span></span>onst e=<span class="cstat-no" title="statement not covered" >FreeTextEditor._internalPadding*this.parentScale,</span>i=<span class="cstat-no" title="statement not covered" >this.getRect(e,e),</span>n=<span class="cstat-no" title="statement not covered" >a.AnnotationEditor._colorManager.convert(this.isAttachedToDOM?getComputedStyle(this.editorDiv).color:this.#Ie),</span>r=<span class="cstat-no" title="statement not covered" >{annotationType:s.AnnotationEditorType.FREETEXT,color:n,fontSize:this.#Ne,value:this.#Le,pageIndex:this.pageIndex,rect:i,rotation:this.rotation};<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.annotationElementId&amp;&amp;!this.#qe(r))<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span></span>.id=this.annotationElementId;<span class="cstat-no" title="statement not covered" >r</span>eturn r}</span>#qe(t){const{value:e,fontSize:i,color:s,rect:n,pageIndex:a}=<span class="cstat-no" title="statement not covered" >this.#Be;<span class="cstat-no" title="statement not covered" ></span>return t.value!==e||t.fontSize!==i||t.rect.some((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.abs(t-n[e])&gt;=1)</span>)||t.color.some((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t!==s[e])</span>)||t.pageIndex!==a}</span>#He(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(!this.annotationElementId)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.#ze();<span class="cstat-no" title="statement not covered" >i</span>f(!t&amp;&amp;(0===this.width||0===this.height)){<span class="cstat-no" title="statement not covered" >setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.#He(!0))</span>,0);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >FreeTextEditor._internalPadding*this.parentScale;<span class="cstat-no" title="statement not covered" ></span>this.#Be.rect=this.getRect(e,e)}</span>}<span class="cstat-no" title="statement not covered" >e.FreeTextEditor=FreeTextEditor}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.StampAnnotationElement=e.InkAnnotationElement=e.FreeTextAnnotationElement=e.AnnotationLayer=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(6),</span>a=<span class="cstat-no" title="statement not covered" >i(3),</span>r=<span class="cstat-no" title="statement not covered" >i(30),</span>o=<span class="cstat-no" title="statement not covered" >i(31),</span>l=<span class="cstat-no" title="statement not covered" >i(32);</span>const c=<span class="cstat-no" title="statement not covered" >1e3,</span>h=<span class="cstat-no" title="statement not covered" >new WeakSet;</span>function <span class="fstat-no" title="function not covered" >getRectDims(</span>t){<span class="cstat-no" title="statement not covered" >return{width:t[2]-t[0],height:t[3]-t[1]}}</span>class AnnotationElementFactory{<span class="fstat-no" title="function not covered" >st</span>atic create(t){<span class="cstat-no" title="statement not covered" >switch(t.data.annotationType){case s.AnnotationType.LINK:<span class="cstat-no" title="statement not covered" >return new LinkAnnotationElement(t);c</span>ase s.AnnotationType.TEXT:<span class="cstat-no" title="statement not covered" >return new TextAnnotationElement(t);c</span>ase s.AnnotationType.WIDGET:<span class="cstat-no" title="statement not covered" >switch(t.data.fieldType){case"Tx":<span class="cstat-no" title="statement not covered" >return new TextWidgetAnnotationElement(t);c</span>ase"Btn":<span class="cstat-no" title="statement not covered" >return t.data.radioButton?new RadioButtonWidgetAnnotationElement(t):t.data.checkBox?new CheckboxWidgetAnnotationElement(t):new PushButtonWidgetAnnotationElement(t);c</span>ase"Ch":<span class="cstat-no" title="statement not covered" >return new ChoiceWidgetAnnotationElement(t);c</span>ase"Sig":<span class="cstat-no" title="statement not covered" >return new SignatureWidgetAnnotationElement(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new WidgetAnnotationElement(t);c</span>ase s.AnnotationType.POPUP:<span class="cstat-no" title="statement not covered" >return new PopupAnnotationElement(t);c</span>ase s.AnnotationType.FREETEXT:<span class="cstat-no" title="statement not covered" >return new FreeTextAnnotationElement(t);c</span>ase s.AnnotationType.LINE:<span class="cstat-no" title="statement not covered" >return new LineAnnotationElement(t);c</span>ase s.AnnotationType.SQUARE:<span class="cstat-no" title="statement not covered" >return new SquareAnnotationElement(t);c</span>ase s.AnnotationType.CIRCLE:<span class="cstat-no" title="statement not covered" >return new CircleAnnotationElement(t);c</span>ase s.AnnotationType.POLYLINE:<span class="cstat-no" title="statement not covered" >return new PolylineAnnotationElement(t);c</span>ase s.AnnotationType.CARET:<span class="cstat-no" title="statement not covered" >return new CaretAnnotationElement(t);c</span>ase s.AnnotationType.INK:<span class="cstat-no" title="statement not covered" >return new InkAnnotationElement(t);c</span>ase s.AnnotationType.POLYGON:<span class="cstat-no" title="statement not covered" >return new PolygonAnnotationElement(t);c</span>ase s.AnnotationType.HIGHLIGHT:<span class="cstat-no" title="statement not covered" >return new HighlightAnnotationElement(t);c</span>ase s.AnnotationType.UNDERLINE:<span class="cstat-no" title="statement not covered" >return new UnderlineAnnotationElement(t);c</span>ase s.AnnotationType.SQUIGGLY:<span class="cstat-no" title="statement not covered" >return new SquigglyAnnotationElement(t);c</span>ase s.AnnotationType.STRIKEOUT:<span class="cstat-no" title="statement not covered" >return new StrikeOutAnnotationElement(t);c</span>ase s.AnnotationType.STAMP:<span class="cstat-no" title="statement not covered" >return new StampAnnotationElement(t);c</span>ase s.AnnotationType.FILEATTACHMENT:<span class="cstat-no" title="statement not covered" >return new FileAttachmentAnnotationElement(t);d</span>efault:<span class="cstat-no" title="statement not covered" >return new AnnotationElement(t)}</span>}</span>}class AnnotationElement{#Ve=<span class="cstat-no" title="statement not covered" >!1;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,{isRenderable:e=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>ignoreBorder:i=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>createQuadrilaterals:s=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this.isRenderable=e;<span class="cstat-no" title="statement not covered" >t</span>his.data=t.data;<span class="cstat-no" title="statement not covered" >t</span>his.layer=t.layer;<span class="cstat-no" title="statement not covered" >t</span>his.linkService=t.linkService;<span class="cstat-no" title="statement not covered" >t</span>his.downloadManager=t.downloadManager;<span class="cstat-no" title="statement not covered" >t</span>his.imageResourcesPath=t.imageResourcesPath;<span class="cstat-no" title="statement not covered" >t</span>his.renderForms=t.renderForms;<span class="cstat-no" title="statement not covered" >t</span>his.svgFactory=t.svgFactory;<span class="cstat-no" title="statement not covered" >t</span>his.annotationStorage=t.annotationStorage;<span class="cstat-no" title="statement not covered" >t</span>his.enableScripting=t.enableScripting;<span class="cstat-no" title="statement not covered" >t</span>his.hasJSActions=t.hasJSActions;<span class="cstat-no" title="statement not covered" >t</span>his._fieldObjects=t.fieldObjects;<span class="cstat-no" title="statement not covered" >t</span>his.parent=t.parent;<span class="cstat-no" title="statement not covered" >e</span>&amp;&amp;(this.container=this._createContainer(i));<span class="cstat-no" title="statement not covered" >s</span>&amp;&amp;this._createQuadrilaterals()}<span class="fstat-no" title="function not covered" ></span>_c</span>reateContainer(t){const{data:e,parent:{page:i,viewport:n}}=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >document.createElement("section");<span class="cstat-no" title="statement not covered" ></span>a.setAttribute("data-annotation-id",e.id);<span class="cstat-no" title="statement not covered" >a</span>.style.zIndex=this.parent.zIndex++;<span class="cstat-no" title="statement not covered" >t</span>his.data.popupRef&amp;&amp;a.setAttribute("aria-haspopup","dialog");<span class="cstat-no" title="statement not covered" >e</span>.noRotate&amp;&amp;a.classList.add("norotate");c</span>onst{pageWidth:r,pageHeight:o,pageX:l,pageY:c}=<span class="cstat-no" title="statement not covered" >n.rawDims;<span class="cstat-no" title="statement not covered" ></span>if(!e.rect||this instanceof PopupAnnotationElement){const{rotation:t}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>e.hasOwnCanvas||0===t||this.setRotation(t,a);<span class="cstat-no" title="statement not covered" >r</span>eturn a}</span>c</span>onst{width:h,height:d}=<span class="cstat-no" title="statement not covered" >getRectDims(e.rect),</span>u=<span class="cstat-no" title="statement not covered" >s.Util.normalizeRect([e.rect[0],i.view[3]-e.rect[1]+i.view[1],e.rect[2],i.view[3]-e.rect[3]+i.view[1]]);<span class="cstat-no" title="statement not covered" ></span>if(!t&amp;&amp;e.borderStyle.width&gt;0){<span class="cstat-no" title="statement not covered" >a.style.borderWidth=`${e.borderStyle.width}px`;c</span>onst t=<span class="cstat-no" title="statement not covered" >e.borderStyle.horizontalCornerRadius,</span>i=<span class="cstat-no" title="statement not covered" >e.borderStyle.verticalCornerRadius;<span class="cstat-no" title="statement not covered" ></span>if(t&gt;0||i&gt;0){const e=<span class="cstat-no" title="statement not covered" >`calc(${t}px * var(--scale-factor)) / calc(${i}px * var(--scale-factor))`;<span class="cstat-no" title="statement not covered" ></span>a.style.borderRadius=e}</span>else <span class="cstat-no" title="statement not covered" >if(this instanceof RadioButtonWidgetAnnotationElement){const t=<span class="cstat-no" title="statement not covered" >`calc(${h}px * var(--scale-factor)) / calc(${d}px * var(--scale-factor))`;<span class="cstat-no" title="statement not covered" ></span>a.style.borderRadius=t}<span class="cstat-no" title="statement not covered" ></span>s</span></span>witch(e.borderStyle.style){case s.AnnotationBorderStyleType.SOLID:<span class="cstat-no" title="statement not covered" >a.style.borderStyle="solid";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.AnnotationBorderStyleType.DASHED:<span class="cstat-no" title="statement not covered" >a.style.borderStyle="dashed";<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.AnnotationBorderStyleType.BEVELED:<span class="cstat-no" title="statement not covered" >(0,s.warn)("Unimplemented border style: beveled");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.AnnotationBorderStyleType.INSET:<span class="cstat-no" title="statement not covered" >(0,s.warn)("Unimplemented border style: inset");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.AnnotationBorderStyleType.UNDERLINE:<span class="cstat-no" title="statement not covered" >a.style.borderBottomStyle="solid"}</span>c</span>onst n=<span class="cstat-no" title="statement not covered" >e.borderColor||null;<span class="cstat-no" title="statement not covered" ></span>if(n){<span class="cstat-no" title="statement not covered" >this.#Ve=!0;<span class="cstat-no" title="statement not covered" >a</span>.style.borderColor=s.Util.makeHexColor(0|n[0],0|n[1],0|n[2])}</span>else <span class="cstat-no" title="statement not covered" >a.style.borderWidth=0}<span class="cstat-no" title="statement not covered" ></span></span>a</span>.style.left=100*(u[0]-l)/r+"%";<span class="cstat-no" title="statement not covered" >a</span>.style.top=100*(u[1]-c)/o+"%";c</span>onst{rotation:p}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>if(e.hasOwnCanvas||0===p){<span class="cstat-no" title="statement not covered" >a.style.width=100*h/r+"%";<span class="cstat-no" title="statement not covered" >a</span>.style.height=100*d/o+"%"}</span>else <span class="cstat-no" title="statement not covered" >this.setRotation(p,a);<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}<span class="fstat-no" title="function not covered" ></span>se</span>tRotation(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >this.container)</span>{<span class="cstat-no" title="statement not covered" >if(!this.data.rect)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{pageWidth:i,pageHeight:s}=<span class="cstat-no" title="statement not covered" >this.parent.viewport.rawDims,</span>{width:n,height:a}=<span class="cstat-no" title="statement not covered" >getRectDims(this.data.rect);</span>let r,o;<span class="cstat-no" title="statement not covered" >if(t%180==0){<span class="cstat-no" title="statement not covered" >r=100*n/i;<span class="cstat-no" title="statement not covered" >o</span>=100*a/s}</span>else{<span class="cstat-no" title="statement not covered" >r=100*a/i;<span class="cstat-no" title="statement not covered" >o</span>=100*n/s}<span class="cstat-no" title="statement not covered" ></span>e</span>.style.width=`${r}%`;<span class="cstat-no" title="statement not covered" >e</span>.style.height=`${o}%`;<span class="cstat-no" title="statement not covered" >e</span>.setAttribute("data-main-rotation",(360-t)%360)}<span class="fstat-no" title="function not covered" ></span>ge</span>t _commonActions(){const setColor=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{const s=<span class="cstat-no" title="statement not covered" >i.detail[t],</span>n=<span class="cstat-no" title="statement not covered" >s[0],</span>a=<span class="cstat-no" title="statement not covered" >s.slice(1);<span class="cstat-no" title="statement not covered" ></span>i.target.style[e]=r.ColorConverters[`${n}_HTML`](a);<span class="cstat-no" title="statement not covered" >t</span>his.annotationStorage.setValue(this.data.id,{[e]:r.ColorConverters[`${n}_rgb`](a)})}</span>;<span class="cstat-no" title="statement not covered" ></span>return(0,s.shadow)(this,"_commonActions",{display:<span class="fstat-no" title="function not covered" >t=</span>&gt;{const{display:e}=<span class="cstat-no" title="statement not covered" >t.detail,</span>i=<span class="cstat-no" title="statement not covered" >e%2==1;<span class="cstat-no" title="statement not covered" ></span>this.container.style.visibility=i?"hidden":"visible";<span class="cstat-no" title="statement not covered" >t</span>his.annotationStorage.setValue(this.data.id,{noView:i,noPrint:1===e||2===e})}</span>,print:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.annotationStorage.setValue(this.data.id,{noPrint:!t.detail.print})}</span>,hidden:<span class="fstat-no" title="function not covered" >t=</span>&gt;{const{hidden:e}=<span class="cstat-no" title="statement not covered" >t.detail;<span class="cstat-no" title="statement not covered" ></span>this.container.style.visibility=e?"hidden":"visible";<span class="cstat-no" title="statement not covered" >t</span>his.annotationStorage.setValue(this.data.id,{noPrint:e,noView:e})}</span>,focus:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.target.focus({preventScroll:!1}))</span>,0)}</span>,userName:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.target.title=t.detail.userName}</span>,readonly:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.target.disabled=t.detail.readonly}</span>,required:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._setRequired(t.target,t.detail.required)}</span>,bgColor:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >setColor("bgColor","backgroundColor",t)}</span>,fillColor:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >setColor("fillColor","backgroundColor",t)}</span>,fgColor:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >setColor("fgColor","color",t)}</span>,textColor:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >setColor("textColor","color",t)}</span>,borderColor:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >setColor("borderColor","borderColor",t)}</span>,strokeColor:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >setColor("strokeColor","borderColor",t)}</span>,rotation:<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t.detail.rotation;<span class="cstat-no" title="statement not covered" ></span>this.setRotation(e);<span class="cstat-no" title="statement not covered" >t</span>his.annotationStorage.setValue(this.data.id,{rotation:e})}</span>})}<span class="fstat-no" title="function not covered" ></span>_d</span>ispatchEventFromSandbox(t,e){const i=<span class="cstat-no" title="statement not covered" >this._commonActions;<span class="cstat-no" title="statement not covered" ></span>for(const s of Object.keys(e.detail)){const n=<span class="cstat-no" title="statement not covered" >t[s]||i[s];<span class="cstat-no" title="statement not covered" ></span>n?.(e)}</span>}<span class="fstat-no" title="function not covered" ></span>_s</span>etDefaultPropertiesFromJS(t){<span class="cstat-no" title="statement not covered" >if(!this.enableScripting)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.annotationStorage.getRawValue(this.data.id);<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this._commonActions;<span class="cstat-no" title="statement not covered" ></span>for(const[s,n]of Object.entries(e)){const a=<span class="cstat-no" title="statement not covered" >i[s];<span class="cstat-no" title="statement not covered" ></span>if(a){<span class="cstat-no" title="statement not covered" >a({detail:{[s]:n},target:t});<span class="cstat-no" title="statement not covered" >d</span>elete e[s]}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>_c</span>reateQuadrilaterals(){<span class="cstat-no" title="statement not covered" >if(!this.container)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{quadPoints:t}=<span class="cstat-no" title="statement not covered" >this.data;<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst[e,i,s,n]=<span class="cstat-no" title="statement not covered" >this.data.rect;<span class="cstat-no" title="statement not covered" ></span>if(1===t.length){const[,{x:a,y:r},{x:o,y:l}]=<span class="cstat-no" title="statement not covered" >t[0];<span class="cstat-no" title="statement not covered" ></span>if(s===a&amp;&amp;n===r&amp;&amp;e===o&amp;&amp;i===l)<span class="cstat-no" title="statement not covered" >return}</span></span>c</span>onst{style:a}=<span class="cstat-no" title="statement not covered" >this.container;</span>let r;<span class="cstat-no" title="statement not covered" >if(this.#Ve){const{borderColor:t,borderWidth:e}=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>a.borderWidth=0;<span class="cstat-no" title="statement not covered" >r</span>=["url('data:image/svg+xml;utf8,",'&lt;svg xmlns="http://www.w3.org/2000/svg"',' preserveAspectRatio="none" viewBox="0 0 1 1"&gt;',`&lt;g fill="transparent" stroke="${t}" stroke-width="${e}"&gt;`];<span class="cstat-no" title="statement not covered" >t</span>his.container.classList.add("hasBorder")}</span>c</span>onst o=<span class="cstat-no" title="statement not covered" >s-e,</span>l=<span class="cstat-no" title="statement not covered" >n-i,</span>{svgFactory:c}=<span class="cstat-no" title="statement not covered" >this,</span>h=<span class="cstat-no" title="statement not covered" >c.createElement("svg");<span class="cstat-no" title="statement not covered" ></span>h.classList.add("quadrilateralsContainer");<span class="cstat-no" title="statement not covered" >h</span>.setAttribute("width",0);<span class="cstat-no" title="statement not covered" >h</span>.setAttribute("height",0);c</span>onst d=<span class="cstat-no" title="statement not covered" >c.createElement("defs");<span class="cstat-no" title="statement not covered" ></span>h.append(d);c</span>onst u=<span class="cstat-no" title="statement not covered" >c.createElement("clipPath"),</span>p=<span class="cstat-no" title="statement not covered" >`clippath_${this.data.id}`;<span class="cstat-no" title="statement not covered" ></span>u.setAttribute("id",p);<span class="cstat-no" title="statement not covered" >u</span>.setAttribute("clipPathUnits","objectBoundingBox");<span class="cstat-no" title="statement not covered" >d</span>.append(u);<span class="cstat-no" title="statement not covered" >f</span>or(const[,{x:i,y:s},{x:a,y:h}]of t){const t=<span class="cstat-no" title="statement not covered" >c.createElement("rect"),</span>d=<span class="cstat-no" title="statement not covered" >(a-e)/o,</span>p=<span class="cstat-no" title="statement not covered" >(n-s)/l,</span>g=<span class="cstat-no" title="statement not covered" >(i-a)/o,</span>m=<span class="cstat-no" title="statement not covered" >(s-h)/l;<span class="cstat-no" title="statement not covered" ></span>t.setAttribute("x",d);<span class="cstat-no" title="statement not covered" >t</span>.setAttribute("y",p);<span class="cstat-no" title="statement not covered" >t</span>.setAttribute("width",g);<span class="cstat-no" title="statement not covered" >t</span>.setAttribute("height",m);<span class="cstat-no" title="statement not covered" >u</span>.append(t);<span class="cstat-no" title="statement not covered" >r</span>?.push(`&lt;rect vector-effect="non-scaling-stroke" x="${d}" y="${p}" width="${g}" height="${m}"/&gt;`)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.#Ve){<span class="cstat-no" title="statement not covered" >r.push("&lt;/g&gt;&lt;/svg&gt;')");<span class="cstat-no" title="statement not covered" >a</span>.backgroundImage=r.join("")}<span class="cstat-no" title="statement not covered" ></span>t</span>his.container.append(h);<span class="cstat-no" title="statement not covered" >t</span>his.container.style.clipPath=`url(#${p})`}<span class="fstat-no" title="function not covered" ></span>_c</span>reatePopup(){const{container:t,data:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t.setAttribute("aria-haspopup","dialog");c</span>onst i=<span class="cstat-no" title="statement not covered" >new PopupAnnotationElement({data:{color:e.color,titleObj:e.titleObj,modificationDate:e.modificationDate,contentsObj:e.contentsObj,richText:e.richText,parentRect:e.rect,borderStyle:0,id:`popup_${e.id}`,rotation:e.rotation},parent:this.parent,elements:[this]});<span class="cstat-no" title="statement not covered" ></span>this.parent.div.append(i.render())}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >(0,s.unreachable)("Abstract method `AnnotationElement.render` called")}<span class="fstat-no" title="function not covered" ></span>_g</span>etElementsByName(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{const i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(this._fieldObjects){const n=<span class="cstat-no" title="statement not covered" >this._fieldObjects[t];<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >for(const{page:t,id:a,exportValues:r}of n){<span class="cstat-no" title="statement not covered" >if(-1===t)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(a===e)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >"string"==typeof r?r:null,</span>o=<span class="cstat-no" title="statement not covered" >document.querySelector(`[data-element-id="${a}"]`);<span class="cstat-no" title="statement not covered" ></span>!o||h.has(o)?i.push({id:a,exportValue:n,domElement:o}):(0,s.warn)(`_getElementsByName - element not allowed: ${a}`)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn i}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const s of document.getElementsByName(t)){const{exportValue:t}=<span class="cstat-no" title="statement not covered" >s,</span>n=<span class="cstat-no" title="statement not covered" >s.getAttribute("data-element-id");<span class="cstat-no" title="statement not covered" ></span>n!==e&amp;&amp;(h.has(s)&amp;&amp;i.push({id:n,exportValue:t,domElement:s}))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>sh</span>ow(){<span class="cstat-no" title="statement not covered" >this.container&amp;&amp;(this.container.hidden=!1);<span class="cstat-no" title="statement not covered" >t</span>his.popup?.maybeShow()}<span class="fstat-no" title="function not covered" ></span>hi</span>de(){<span class="cstat-no" title="statement not covered" >this.container&amp;&amp;(this.container.hidden=!0);<span class="cstat-no" title="statement not covered" >t</span>his.popup?.forceHide()}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsToTriggerPopup(){<span class="cstat-no" title="statement not covered" >return this.container}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightArea(){const t=<span class="cstat-no" title="statement not covered" >this.getElementsToTriggerPopup();<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(t))<span class="cstat-no" title="statement not covered" >for(const e of t)<span class="cstat-no" title="statement not covered" >e.classList.add("highlightArea");e</span></span>lse <span class="cstat-no" title="statement not covered" >t.classList.add("highlightArea")}<span class="fstat-no" title="function not covered" ></span></span>_e</span>ditOnDoubleClick(){const{annotationEditorType:t,data:{id:e}}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.container.addEventListener("dblclick",(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.linkService.eventBus?.dispatch("switchannotationeditormode",{source:this,mode:t,editId:e})}</span>))}</span>}class LinkAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!0,ignoreBorder:!!e?.ignoreBorder,createQuadrilaterals:!0});<span class="cstat-no" title="statement not covered" >t</span>his.isTooltipOnly=t.data.isTooltipOnly}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){const{data:t,linkService:e}=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >document.createElement("a");<span class="cstat-no" title="statement not covered" ></span>i.setAttribute("data-element-id",t.id);l</span>et s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(t.url){<span class="cstat-no" title="statement not covered" >e.addLinkAttributes(i,t.url,t.newWindow);<span class="cstat-no" title="statement not covered" >s</span>=!0}</span>else <span class="cstat-no" title="statement not covered" >if(t.action){<span class="cstat-no" title="statement not covered" >this._bindNamedAction(i,t.action);<span class="cstat-no" title="statement not covered" >s</span>=!0}</span>else <span class="cstat-no" title="statement not covered" >if(t.attachment){<span class="cstat-no" title="statement not covered" >this._bindAttachment(i,t.attachment);<span class="cstat-no" title="statement not covered" >s</span>=!0}</span>else <span class="cstat-no" title="statement not covered" >if(t.setOCGState){<span class="cstat-no" title="statement not covered" >this.#$e(i,t.setOCGState);<span class="cstat-no" title="statement not covered" >s</span>=!0}</span>else <span class="cstat-no" title="statement not covered" >if(t.dest){<span class="cstat-no" title="statement not covered" >this._bindLink(i,t.dest);<span class="cstat-no" title="statement not covered" >s</span>=!0}</span>else{<span class="cstat-no" title="statement not covered" >if(t.actions&amp;&amp;(t.actions.Action||t.actions["Mouse Up"]||t.actions["Mouse Down"])&amp;&amp;this.enableScripting&amp;&amp;this.hasJSActions){<span class="cstat-no" title="statement not covered" >this._bindJSAction(i,t);<span class="cstat-no" title="statement not covered" >s</span>=!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.resetForm){<span class="cstat-no" title="statement not covered" >this._bindResetFormAction(i,t.resetForm);<span class="cstat-no" title="statement not covered" >s</span>=!0}</span>else <span class="cstat-no" title="statement not covered" >if(this.isTooltipOnly&amp;&amp;!s){<span class="cstat-no" title="statement not covered" >this._bindLink(i,"");<span class="cstat-no" title="statement not covered" >s</span>=!0}</span>}<span class="cstat-no" title="statement not covered" ></span></span>t</span></span></span></span></span>his.container.classList.add("linkAnnotation");<span class="cstat-no" title="statement not covered" >s</span>&amp;&amp;this.container.append(i);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>#Xe(){<span class="cstat-no" title="statement not covered" >this.container.setAttribute("data-internal-link","")}<span class="fstat-no" title="function not covered" ></span>_b</span>indLink(t,e){<span class="cstat-no" title="statement not covered" >t.href=this.linkService.getDestinationHash(e);<span class="cstat-no" title="statement not covered" >t</span>.onclick=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e&amp;&amp;this.linkService.goToDestination(e);<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>;<span class="cstat-no" title="statement not covered" >(</span>e||""===e)&amp;&amp;this.#Xe()}<span class="fstat-no" title="function not covered" ></span>_b</span>indNamedAction(t,e){<span class="cstat-no" title="statement not covered" >t.href=this.linkService.getAnchorUrl("");<span class="cstat-no" title="statement not covered" >t</span>.onclick=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.linkService.executeNamedAction(e);<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>;<span class="cstat-no" title="statement not covered" >t</span>his.#Xe()}<span class="fstat-no" title="function not covered" ></span>_b</span>indAttachment(t,e){<span class="cstat-no" title="statement not covered" >t.href=this.linkService.getAnchorUrl("");<span class="cstat-no" title="statement not covered" >t</span>.onclick=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.downloadManager?.openOrDownloadData(this.container,e.content,e.filename);<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>;<span class="cstat-no" title="statement not covered" >t</span>his.#Xe()}</span>#$e(t,e){<span class="cstat-no" title="statement not covered" >t.href=this.linkService.getAnchorUrl("");<span class="cstat-no" title="statement not covered" >t</span>.onclick=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.linkService.executeSetOCGState(e);<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>;<span class="cstat-no" title="statement not covered" >t</span>his.#Xe()}<span class="fstat-no" title="function not covered" ></span>_b</span>indJSAction(t,e){<span class="cstat-no" title="statement not covered" >t.href=this.linkService.getAnchorUrl("");c</span>onst i=<span class="cstat-no" title="statement not covered" >new Map([["Action","onclick"],["Mouse Up","onmouseup"],["Mouse Down","onmousedown"]]);<span class="cstat-no" title="statement not covered" ></span>for(const s of Object.keys(e.actions)){const n=<span class="cstat-no" title="statement not covered" >i.get(s);<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(t[n]=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:e.id,name:s}});<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>)}<span class="cstat-no" title="statement not covered" ></span>t</span>.onclick||(t.onclick=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!1)</span>;<span class="cstat-no" title="statement not covered" >t</span>his.#Xe()}<span class="fstat-no" title="function not covered" ></span>_b</span>indResetFormAction(t,e){const i=<span class="cstat-no" title="statement not covered" >t.onclick;<span class="cstat-no" title="statement not covered" ></span>i||(t.href=this.linkService.getAnchorUrl(""));<span class="cstat-no" title="statement not covered" >t</span>his.#Xe();<span class="cstat-no" title="statement not covered" >i</span>f(this._fieldObjects)<span class="cstat-no" title="statement not covered" >t.onclick=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i?.();c</span>onst{fields:t,refs:n,include:a}=<span class="cstat-no" title="statement not covered" >e,</span>r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(0!==t.length||0!==n.length){const e=<span class="cstat-no" title="statement not covered" >new Set(n);<span class="cstat-no" title="statement not covered" ></span>for(const i of t){const t=<span class="cstat-no" title="statement not covered" >this._fieldObjects[i]||[];<span class="cstat-no" title="statement not covered" ></span>for(const{id:i}of t)<span class="cstat-no" title="statement not covered" >e.add(i)}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(const t of Object.values(this._fieldObjects))<span class="cstat-no" title="statement not covered" >for(const i of t)<span class="cstat-no" title="statement not covered" >e.has(i.id)===a&amp;&amp;r.push(i)}</span></span></span>else <span class="cstat-no" title="statement not covered" >for(const t of Object.values(this._fieldObjects))<span class="cstat-no" title="statement not covered" >r.push(...t);c</span></span></span>onst o=<span class="cstat-no" title="statement not covered" >this.annotationStorage,</span>l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const t of r){const{id:e}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>l.push(e);<span class="cstat-no" title="statement not covered" >s</span>witch(t.type){case"text":{const i=<span class="cstat-no" title="statement not covered" >t.defaultValue||"";<span class="cstat-no" title="statement not covered" ></span>o.setValue(e,{value:i});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"checkbox":case"radiobutton":{const i=<span class="cstat-no" title="statement not covered" >t.defaultValue===t.exportValues;<span class="cstat-no" title="statement not covered" ></span>o.setValue(e,{value:i});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"combobox":case"listbox":{const i=<span class="cstat-no" title="statement not covered" >t.defaultValue||"";<span class="cstat-no" title="statement not covered" ></span>o.setValue(e,{value:i});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>default:<span class="cstat-no" title="statement not covered" >continue}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >document.querySelector(`[data-element-id="${e}"]`);<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(h.has(i)?i.dispatchEvent(new Event("resetform")):(0,s.warn)(`_bindResetFormAction - element not allowed: ${e}`))}<span class="cstat-no" title="statement not covered" ></span>t</span>his.enableScripting&amp;&amp;this.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:"app",ids:l,name:"ResetForm"}});<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>;e</span>lse{<span class="cstat-no" title="statement not covered" >(0,s.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.');<span class="cstat-no" title="statement not covered" >i</span>||(t.onclick=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!1)</span>}</span>}</span>}class TextAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str)})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("textAnnotation");c</span>onst t=<span class="cstat-no" title="statement not covered" >document.createElement("img");<span class="cstat-no" title="statement not covered" ></span>t.src=this.imageResourcesPath+"annotation-"+this.data.name.toLowerCase()+".svg";<span class="cstat-no" title="statement not covered" >t</span>.alt="[{{type}} Annotation]";<span class="cstat-no" title="statement not covered" >t</span>.dataset.l10nId="text_annotation_type";<span class="cstat-no" title="statement not covered" >t</span>.dataset.l10nArgs=JSON.stringify({type:this.data.name});<span class="cstat-no" title="statement not covered" >t</span>his.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >t</span>his.container.append(t);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class WidgetAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >re</span>nder(){<span class="cstat-no" title="statement not covered" >this.data.alternativeText&amp;&amp;(this.container.title=this.data.alternativeText);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}<span class="fstat-no" title="function not covered" ></span>sh</span>owElementAndHideCanvas(t){<span class="cstat-no" title="statement not covered" >if(this.data.hasOwnCanvas){<span class="cstat-no" title="statement not covered" >"CANVAS"===t.previousSibling?.nodeName&amp;&amp;(t.previousSibling.hidden=!0);<span class="cstat-no" title="statement not covered" >t</span>.hidden=!1}</span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etKeyModifier(t){const{isWin:e,isMac:i}=<span class="cstat-no" title="statement not covered" >s.FeatureTest.platform;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;t.ctrlKey||i&amp;&amp;t.metaKey}<span class="fstat-no" title="function not covered" ></span>_s</span>etEventListener(t,e,i,s){<span class="cstat-no" title="statement not covered" >e.includes("mouse")?t.addEventListener(e,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:this.data.id,name:i,value:s(t),shift:t.shiftKey,modifier:this._getKeyModifier(t)}})}</span>)):t.addEventListener(e,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:this.data.id,name:i,value:s(t)}})}</span>))}<span class="fstat-no" title="function not covered" ></span>_s</span>etEventListeners(t,e,i){<span class="cstat-no" title="statement not covered" >for(const[s,n]of e)<span class="cstat-no" title="statement not covered" >("Action"===n||this.data.actions?.[n])&amp;&amp;this._setEventListener(t,s,n,i)}<span class="fstat-no" title="function not covered" ></span></span>_s</span>etBackgroundColor(t){const e=<span class="cstat-no" title="statement not covered" >this.data.backgroundColor||null;<span class="cstat-no" title="statement not covered" ></span>t.style.backgroundColor=null===e?"transparent":s.Util.makeHexColor(e[0],e[1],e[2])}<span class="fstat-no" title="function not covered" ></span>_s</span>etTextStyle(t){const e=<span class="cstat-no" title="statement not covered" >["left","center","right"],</span>{fontColor:i}=<span class="cstat-no" title="statement not covered" >this.data.defaultAppearanceData,</span>n=<span class="cstat-no" title="statement not covered" >this.data.defaultAppearanceData.fontSize||9,</span>a=<span class="cstat-no" title="statement not covered" >t.style;</span>let r;const roundToOneDecimal=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.round(10*t)/10;<span class="cstat-no" title="statement not covered" ></span></span>if(this.data.multiLine){const t=<span class="cstat-no" title="statement not covered" >Math.abs(this.data.rect[3]-this.data.rect[1]-2),</span>e=<span class="cstat-no" title="statement not covered" >t/(Math.round(t/(s.LINE_FACTOR*n))||1);<span class="cstat-no" title="statement not covered" ></span>r=Math.min(n,roundToOneDecimal(e/s.LINE_FACTOR))}</span>else{const t=<span class="cstat-no" title="statement not covered" >Math.abs(this.data.rect[3]-this.data.rect[1]-2);<span class="cstat-no" title="statement not covered" ></span>r=Math.min(n,roundToOneDecimal(t/s.LINE_FACTOR))}<span class="cstat-no" title="statement not covered" ></span>a</span>.fontSize=`calc(${r}px * var(--scale-factor))`;<span class="cstat-no" title="statement not covered" >a</span>.color=s.Util.makeHexColor(i[0],i[1],i[2]);<span class="cstat-no" title="statement not covered" >n</span>ull!==this.data.textAlignment&amp;&amp;(a.textAlign=e[this.data.textAlignment])}<span class="fstat-no" title="function not covered" ></span>_s</span>etRequired(t,e){<span class="cstat-no" title="statement not covered" >e?t.setAttribute("required",!0):t.removeAttribute("required");<span class="cstat-no" title="statement not covered" >t</span>.setAttribute("aria-required",e)}</span>}class TextWidgetAnnotationElement extends WidgetAnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:t.renderForms||!t.data.hasAppearance&amp;&amp;!!t.data.fieldValue})}<span class="fstat-no" title="function not covered" ></span>se</span>tPropertyOnSiblings(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.annotationStorage;<span class="cstat-no" title="statement not covered" ></span>for(const a of this._getElementsByName(t.name,t.id)){<span class="cstat-no" title="statement not covered" >a.domElement&amp;&amp;(a.domElement[e]=i);<span class="cstat-no" title="statement not covered" >n</span>.setValue(a.id,{[s]:i})}</span>}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){const t=<span class="cstat-no" title="statement not covered" >this.annotationStorage,</span>e=<span class="cstat-no" title="statement not covered" >this.data.id;<span class="cstat-no" title="statement not covered" ></span>this.container.classList.add("textWidgetAnnotation");l</span>et i=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(this.renderForms){const s=<span class="cstat-no" title="statement not covered" >t.getValue(e,{value:this.data.fieldValue});</span>let n=<span class="cstat-no" title="statement not covered" >s.value||"";</span>const a=<span class="cstat-no" title="statement not covered" >t.getValue(e,{charLimit:this.data.maxLen}).charLimit;<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;n.length&gt;a&amp;&amp;(n=n.slice(0,a));l</span>et r=<span class="cstat-no" title="statement not covered" >s.formattedValue||this.data.textContent?.join("\n")||null;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;this.data.comb&amp;&amp;(r=r.replaceAll(/\s+/g,""));c</span>onst o=<span class="cstat-no" title="statement not covered" >{userValue:n,formattedValue:r,lastCommittedValue:null,commitKey:1};<span class="cstat-no" title="statement not covered" ></span>if(this.data.multiLine){<span class="cstat-no" title="statement not covered" >i=document.createElement("textarea");<span class="cstat-no" title="statement not covered" >i</span>.textContent=r??n;<span class="cstat-no" title="statement not covered" >t</span>his.data.doNotScroll&amp;&amp;(i.style.overflowY="hidden")}</span>else{<span class="cstat-no" title="statement not covered" >i=document.createElement("input");<span class="cstat-no" title="statement not covered" >i</span>.type="text";<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("value",r??n);<span class="cstat-no" title="statement not covered" >t</span>his.data.doNotScroll&amp;&amp;(i.style.overflowX="hidden")}<span class="cstat-no" title="statement not covered" ></span>t</span>his.data.hasOwnCanvas&amp;&amp;(i.hidden=!0);<span class="cstat-no" title="statement not covered" >h</span>.add(i);<span class="cstat-no" title="statement not covered" >i</span>.setAttribute("data-element-id",e);<span class="cstat-no" title="statement not covered" >i</span>.disabled=this.data.readOnly;<span class="cstat-no" title="statement not covered" >i</span>.name=this.data.fieldName;<span class="cstat-no" title="statement not covered" >i</span>.tabIndex=c;<span class="cstat-no" title="statement not covered" >t</span>his._setRequired(i,this.data.required);<span class="cstat-no" title="statement not covered" >a</span>&amp;&amp;(i.maxLength=a);<span class="cstat-no" title="statement not covered" >i</span>.addEventListener("input",(<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.setValue(e,{value:s.target.value});<span class="cstat-no" title="statement not covered" >t</span>his.setPropertyOnSiblings(i,"value",s.target.value,"value");<span class="cstat-no" title="statement not covered" >o</span>.formattedValue=null}</span>));<span class="cstat-no" title="statement not covered" >i</span>.addEventListener("resetform",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >this.data.defaultFieldValue??"";<span class="cstat-no" title="statement not covered" ></span>i.value=o.userValue=e;<span class="cstat-no" title="statement not covered" >o</span>.formattedValue=null}</span>));l</span>et blurListener=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const{formattedValue:e}=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>null!=e&amp;&amp;(t.target.value=e);<span class="cstat-no" title="statement not covered" >t</span>.target.scrollLeft=0}</span>;<span class="cstat-no" title="statement not covered" ></span>if(this.enableScripting&amp;&amp;this.hasJSActions){<span class="cstat-no" title="statement not covered" >i.addEventListener("focus",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const{target:e}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>o.userValue&amp;&amp;(e.value=o.userValue);<span class="cstat-no" title="statement not covered" >o</span>.lastCommittedValue=e.value;<span class="cstat-no" title="statement not covered" >o</span>.commitKey=1}</span>));<span class="cstat-no" title="statement not covered" >i</span>.addEventListener("updatefromsandbox",(<span class="fstat-no" title="function not covered" >i=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.showElementAndHideCanvas(i.target);c</span>onst s=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >va</span>lue(i){<span class="cstat-no" title="statement not covered" >o.userValue=i.detail.value??"";<span class="cstat-no" title="statement not covered" >t</span>.setValue(e,{value:o.userValue.toString()});<span class="cstat-no" title="statement not covered" >i</span>.target.value=o.userValue}</span>,<span class="fstat-no" title="function not covered" >fo</span>rmattedValue(i){const{formattedValue:s}=<span class="cstat-no" title="statement not covered" >i.detail;<span class="cstat-no" title="statement not covered" ></span>o.formattedValue=s;<span class="cstat-no" title="statement not covered" >n</span>ull!=s&amp;&amp;i.target!==document.activeElement&amp;&amp;(i.target.value=s);<span class="cstat-no" title="statement not covered" >t</span>.setValue(e,{formattedValue:s})}</span>,<span class="fstat-no" title="function not covered" >se</span>lRange(t){<span class="cstat-no" title="statement not covered" >t.target.setSelectionRange(...t.detail.selRange)}</span>,charLimit:<span class="fstat-no" title="function not covered" >i=</span>&gt;{const{charLimit:s}=<span class="cstat-no" title="statement not covered" >i.detail,</span>{target:n}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(0===s){<span class="cstat-no" title="statement not covered" >n.removeAttribute("maxLength");<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>n</span>.setAttribute("maxLength",s);l</span>et a=<span class="cstat-no" title="statement not covered" >o.userValue;<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;!(a.length&lt;=s)){<span class="cstat-no" title="statement not covered" >a=a.slice(0,s);<span class="cstat-no" title="statement not covered" >n</span>.value=o.userValue=a;<span class="cstat-no" title="statement not covered" >t</span>.setValue(e,{value:a});<span class="cstat-no" title="statement not covered" >t</span>his.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:e,name:"Keystroke",value:a,willCommit:!0,commitKey:1,selStart:n.selectionStart,selEnd:n.selectionEnd}})}</span>}</span>};<span class="cstat-no" title="statement not covered" ></span>this._dispatchEventFromSandbox(s,i)}</span>));<span class="cstat-no" title="statement not covered" >i</span>.addEventListener("keydown",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >o.commitKey=1;l</span>et i=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>"Escape"===t.key?i=0:"Enter"!==t.key||this.data.multiLine?"Tab"===t.key&amp;&amp;(o.commitKey=3):i=2;<span class="cstat-no" title="statement not covered" >i</span>f(-1===i)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{value:s}=<span class="cstat-no" title="statement not covered" >t.target;<span class="cstat-no" title="statement not covered" ></span>if(o.lastCommittedValue!==s){<span class="cstat-no" title="statement not covered" >o.lastCommittedValue=s;<span class="cstat-no" title="statement not covered" >o</span>.userValue=s;<span class="cstat-no" title="statement not covered" >t</span>his.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:e,name:"Keystroke",value:s,willCommit:!0,commitKey:i,selStart:t.target.selectionStart,selEnd:t.target.selectionEnd}})}</span>}</span>));c</span>onst s=<span class="cstat-no" title="statement not covered" >blurListener;<span class="cstat-no" title="statement not covered" ></span>blurListener=null;<span class="cstat-no" title="statement not covered" >i</span>.addEventListener("blur",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!t.relatedTarget)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{value:i}=<span class="cstat-no" title="statement not covered" >t.target;<span class="cstat-no" title="statement not covered" ></span>o.userValue=i;<span class="cstat-no" title="statement not covered" >o</span>.lastCommittedValue!==i&amp;&amp;this.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:e,name:"Keystroke",value:i,willCommit:!0,commitKey:o.commitKey,selStart:t.target.selectionStart,selEnd:t.target.selectionEnd}});<span class="cstat-no" title="statement not covered" >s</span>(t)}</span>));<span class="cstat-no" title="statement not covered" >t</span>his.data.actions?.Keystroke&amp;&amp;i.addEventListener("beforeinput",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >o.lastCommittedValue=null;c</span>onst{data:i,target:s}=<span class="cstat-no" title="statement not covered" >t,</span>{value:n,selectionStart:a,selectionEnd:r}=<span class="cstat-no" title="statement not covered" >s;</span>let l=<span class="cstat-no" title="statement not covered" >a,</span>c=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>switch(t.inputType){case"deleteWordBackward":{const t=<span class="cstat-no" title="statement not covered" >n.substring(0,a).match(/\w*[^\w]*$/);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(l-=t[0].length);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"deleteWordForward":{const t=<span class="cstat-no" title="statement not covered" >n.substring(a).match(/^[^\w]*\w*/);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(c+=t[0].length);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"deleteContentBackward":<span class="cstat-no" title="statement not covered" >a===r&amp;&amp;(l-=1);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"deleteContentForward":<span class="cstat-no" title="statement not covered" >a===r&amp;&amp;(c+=1)}<span class="cstat-no" title="statement not covered" ></span>t</span>.preventDefault();<span class="cstat-no" title="statement not covered" >t</span>his.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:e,name:"Keystroke",value:n,change:i||"",willCommit:!1,selStart:l,selEnd:c}})}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._setEventListeners(i,[["focus","Focus"],["blur","Blur"],["mousedown","Mouse Down"],["mouseenter","Mouse Enter"],["mouseleave","Mouse Exit"],["mouseup","Mouse Up"]],(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.target.value)</span>)}<span class="cstat-no" title="statement not covered" ></span>b</span>lurListener&amp;&amp;i.addEventListener("blur",blurListener);<span class="cstat-no" title="statement not covered" >i</span>f(this.data.comb){const t=<span class="cstat-no" title="statement not covered" >(this.data.rect[2]-this.data.rect[0])/a;<span class="cstat-no" title="statement not covered" ></span>i.classList.add("comb");<span class="cstat-no" title="statement not covered" >i</span>.style.letterSpacing=`calc(${t}px * var(--scale-factor) - 1ch)`}</span>}</span>else{<span class="cstat-no" title="statement not covered" >i=document.createElement("div");<span class="cstat-no" title="statement not covered" >i</span>.textContent=this.data.fieldValue;<span class="cstat-no" title="statement not covered" >i</span>.style.verticalAlign="middle";<span class="cstat-no" title="statement not covered" >i</span>.style.display="table-cell"}<span class="cstat-no" title="statement not covered" ></span>t</span>his._setTextStyle(i);<span class="cstat-no" title="statement not covered" >t</span>his._setBackgroundColor(i);<span class="cstat-no" title="statement not covered" >t</span>his._setDefaultPropertiesFromJS(i);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(i);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class SignatureWidgetAnnotationElement extends WidgetAnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!t.data.hasOwnCanvas})}</span>}class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:t.renderForms})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){const t=<span class="cstat-no" title="statement not covered" >this.annotationStorage,</span>e=<span class="cstat-no" title="statement not covered" >this.data,</span>i=<span class="cstat-no" title="statement not covered" >e.id;</span>let s=<span class="cstat-no" title="statement not covered" >t.getValue(i,{value:e.exportValue===e.fieldValue}).value;<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof s){<span class="cstat-no" title="statement not covered" >s="Off"!==s;<span class="cstat-no" title="statement not covered" >t</span>.setValue(i,{value:s})}<span class="cstat-no" title="statement not covered" ></span>t</span>his.container.classList.add("buttonWidgetAnnotation","checkBox");c</span>onst n=<span class="cstat-no" title="statement not covered" >document.createElement("input");<span class="cstat-no" title="statement not covered" ></span>h.add(n);<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("data-element-id",i);<span class="cstat-no" title="statement not covered" >n</span>.disabled=e.readOnly;<span class="cstat-no" title="statement not covered" >t</span>his._setRequired(n,this.data.required);<span class="cstat-no" title="statement not covered" >n</span>.type="checkbox";<span class="cstat-no" title="statement not covered" >n</span>.name=e.fieldName;<span class="cstat-no" title="statement not covered" >s</span>&amp;&amp;n.setAttribute("checked",!0);<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("exportValue",e.exportValue);<span class="cstat-no" title="statement not covered" >n</span>.tabIndex=c;<span class="cstat-no" title="statement not covered" >n</span>.addEventListener("change",(<span class="fstat-no" title="function not covered" >s=</span>&gt;{const{name:n,checked:a}=<span class="cstat-no" title="statement not covered" >s.target;<span class="cstat-no" title="statement not covered" ></span>for(const s of this._getElementsByName(n,i)){const i=<span class="cstat-no" title="statement not covered" >a&amp;&amp;s.exportValue===e.exportValue;<span class="cstat-no" title="statement not covered" ></span>s.domElement&amp;&amp;(s.domElement.checked=i);<span class="cstat-no" title="statement not covered" >t</span>.setValue(s.id,{value:i})}<span class="cstat-no" title="statement not covered" ></span>t</span>.setValue(i,{value:a})}</span>));<span class="cstat-no" title="statement not covered" >n</span>.addEventListener("resetform",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >e.defaultFieldValue||"Off";<span class="cstat-no" title="statement not covered" ></span>t.target.checked=i===e.exportValue}</span>));<span class="cstat-no" title="statement not covered" >i</span>f(this.enableScripting&amp;&amp;this.hasJSActions){<span class="cstat-no" title="statement not covered" >n.addEventListener("updatefromsandbox",(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >va</span>lue(e){<span class="cstat-no" title="statement not covered" >e.target.checked="Off"!==e.detail.value;<span class="cstat-no" title="statement not covered" >t</span>.setValue(i,{value:e.target.checked})}</span>};<span class="cstat-no" title="statement not covered" ></span>this._dispatchEventFromSandbox(s,e)}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._setEventListeners(n,[["change","Validate"],["change","Action"],["focus","Focus"],["blur","Blur"],["mousedown","Mouse Down"],["mouseenter","Mouse Enter"],["mouseleave","Mouse Exit"],["mouseup","Mouse Up"]],(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.target.checked)</span>)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._setBackgroundColor(n);<span class="cstat-no" title="statement not covered" >t</span>his._setDefaultPropertiesFromJS(n);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(n);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:t.renderForms})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("buttonWidgetAnnotation","radioButton");c</span>onst t=<span class="cstat-no" title="statement not covered" >this.annotationStorage,</span>e=<span class="cstat-no" title="statement not covered" >this.data,</span>i=<span class="cstat-no" title="statement not covered" >e.id;</span>let s=<span class="cstat-no" title="statement not covered" >t.getValue(i,{value:e.fieldValue===e.buttonValue}).value;<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof s){<span class="cstat-no" title="statement not covered" >s=s!==e.buttonValue;<span class="cstat-no" title="statement not covered" >t</span>.setValue(i,{value:s})}</span>c</span>onst n=<span class="cstat-no" title="statement not covered" >document.createElement("input");<span class="cstat-no" title="statement not covered" ></span>h.add(n);<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("data-element-id",i);<span class="cstat-no" title="statement not covered" >n</span>.disabled=e.readOnly;<span class="cstat-no" title="statement not covered" >t</span>his._setRequired(n,this.data.required);<span class="cstat-no" title="statement not covered" >n</span>.type="radio";<span class="cstat-no" title="statement not covered" >n</span>.name=e.fieldName;<span class="cstat-no" title="statement not covered" >s</span>&amp;&amp;n.setAttribute("checked",!0);<span class="cstat-no" title="statement not covered" >n</span>.tabIndex=c;<span class="cstat-no" title="statement not covered" >n</span>.addEventListener("change",(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const{name:s,checked:n}=<span class="cstat-no" title="statement not covered" >e.target;<span class="cstat-no" title="statement not covered" ></span>for(const e of this._getElementsByName(s,i))<span class="cstat-no" title="statement not covered" >t.setValue(e.id,{value:!1});<span class="cstat-no" title="statement not covered" >t</span></span>.setValue(i,{value:n})}</span>));<span class="cstat-no" title="statement not covered" >n</span>.addEventListener("resetform",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >e.defaultFieldValue;<span class="cstat-no" title="statement not covered" ></span>t.target.checked=null!=i&amp;&amp;i===e.buttonValue}</span>));<span class="cstat-no" title="statement not covered" >i</span>f(this.enableScripting&amp;&amp;this.hasJSActions){const s=<span class="cstat-no" title="statement not covered" >e.buttonValue;<span class="cstat-no" title="statement not covered" ></span>n.addEventListener("updatefromsandbox",(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >{value:<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >s===e.detail.value;<span class="cstat-no" title="statement not covered" ></span>for(const s of this._getElementsByName(e.target.name)){const e=<span class="cstat-no" title="statement not covered" >n&amp;&amp;s.id===i;<span class="cstat-no" title="statement not covered" ></span>s.domElement&amp;&amp;(s.domElement.checked=e);<span class="cstat-no" title="statement not covered" >t</span>.setValue(s.id,{value:e})}</span>}</span>};<span class="cstat-no" title="statement not covered" ></span>this._dispatchEventFromSandbox(n,e)}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._setEventListeners(n,[["change","Validate"],["change","Action"],["focus","Focus"],["blur","Blur"],["mousedown","Mouse Down"],["mouseenter","Mouse Enter"],["mouseleave","Mouse Exit"],["mouseup","Mouse Up"]],(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.target.checked)</span>)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._setBackgroundColor(n);<span class="cstat-no" title="statement not covered" >t</span>his._setDefaultPropertiesFromJS(n);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(n);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class PushButtonWidgetAnnotationElement extends LinkAnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{ignoreBorder:t.data.hasAppearance})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){const t=<span class="cstat-no" title="statement not covered" >super.render();<span class="cstat-no" title="statement not covered" ></span>t.classList.add("buttonWidgetAnnotation","pushButton");<span class="cstat-no" title="statement not covered" >t</span>his.data.alternativeText&amp;&amp;(t.title=this.data.alternativeText);c</span>onst e=<span class="cstat-no" title="statement not covered" >t.lastChild;<span class="cstat-no" title="statement not covered" ></span>if(this.enableScripting&amp;&amp;this.hasJSActions&amp;&amp;e){<span class="cstat-no" title="statement not covered" >this._setDefaultPropertiesFromJS(e);<span class="cstat-no" title="statement not covered" >e</span>.addEventListener("updatefromsandbox",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._dispatchEventFromSandbox({},t)}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>}class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:t.renderForms})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("choiceWidgetAnnotation");c</span>onst t=<span class="cstat-no" title="statement not covered" >this.annotationStorage,</span>e=<span class="cstat-no" title="statement not covered" >this.data.id,</span>i=<span class="cstat-no" title="statement not covered" >t.getValue(e,{value:this.data.fieldValue}),</span>s=<span class="cstat-no" title="statement not covered" >document.createElement("select");<span class="cstat-no" title="statement not covered" ></span>h.add(s);<span class="cstat-no" title="statement not covered" >s</span>.setAttribute("data-element-id",e);<span class="cstat-no" title="statement not covered" >s</span>.disabled=this.data.readOnly;<span class="cstat-no" title="statement not covered" >t</span>his._setRequired(s,this.data.required);<span class="cstat-no" title="statement not covered" >s</span>.name=this.data.fieldName;<span class="cstat-no" title="statement not covered" >s</span>.tabIndex=c;l</span>et n=<span class="cstat-no" title="statement not covered" >this.data.combo&amp;&amp;this.data.options.length&gt;0;<span class="cstat-no" title="statement not covered" ></span>if(!this.data.combo){<span class="cstat-no" title="statement not covered" >s.size=this.data.options.length;<span class="cstat-no" title="statement not covered" >t</span>his.data.multiSelect&amp;&amp;(s.multiple=!0)}<span class="cstat-no" title="statement not covered" ></span>s</span>.addEventListener("resetform",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >this.data.defaultFieldValue;<span class="cstat-no" title="statement not covered" ></span>for(const t of s.options)<span class="cstat-no" title="statement not covered" >t.selected=t.value===e}</span></span>));<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.data.options){const e=<span class="cstat-no" title="statement not covered" >document.createElement("option");<span class="cstat-no" title="statement not covered" ></span>e.textContent=t.displayValue;<span class="cstat-no" title="statement not covered" >e</span>.value=t.exportValue;<span class="cstat-no" title="statement not covered" >i</span>f(i.value.includes(t.exportValue)){<span class="cstat-no" title="statement not covered" >e.setAttribute("selected",!0);<span class="cstat-no" title="statement not covered" >n</span>=!1}<span class="cstat-no" title="statement not covered" ></span>s</span>.append(e)}</span>l</span>et a=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(n){const t=<span class="cstat-no" title="statement not covered" >document.createElement("option");<span class="cstat-no" title="statement not covered" ></span>t.value=" ";<span class="cstat-no" title="statement not covered" >t</span>.setAttribute("hidden",!0);<span class="cstat-no" title="statement not covered" >t</span>.setAttribute("selected",!0);<span class="cstat-no" title="statement not covered" >s</span>.prepend(t);<span class="cstat-no" title="statement not covered" >a</span>=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.remove();<span class="cstat-no" title="statement not covered" >s</span>.removeEventListener("input",a);<span class="cstat-no" title="statement not covered" >a</span>=null}</span>;<span class="cstat-no" title="statement not covered" >s</span>.addEventListener("input",a)}</span>c</span>onst getValue=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t?"value":"textContent",</span>{options:i,multiple:n}=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>return n?Array.prototype.filter.call(i,(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.selected)</span>).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t[e])</span>):-1===i.selectedIndex?null:i[i.selectedIndex][e]}</span>;</span>let r=<span class="cstat-no" title="statement not covered" >getValue(!1);</span>const getItems=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t.target.options;<span class="cstat-no" title="statement not covered" ></span>return Array.prototype.map.call(e,(<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{displayValue:t.textContent,exportValue:t.value})</span>))}</span>;<span class="cstat-no" title="statement not covered" ></span>if(this.enableScripting&amp;&amp;this.hasJSActions){<span class="cstat-no" title="statement not covered" >s.addEventListener("updatefromsandbox",(<span class="fstat-no" title="function not covered" >i=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >va</span>lue(i){<span class="cstat-no" title="statement not covered" >a?.();c</span>onst n=<span class="cstat-no" title="statement not covered" >i.detail.value,</span>o=<span class="cstat-no" title="statement not covered" >new Set(Array.isArray(n)?n:[n]);<span class="cstat-no" title="statement not covered" ></span>for(const t of s.options)<span class="cstat-no" title="statement not covered" >t.selected=o.has(t.value);<span class="cstat-no" title="statement not covered" >t</span></span>.setValue(e,{value:getValue(!0)});<span class="cstat-no" title="statement not covered" >r</span>=getValue(!1)}</span>,<span class="fstat-no" title="function not covered" >mu</span>ltipleSelection(t){<span class="cstat-no" title="statement not covered" >s.multiple=!0}</span>,<span class="fstat-no" title="function not covered" >re</span>move(i){const n=<span class="cstat-no" title="statement not covered" >s.options,</span>a=<span class="cstat-no" title="statement not covered" >i.detail.remove;<span class="cstat-no" title="statement not covered" ></span>n[a].selected=!1;<span class="cstat-no" title="statement not covered" >s</span>.remove(a);<span class="cstat-no" title="statement not covered" >i</span>f(n.length&gt;0){<span class="cstat-no" title="statement not covered" >-1===Array.prototype.findIndex.call(n,(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.selected)</span>)&amp;&amp;(n[0].selected=!0)}<span class="cstat-no" title="statement not covered" ></span>t</span>.setValue(e,{value:getValue(!0),items:getItems(i)});<span class="cstat-no" title="statement not covered" >r</span>=getValue(!1)}</span>,<span class="fstat-no" title="function not covered" >cl</span>ear(i){<span class="cstat-no" title="statement not covered" >for(;0!==s.length;)<span class="cstat-no" title="statement not covered" >s.remove(0);<span class="cstat-no" title="statement not covered" >t</span></span>.setValue(e,{value:null,items:[]});<span class="cstat-no" title="statement not covered" >r</span>=getValue(!1)}</span>,<span class="fstat-no" title="function not covered" >in</span>sert(i){const{index:n,displayValue:a,exportValue:o}=<span class="cstat-no" title="statement not covered" >i.detail.insert,</span>l=<span class="cstat-no" title="statement not covered" >s.children[n],</span>c=<span class="cstat-no" title="statement not covered" >document.createElement("option");<span class="cstat-no" title="statement not covered" ></span>c.textContent=a;<span class="cstat-no" title="statement not covered" >c</span>.value=o;<span class="cstat-no" title="statement not covered" >l</span>?l.before(c):s.append(c);<span class="cstat-no" title="statement not covered" >t</span>.setValue(e,{value:getValue(!0),items:getItems(i)});<span class="cstat-no" title="statement not covered" >r</span>=getValue(!1)}</span>,<span class="fstat-no" title="function not covered" >it</span>ems(i){const{items:n}=<span class="cstat-no" title="statement not covered" >i.detail;<span class="cstat-no" title="statement not covered" ></span>for(;0!==s.length;)<span class="cstat-no" title="statement not covered" >s.remove(0);<span class="cstat-no" title="statement not covered" >f</span></span>or(const t of n){const{displayValue:e,exportValue:i}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >document.createElement("option");<span class="cstat-no" title="statement not covered" ></span>n.textContent=e;<span class="cstat-no" title="statement not covered" >n</span>.value=i;<span class="cstat-no" title="statement not covered" >s</span>.append(n)}<span class="cstat-no" title="statement not covered" ></span>s</span>.options.length&gt;0&amp;&amp;(s.options[0].selected=!0);<span class="cstat-no" title="statement not covered" >t</span>.setValue(e,{value:getValue(!0),items:getItems(i)});<span class="cstat-no" title="statement not covered" >r</span>=getValue(!1)}</span>,<span class="fstat-no" title="function not covered" >in</span>dices(i){const s=<span class="cstat-no" title="statement not covered" >new Set(i.detail.indices);<span class="cstat-no" title="statement not covered" ></span>for(const t of i.target.options)<span class="cstat-no" title="statement not covered" >t.selected=s.has(t.index);<span class="cstat-no" title="statement not covered" >t</span></span>.setValue(e,{value:getValue(!0)});<span class="cstat-no" title="statement not covered" >r</span>=getValue(!1)}</span>,<span class="fstat-no" title="function not covered" >ed</span>itable(t){<span class="cstat-no" title="statement not covered" >t.target.disabled=!t.detail.editable}</span>};<span class="cstat-no" title="statement not covered" ></span>this._dispatchEventFromSandbox(n,i)}</span>));<span class="cstat-no" title="statement not covered" >s</span>.addEventListener("input",(<span class="fstat-no" title="function not covered" >i=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >getValue(!0);<span class="cstat-no" title="statement not covered" ></span>t.setValue(e,{value:s});<span class="cstat-no" title="statement not covered" >i</span>.preventDefault();<span class="cstat-no" title="statement not covered" >t</span>his.linkService.eventBus?.dispatch("dispatcheventinsandbox",{source:this,detail:{id:e,name:"Keystroke",value:r,changeEx:s,willCommit:!1,commitKey:1,keyDown:!1}})}</span>));<span class="cstat-no" title="statement not covered" >t</span>his._setEventListeners(s,[["focus","Focus"],["blur","Blur"],["mousedown","Mouse Down"],["mouseenter","Mouse Enter"],["mouseleave","Mouse Exit"],["mouseup","Mouse Up"],["input","Action"],["input","Validate"]],(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.target.value)</span>)}</span>else <span class="cstat-no" title="statement not covered" >s.addEventListener("input",(<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >t.setValue(e,{value:getValue(!0)})}</span>));<span class="cstat-no" title="statement not covered" >t</span></span>his.data.combo&amp;&amp;this._setTextStyle(s);<span class="cstat-no" title="statement not covered" >t</span>his._setBackgroundColor(s);<span class="cstat-no" title="statement not covered" >t</span>his._setDefaultPropertiesFromJS(s);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(s);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class PopupAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){const{data:e,elements:i}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>super(t,{isRenderable:!!(e.titleObj?.str||e.contentsObj?.str||e.richText?.str)});<span class="cstat-no" title="statement not covered" >t</span>his.elements=i}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("popupAnnotation");c</span>onst t=<span class="cstat-no" title="statement not covered" >new PopupElement({container:this.container,color:this.data.color,titleObj:this.data.titleObj,modificationDate:this.data.modificationDate,contentsObj:this.data.contentsObj,richText:this.data.richText,rect:this.data.rect,parentRect:this.data.parentRect||null,parent:this.parent,elements:this.elements,open:this.data.open}),</span>e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const i of this.elements){<span class="cstat-no" title="statement not covered" >i.popup=t;<span class="cstat-no" title="statement not covered" >e</span>.push(i.data.id);<span class="cstat-no" title="statement not covered" >i</span>.addHighlightArea()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.container.setAttribute("aria-controls",e.join(","));<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class PopupElement{#Ke=<span class="cstat-no" title="statement not covered" >null;</span>#Ye=<span class="cstat-no" title="statement not covered" >this.#Je.bind(this);</span>#Qe=<span class="cstat-no" title="statement not covered" >this.#Ze.bind(this);</span>#ti=<span class="cstat-no" title="statement not covered" >this.#ei.bind(this);</span>#Ie=<span class="cstat-no" title="statement not covered" >null;</span>#Ct=<span class="cstat-no" title="statement not covered" >null;</span>#ii=<span class="cstat-no" title="statement not covered" >null;</span>#si=<span class="cstat-no" title="statement not covered" >null;</span>#ni=<span class="cstat-no" title="statement not covered" >null;</span>#ai=<span class="cstat-no" title="statement not covered" >null;</span>#ri=<span class="cstat-no" title="statement not covered" >!1;</span>#oi=<span class="cstat-no" title="statement not covered" >null;</span>#li=<span class="cstat-no" title="statement not covered" >null;</span>#ci=<span class="cstat-no" title="statement not covered" >null;</span>#hi=<span class="cstat-no" title="statement not covered" >null;</span>#di=<span class="cstat-no" title="statement not covered" >!1;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor({container:t,color:e,elements:i,titleObj:s,modificationDate:a,contentsObj:r,richText:o,parent:l,rect:c,parentRect:h,open:d}){<span class="cstat-no" title="statement not covered" >this.#Ct=t;<span class="cstat-no" title="statement not covered" >t</span>his.#hi=s;<span class="cstat-no" title="statement not covered" >t</span>his.#ii=r;<span class="cstat-no" title="statement not covered" >t</span>his.#ci=o;<span class="cstat-no" title="statement not covered" >t</span>his.#ni=l;<span class="cstat-no" title="statement not covered" >t</span>his.#Ie=e;<span class="cstat-no" title="statement not covered" >t</span>his.#li=c;<span class="cstat-no" title="statement not covered" >t</span>his.#ai=h;<span class="cstat-no" title="statement not covered" >t</span>his.#si=i;c</span>onst u=<span class="cstat-no" title="statement not covered" >n.PDFDateString.toDateObject(a);<span class="cstat-no" title="statement not covered" ></span>u&amp;&amp;(this.#Ke=l.l10n.get("annotation_date_string",{date:u.toLocaleDateString(),time:u.toLocaleTimeString()}));<span class="cstat-no" title="statement not covered" >t</span>his.trigger=i.flatMap((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.getElementsToTriggerPopup())</span>);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.trigger){<span class="cstat-no" title="statement not covered" >t.addEventListener("click",this.#ti);<span class="cstat-no" title="statement not covered" >t</span>.addEventListener("mouseenter",this.#Qe);<span class="cstat-no" title="statement not covered" >t</span>.addEventListener("mouseleave",this.#Ye)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#Ct.hidden=!0;<span class="cstat-no" title="statement not covered" >d</span>&amp;&amp;this.#ei()}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >if(this.#oi)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{page:{view:t},viewport:{rawDims:{pageWidth:e,pageHeight:i,pageX:n,pageY:a}}}=<span class="cstat-no" title="statement not covered" >this.#ni,</span>r=<span class="cstat-no" title="statement not covered" >this.#oi=document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>r.className="popup";<span class="cstat-no" title="statement not covered" >i</span>f(this.#Ie){const t=<span class="cstat-no" title="statement not covered" >r.style.outlineColor=s.Util.makeHexColor(...this.#Ie);<span class="cstat-no" title="statement not covered" ></span>if(CSS.supports("background-color","color-mix(in srgb, red 30%, white)"))<span class="cstat-no" title="statement not covered" >r.style.backgroundColor=`color-mix(in srgb, ${t} 30%, white)`;e</span>lse{const t=<span class="cstat-no" title="statement not covered" >.7;<span class="cstat-no" title="statement not covered" ></span>r.style.backgroundColor=s.Util.makeHexColor(...this.#Ie.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.floor(t*(255-e)+e))</span>))}</span>}</span>c</span>onst o=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>o.className="header";c</span>onst c=<span class="cstat-no" title="statement not covered" >document.createElement("h1");<span class="cstat-no" title="statement not covered" ></span>o.append(c);<span class="cstat-no" title="statement not covered" >(</span>{dir:c.dir,str:c.textContent}=this.#hi);<span class="cstat-no" title="statement not covered" >r</span>.append(o);<span class="cstat-no" title="statement not covered" >i</span>f(this.#Ke){const t=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>t.classList.add("popupDate");<span class="cstat-no" title="statement not covered" >t</span>his.#Ke.then((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.textContent=e}</span>));<span class="cstat-no" title="statement not covered" >o</span>.append(t)}</span>c</span>onst h=<span class="cstat-no" title="statement not covered" >this.#ii,</span>d=<span class="cstat-no" title="statement not covered" >this.#ci;<span class="cstat-no" title="statement not covered" ></span>if(!d?.str||h?.str&amp;&amp;h.str!==d.str){const t=<span class="cstat-no" title="statement not covered" >this._formatContents(h);<span class="cstat-no" title="statement not covered" ></span>r.append(t)}</span>else{<span class="cstat-no" title="statement not covered" >l.XfaLayer.render({xfaHtml:d.html,intent:"richText",div:r});<span class="cstat-no" title="statement not covered" >r</span>.lastChild.classList.add("richText","popupContent")}</span>l</span>et u=<span class="cstat-no" title="statement not covered" >!!this.#ai,</span>p=<span class="cstat-no" title="statement not covered" >u?this.#ai:this.#li;<span class="cstat-no" title="statement not covered" ></span>for(const t of this.#si)<span class="cstat-no" title="statement not covered" >if(!p||null!==s.Util.intersect(t.data.rect,p)){<span class="cstat-no" title="statement not covered" >p=t.data.rect;<span class="cstat-no" title="statement not covered" >u</span>=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>c</span></span>onst g=<span class="cstat-no" title="statement not covered" >s.Util.normalizeRect([p[0],t[3]-p[1]+t[1],p[2],t[3]-p[3]+t[1]]),</span>m=<span class="cstat-no" title="statement not covered" >u?p[2]-p[0]+5:0,</span>f=<span class="cstat-no" title="statement not covered" >g[0]+m,</span>b=<span class="cstat-no" title="statement not covered" >g[1],</span>{style:A}=<span class="cstat-no" title="statement not covered" >this.#Ct;<span class="cstat-no" title="statement not covered" ></span>A.left=100*(f-n)/e+"%";<span class="cstat-no" title="statement not covered" >A</span>.top=100*(b-a)/i+"%";<span class="cstat-no" title="statement not covered" >t</span>his.#Ct.append(r)}<span class="fstat-no" title="function not covered" ></span>_f</span>ormatContents({str:t,dir:e}){const i=<span class="cstat-no" title="statement not covered" >document.createElement("p");<span class="cstat-no" title="statement not covered" ></span>i.classList.add("popupContent");<span class="cstat-no" title="statement not covered" >i</span>.dir=e;c</span>onst s=<span class="cstat-no" title="statement not covered" >t.split(/(?:\r\n?|\n)/);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >s.length;</span>t&lt;e;++t){const n=<span class="cstat-no" title="statement not covered" >s[t];<span class="cstat-no" title="statement not covered" ></span>i.append(document.createTextNode(n));<span class="cstat-no" title="statement not covered" >t</span>&lt;e-1&amp;&amp;i.append(document.createElement("br"))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>#ei(){<span class="cstat-no" title="statement not covered" >this.#ri=!this.#ri;<span class="cstat-no" title="statement not covered" >i</span>f(this.#ri){<span class="cstat-no" title="statement not covered" >this.#Ze();<span class="cstat-no" title="statement not covered" >t</span>his.#Ct.addEventListener("click",this.#ti)}</span>else{<span class="cstat-no" title="statement not covered" >this.#Je();<span class="cstat-no" title="statement not covered" >t</span>his.#Ct.removeEventListener("click",this.#ti)}</span>}</span>#Ze(){<span class="cstat-no" title="statement not covered" >this.#oi||this.render();<span class="cstat-no" title="statement not covered" >i</span>f(this.isVisible)<span class="cstat-no" title="statement not covered" >this.#ri&amp;&amp;this.#Ct.classList.add("focused");e</span>lse{<span class="cstat-no" title="statement not covered" >this.#Ct.hidden=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#Ct.style.zIndex=parseInt(this.#Ct.style.zIndex)+1e3}</span>}</span>#Je(){<span class="cstat-no" title="statement not covered" >this.#Ct.classList.remove("focused");<span class="cstat-no" title="statement not covered" >i</span>f(!this.#ri&amp;&amp;this.isVisible){<span class="cstat-no" title="statement not covered" >this.#Ct.hidden=!0;<span class="cstat-no" title="statement not covered" >t</span>his.#Ct.style.zIndex=parseInt(this.#Ct.style.zIndex)-1e3}</span>}<span class="fstat-no" title="function not covered" ></span>fo</span>rceHide(){<span class="cstat-no" title="statement not covered" >this.#di=this.isVisible;<span class="cstat-no" title="statement not covered" >t</span>his.#di&amp;&amp;(this.#Ct.hidden=!0)}<span class="fstat-no" title="function not covered" ></span>ma</span>ybeShow(){<span class="cstat-no" title="statement not covered" >if(this.#di){<span class="cstat-no" title="statement not covered" >this.#di=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#Ct.hidden=!1}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t isVisible(){<span class="cstat-no" title="statement not covered" >return!1===this.#Ct.hidden}</span>}class FreeTextAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0});<span class="cstat-no" title="statement not covered" >t</span>his.textContent=t.data.textContent;<span class="cstat-no" title="statement not covered" >t</span>his.textPosition=t.data.textPosition;<span class="cstat-no" title="statement not covered" >t</span>his.annotationEditorType=s.AnnotationEditorType.FREETEXT}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("freeTextAnnotation");<span class="cstat-no" title="statement not covered" >i</span>f(this.textContent){const t=<span class="cstat-no" title="statement not covered" >document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>t.classList.add("annotationTextContent");<span class="cstat-no" title="statement not covered" >t</span>.setAttribute("role","comment");<span class="cstat-no" title="statement not covered" >f</span>or(const e of this.textContent){const i=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>i.textContent=e;<span class="cstat-no" title="statement not covered" >t</span>.append(i)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.container.append(t)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >t</span>his._editOnDoubleClick();<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}<span class="cstat-no" title="statement not covered" >e.FreeTextAnnotationElement=FreeTextAnnotationElement;c</span>lass LineAnnotationElement extends AnnotationElement{#ui=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("lineAnnotation");c</span>onst t=<span class="cstat-no" title="statement not covered" >this.data,</span>{width:e,height:i}=<span class="cstat-no" title="statement not covered" >getRectDims(t.rect),</span>s=<span class="cstat-no" title="statement not covered" >this.svgFactory.create(e,i,!0),</span>n=<span class="cstat-no" title="statement not covered" >this.#ui=this.svgFactory.createElement("svg:line");<span class="cstat-no" title="statement not covered" ></span>n.setAttribute("x1",t.rect[2]-t.lineCoordinates[0]);<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("y1",t.rect[3]-t.lineCoordinates[1]);<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("x2",t.rect[2]-t.lineCoordinates[2]);<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("y2",t.rect[3]-t.lineCoordinates[3]);<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("stroke-width",t.borderStyle.width||1);<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("stroke","transparent");<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("fill","transparent");<span class="cstat-no" title="statement not covered" >s</span>.append(n);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(s);<span class="cstat-no" title="statement not covered" >t</span>.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsToTriggerPopup(){<span class="cstat-no" title="statement not covered" >return this.#ui}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightArea(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("highlightArea")}</span>}class SquareAnnotationElement extends AnnotationElement{#pi=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("squareAnnotation");c</span>onst t=<span class="cstat-no" title="statement not covered" >this.data,</span>{width:e,height:i}=<span class="cstat-no" title="statement not covered" >getRectDims(t.rect),</span>s=<span class="cstat-no" title="statement not covered" >this.svgFactory.create(e,i,!0),</span>n=<span class="cstat-no" title="statement not covered" >t.borderStyle.width,</span>a=<span class="cstat-no" title="statement not covered" >this.#pi=this.svgFactory.createElement("svg:rect");<span class="cstat-no" title="statement not covered" ></span>a.setAttribute("x",n/2);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("y",n/2);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("width",e-n);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("height",i-n);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("stroke-width",n||1);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("stroke","transparent");<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("fill","transparent");<span class="cstat-no" title="statement not covered" >s</span>.append(a);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(s);<span class="cstat-no" title="statement not covered" >t</span>.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsToTriggerPopup(){<span class="cstat-no" title="statement not covered" >return this.#pi}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightArea(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("highlightArea")}</span>}class CircleAnnotationElement extends AnnotationElement{#gi=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("circleAnnotation");c</span>onst t=<span class="cstat-no" title="statement not covered" >this.data,</span>{width:e,height:i}=<span class="cstat-no" title="statement not covered" >getRectDims(t.rect),</span>s=<span class="cstat-no" title="statement not covered" >this.svgFactory.create(e,i,!0),</span>n=<span class="cstat-no" title="statement not covered" >t.borderStyle.width,</span>a=<span class="cstat-no" title="statement not covered" >this.#gi=this.svgFactory.createElement("svg:ellipse");<span class="cstat-no" title="statement not covered" ></span>a.setAttribute("cx",e/2);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("cy",i/2);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("rx",e/2-n/2);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("ry",i/2-n/2);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("stroke-width",n||1);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("stroke","transparent");<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("fill","transparent");<span class="cstat-no" title="statement not covered" >s</span>.append(a);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(s);<span class="cstat-no" title="statement not covered" >t</span>.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsToTriggerPopup(){<span class="cstat-no" title="statement not covered" >return this.#gi}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightArea(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("highlightArea")}</span>}class PolylineAnnotationElement extends AnnotationElement{#mi=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0});<span class="cstat-no" title="statement not covered" >t</span>his.containerClassName="polylineAnnotation";<span class="cstat-no" title="statement not covered" >t</span>his.svgElementName="svg:polyline"}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add(this.containerClassName);c</span>onst t=<span class="cstat-no" title="statement not covered" >this.data,</span>{width:e,height:i}=<span class="cstat-no" title="statement not covered" >getRectDims(t.rect),</span>s=<span class="cstat-no" title="statement not covered" >this.svgFactory.create(e,i,!0);</span>let n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const e of t.vertices){const i=<span class="cstat-no" title="statement not covered" >e.x-t.rect[0],</span>s=<span class="cstat-no" title="statement not covered" >t.rect[3]-e.y;<span class="cstat-no" title="statement not covered" ></span>n.push(i+","+s)}<span class="cstat-no" title="statement not covered" ></span>n</span>=n.join(" ");c</span>onst a=<span class="cstat-no" title="statement not covered" >this.#mi=this.svgFactory.createElement(this.svgElementName);<span class="cstat-no" title="statement not covered" ></span>a.setAttribute("points",n);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("stroke-width",t.borderStyle.width||1);<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("stroke","transparent");<span class="cstat-no" title="statement not covered" >a</span>.setAttribute("fill","transparent");<span class="cstat-no" title="statement not covered" >s</span>.append(a);<span class="cstat-no" title="statement not covered" >t</span>his.container.append(s);<span class="cstat-no" title="statement not covered" >t</span>.popupRef||this._createPopup(a,t);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsToTriggerPopup(){<span class="cstat-no" title="statement not covered" >return this.#mi}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightArea(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("highlightArea")}</span>}class PolygonAnnotationElement extends PolylineAnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t);<span class="cstat-no" title="statement not covered" >t</span>his.containerClassName="polygonAnnotation";<span class="cstat-no" title="statement not covered" >t</span>his.svgElementName="svg:polygon"}</span>}class CaretAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("caretAnnotation");<span class="cstat-no" title="statement not covered" >t</span>his.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class InkAnnotationElement extends AnnotationElement{#fi=<span class="cstat-no" title="statement not covered" >[];<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0});<span class="cstat-no" title="statement not covered" >t</span>his.containerClassName="inkAnnotation";<span class="cstat-no" title="statement not covered" >t</span>his.svgElementName="svg:polyline";<span class="cstat-no" title="statement not covered" >t</span>his.annotationEditorType=s.AnnotationEditorType.INK}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add(this.containerClassName);c</span>onst t=<span class="cstat-no" title="statement not covered" >this.data,</span>{width:e,height:i}=<span class="cstat-no" title="statement not covered" >getRectDims(t.rect),</span>s=<span class="cstat-no" title="statement not covered" >this.svgFactory.create(e,i,!0);<span class="cstat-no" title="statement not covered" ></span>for(const e of t.inkLists){let i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const s of e){const e=<span class="cstat-no" title="statement not covered" >s.x-t.rect[0],</span>n=<span class="cstat-no" title="statement not covered" >t.rect[3]-s.y;<span class="cstat-no" title="statement not covered" ></span>i.push(`${e},${n}`)}<span class="cstat-no" title="statement not covered" ></span>i</span>=i.join(" ");c</span>onst n=<span class="cstat-no" title="statement not covered" >this.svgFactory.createElement(this.svgElementName);<span class="cstat-no" title="statement not covered" ></span>this.#fi.push(n);<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("points",i);<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("stroke-width",t.borderStyle.width||1);<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("stroke","transparent");<span class="cstat-no" title="statement not covered" >n</span>.setAttribute("fill","transparent");<span class="cstat-no" title="statement not covered" >t</span>.popupRef||this._createPopup(n,t);<span class="cstat-no" title="statement not covered" >s</span>.append(n)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.container.append(s);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsToTriggerPopup(){<span class="cstat-no" title="statement not covered" >return this.#fi}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightArea(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("highlightArea")}</span>}<span class="cstat-no" title="statement not covered" >e.InkAnnotationElement=InkAnnotationElement;c</span>lass HighlightAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0,createQuadrilaterals:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >t</span>his.container.classList.add("highlightAnnotation");<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class UnderlineAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0,createQuadrilaterals:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >t</span>his.container.classList.add("underlineAnnotation");<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class SquigglyAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0,createQuadrilaterals:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >t</span>his.container.classList.add("squigglyAnnotation");<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class StrikeOutAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0,createQuadrilaterals:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >t</span>his.container.classList.add("strikeoutAnnotation");<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}class StampAnnotationElement extends AnnotationElement{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!!(t.data.popupRef||t.data.titleObj?.str||t.data.contentsObj?.str||t.data.richText?.str),ignoreBorder:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("stampAnnotation");<span class="cstat-no" title="statement not covered" >t</span>his.data.popupRef||this._createPopup();<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}</span>}<span class="cstat-no" title="statement not covered" >e.StampAnnotationElement=StampAnnotationElement;c</span>lass FileAttachmentAnnotationElement extends AnnotationElement{#bi=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t,{isRenderable:!0});c</span>onst{filename:e,content:i}=<span class="cstat-no" title="statement not covered" >this.data.file;<span class="cstat-no" title="statement not covered" ></span>this.filename=(0,n.getFilenameFromUrl)(e,!0);<span class="cstat-no" title="statement not covered" >t</span>his.content=i;<span class="cstat-no" title="statement not covered" >t</span>his.linkService.eventBus?.dispatch("fileattachmentannotation",{source:this,filename:e,content:i})}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("fileAttachmentAnnotation");c</span>onst{data:t}=<span class="cstat-no" title="statement not covered" >this;</span>let e;<span class="cstat-no" title="statement not covered" >if(t.hasAppearance||0===t.fillAlpha)<span class="cstat-no" title="statement not covered" >e=document.createElement("div");e</span>lse{<span class="cstat-no" title="statement not covered" >e=document.createElement("img");<span class="cstat-no" title="statement not covered" >e</span>.src=`${this.imageResourcesPath}annotation-${/paperclip/i.test(t.name)?"paperclip":"pushpin"}.svg`;<span class="cstat-no" title="statement not covered" >t</span>.fillAlpha&amp;&amp;t.fillAlpha&lt;1&amp;&amp;(e.style=`filter: opacity(${Math.round(100*t.fillAlpha)}%);`)}<span class="cstat-no" title="statement not covered" ></span>e</span>.classList.add("popupTriggerArea");<span class="cstat-no" title="statement not covered" >e</span>.addEventListener("dblclick",this._download.bind(this));<span class="cstat-no" title="statement not covered" >t</span>his.#bi=e;<span class="cstat-no" title="statement not covered" >!</span>t.popupRef&amp;&amp;(t.titleObj?.str||t.contentsObj?.str||t.richText)&amp;&amp;this._createPopup();<span class="cstat-no" title="statement not covered" >t</span>his.container.append(e);<span class="cstat-no" title="statement not covered" >r</span>eturn this.container}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsToTriggerPopup(){<span class="cstat-no" title="statement not covered" >return this.#bi}<span class="fstat-no" title="function not covered" ></span>ad</span>dHighlightArea(){<span class="cstat-no" title="statement not covered" >this.container.classList.add("highlightArea")}<span class="fstat-no" title="function not covered" ></span>_d</span>ownload(){<span class="cstat-no" title="statement not covered" >this.downloadManager?.openOrDownloadData(this.container,this.content,this.filename)}</span>}<span class="cstat-no" title="statement not covered" >e.AnnotationLayer=class AnnotationLayer{#fe=<span class="cstat-no" title="statement not covered" >null;</span>#Ai=<span class="cstat-no" title="statement not covered" >null;</span>#_i=<span class="cstat-no" title="statement not covered" >new Map;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor({div:t,accessibilityManager:e,annotationCanvasMap:i,l10n:s,page:n,viewport:a}){<span class="cstat-no" title="statement not covered" >this.div=t;<span class="cstat-no" title="statement not covered" >t</span>his.#fe=e;<span class="cstat-no" title="statement not covered" >t</span>his.#Ai=i;<span class="cstat-no" title="statement not covered" >t</span>his.l10n=s;<span class="cstat-no" title="statement not covered" >t</span>his.page=n;<span class="cstat-no" title="statement not covered" >t</span>his.viewport=a;<span class="cstat-no" title="statement not covered" >t</span>his.zIndex=0;<span class="cstat-no" title="statement not covered" >t</span>his.l10n||=o.NullL10n}</span>#vi(t,e){const i=<span class="cstat-no" title="statement not covered" >t.firstChild||t;<span class="cstat-no" title="statement not covered" ></span>i.id=`${n.AnnotationPrefix}${e}`;<span class="cstat-no" title="statement not covered" >t</span>his.div.append(t);<span class="cstat-no" title="statement not covered" >t</span>his.#fe?.moveElementInDOM(this.div,t,i,!1)}<span class="fstat-no" title="function not covered" ></span>as</span>ync render(t){const{annotations:e}=<span class="cstat-no" title="statement not covered" >t,</span>i=<span class="cstat-no" title="statement not covered" >this.div;<span class="cstat-no" title="statement not covered" ></span>(0,n.setLayerDimensions)(i,this.viewport);c</span>onst r=<span class="cstat-no" title="statement not covered" >new Map,</span>o=<span class="cstat-no" title="statement not covered" >{data:null,layer:i,linkService:t.linkService,downloadManager:t.downloadManager,imageResourcesPath:t.imageResourcesPath||"",renderForms:!1!==t.renderForms,svgFactory:new n.DOMSVGFactory,annotationStorage:t.annotationStorage||new a.AnnotationStorage,enableScripting:!0===t.enableScripting,hasJSActions:t.hasJSActions,fieldObjects:t.fieldObjects,parent:this,elements:null};<span class="cstat-no" title="statement not covered" ></span>for(const t of e){<span class="cstat-no" title="statement not covered" >if(t.noHTML)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t.annotationType===s.AnnotationType.POPUP;<span class="cstat-no" title="statement not covered" ></span>if(e){const e=<span class="cstat-no" title="statement not covered" >r.get(t.id);<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >o</span></span>.elements=e}</span>else{const{width:e,height:i}=<span class="cstat-no" title="statement not covered" >getRectDims(t.rect);<span class="cstat-no" title="statement not covered" ></span>if(e&lt;=0||i&lt;=0)<span class="cstat-no" title="statement not covered" >continue}<span class="cstat-no" title="statement not covered" ></span></span>o</span>.data=t;c</span>onst i=<span class="cstat-no" title="statement not covered" >AnnotationElementFactory.create(o);<span class="cstat-no" title="statement not covered" ></span>if(!i.isRenderable)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(!e&amp;&amp;t.popupRef){const e=<span class="cstat-no" title="statement not covered" >r.get(t.popupRef);<span class="cstat-no" title="statement not covered" ></span>e?e.push(i):r.set(t.popupRef,[i])}<span class="cstat-no" title="statement not covered" ></span>i</span>.annotationEditorType&gt;0&amp;&amp;this.#_i.set(i.data.id,i);c</span>onst n=<span class="cstat-no" title="statement not covered" >i.render();<span class="cstat-no" title="statement not covered" ></span>t.hidden&amp;&amp;(n.style.visibility="hidden");<span class="cstat-no" title="statement not covered" >t</span>his.#vi(n,t.id)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#yi();<span class="cstat-no" title="statement not covered" >a</span>wait this.l10n.translate(i)}<span class="fstat-no" title="function not covered" ></span>up</span>date({viewport:t}){const e=<span class="cstat-no" title="statement not covered" >this.div;<span class="cstat-no" title="statement not covered" ></span>this.viewport=t;<span class="cstat-no" title="statement not covered" >(</span>0,n.setLayerDimensions)(e,{rotation:t.rotation});<span class="cstat-no" title="statement not covered" >t</span>his.#yi();<span class="cstat-no" title="statement not covered" >e</span>.hidden=!1}</span>#yi(){<span class="cstat-no" title="statement not covered" >if(!this.#Ai)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.div;<span class="cstat-no" title="statement not covered" ></span>for(const[e,i]of this.#Ai){const s=<span class="cstat-no" title="statement not covered" >t.querySelector(`[data-annotation-id="${e}"]`);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst{firstChild:n}=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>n?"CANVAS"===n.nodeName?n.replaceWith(i):n.before(i):s.append(i)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#Ai.clear()}<span class="fstat-no" title="function not covered" ></span>ge</span>tEditableAnnotations(){<span class="cstat-no" title="statement not covered" >return Array.from(this.#_i.values())}<span class="fstat-no" title="function not covered" ></span>ge</span>tEditableAnnotation(t){<span class="cstat-no" title="statement not covered" >return this.#_i.get(t)}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.ColorConverters=void 0;f</span>unction <span class="fstat-no" title="function not covered" >makeColorComp(</span>t){<span class="cstat-no" title="statement not covered" >return Math.floor(255*Math.max(0,Math.min(1,t))).toString(16).padStart(2,"0")}</span>function <span class="fstat-no" title="function not covered" >scaleAndClamp(</span>t){<span class="cstat-no" title="statement not covered" >return Math.max(0,Math.min(255,255*t))}<span class="cstat-no" title="statement not covered" ></span>e.ColorConverters=class ColorConverters{<span class="fstat-no" title="function not covered" >st</span>atic CMYK_G([t,e,i,s]){<span class="cstat-no" title="statement not covered" >return["G",1-Math.min(1,.3*t+.59*i+.11*e+s)]}<span class="fstat-no" title="function not covered" ></span>st</span>atic G_CMYK([t]){<span class="cstat-no" title="statement not covered" >return["CMYK",0,0,0,1-t]}<span class="fstat-no" title="function not covered" ></span>st</span>atic G_RGB([t]){<span class="cstat-no" title="statement not covered" >return["RGB",t,t,t]}<span class="fstat-no" title="function not covered" ></span>st</span>atic G_rgb([t]){<span class="cstat-no" title="statement not covered" >return[t=scaleAndClamp(t),t,t]}<span class="fstat-no" title="function not covered" ></span>st</span>atic G_HTML([t]){const e=<span class="cstat-no" title="statement not covered" >makeColorComp(t);<span class="cstat-no" title="statement not covered" ></span>return`#${e}${e}${e}`}<span class="fstat-no" title="function not covered" ></span>st</span>atic RGB_G([t,e,i]){<span class="cstat-no" title="statement not covered" >return["G",.3*t+.59*e+.11*i]}<span class="fstat-no" title="function not covered" ></span>st</span>atic RGB_rgb(t){<span class="cstat-no" title="statement not covered" >return t.map(scaleAndClamp)}<span class="fstat-no" title="function not covered" ></span>st</span>atic RGB_HTML(t){<span class="cstat-no" title="statement not covered" >return`#${t.map(makeColorComp).join("")}`}<span class="fstat-no" title="function not covered" ></span>st</span>atic T_HTML(){<span class="cstat-no" title="statement not covered" >return"#00000000"}<span class="fstat-no" title="function not covered" ></span>st</span>atic T_rgb(){<span class="cstat-no" title="statement not covered" >return[null]}<span class="fstat-no" title="function not covered" ></span>st</span>atic CMYK_RGB([t,e,i,s]){<span class="cstat-no" title="statement not covered" >return["RGB",1-Math.min(1,t+s),1-Math.min(1,i+s),1-Math.min(1,e+s)]}<span class="fstat-no" title="function not covered" ></span>st</span>atic CMYK_rgb([t,e,i,s]){<span class="cstat-no" title="statement not covered" >return[scaleAndClamp(1-Math.min(1,t+s)),scaleAndClamp(1-Math.min(1,i+s)),scaleAndClamp(1-Math.min(1,e+s))]}<span class="fstat-no" title="function not covered" ></span>st</span>atic CMYK_HTML(t){const e=<span class="cstat-no" title="statement not covered" >this.CMYK_RGB(t).slice(1);<span class="cstat-no" title="statement not covered" ></span>return this.RGB_HTML(e)}<span class="fstat-no" title="function not covered" ></span>st</span>atic RGB_CMYK([t,e,i]){const s=<span class="cstat-no" title="statement not covered" >1-t,</span>n=<span class="cstat-no" title="statement not covered" >1-e,</span>a=<span class="cstat-no" title="statement not covered" >1-i;<span class="cstat-no" title="statement not covered" ></span>return["CMYK",s,n,a,Math.min(s,n,a)]}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.NullL10n=void 0;<span class="cstat-no" title="statement not covered" >e</span>.getL10nFallback=getL10nFallback;c</span>onst i=<span class="cstat-no" title="statement not covered" >{of_pages:"of {{pagesCount}}",page_of_pages:"({{pageNumber}} of {{pagesCount}})",document_properties_kb:"{{size_kb}} KB ({{size_b}} bytes)",document_properties_mb:"{{size_mb}} MB ({{size_b}} bytes)",document_properties_date_string:"{{date}}, {{time}}",document_properties_page_size_unit_inches:"in",document_properties_page_size_unit_millimeters:"mm",document_properties_page_size_orientation_portrait:"portrait",document_properties_page_size_orientation_landscape:"landscape",document_properties_page_size_name_a3:"A3",document_properties_page_size_name_a4:"A4",document_properties_page_size_name_letter:"Letter",document_properties_page_size_name_legal:"Legal",document_properties_page_size_dimension_string:"{{width}} × {{height}} {{unit}} ({{orientation}})",document_properties_page_size_dimension_name_string:"{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",document_properties_linearized_yes:"Yes",document_properties_linearized_no:"No",additional_layers:"Additional Layers",page_landmark:"Page {{page}}",thumb_page_title:"Page {{page}}",thumb_page_canvas:"Thumbnail of Page {{page}}",find_reached_top:"Reached top of document, continued from bottom",find_reached_bottom:"Reached end of document, continued from top","find_match_count[one]":"{{current}} of {{total}} match","find_match_count[other]":"{{current}} of {{total}} matches","find_match_count_limit[one]":"More than {{limit}} match","find_match_count_limit[other]":"More than {{limit}} matches",find_not_found:"Phrase not found",page_scale_width:"Page Width",page_scale_fit:"Page Fit",page_scale_auto:"Automatic Zoom",page_scale_actual:"Actual Size",page_scale_percent:"{{scale}}%",loading_error:"An error occurred while loading the PDF.",invalid_file_error:"Invalid or corrupted PDF file.",missing_file_error:"Missing PDF file.",unexpected_response_error:"Unexpected server response.",rendering_error:"An error occurred while rendering the page.",annotation_date_string:"{{date}}, {{time}}",printing_not_supported:"Warning: Printing is not fully supported by this browser.",printing_not_ready:"Warning: The PDF is not fully loaded for printing.",web_fonts_disabled:"Web fonts are disabled: unable to use embedded PDF fonts.",free_text2_default_content:"Start typing…",editor_free_text2_aria_label:"Text Editor",editor_ink2_aria_label:"Draw Editor",editor_ink_canvas_aria_label:"User-created image",print_progress_percent:"{{progress}}%"};</span>function <span class="fstat-no" title="function not covered" >getL10nFallback(</span>t,e){<span class="cstat-no" title="statement not covered" >switch(t){case"find_match_count":<span class="cstat-no" title="statement not covered" >t=`find_match_count[${1===e.total?"one":"other"}]`;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"find_match_count_limit":<span class="cstat-no" title="statement not covered" >t=`find_match_count_limit[${1===e.limit?"one":"other"}]`}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i[t]||""}</span>const s=<span class="cstat-no" title="statement not covered" >{getLanguage:<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;<span class="cstat-no" title="statement not covered" >"en-us",</span>getDirection:<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;<span class="cstat-no" title="statement not covered" >"ltr",</span>get:<span class="fstat-no" title="function not covered" >as</span>ync(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >getL10nFallback(t,e))</span>=&gt;<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >formatL10nValue(</span>t,e){<span class="cstat-no" title="statement not covered" >return e?t.replaceAll(/\{\{\s*(\w+)\s*\}\}/g,(<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >i in e?e[i]:"{{"+i+"}}")</span>):t}</span>(i,e),<span class="fstat-no" title="function not covered" ></span>as</span>ync translate(t){}};<span class="cstat-no" title="statement not covered" ></span>e.NullL10n=s}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.XfaLayer=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(25);<span class="cstat-no" title="statement not covered" ></span>e.XfaLayer=class XfaLayer{<span class="fstat-no" title="function not covered" >st</span>atic setupStorage(t,e,i,s,n){const a=<span class="cstat-no" title="statement not covered" >s.getValue(e,{value:null});<span class="cstat-no" title="statement not covered" ></span>switch(i.name){case"textarea":<span class="cstat-no" title="statement not covered" >null!==a.value&amp;&amp;(t.textContent=a.value);<span class="cstat-no" title="statement not covered" >i</span>f("print"===n)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span></span>.addEventListener("input",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >s.setValue(e,{value:t.target.value})}</span>));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"input":<span class="cstat-no" title="statement not covered" >if("radio"===i.attributes.type||"checkbox"===i.attributes.type){<span class="cstat-no" title="statement not covered" >a.value===i.attributes.xfaOn?t.setAttribute("checked",!0):a.value===i.attributes.xfaOff&amp;&amp;t.removeAttribute("checked");<span class="cstat-no" title="statement not covered" >i</span>f("print"===n)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span></span>.addEventListener("change",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >s.setValue(e,{value:t.target.checked?t.target.getAttribute("xfaOn"):t.target.getAttribute("xfaOff")})}</span>))}</span>else{<span class="cstat-no" title="statement not covered" >null!==a.value&amp;&amp;t.setAttribute("value",a.value);<span class="cstat-no" title="statement not covered" >i</span>f("print"===n)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span></span>.addEventListener("input",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >s.setValue(e,{value:t.target.value})}</span>))}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase"select":<span class="cstat-no" title="statement not covered" >if(null!==a.value){<span class="cstat-no" title="statement not covered" >t.setAttribute("value",a.value);<span class="cstat-no" title="statement not covered" >f</span>or(const t of i.children)<span class="cstat-no" title="statement not covered" >t.attributes.value===a.value?t.attributes.selected=!0:t.attributes.hasOwnProperty("selected")&amp;&amp;delete t.attributes.selected}<span class="cstat-no" title="statement not covered" ></span></span>t</span>.addEventListener("input",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >t.target.options,</span>n=<span class="cstat-no" title="statement not covered" >-1===i.selectedIndex?"":i[i.selectedIndex].value;<span class="cstat-no" title="statement not covered" ></span>s.setValue(e,{value:n})}</span>))}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>atic setAttributes({html:t,element:e,storage:i=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>intent:s,linkService:n}){const{attributes:a}=<span class="cstat-no" title="statement not covered" >e,</span>r=<span class="cstat-no" title="statement not covered" >t instanceof HTMLAnchorElement;<span class="cstat-no" title="statement not covered" ></span>"radio"===a.type&amp;&amp;(a.name=`${a.name}-${s}`);<span class="cstat-no" title="statement not covered" >f</span>or(const[e,i]of Object.entries(a))<span class="cstat-no" title="statement not covered" >if(null!=i)<span class="cstat-no" title="statement not covered" >switch(e){case"class":<span class="cstat-no" title="statement not covered" >i.length&amp;&amp;t.setAttribute(e,i.join(" "));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"dataId":<span class="cstat-no" title="statement not covered" >break;c</span>ase"id":<span class="cstat-no" title="statement not covered" >t.setAttribute("data-element-id",i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"style":<span class="cstat-no" title="statement not covered" >Object.assign(t.style,i);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"textContent":<span class="cstat-no" title="statement not covered" >t.textContent=i;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >(!r||"href"!==e&amp;&amp;"newWindow"!==e)&amp;&amp;t.setAttribute(e,i)}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>&amp;&amp;n.addLinkAttributes(t,a.href,a.newWindow);<span class="cstat-no" title="statement not covered" >i</span>&amp;&amp;a.dataId&amp;&amp;this.setupStorage(t,a.dataId,e,i)}<span class="fstat-no" title="function not covered" ></span>st</span>atic render(t){const e=<span class="cstat-no" title="statement not covered" >t.annotationStorage,</span>i=<span class="cstat-no" title="statement not covered" >t.linkService,</span>n=<span class="cstat-no" title="statement not covered" >t.xfaHtml,</span>a=<span class="cstat-no" title="statement not covered" >t.intent||"display",</span>r=<span class="cstat-no" title="statement not covered" >document.createElement(n.name);<span class="cstat-no" title="statement not covered" ></span>n.attributes&amp;&amp;this.setAttributes({html:r,element:n,intent:a,linkService:i});c</span>onst o=<span class="cstat-no" title="statement not covered" >[[n,-1,r]],</span>l=<span class="cstat-no" title="statement not covered" >t.div;<span class="cstat-no" title="statement not covered" ></span>l.append(r);<span class="cstat-no" title="statement not covered" >i</span>f(t.viewport){const e=<span class="cstat-no" title="statement not covered" >`matrix(${t.viewport.transform.join(",")})`;<span class="cstat-no" title="statement not covered" ></span>l.style.transform=e}<span class="cstat-no" title="statement not covered" ></span>"</span>richText"!==a&amp;&amp;l.setAttribute("class","xfaLayer xfaFont");c</span>onst c=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(;o.length&gt;0;){const[t,n,r]=<span class="cstat-no" title="statement not covered" >o.at(-1);<span class="cstat-no" title="statement not covered" ></span>if(n+1===t.children.length){<span class="cstat-no" title="statement not covered" >o.pop();<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst l=<span class="cstat-no" title="statement not covered" >t.children[++o.at(-1)[1]];<span class="cstat-no" title="statement not covered" ></span>if(null===l)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst{name:h}=<span class="cstat-no" title="statement not covered" >l;<span class="cstat-no" title="statement not covered" ></span>if("#text"===h){const t=<span class="cstat-no" title="statement not covered" >document.createTextNode(l.value);<span class="cstat-no" title="statement not covered" ></span>c.push(t);<span class="cstat-no" title="statement not covered" >r</span>.append(t);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst d=<span class="cstat-no" title="statement not covered" >l?.attributes?.xmlns?document.createElementNS(l.attributes.xmlns,h):document.createElement(h);<span class="cstat-no" title="statement not covered" ></span>r.append(d);<span class="cstat-no" title="statement not covered" >l</span>.attributes&amp;&amp;this.setAttributes({html:d,element:l,storage:e,intent:a,linkService:i});<span class="cstat-no" title="statement not covered" >i</span>f(l.children&amp;&amp;l.children.length&gt;0)<span class="cstat-no" title="statement not covered" >o.push([l,-1,d]);e</span>lse <span class="cstat-no" title="statement not covered" >if(l.value){const t=<span class="cstat-no" title="statement not covered" >document.createTextNode(l.value);<span class="cstat-no" title="statement not covered" ></span>s.XfaText.shouldBuildText(h)&amp;&amp;c.push(t);<span class="cstat-no" title="statement not covered" >d</span>.append(t)}</span>}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(const t of l.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))<span class="cstat-no" title="statement not covered" >t.setAttribute("readOnly",!0);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{textDivs:c}}<span class="fstat-no" title="function not covered" ></span>st</span>atic update(t){const e=<span class="cstat-no" title="statement not covered" >`matrix(${t.viewport.transform.join(",")})`;<span class="cstat-no" title="statement not covered" ></span>t.div.style.transform=e;<span class="cstat-no" title="statement not covered" >t</span>.div.hidden=!1}</span>}}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.InkEditor=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(4),</span>a=<span class="cstat-no" title="statement not covered" >i(29),</span>r=<span class="cstat-no" title="statement not covered" >i(5);</span>class InkEditor extends n.AnnotationEditor{#Si=<span class="cstat-no" title="statement not covered" >0;</span>#Ei=<span class="cstat-no" title="statement not covered" >0;</span>#xi=<span class="cstat-no" title="statement not covered" >this.canvasContextMenu.bind(this);</span>#wi=<span class="cstat-no" title="statement not covered" >this.canvasPointermove.bind(this);</span>#Ci=<span class="cstat-no" title="statement not covered" >this.canvasPointerleave.bind(this);</span>#Ti=<span class="cstat-no" title="statement not covered" >this.canvasPointerup.bind(this);</span>#Pi=<span class="cstat-no" title="statement not covered" >this.canvasPointerdown.bind(this);</span>#Mi=<span class="cstat-no" title="statement not covered" >new Path2D;</span>#Fi=<span class="cstat-no" title="statement not covered" >!1;</span>#ki=<span class="cstat-no" title="statement not covered" >!1;</span>#Ri=<span class="cstat-no" title="statement not covered" >!1;</span>#Di=<span class="cstat-no" title="statement not covered" >null;</span>#Ii=<span class="cstat-no" title="statement not covered" >0;</span>#Li=<span class="cstat-no" title="statement not covered" >0;</span>#Oi=<span class="cstat-no" title="statement not covered" >null;</span>static _defaultColor=<span class="cstat-no" title="statement not covered" >null;</span>static _defaultOpacity=<span class="cstat-no" title="statement not covered" >1;</span>static _defaultThickness=<span class="cstat-no" title="statement not covered" >1;</span>static _l10nPromise;static _type=<span class="cstat-no" title="statement not covered" >"ink";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super({...t,name:"inkEditor"});<span class="cstat-no" title="statement not covered" >t</span>his.color=t.color||null;<span class="cstat-no" title="statement not covered" >t</span>his.thickness=t.thickness||null;<span class="cstat-no" title="statement not covered" >t</span>his.opacity=t.opacity||null;<span class="cstat-no" title="statement not covered" >t</span>his.paths=[];<span class="cstat-no" title="statement not covered" >t</span>his.bezierPath2D=[];<span class="cstat-no" title="statement not covered" >t</span>his.allRawPaths=[];<span class="cstat-no" title="statement not covered" >t</span>his.currentPath=[];<span class="cstat-no" title="statement not covered" >t</span>his.scaleFactor=1;<span class="cstat-no" title="statement not covered" >t</span>his.translationX=this.translationY=0;<span class="cstat-no" title="statement not covered" >t</span>his.x=0;<span class="cstat-no" title="statement not covered" >t</span>his.y=0;<span class="cstat-no" title="statement not covered" >t</span>his._willKeepAspectRatio=!0}<span class="fstat-no" title="function not covered" ></span>st</span>atic initialize(t){<span class="cstat-no" title="statement not covered" >this._l10nPromise=new Map(["editor_ink_canvas_aria_label","editor_ink2_aria_label"].map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >[e,t.get(e)])</span>))}<span class="fstat-no" title="function not covered" ></span>st</span>atic updateDefaultParams(t,e){<span class="cstat-no" title="statement not covered" >switch(t){case s.AnnotationEditorParamsType.INK_THICKNESS:<span class="cstat-no" title="statement not covered" >InkEditor._defaultThickness=e;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.AnnotationEditorParamsType.INK_COLOR:<span class="cstat-no" title="statement not covered" >InkEditor._defaultColor=e;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.AnnotationEditorParamsType.INK_OPACITY:<span class="cstat-no" title="statement not covered" >InkEditor._defaultOpacity=e/100}</span>}<span class="fstat-no" title="function not covered" ></span>up</span>dateParams(t,e){<span class="cstat-no" title="statement not covered" >switch(t){case s.AnnotationEditorParamsType.INK_THICKNESS:<span class="cstat-no" title="statement not covered" >this.#Ni(e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.AnnotationEditorParamsType.INK_COLOR:<span class="cstat-no" title="statement not covered" >this.#je(e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase s.AnnotationEditorParamsType.INK_OPACITY:<span class="cstat-no" title="statement not covered" >this.#Bi(e)}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>atic get defaultPropertiesToUpdate(){<span class="cstat-no" title="statement not covered" >return[[s.AnnotationEditorParamsType.INK_THICKNESS,InkEditor._defaultThickness],[s.AnnotationEditorParamsType.INK_COLOR,InkEditor._defaultColor||n.AnnotationEditor._defaultLineColor],[s.AnnotationEditorParamsType.INK_OPACITY,Math.round(100*InkEditor._defaultOpacity)]]}<span class="fstat-no" title="function not covered" ></span>ge</span>t propertiesToUpdate(){<span class="cstat-no" title="statement not covered" >return[[s.AnnotationEditorParamsType.INK_THICKNESS,this.thickness||InkEditor._defaultThickness],[s.AnnotationEditorParamsType.INK_COLOR,this.color||InkEditor._defaultColor||n.AnnotationEditor._defaultLineColor],[s.AnnotationEditorParamsType.INK_OPACITY,Math.round(100*(this.opacity??InkEditor._defaultOpacity))]]}</span>#Ni(t){const e=<span class="cstat-no" title="statement not covered" >this.thickness;<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.thickness=t;<span class="cstat-no" title="statement not covered" >t</span>his.#Ui()}</span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.thickness=e;<span class="cstat-no" title="statement not covered" >t</span>his.#Ui()}</span>,mustExec:!0,type:s.AnnotationEditorParamsType.INK_THICKNESS,overwriteIfSameType:!0,keepUndo:!0})}</span>#je(t){const e=<span class="cstat-no" title="statement not covered" >this.color;<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.color=t;<span class="cstat-no" title="statement not covered" >t</span>his.#ji()}</span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.color=e;<span class="cstat-no" title="statement not covered" >t</span>his.#ji()}</span>,mustExec:!0,type:s.AnnotationEditorParamsType.INK_COLOR,overwriteIfSameType:!0,keepUndo:!0})}</span>#Bi(t){<span class="cstat-no" title="statement not covered" >t/=100;c</span>onst e=<span class="cstat-no" title="statement not covered" >this.opacity;<span class="cstat-no" title="statement not covered" ></span>this.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.opacity=t;<span class="cstat-no" title="statement not covered" >t</span>his.#ji()}</span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.opacity=e;<span class="cstat-no" title="statement not covered" >t</span>his.#ji()}</span>,mustExec:!0,type:s.AnnotationEditorParamsType.INK_OPACITY,overwriteIfSameType:!0,keepUndo:!0})}<span class="fstat-no" title="function not covered" ></span>re</span>build(){<span class="cstat-no" title="statement not covered" >if(this.parent){<span class="cstat-no" title="statement not covered" >super.rebuild();<span class="cstat-no" title="statement not covered" >i</span>f(null!==this.div){<span class="cstat-no" title="statement not covered" >if(!this.canvas){<span class="cstat-no" title="statement not covered" >this.#zi();<span class="cstat-no" title="statement not covered" >t</span>his.#Hi()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this.isAttachedToDOM){<span class="cstat-no" title="statement not covered" >this.parent.add(this);<span class="cstat-no" title="statement not covered" >t</span>his.#Wi()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#Ui()}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>re</span>move(){<span class="cstat-no" title="statement not covered" >if(null!==this.canvas){<span class="cstat-no" title="statement not covered" >this.isEmpty()||this.commit();<span class="cstat-no" title="statement not covered" >t</span>his.canvas.width=this.canvas.height=0;<span class="cstat-no" title="statement not covered" >t</span>his.canvas.remove();<span class="cstat-no" title="statement not covered" >t</span>his.canvas=null;<span class="cstat-no" title="statement not covered" >t</span>his.#Di.disconnect();<span class="cstat-no" title="statement not covered" >t</span>his.#Di=null;<span class="cstat-no" title="statement not covered" >s</span>uper.remove()}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>tParent(t){<span class="cstat-no" title="statement not covered" >!this.parent&amp;&amp;t?this._uiManager.removeShouldRescale(this):this.parent&amp;&amp;null===t&amp;&amp;this._uiManager.addShouldRescale(this);<span class="cstat-no" title="statement not covered" >s</span>uper.setParent(t)}<span class="fstat-no" title="function not covered" ></span>on</span>ScaleChanging(){const[t,e]=<span class="cstat-no" title="statement not covered" >this.parentDimensions,</span>i=<span class="cstat-no" title="statement not covered" >this.width*t,</span>s=<span class="cstat-no" title="statement not covered" >this.height*e;<span class="cstat-no" title="statement not covered" ></span>this.setDimensions(i,s)}<span class="fstat-no" title="function not covered" ></span>en</span>ableEditMode(){<span class="cstat-no" title="statement not covered" >if(!this.#Fi&amp;&amp;null!==this.canvas){<span class="cstat-no" title="statement not covered" >super.enableEditMode();<span class="cstat-no" title="statement not covered" >t</span>his._isDraggable=!1;<span class="cstat-no" title="statement not covered" >t</span>his.canvas.addEventListener("pointerdown",this.#Pi)}</span>}<span class="fstat-no" title="function not covered" ></span>di</span>sableEditMode(){<span class="cstat-no" title="statement not covered" >if(this.isInEditMode()&amp;&amp;null!==this.canvas){<span class="cstat-no" title="statement not covered" >super.disableEditMode();<span class="cstat-no" title="statement not covered" >t</span>his._isDraggable=!this.isEmpty();<span class="cstat-no" title="statement not covered" >t</span>his.div.classList.remove("editing");<span class="cstat-no" title="statement not covered" >t</span>his.canvas.removeEventListener("pointerdown",this.#Pi)}</span>}<span class="fstat-no" title="function not covered" ></span>on</span>ceAdded(){<span class="cstat-no" title="statement not covered" >this._isDraggable=!this.isEmpty()}<span class="fstat-no" title="function not covered" ></span>is</span>Empty(){<span class="cstat-no" title="statement not covered" >return 0===this.paths.length||1===this.paths.length&amp;&amp;0===this.paths[0].length}</span>#Gi(){const{parentRotation:t,parentDimensions:[e,i]}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>switch(t){case 90:<span class="cstat-no" title="statement not covered" >return[0,i,i,e];c</span>ase 180:<span class="cstat-no" title="statement not covered" >return[e,i,e,i];c</span>ase 270:<span class="cstat-no" title="statement not covered" >return[e,0,i,e];d</span>efault:<span class="cstat-no" title="statement not covered" >return[0,0,e,i]}</span>}</span>#qi(){const{ctx:t,color:e,opacity:i,thickness:s,parentScale:n,scaleFactor:a}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t.lineWidth=s*n/a;<span class="cstat-no" title="statement not covered" >t</span>.lineCap="round";<span class="cstat-no" title="statement not covered" >t</span>.lineJoin="round";<span class="cstat-no" title="statement not covered" >t</span>.miterLimit=10;<span class="cstat-no" title="statement not covered" >t</span>.strokeStyle=`${e}${(0,r.opacityToHex)(i)}`}</span>#Vi(t,e){<span class="cstat-no" title="statement not covered" >this.canvas.addEventListener("contextmenu",this.#xi);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.addEventListener("pointerleave",this.#Ci);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.addEventListener("pointermove",this.#wi);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.addEventListener("pointerup",this.#Ti);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.removeEventListener("pointerdown",this.#Pi);<span class="cstat-no" title="statement not covered" >t</span>his.isEditing=!0;<span class="cstat-no" title="statement not covered" >i</span>f(!this.#Ri){<span class="cstat-no" title="statement not covered" >this.#Ri=!0;<span class="cstat-no" title="statement not covered" >t</span>his.#Wi();<span class="cstat-no" title="statement not covered" >t</span>his.thickness||=InkEditor._defaultThickness;<span class="cstat-no" title="statement not covered" >t</span>his.color||=InkEditor._defaultColor||n.AnnotationEditor._defaultLineColor;<span class="cstat-no" title="statement not covered" >t</span>his.opacity??=InkEditor._defaultOpacity}<span class="cstat-no" title="statement not covered" ></span>t</span>his.currentPath.push([t,e]);<span class="cstat-no" title="statement not covered" >t</span>his.#ki=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#qi();<span class="cstat-no" title="statement not covered" >t</span>his.#Oi=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.#$i();<span class="cstat-no" title="statement not covered" >t</span>his.#Oi&amp;&amp;window.requestAnimationFrame(this.#Oi)}</span>;<span class="cstat-no" title="statement not covered" >w</span>indow.requestAnimationFrame(this.#Oi)}</span>#Xi(t,e){const[i,s]=<span class="cstat-no" title="statement not covered" >this.currentPath.at(-1);<span class="cstat-no" title="statement not covered" ></span>if(this.currentPath.length&gt;1&amp;&amp;t===i&amp;&amp;e===s)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this.currentPath;</span>let a=<span class="cstat-no" title="statement not covered" >this.#Mi;<span class="cstat-no" title="statement not covered" ></span>n.push([t,e]);<span class="cstat-no" title="statement not covered" >t</span>his.#ki=!0;<span class="cstat-no" title="statement not covered" >i</span>f(n.length&lt;=2){<span class="cstat-no" title="statement not covered" >a.moveTo(...n[0]);<span class="cstat-no" title="statement not covered" >a</span>.lineTo(t,e)}</span>else{<span class="cstat-no" title="statement not covered" >if(3===n.length){<span class="cstat-no" title="statement not covered" >this.#Mi=a=new Path2D;<span class="cstat-no" title="statement not covered" >a</span>.moveTo(...n[0])}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#Ki(a,...n.at(-3),...n.at(-2),t,e)}</span>}</span>#Yi(){<span class="cstat-no" title="statement not covered" >if(0===this.currentPath.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.currentPath.at(-1);<span class="cstat-no" title="statement not covered" ></span>this.#Mi.lineTo(...t)}</span>#Ji(t,e){<span class="cstat-no" title="statement not covered" >this.#Oi=null;<span class="cstat-no" title="statement not covered" >t</span>=Math.min(Math.max(t,0),this.canvas.width);<span class="cstat-no" title="statement not covered" >e</span>=Math.min(Math.max(e,0),this.canvas.height);<span class="cstat-no" title="statement not covered" >t</span>his.#Xi(t,e);<span class="cstat-no" title="statement not covered" >t</span>his.#Yi();l</span>et i;<span class="cstat-no" title="statement not covered" >if(1!==this.currentPath.length)<span class="cstat-no" title="statement not covered" >i=this.#Qi();e</span>lse{const s=<span class="cstat-no" title="statement not covered" >[t,e];<span class="cstat-no" title="statement not covered" ></span>i=[[s,s.slice(),s.slice(),s]]}</span>c</span>onst s=<span class="cstat-no" title="statement not covered" >this.#Mi,</span>n=<span class="cstat-no" title="statement not covered" >this.currentPath;<span class="cstat-no" title="statement not covered" ></span>this.currentPath=[];<span class="cstat-no" title="statement not covered" >t</span>his.#Mi=new Path2D;<span class="cstat-no" title="statement not covered" >t</span>his.addCommands({cmd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.allRawPaths.push(n);<span class="cstat-no" title="statement not covered" >t</span>his.paths.push(i);<span class="cstat-no" title="statement not covered" >t</span>his.bezierPath2D.push(s);<span class="cstat-no" title="statement not covered" >t</span>his.rebuild()}</span>,undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.allRawPaths.pop();<span class="cstat-no" title="statement not covered" >t</span>his.paths.pop();<span class="cstat-no" title="statement not covered" >t</span>his.bezierPath2D.pop();<span class="cstat-no" title="statement not covered" >i</span>f(0===this.paths.length)<span class="cstat-no" title="statement not covered" >this.remove();e</span>lse{<span class="cstat-no" title="statement not covered" >if(!this.canvas){<span class="cstat-no" title="statement not covered" >this.#zi();<span class="cstat-no" title="statement not covered" >t</span>his.#Hi()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#Ui()}</span>}</span>,mustExec:!0})}</span>#$i(){<span class="cstat-no" title="statement not covered" >if(!this.#ki)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.#ki=!1;c</span>onst t=<span class="cstat-no" title="statement not covered" >Math.ceil(this.thickness*this.parentScale),</span>e=<span class="cstat-no" title="statement not covered" >this.currentPath.slice(-3),</span>i=<span class="cstat-no" title="statement not covered" >e.map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t[0])</span>),</span>s=<span class="cstat-no" title="statement not covered" >e.map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t[1])</span>),</span>{ctx:n}=(<span class="cstat-no" title="statement not covered" >Math.min(...i),Math.max(...i),Math.min(...s),Math.max(...s),this)</span>;<span class="cstat-no" title="statement not covered" >n.save();<span class="cstat-no" title="statement not covered" >n</span>.clearRect(0,0,this.canvas.width,this.canvas.height);<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.bezierPath2D)<span class="cstat-no" title="statement not covered" >n.stroke(t);<span class="cstat-no" title="statement not covered" >n</span></span>.stroke(this.#Mi);<span class="cstat-no" title="statement not covered" >n</span>.restore()}</span>#Ki(t,e,i,s,n,a,r){const o=<span class="cstat-no" title="statement not covered" >(e+s)/2,</span>l=<span class="cstat-no" title="statement not covered" >(i+n)/2,</span>c=<span class="cstat-no" title="statement not covered" >(s+a)/2,</span>h=<span class="cstat-no" title="statement not covered" >(n+r)/2;<span class="cstat-no" title="statement not covered" ></span>t.bezierCurveTo(o+2*(s-o)/3,l+2*(n-l)/3,c+2*(s-c)/3,h+2*(n-h)/3,c,h)}</span>#Qi(){const t=<span class="cstat-no" title="statement not covered" >this.currentPath;<span class="cstat-no" title="statement not covered" ></span>if(t.length&lt;=2)<span class="cstat-no" title="statement not covered" >return[[t[0],t[0],t.at(-1),t.at(-1)]];c</span></span>onst e=<span class="cstat-no" title="statement not covered" >[];</span>let i,[s,n]=<span class="cstat-no" title="statement not covered" >t[0];<span class="cstat-no" title="statement not covered" ></span>for(i=1;i&lt;t.length-2;i++){const[a,r]=<span class="cstat-no" title="statement not covered" >t[i],</span>[o,l]=<span class="cstat-no" title="statement not covered" >t[i+1],</span>c=<span class="cstat-no" title="statement not covered" >(a+o)/2,</span>h=<span class="cstat-no" title="statement not covered" >(r+l)/2,</span>d=<span class="cstat-no" title="statement not covered" >[s+2*(a-s)/3,n+2*(r-n)/3],</span>u=<span class="cstat-no" title="statement not covered" >[c+2*(a-c)/3,h+2*(r-h)/3];<span class="cstat-no" title="statement not covered" ></span>e.push([[s,n],d,u,[c,h]]);<span class="cstat-no" title="statement not covered" >[</span>s,n]=[c,h]}</span>c</span>onst[a,r]=<span class="cstat-no" title="statement not covered" >t[i],</span>[o,l]=<span class="cstat-no" title="statement not covered" >t[i+1],</span>c=<span class="cstat-no" title="statement not covered" >[s+2*(a-s)/3,n+2*(r-n)/3],</span>h=<span class="cstat-no" title="statement not covered" >[o+2*(a-o)/3,l+2*(r-l)/3];<span class="cstat-no" title="statement not covered" ></span>e.push([[s,n],c,h,[o,l]]);<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>#ji(){<span class="cstat-no" title="statement not covered" >if(this.isEmpty()){<span class="cstat-no" title="statement not covered" >this.#Zi();<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#qi();c</span>onst{canvas:t,ctx:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>e.setTransform(1,0,0,1,0,0);<span class="cstat-no" title="statement not covered" >e</span>.clearRect(0,0,t.width,t.height);<span class="cstat-no" title="statement not covered" >t</span>his.#Zi();<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.bezierPath2D)<span class="cstat-no" title="statement not covered" >e.stroke(t)}<span class="fstat-no" title="function not covered" ></span></span>co</span>mmit(){<span class="cstat-no" title="statement not covered" >if(!this.#Fi){<span class="cstat-no" title="statement not covered" >super.commit();<span class="cstat-no" title="statement not covered" >t</span>his.isEditing=!1;<span class="cstat-no" title="statement not covered" >t</span>his.disableEditMode();<span class="cstat-no" title="statement not covered" >t</span>his.setInForeground();<span class="cstat-no" title="statement not covered" >t</span>his.#Fi=!0;<span class="cstat-no" title="statement not covered" >t</span>his.div.classList.add("disabled");<span class="cstat-no" title="statement not covered" >t</span>his.#Ui(!0);<span class="cstat-no" title="statement not covered" >t</span>his.makeResizable();<span class="cstat-no" title="statement not covered" >t</span>his.parent.addInkEditorIfNeeded(!0);<span class="cstat-no" title="statement not covered" >t</span>his.moveInDOM();<span class="cstat-no" title="statement not covered" >t</span>his.div.focus({preventScroll:!0})}</span>}<span class="fstat-no" title="function not covered" ></span>fo</span>cusin(t){<span class="cstat-no" title="statement not covered" >if(this._focusEventsAllowed){<span class="cstat-no" title="statement not covered" >super.focusin(t);<span class="cstat-no" title="statement not covered" >t</span>his.enableEditMode()}</span>}<span class="fstat-no" title="function not covered" ></span>ca</span>nvasPointerdown(t){<span class="cstat-no" title="statement not covered" >if(0===t.button&amp;&amp;this.isInEditMode()&amp;&amp;!this.#Fi){<span class="cstat-no" title="statement not covered" >this.setInForeground();<span class="cstat-no" title="statement not covered" >t</span>.preventDefault();<span class="cstat-no" title="statement not covered" >"</span>mouse"!==t.type&amp;&amp;this.div.focus();<span class="cstat-no" title="statement not covered" >t</span>his.#Vi(t.offsetX,t.offsetY)}</span>}<span class="fstat-no" title="function not covered" ></span>ca</span>nvasContextMenu(t){<span class="cstat-no" title="statement not covered" >t.preventDefault()}<span class="fstat-no" title="function not covered" ></span>ca</span>nvasPointermove(t){<span class="cstat-no" title="statement not covered" >t.preventDefault();<span class="cstat-no" title="statement not covered" >t</span>his.#Xi(t.offsetX,t.offsetY)}<span class="fstat-no" title="function not covered" ></span>ca</span>nvasPointerup(t){<span class="cstat-no" title="statement not covered" >t.preventDefault();<span class="cstat-no" title="statement not covered" >t</span>his.#ts(t)}<span class="fstat-no" title="function not covered" ></span>ca</span>nvasPointerleave(t){<span class="cstat-no" title="statement not covered" >this.#ts(t)}</span>#ts(t){<span class="cstat-no" title="statement not covered" >this.canvas.removeEventListener("pointerleave",this.#Ci);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.removeEventListener("pointermove",this.#wi);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.removeEventListener("pointerup",this.#Ti);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.addEventListener("pointerdown",this.#Pi);<span class="cstat-no" title="statement not covered" >s</span>etTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.canvas.removeEventListener("contextmenu",this.#xi)}</span>),10);<span class="cstat-no" title="statement not covered" >t</span>his.#Ji(t.offsetX,t.offsetY);<span class="cstat-no" title="statement not covered" >t</span>his.addToAnnotationStorage();<span class="cstat-no" title="statement not covered" >t</span>his.setInBackground()}</span>#zi(){<span class="cstat-no" title="statement not covered" >this.canvas=document.createElement("canvas");<span class="cstat-no" title="statement not covered" >t</span>his.canvas.width=this.canvas.height=0;<span class="cstat-no" title="statement not covered" >t</span>his.canvas.className="inkEditorCanvas";<span class="cstat-no" title="statement not covered" >I</span>nkEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.canvas?.setAttribute("aria-label",t))</span>);<span class="cstat-no" title="statement not covered" >t</span>his.div.append(this.canvas);<span class="cstat-no" title="statement not covered" >t</span>his.ctx=this.canvas.getContext("2d")}</span>#Hi(){<span class="cstat-no" title="statement not covered" >this.#Di=new ResizeObserver((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t[0].contentRect;<span class="cstat-no" title="statement not covered" ></span>e.width&amp;&amp;e.height&amp;&amp;this.setDimensions(e.width,e.height)}</span>));<span class="cstat-no" title="statement not covered" >t</span>his.#Di.observe(this.div)}<span class="fstat-no" title="function not covered" ></span>ge</span>t isResizable(){<span class="cstat-no" title="statement not covered" >return!this.isEmpty()&amp;&amp;this.#Fi}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >if(this.div)<span class="cstat-no" title="statement not covered" >return this.div;l</span></span>et t,e;<span class="cstat-no" title="statement not covered" >if(this.width){<span class="cstat-no" title="statement not covered" >t=this.x;<span class="cstat-no" title="statement not covered" >e</span>=this.y}<span class="cstat-no" title="statement not covered" ></span>s</span>uper.render();<span class="cstat-no" title="statement not covered" >I</span>nkEditor._l10nPromise.get("editor_ink2_aria_label").then((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.div?.setAttribute("aria-label",t))</span>);c</span>onst[i,s,n,a]=<span class="cstat-no" title="statement not covered" >this.#Gi();<span class="cstat-no" title="statement not covered" ></span>this.setAt(i,s,0,0);<span class="cstat-no" title="statement not covered" >t</span>his.setDims(n,a);<span class="cstat-no" title="statement not covered" >t</span>his.#zi();<span class="cstat-no" title="statement not covered" >i</span>f(this.width){const[i,s]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.setAspectRatio(this.width*i,this.height*s);<span class="cstat-no" title="statement not covered" >t</span>his.setAt(t*i,e*s,this.width*i,this.height*s);<span class="cstat-no" title="statement not covered" >t</span>his.#Ri=!0;<span class="cstat-no" title="statement not covered" >t</span>his.#Wi();<span class="cstat-no" title="statement not covered" >t</span>his.setDims(this.width*i,this.height*s);<span class="cstat-no" title="statement not covered" >t</span>his.#ji();<span class="cstat-no" title="statement not covered" >t</span>his.div.classList.add("disabled")}</span>else{<span class="cstat-no" title="statement not covered" >this.div.classList.add("editing");<span class="cstat-no" title="statement not covered" >t</span>his.enableEditMode()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#Hi();<span class="cstat-no" title="statement not covered" >r</span>eturn this.div}</span>#Wi(){<span class="cstat-no" title="statement not covered" >if(!this.#Ri)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst[t,e]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.canvas.width=Math.ceil(this.width*t);<span class="cstat-no" title="statement not covered" >t</span>his.canvas.height=Math.ceil(this.height*e);<span class="cstat-no" title="statement not covered" >t</span>his.#Zi()}<span class="fstat-no" title="function not covered" ></span>se</span>tDimensions(t,e){const i=<span class="cstat-no" title="statement not covered" >Math.round(t),</span>s=<span class="cstat-no" title="statement not covered" >Math.round(e);<span class="cstat-no" title="statement not covered" ></span>if(this.#Ii===i&amp;&amp;this.#Li===s)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.#Ii=i;<span class="cstat-no" title="statement not covered" >t</span>his.#Li=s;<span class="cstat-no" title="statement not covered" >t</span>his.canvas.style.visibility="hidden";c</span>onst[n,a]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.width=t/n;<span class="cstat-no" title="statement not covered" >t</span>his.height=e/a;<span class="cstat-no" title="statement not covered" >t</span>his.fixAndSetPosition();<span class="cstat-no" title="statement not covered" >t</span>his.#Fi&amp;&amp;this.#es(t,e);<span class="cstat-no" title="statement not covered" >t</span>his.#Wi();<span class="cstat-no" title="statement not covered" >t</span>his.#ji();<span class="cstat-no" title="statement not covered" >t</span>his.canvas.style.visibility="visible";<span class="cstat-no" title="statement not covered" >t</span>his.fixDims()}</span>#es(t,e){const i=<span class="cstat-no" title="statement not covered" >this.#is(),</span>s=<span class="cstat-no" title="statement not covered" >(t-i)/this.#Ei,</span>n=<span class="cstat-no" title="statement not covered" >(e-i)/this.#Si;<span class="cstat-no" title="statement not covered" ></span>this.scaleFactor=Math.min(s,n)}</span>#Zi(){const t=<span class="cstat-no" title="statement not covered" >this.#is()/2;<span class="cstat-no" title="statement not covered" ></span>this.ctx.setTransform(this.scaleFactor,0,0,this.scaleFactor,this.translationX*this.scaleFactor+t,this.translationY*this.scaleFactor+t)}</span>static#ss(t){const e=<span class="cstat-no" title="statement not covered" >new Path2D;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>i&lt;s;i++){const[s,n,a,r]=<span class="cstat-no" title="statement not covered" >t[i];<span class="cstat-no" title="statement not covered" ></span>0===i&amp;&amp;e.moveTo(...s);<span class="cstat-no" title="statement not covered" >e</span>.bezierCurveTo(n[0],n[1],a[0],a[1],r[0],r[1])}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>static#ns(t,e,i){const[s,n,a,r]=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>switch(i){case 0:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;i;e+=2){<span class="cstat-no" title="statement not covered" >t[e]+=s;<span class="cstat-no" title="statement not covered" >t</span>[e+1]=r-t[e+1]}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 90:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;i;e+=2){const i=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>t[e]=t[e+1]+s;<span class="cstat-no" title="statement not covered" >t</span>[e+1]=i+n}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 180:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;i;e+=2){<span class="cstat-no" title="statement not covered" >t[e]=a-t[e];<span class="cstat-no" title="statement not covered" >t</span>[e+1]+=n}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 270:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;i;e+=2){const i=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>t[e]=a-t[e+1];<span class="cstat-no" title="statement not covered" >t</span>[e+1]=r-i}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("Invalid rotation")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>static#as(t,e,i){const[s,n,a,r]=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>switch(i){case 0:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;i;e+=2){<span class="cstat-no" title="statement not covered" >t[e]-=s;<span class="cstat-no" title="statement not covered" >t</span>[e+1]=r-t[e+1]}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 90:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;i;e+=2){const i=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>t[e]=t[e+1]-n;<span class="cstat-no" title="statement not covered" >t</span>[e+1]=i-s}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 180:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;i;e+=2){<span class="cstat-no" title="statement not covered" >t[e]=a-t[e];<span class="cstat-no" title="statement not covered" >t</span>[e+1]-=n}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 270:<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >t.length;</span>e&lt;i;e+=2){const i=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>t[e]=r-t[e+1];<span class="cstat-no" title="statement not covered" >t</span>[e+1]=a-i}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("Invalid rotation")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>#rs(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >this.thickness/2,</span>r=<span class="cstat-no" title="statement not covered" >t*e+a,</span>o=<span class="cstat-no" title="statement not covered" >t*i+a;<span class="cstat-no" title="statement not covered" ></span>for(const e of this.paths){const i=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >e.length;</span>s&lt;n;s++){const[l,c,h,d]=<span class="cstat-no" title="statement not covered" >e[s],</span>u=<span class="cstat-no" title="statement not covered" >t*l[0]+r,</span>p=<span class="cstat-no" title="statement not covered" >t*l[1]+o,</span>g=<span class="cstat-no" title="statement not covered" >t*c[0]+r,</span>m=<span class="cstat-no" title="statement not covered" >t*c[1]+o,</span>f=<span class="cstat-no" title="statement not covered" >t*h[0]+r,</span>b=<span class="cstat-no" title="statement not covered" >t*h[1]+o,</span>A=<span class="cstat-no" title="statement not covered" >t*d[0]+r,</span>_=<span class="cstat-no" title="statement not covered" >t*d[1]+o;<span class="cstat-no" title="statement not covered" ></span>if(0===s){<span class="cstat-no" title="statement not covered" >i.push(u,p);<span class="cstat-no" title="statement not covered" >a</span>.push(u,p)}<span class="cstat-no" title="statement not covered" ></span>i</span>.push(g,m,f,b,A,_);<span class="cstat-no" title="statement not covered" >a</span>.push(g,m);<span class="cstat-no" title="statement not covered" >s</span>===n-1&amp;&amp;a.push(A,_)}<span class="cstat-no" title="statement not covered" ></span>n</span>.push({bezier:InkEditor.#ns(i,s,this.rotation),points:InkEditor.#ns(a,s,this.rotation)})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>#os(){let t=<span class="cstat-no" title="statement not covered" >1/0,</span>e=<span class="cstat-no" title="statement not covered" >-1/0,</span>i=<span class="cstat-no" title="statement not covered" >1/0,</span>n=<span class="cstat-no" title="statement not covered" >-1/0;<span class="cstat-no" title="statement not covered" ></span>for(const a of this.paths)<span class="cstat-no" title="statement not covered" >for(const[r,o,l,c]of a){const a=<span class="cstat-no" title="statement not covered" >s.Util.bezierBoundingBox(...r,...o,...l,...c);<span class="cstat-no" title="statement not covered" ></span>t=Math.min(t,a[0]);<span class="cstat-no" title="statement not covered" >i</span>=Math.min(i,a[1]);<span class="cstat-no" title="statement not covered" >e</span>=Math.max(e,a[2]);<span class="cstat-no" title="statement not covered" >n</span>=Math.max(n,a[3])}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn[t,i,e,n]}</span>#is(){<span class="cstat-no" title="statement not covered" >return this.#Fi?Math.ceil(this.thickness*this.parentScale):0}</span>#Ui(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(this.isEmpty())<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.#Fi){<span class="cstat-no" title="statement not covered" >this.#ji();<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >this.#os(),</span>i=<span class="cstat-no" title="statement not covered" >this.#is();<span class="cstat-no" title="statement not covered" ></span>this.#Ei=Math.max(n.AnnotationEditor.MIN_SIZE,e[2]-e[0]);<span class="cstat-no" title="statement not covered" >t</span>his.#Si=Math.max(n.AnnotationEditor.MIN_SIZE,e[3]-e[1]);c</span>onst s=<span class="cstat-no" title="statement not covered" >Math.ceil(i+this.#Ei*this.scaleFactor),</span>a=<span class="cstat-no" title="statement not covered" >Math.ceil(i+this.#Si*this.scaleFactor),</span>[r,o]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.width=s/r;<span class="cstat-no" title="statement not covered" >t</span>his.height=a/o;<span class="cstat-no" title="statement not covered" >t</span>his.setAspectRatio(s,a);c</span>onst l=<span class="cstat-no" title="statement not covered" >this.translationX,</span>c=<span class="cstat-no" title="statement not covered" >this.translationY;<span class="cstat-no" title="statement not covered" ></span>this.translationX=-e[0];<span class="cstat-no" title="statement not covered" >t</span>his.translationY=-e[1];<span class="cstat-no" title="statement not covered" >t</span>his.#Wi();<span class="cstat-no" title="statement not covered" >t</span>his.#ji();<span class="cstat-no" title="statement not covered" >t</span>his.#Ii=s;<span class="cstat-no" title="statement not covered" >t</span>his.#Li=a;<span class="cstat-no" title="statement not covered" >t</span>his.setDims(s,a);c</span>onst h=<span class="cstat-no" title="statement not covered" >t?i/this.scaleFactor/2:0;<span class="cstat-no" title="statement not covered" ></span>this.translate(l-this.translationX-h,c-this.translationY-h)}<span class="fstat-no" title="function not covered" ></span>st</span>atic deserialize(t,e,i){<span class="cstat-no" title="statement not covered" >if(t instanceof a.InkAnnotationElement)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >super.deserialize(t,e,i);<span class="cstat-no" title="statement not covered" ></span>r.thickness=t.thickness;<span class="cstat-no" title="statement not covered" >r</span>.color=s.Util.makeHexColor(...t.color);<span class="cstat-no" title="statement not covered" >r</span>.opacity=t.opacity;c</span>onst[o,l]=<span class="cstat-no" title="statement not covered" >r.pageDimensions,</span>c=<span class="cstat-no" title="statement not covered" >r.width*o,</span>h=<span class="cstat-no" title="statement not covered" >r.height*l,</span>d=<span class="cstat-no" title="statement not covered" >r.parentScale,</span>u=<span class="cstat-no" title="statement not covered" >t.thickness/2;<span class="cstat-no" title="statement not covered" ></span>r.#Fi=!0;<span class="cstat-no" title="statement not covered" >r</span>.#Ii=Math.round(c);<span class="cstat-no" title="statement not covered" >r</span>.#Li=Math.round(h);c</span>onst{paths:p,rect:g,rotation:m}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>for(let{bezier:t}of p){<span class="cstat-no" title="statement not covered" >t=InkEditor.#as(t,g,m);c</span>onst e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>r.paths.push(e);l</span>et i=<span class="cstat-no" title="statement not covered" >d*(t[0]-u),</span>s=<span class="cstat-no" title="statement not covered" >d*(t[1]-u);<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >2,</span>a=<span class="cstat-no" title="statement not covered" >t.length;</span>n&lt;a;n+=6){const a=<span class="cstat-no" title="statement not covered" >d*(t[n]-u),</span>r=<span class="cstat-no" title="statement not covered" >d*(t[n+1]-u),</span>o=<span class="cstat-no" title="statement not covered" >d*(t[n+2]-u),</span>l=<span class="cstat-no" title="statement not covered" >d*(t[n+3]-u),</span>c=<span class="cstat-no" title="statement not covered" >d*(t[n+4]-u),</span>h=<span class="cstat-no" title="statement not covered" >d*(t[n+5]-u);<span class="cstat-no" title="statement not covered" ></span>e.push([[i,s],[a,r],[o,l],[c,h]]);<span class="cstat-no" title="statement not covered" >i</span>=c;<span class="cstat-no" title="statement not covered" >s</span>=h}</span>c</span>onst n=<span class="cstat-no" title="statement not covered" >this.#ss(e);<span class="cstat-no" title="statement not covered" ></span>r.bezierPath2D.push(n)}</span>c</span>onst f=<span class="cstat-no" title="statement not covered" >r.#os();<span class="cstat-no" title="statement not covered" ></span>r.#Ei=Math.max(n.AnnotationEditor.MIN_SIZE,f[2]-f[0]);<span class="cstat-no" title="statement not covered" >r</span>.#Si=Math.max(n.AnnotationEditor.MIN_SIZE,f[3]-f[1]);<span class="cstat-no" title="statement not covered" >r</span>.#es(c,h);<span class="cstat-no" title="statement not covered" >r</span>eturn r}<span class="fstat-no" title="function not covered" ></span>se</span>rialize(){<span class="cstat-no" title="statement not covered" >if(this.isEmpty())<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.getRect(0,0),</span>e=<span class="cstat-no" title="statement not covered" >n.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);<span class="cstat-no" title="statement not covered" ></span>return{annotationType:s.AnnotationEditorType.INK,color:e,thickness:this.thickness,opacity:this.opacity,paths:this.#rs(this.scaleFactor/this.parentScale,this.translationX,this.translationY,t),pageIndex:this.pageIndex,rect:t,rotation:this.rotation}}</span>}<span class="cstat-no" title="statement not covered" >e.InkEditor=InkEditor}</span>,<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >e</span>.StampEditor=void 0;v</span>ar s=<span class="cstat-no" title="statement not covered" >i(1),</span>n=<span class="cstat-no" title="statement not covered" >i(4),</span>a=<span class="cstat-no" title="statement not covered" >i(6),</span>r=<span class="cstat-no" title="statement not covered" >i(29);</span>class StampEditor extends n.AnnotationEditor{#ls=<span class="cstat-no" title="statement not covered" >null;</span>#cs=<span class="cstat-no" title="statement not covered" >null;</span>#hs=<span class="cstat-no" title="statement not covered" >null;</span>#ds=<span class="cstat-no" title="statement not covered" >null;</span>#us=<span class="cstat-no" title="statement not covered" >null;</span>#ps=<span class="cstat-no" title="statement not covered" >null;</span>#Di=<span class="cstat-no" title="statement not covered" >null;</span>#gs=<span class="cstat-no" title="statement not covered" >null;</span>#ms=<span class="cstat-no" title="statement not covered" >!1;</span>#fs=<span class="cstat-no" title="statement not covered" >!1;</span>static _type=<span class="cstat-no" title="statement not covered" >"stamp";<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super({...t,name:"stampEditor"});<span class="cstat-no" title="statement not covered" >t</span>his.#ds=t.bitmapUrl;<span class="cstat-no" title="statement not covered" >t</span>his.#us=t.bitmapFile}<span class="fstat-no" title="function not covered" ></span>st</span>atic get supportedTypes(){<span class="cstat-no" title="statement not covered" >return(0,s.shadow)(this,"supportedTypes",["apng","avif","bmp","gif","jpeg","png","svg+xml","webp","x-icon"].map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >`image/${t}`)</span>))}<span class="fstat-no" title="function not covered" ></span>st</span>atic get supportedTypesStr(){<span class="cstat-no" title="statement not covered" >return(0,s.shadow)(this,"supportedTypesStr",this.supportedTypes.join(","))}<span class="fstat-no" title="function not covered" ></span>st</span>atic isHandlingMimeForPasting(t){<span class="cstat-no" title="statement not covered" >return this.supportedTypes.includes(t)}<span class="fstat-no" title="function not covered" ></span>st</span>atic paste(t,e){<span class="cstat-no" title="statement not covered" >e.pasteEditor(s.AnnotationEditorType.STAMP,{bitmapFile:t.getAsFile()})}</span>#bs(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(t){<span class="cstat-no" title="statement not covered" >this.#ls=t.bitmap;<span class="cstat-no" title="statement not covered" >i</span>f(!e){<span class="cstat-no" title="statement not covered" >this.#cs=t.id;<span class="cstat-no" title="statement not covered" >t</span>his.#ms=t.isSvg}<span class="cstat-no" title="statement not covered" ></span>t</span>his.#zi()}</span>else <span class="cstat-no" title="statement not covered" >this.remove()}</span></span>#As(){<span class="cstat-no" title="statement not covered" >this.#hs=null;<span class="cstat-no" title="statement not covered" >t</span>his._uiManager.enableWaiting(!1);<span class="cstat-no" title="statement not covered" >t</span>his.#ps&amp;&amp;this.div.focus()}</span>#_s(){<span class="cstat-no" title="statement not covered" >if(this.#cs){<span class="cstat-no" title="statement not covered" >this._uiManager.enableWaiting(!0);<span class="cstat-no" title="statement not covered" >t</span>his._uiManager.imageManager.getFromId(this.#cs).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.#bs(t,!0))</span>).finally((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.#As())</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.#ds){const t=<span class="cstat-no" title="statement not covered" >this.#ds;<span class="cstat-no" title="statement not covered" ></span>this.#ds=null;<span class="cstat-no" title="statement not covered" >t</span>his._uiManager.enableWaiting(!0);<span class="cstat-no" title="statement not covered" >t</span>his.#hs=this._uiManager.imageManager.getFromUrl(t).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.#bs(t))</span>).finally((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.#As())</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.#us){const t=<span class="cstat-no" title="statement not covered" >this.#us;<span class="cstat-no" title="statement not covered" ></span>this.#us=null;<span class="cstat-no" title="statement not covered" >t</span>his._uiManager.enableWaiting(!0);<span class="cstat-no" title="statement not covered" >t</span>his.#hs=this._uiManager.imageManager.getFromFile(t).then((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.#bs(t))</span>).finally((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.#As())</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst t=<span class="cstat-no" title="statement not covered" >document.createElement("input");<span class="cstat-no" title="statement not covered" ></span>t.type="file";<span class="cstat-no" title="statement not covered" >t</span>.accept=StampEditor.supportedTypesStr;<span class="cstat-no" title="statement not covered" >t</span>his.#hs=new Promise((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.addEventListener("change",(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >if(t.files&amp;&amp;0!==t.files.length){<span class="cstat-no" title="statement not covered" >this._uiManager.enableWaiting(!0);c</span>onst e=<span class="cstat-no" title="statement not covered" >await this._uiManager.imageManager.getFromFile(t.files[0]);<span class="cstat-no" title="statement not covered" ></span>this.#bs(e)}</span>else <span class="cstat-no" title="statement not covered" >this.remove();<span class="cstat-no" title="statement not covered" >e</span></span>()}</span>));<span class="cstat-no" title="statement not covered" >t</span>.addEventListener("cancel",(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.remove();<span class="cstat-no" title="statement not covered" >e</span>()}</span>))}</span>)).finally((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.#As())</span>);<span class="cstat-no" title="statement not covered" >t</span>.click()}<span class="fstat-no" title="function not covered" ></span>re</span>move(){<span class="cstat-no" title="statement not covered" >if(this.#cs){<span class="cstat-no" title="statement not covered" >this.#ls=null;<span class="cstat-no" title="statement not covered" >t</span>his._uiManager.imageManager.deleteId(this.#cs);<span class="cstat-no" title="statement not covered" >t</span>his.#ps?.remove();<span class="cstat-no" title="statement not covered" >t</span>his.#ps=null;<span class="cstat-no" title="statement not covered" >t</span>his.#Di?.disconnect();<span class="cstat-no" title="statement not covered" >t</span>his.#Di=null}<span class="cstat-no" title="statement not covered" ></span>s</span>uper.remove()}<span class="fstat-no" title="function not covered" ></span>re</span>build(){<span class="cstat-no" title="statement not covered" >if(this.parent){<span class="cstat-no" title="statement not covered" >super.rebuild();<span class="cstat-no" title="statement not covered" >i</span>f(null!==this.div){<span class="cstat-no" title="statement not covered" >this.#cs&amp;&amp;this.#_s();<span class="cstat-no" title="statement not covered" >t</span>his.isAttachedToDOM||this.parent.add(this)}</span>}</span>else <span class="cstat-no" title="statement not covered" >this.#cs&amp;&amp;this.#_s()}<span class="fstat-no" title="function not covered" ></span></span>on</span>ceAdded(){<span class="cstat-no" title="statement not covered" >this._isDraggable=!0;<span class="cstat-no" title="statement not covered" >t</span>his.div.focus()}<span class="fstat-no" title="function not covered" ></span>is</span>Empty(){<span class="cstat-no" title="statement not covered" >return!(this.#hs||this.#ls||this.#ds||this.#us)}<span class="fstat-no" title="function not covered" ></span>ge</span>t isResizable(){<span class="cstat-no" title="statement not covered" >return!0}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >if(this.div)<span class="cstat-no" title="statement not covered" >return this.div;l</span></span>et t,e;<span class="cstat-no" title="statement not covered" >if(this.width){<span class="cstat-no" title="statement not covered" >t=this.x;<span class="cstat-no" title="statement not covered" >e</span>=this.y}<span class="cstat-no" title="statement not covered" ></span>s</span>uper.render();<span class="cstat-no" title="statement not covered" >t</span>his.div.hidden=!0;<span class="cstat-no" title="statement not covered" >t</span>his.#ls?this.#zi():this.#_s();<span class="cstat-no" title="statement not covered" >i</span>f(this.width){const[i,s]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.setAt(t*i,e*s,this.width*i,this.height*s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.div}</span>#zi(){const{div:t}=<span class="cstat-no" title="statement not covered" >this;</span>let{width:e,height:i}=<span class="cstat-no" title="statement not covered" >this.#ls;</span>const[s,n]=<span class="cstat-no" title="statement not covered" >this.pageDimensions,</span>a=<span class="cstat-no" title="statement not covered" >.75;<span class="cstat-no" title="statement not covered" ></span>if(this.width){<span class="cstat-no" title="statement not covered" >e=this.width*s;<span class="cstat-no" title="statement not covered" >i</span>=this.height*n}</span>else <span class="cstat-no" title="statement not covered" >if(e&gt;a*s||i&gt;a*n){const t=<span class="cstat-no" title="statement not covered" >Math.min(a*s/e,a*n/i);<span class="cstat-no" title="statement not covered" ></span>e*=t;<span class="cstat-no" title="statement not covered" >i</span>*=t}</span>c</span></span>onst[r,o]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.setDims(e*r/s,i*o/n);<span class="cstat-no" title="statement not covered" >t</span>his._uiManager.enableWaiting(!1);c</span>onst l=<span class="cstat-no" title="statement not covered" >this.#ps=document.createElement("canvas");<span class="cstat-no" title="statement not covered" ></span>t.append(l);<span class="cstat-no" title="statement not covered" >t</span>.hidden=!1;<span class="cstat-no" title="statement not covered" >t</span>his.#vs(e,i);<span class="cstat-no" title="statement not covered" >t</span>his.#Hi();<span class="cstat-no" title="statement not covered" >i</span>f(!this.#fs){<span class="cstat-no" title="statement not covered" >this.parent.addUndoableEditor(this);<span class="cstat-no" title="statement not covered" >t</span>his.#fs=!0}</span>}</span>#ys(t,e){const[i,s]=<span class="cstat-no" title="statement not covered" >this.parentDimensions;<span class="cstat-no" title="statement not covered" ></span>this.width=t/i;<span class="cstat-no" title="statement not covered" >t</span>his.height=e/s;<span class="cstat-no" title="statement not covered" >t</span>his.setDims(t,e);<span class="cstat-no" title="statement not covered" >t</span>his._initialOptions?.isCentered?this.center():this.fixAndSetPosition();<span class="cstat-no" title="statement not covered" >t</span>his._initialOptions=null;<span class="cstat-no" title="statement not covered" >n</span>ull!==this.#gs&amp;&amp;clearTimeout(this.#gs);<span class="cstat-no" title="statement not covered" >t</span>his.#gs=setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.#gs=null;<span class="cstat-no" title="statement not covered" >t</span>his.#vs(t,e)}</span>),200)}</span>#Ss(t,e){const{width:i,height:s}=<span class="cstat-no" title="statement not covered" >this.#ls;</span>let n=<span class="cstat-no" title="statement not covered" >i,</span>a=<span class="cstat-no" title="statement not covered" >s,</span>r=<span class="cstat-no" title="statement not covered" >this.#ls;<span class="cstat-no" title="statement not covered" ></span>for(;n&gt;2*t||a&gt;2*e;){const i=<span class="cstat-no" title="statement not covered" >n,</span>s=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>n&gt;2*t&amp;&amp;(n=n&gt;=16384?Math.floor(n/2)-1:Math.ceil(n/2));<span class="cstat-no" title="statement not covered" >a</span>&gt;2*e&amp;&amp;(a=a&gt;=16384?Math.floor(a/2)-1:Math.ceil(a/2));c</span>onst o=<span class="cstat-no" title="statement not covered" >new OffscreenCanvas(n,a);<span class="cstat-no" title="statement not covered" ></span>o.getContext("2d").drawImage(r,0,0,i,s,0,0,n,a);<span class="cstat-no" title="statement not covered" >r</span>=o.transferToImageBitmap()}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>#vs(t,e){<span class="cstat-no" title="statement not covered" >t=Math.ceil(t);<span class="cstat-no" title="statement not covered" >e</span>=Math.ceil(e);c</span>onst i=<span class="cstat-no" title="statement not covered" >this.#ps;<span class="cstat-no" title="statement not covered" ></span>if(!i||i.width===t&amp;&amp;i.height===e)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>.width=t;<span class="cstat-no" title="statement not covered" >i</span>.height=e;c</span>onst s=<span class="cstat-no" title="statement not covered" >this.#ms?this.#ls:this.#Ss(t,e),</span>n=<span class="cstat-no" title="statement not covered" >i.getContext("2d");<span class="cstat-no" title="statement not covered" ></span>n.filter=this._uiManager.hcmFilter;<span class="cstat-no" title="statement not covered" >n</span>.drawImage(s,0,0,s.width,s.height,0,0,t,e)}</span>#Es(t){<span class="cstat-no" title="statement not covered" >if(t){<span class="cstat-no" title="statement not covered" >if(this.#ms){const t=<span class="cstat-no" title="statement not covered" >this._uiManager.imageManager.getSvgUrl(this.#cs);<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >return t}</span></span>c</span>onst t=<span class="cstat-no" title="statement not covered" >document.createElement("canvas");<span class="cstat-no" title="statement not covered" ></span>({width:t.width,height:t.height}=this.#ls);<span class="cstat-no" title="statement not covered" >t</span>.getContext("2d").drawImage(this.#ls,0,0);<span class="cstat-no" title="statement not covered" >r</span>eturn t.toDataURL()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.#ms){const[t,e]=<span class="cstat-no" title="statement not covered" >this.pageDimensions,</span>i=<span class="cstat-no" title="statement not covered" >Math.round(this.width*t*a.PixelsPerInch.PDF_TO_CSS_UNITS),</span>s=<span class="cstat-no" title="statement not covered" >Math.round(this.height*e*a.PixelsPerInch.PDF_TO_CSS_UNITS),</span>n=<span class="cstat-no" title="statement not covered" >new OffscreenCanvas(i,s);<span class="cstat-no" title="statement not covered" ></span>n.getContext("2d").drawImage(this.#ls,0,0,this.#ls.width,this.#ls.height,0,0,i,s);<span class="cstat-no" title="statement not covered" >r</span>eturn n.transferToImageBitmap()}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn structuredClone(this.#ls)}</span>#Hi(){<span class="cstat-no" title="statement not covered" >this.#Di=new ResizeObserver((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t[0].contentRect;<span class="cstat-no" title="statement not covered" ></span>e.width&amp;&amp;e.height&amp;&amp;this.#ys(e.width,e.height)}</span>));<span class="cstat-no" title="statement not covered" >t</span>his.#Di.observe(this.div)}<span class="fstat-no" title="function not covered" ></span>st</span>atic deserialize(t,e,i){<span class="cstat-no" title="statement not covered" >if(t instanceof r.StampAnnotationElement)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >super.deserialize(t,e,i),</span>{rect:n,bitmapUrl:a,bitmapId:o,isSvg:l}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;i.imageManager.isValidId(o)?s.#cs=o:s.#ds=a;<span class="cstat-no" title="statement not covered" >s</span>.#ms=l;c</span>onst[c,h]=<span class="cstat-no" title="statement not covered" >s.pageDimensions;<span class="cstat-no" title="statement not covered" ></span>s.width=(n[2]-n[0])/c;<span class="cstat-no" title="statement not covered" >s</span>.height=(n[3]-n[1])/h;<span class="cstat-no" title="statement not covered" >r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>se</span>rialize(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >if(this.isEmpty())<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >{annotationType:s.AnnotationEditorType.STAMP,bitmapId:this.#cs,pageIndex:this.pageIndex,rect:this.getRect(0,0),rotation:this.rotation,isSvg:this.#ms};<span class="cstat-no" title="statement not covered" ></span>if(t){<span class="cstat-no" title="statement not covered" >i.bitmapUrl=this.#Es(!0);<span class="cstat-no" title="statement not covered" >r</span>eturn i}<span class="cstat-no" title="statement not covered" ></span>i</span>f(null===e)<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >e</span></span>.stamps||=new Map;c</span>onst n=<span class="cstat-no" title="statement not covered" >this.#ms?(i.rect[2]-i.rect[0])*(i.rect[3]-i.rect[1]):null;<span class="cstat-no" title="statement not covered" ></span>if(e.stamps.has(this.#cs)){<span class="cstat-no" title="statement not covered" >if(this.#ms){const t=<span class="cstat-no" title="statement not covered" >e.stamps.get(this.#cs);<span class="cstat-no" title="statement not covered" ></span>if(n&gt;t.area){<span class="cstat-no" title="statement not covered" >t.area=n;<span class="cstat-no" title="statement not covered" >t</span>.serialized.bitmap.close();<span class="cstat-no" title="statement not covered" >t</span>.serialized.bitmap=this.#Es(!1)}</span>}</span>}</span>else{<span class="cstat-no" title="statement not covered" >e.stamps.set(this.#cs,{area:n,serialized:i});<span class="cstat-no" title="statement not covered" >i</span>.bitmap=this.#Es(!1)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>}<span class="cstat-no" title="statement not covered" >e.StampEditor=StampEditor}</span>],</span>__webpack_module_cache__=<span class="cstat-no" title="statement not covered" >{};</span>function <span class="fstat-no" title="function not covered" >__w_pdfjs_require__(</span>t){var e=<span class="cstat-no" title="statement not covered" >__webpack_module_cache__[t];<span class="cstat-no" title="statement not covered" ></span>if(void 0!==e)<span class="cstat-no" title="statement not covered" >return e.exports;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >__webpack_module_cache__[t]={exports:{}};<span class="cstat-no" title="statement not covered" ></span>__webpack_modules__[t](i,i.exports,__w_pdfjs_require__);<span class="cstat-no" title="statement not covered" >r</span>eturn i.exports}</span>var __webpack_exports__=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>(<span class="fstat-no" title="function not covered" >()</span>=&gt;{var t=<span class="cstat-no" title="statement not covered" >__webpack_exports__;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,"__esModule",{value:!0});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"AbortException",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.AbortException}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"AnnotationEditorLayer",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a.AnnotationEditorLayer}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"AnnotationEditorParamsType",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.AnnotationEditorParamsType}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"AnnotationEditorType",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.AnnotationEditorType}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"AnnotationEditorUIManager",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return r.AnnotationEditorUIManager}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"AnnotationLayer",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return o.AnnotationLayer}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"AnnotationMode",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.AnnotationMode}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"CMapCompressionType",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.CMapCompressionType}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"FeatureTest",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.FeatureTest}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"GlobalWorkerOptions",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return l.GlobalWorkerOptions}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"ImageKind",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.ImageKind}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"InvalidPDFException",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.InvalidPDFException}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"MissingPDFException",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.MissingPDFException}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"OPS",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.OPS}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"PDFDataRangeTransport",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i.PDFDataRangeTransport}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"PDFDateString",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.PDFDateString}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"PDFWorker",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i.PDFWorker}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"PasswordResponses",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.PasswordResponses}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"PermissionFlag",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.PermissionFlag}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"PixelsPerInch",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.PixelsPerInch}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"PromiseCapability",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.PromiseCapability}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"RenderingCancelledException",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.RenderingCancelledException}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"SVGGraphics",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i.SVGGraphics}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"UnexpectedResponseException",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.UnexpectedResponseException}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"Util",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.Util}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"VerbosityLevel",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.VerbosityLevel}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"XfaLayer",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return c.XfaLayer}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"build",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i.build}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"createValidAbsoluteUrl",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.createValidAbsoluteUrl}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"getDocument",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i.getDocument}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"getFilenameFromUrl",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.getFilenameFromUrl}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"getPdfFilenameFromUrl",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.getPdfFilenameFromUrl}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"getXfaPageViewport",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.getXfaPageViewport}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"isDataScheme",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.isDataScheme}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"isPdfFile",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.isPdfFile}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"loadScript",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.loadScript}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"normalizeUnicode",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.normalizeUnicode}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"renderTextLayer",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n.renderTextLayer}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"setLayerDimensions",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s.setLayerDimensions}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"shadow",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.shadow}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"updateTextLayer",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return n.updateTextLayer}</span>});<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"version",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i.version}</span>});v</span>ar e=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(1),</span>i=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(2),</span>s=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(6),</span>n=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(26),</span>a=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(27),</span>r=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(5),</span>o=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(29),</span>l=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(14),</span>c=<span class="cstat-no" title="statement not covered" >__w_pdfjs_require__(32)}</span>)();<span class="cstat-no" title="statement not covered" >r</span>eturn __webpack_exports__}</span>)())</span>);</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-08-19T11:01:38.619Z
            </div>
        <script src="../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../sorter.js"></script>
        <script src="../block-navigation.js"></script>
    </body>
</html>
    