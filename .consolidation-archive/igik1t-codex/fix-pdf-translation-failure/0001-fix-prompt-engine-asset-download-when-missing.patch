From 8d6ae7c3e3f02f942c3cb39c7871a25e6e9d8c36 Mon Sep 17 00:00:00 2001
From: MikkoParkkola <78788115+MikkoParkkola@users.noreply.github.com>
Date: Tue, 12 Aug 2025 06:19:31 +0200
Subject: [PATCH] fix: prompt engine asset download when missing

---
 src/manifest.json                |  2 +-
 src/pdfViewer.js                 | 42 +++++++++++++++++++---------
 src/sessionPdf.js                | 48 ++++++++++++++++++++++++++++++++
 src/translator.js                | 14 ++++------
 src/wasm/engine.js               | 26 +++++++++++++----
 src/wasm/pdfFetch.js             | 17 +++++++++--
 src/wasm/pipeline.js             | 28 ++++++++++++++++---
 src/wasm/vendor/simple.engine.js |  8 +++---
 test/engine.test.js              | 20 +++++++++++++
 test/pipeline.test.js            | 47 +++++++++++++++++++++++++++++++
 test/simple.engine.test.js       | 33 ++++++++++++++++++++++
 test/translator.test.js          | 21 ++++++++++++++
 12 files changed, 268 insertions(+), 38 deletions(-)
 create mode 100644 src/sessionPdf.js
 create mode 100644 test/pipeline.test.js
 create mode 100644 test/simple.engine.test.js

diff --git a/src/manifest.json b/src/manifest.json
index 02da7d0..33c1af7 100644
--- a/src/manifest.json
+++ b/src/manifest.json
@@ -32,7 +32,7 @@
     {
       "resources": [
         "translator.js", "config.js", "languages.js", "throttle.js",
-        "pdfViewer.html", "pdfViewer.js", "pdf.min.js", "pdf.worker.min.js",
+        "pdfViewer.html", "pdfViewer.js", "sessionPdf.js", "pdf.min.js", "pdf.worker.min.js",
         "wasm/pipeline.js", "wasm/pdfgen.js", "wasm/engine.js",
         "wasm/vendor/hb.wasm", "wasm/vendor/icu4x_segmenter.wasm",
         "wasm/vendor/mupdf.engine.js", "wasm/vendor/mupdf.wasm",
diff --git a/src/pdfViewer.js b/src/pdfViewer.js
index 9410f2f..0be6817 100644
--- a/src/pdfViewer.js
+++ b/src/pdfViewer.js
@@ -1,6 +1,7 @@
 import { regeneratePdfFromUrl } from './wasm/pipeline.js';
 import { chooseEngine, WASM_ASSETS } from './wasm/engine.js';
 import { safeFetchPdf } from './wasm/pdfFetch.js';
+import { storePdfInSession, readPdfFromSession } from './sessionPdf.js';
 
 (async function() {
   function isLikelyDutch(text) {
@@ -50,6 +51,7 @@ import { safeFetchPdf } from './wasm/pdfFetch.js';
   }
   const params = new URL(location.href).searchParams;
   const file = params.get('file');
+  const sessionKey = params.get('session');
   const origFile = params.get('orig') || file;
   const viewer = document.getElementById('viewer');
   const thumbs = document.getElementById('thumbs');
@@ -81,7 +83,7 @@ import { safeFetchPdf } from './wasm/pdfFetch.js';
     badge.style.color = isTranslatedParam ? '#2e7d32' : '#666';
   }
 
-  if (!file) {
+  if (!file && !sessionKey) {
     viewer.textContent = 'No PDF specified';
     console.log('DEBUG: No PDF file specified.');
     return;
@@ -205,7 +207,8 @@ import { safeFetchPdf } from './wasm/pdfFetch.js';
     if (translatedMenu) translatedMenu.style.display = 'none';
   }
 
-  async function generateTranslatedBlobUrl(originalUrl) {
+  async function generateTranslatedSessionKey(originalUrl) {
+    console.log('DEBUG: starting translation for', originalUrl);
     const overlay = document.getElementById('regenOverlay');
     const text = document.getElementById('regenText');
     const bar = document.getElementById('regenBar');
@@ -223,19 +226,23 @@ import { safeFetchPdf } from './wasm/pdfFetch.js';
         if (p.phase === 'translate') { pct = 20 + Math.round((p.page / p.total) * 40); setProgress(`Translating… (${p.page}/${p.total})`, pct); }
         if (p.phase === 'render') { pct = 60 + Math.round((p.page / p.total) * 40); setProgress(`Rendering pages… (${p.page}/${p.total})`, pct); }
       });
-      const url = URL.createObjectURL(blob);
-      return url;
+      console.log('DEBUG: translation finished, blob size', blob.size);
+      const key = await storePdfInSession(blob);
+      console.log('DEBUG: stored translated PDF key', key);
+      return key;
     } finally {
       if (overlay) setTimeout(()=>{ overlay.style.display = 'none'; const b = document.getElementById('regenBar'); if (b) b.style.width = '0%'; }, 800);
     }
   }
 
   function gotoOriginal(originalUrl) {
+    console.log('DEBUG: navigating to original', originalUrl);
     const viewerUrl = chrome.runtime.getURL('pdfViewer.html') + '?file=' + encodeURIComponent(originalUrl) + '&orig=' + encodeURIComponent(originalUrl);
     window.location.href = viewerUrl;
   }
-  function gotoTranslated(originalUrl, translatedBlobUrl) {
-    const viewerUrl = chrome.runtime.getURL('pdfViewer.html') + `?translated=1&file=${encodeURIComponent(translatedBlobUrl)}&orig=${encodeURIComponent(originalUrl)}`;
+  function gotoTranslated(originalUrl, sessionKey) {
+    console.log('DEBUG: navigating to translated', { originalUrl, sessionKey });
+    const viewerUrl = chrome.runtime.getURL('pdfViewer.html') + `?translated=1&session=${encodeURIComponent(sessionKey)}&orig=${encodeURIComponent(originalUrl)}`;
     window.location.href = viewerUrl;
   }
 
@@ -249,8 +256,8 @@ import { safeFetchPdf } from './wasm/pdfFetch.js';
       try {
         btnTranslated.disabled = true;
         btnOriginal && (btnOriginal.disabled = true);
-        const blobUrl = isTranslatedParam ? file : await generateTranslatedBlobUrl(origFile);
-        gotoTranslated(origFile, blobUrl);
+        const key = isTranslatedParam ? sessionKey : await generateTranslatedSessionKey(origFile);
+        gotoTranslated(origFile, key);
       } catch (e) { console.error('Translate view failed', e); }
       finally {
         btnTranslated.disabled = false;
@@ -272,10 +279,13 @@ import { safeFetchPdf } from './wasm/pdfFetch.js';
     actionSaveTranslated.dataset.bound = '1';
     actionSaveTranslated.addEventListener('click', async () => {
       try {
-        let url = file;
+        let key = sessionKey;
         if (!isTranslatedParam) {
-          url = await generateTranslatedBlobUrl(origFile);
+          key = await generateTranslatedSessionKey(origFile);
         }
+        const buf = readPdfFromSession(key);
+        const blob = new Blob([buf], { type: 'application/pdf' });
+        const url = URL.createObjectURL(blob);
         if (chrome && chrome.downloads && chrome.downloads.download) {
           const ts = new Date();
           const fname = `translated-${ts.getFullYear()}${String(ts.getMonth()+1).padStart(2,'0')}${String(ts.getDate()).padStart(2,'0')}-${String(ts.getHours()).padStart(2,'0')}${String(ts.getMinutes()).padStart(2,'0')}${String(ts.getSeconds()).padStart(2,'0')}.pdf`;
@@ -292,8 +302,8 @@ import { safeFetchPdf } from './wasm/pdfFetch.js';
   setModeUI(initialMode);
   if (initialMode === 'translated' && !isTranslatedParam && origFile) {
     try {
-      const blobUrl = await generateTranslatedBlobUrl(origFile);
-      gotoTranslated(origFile, blobUrl);
+      const key = await generateTranslatedSessionKey(origFile);
+      gotoTranslated(origFile, key);
       return; // stop rendering original while navigating
     } catch (e) {
       console.error('Auto-translate preview failed', e);
@@ -307,9 +317,15 @@ import { safeFetchPdf } from './wasm/pdfFetch.js';
   console.log('DEBUG: API key loaded.');
 
   try {
+    let buffer;
+    if (sessionKey) {
+      buffer = readPdfFromSession(sessionKey);
+      console.log('DEBUG: Loaded PDF from session storage.');
+    } else {
       console.log(`DEBUG: Attempting to fetch PDF from: ${file}`);
-      const buffer = await safeFetchPdf(file);
+      buffer = await safeFetchPdf(file);
       console.log('DEBUG: PDF fetched successfully.');
+    }
     const loadingTask = pdfjsLib.getDocument({ data: new Uint8Array(buffer) });
     console.log('DEBUG: PDF loading task created.');
     const pdf = await loadingTask.promise;
diff --git a/src/sessionPdf.js b/src/sessionPdf.js
new file mode 100644
index 0000000..da202bf
--- /dev/null
+++ b/src/sessionPdf.js
@@ -0,0 +1,48 @@
+export async function storePdfInSession(blob) {
+  console.log('DEBUG: storing PDF in session');
+  const buf = await blob.arrayBuffer();
+  console.log(`DEBUG: PDF size ${buf.byteLength} bytes`);
+  const b64 = base64Encode(buf);
+  const key = `pdf-${Date.now().toString(36)}-${Math.random().toString(36).slice(2)}`;
+  try {
+    sessionStorage.setItem(key, b64);
+    console.log(`DEBUG: stored PDF under key ${key}`);
+  } catch (e) {
+    console.error('DEBUG: failed to store PDF', e);
+    throw new Error('Failed to store PDF in session');
+  }
+  return key;
+}
+
+export function readPdfFromSession(key) {
+  console.log(`DEBUG: reading PDF from session key ${key}`);
+  const b64 = sessionStorage.getItem(key);
+  if (!b64) {
+    console.log('DEBUG: session PDF missing');
+    throw new Error('Session PDF missing');
+  }
+  const buf = base64Decode(b64);
+  console.log(`DEBUG: decoded session PDF size ${buf.byteLength} bytes`);
+  return buf;
+}
+
+function base64Encode(buffer) {
+  if (typeof btoa === 'function') {
+    let binary = '';
+    const bytes = new Uint8Array(buffer);
+    bytes.forEach(b => { binary += String.fromCharCode(b); });
+    return btoa(binary);
+  }
+  return Buffer.from(buffer).toString('base64');
+}
+
+function base64Decode(b64) {
+  if (typeof atob === 'function') {
+    const bin = atob(b64);
+    const buf = new ArrayBuffer(bin.length);
+    const bytes = new Uint8Array(buf);
+    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
+    return buf;
+  }
+  return Buffer.from(b64, 'base64').buffer;
+}
diff --git a/src/translator.js b/src/translator.js
index 36d4acc..ee5ce5b 100644
--- a/src/translator.js
+++ b/src/translator.js
@@ -74,13 +74,12 @@ async function doFetch({ endpoint, apiKey, model, text, source, target, signal,
     },
   };
   if (debug) console.log('QTDEBUG: request body', body);
+  const key = (apiKey || '').trim();
+  const headers = { 'Content-Type': 'application/json' };
+  if (key) headers.Authorization = /^bearer\s/i.test(key) ? key : `Bearer ${key}`;
+  if (stream) headers['X-DashScope-SSE'] = 'enable';
   let resp;
   try {
-    const headers = {
-      'Content-Type': 'application/json',
-      Authorization: apiKey,
-    };
-    if (stream) headers['X-DashScope-SSE'] = 'enable';
     resp = await fetchFn(url, {
       method: 'POST',
       headers,
@@ -98,10 +97,7 @@ async function doFetch({ endpoint, apiKey, model, text, source, target, signal,
         url,
         {
           method: 'POST',
-          headers: {
-            'Content-Type': 'application/json',
-            Authorization: apiKey,
-          },
+          headers,
           body: JSON.stringify(body),
           signal,
         },
diff --git a/src/wasm/engine.js b/src/wasm/engine.js
index 9bf68d5..3ea253d 100644
--- a/src/wasm/engine.js
+++ b/src/wasm/engine.js
@@ -61,6 +61,7 @@ async function check(base, path) {
 
 export async function chooseEngine(base, requested) {
   const wants = (requested || 'auto').toLowerCase();
+  console.log('DEBUG: chooseEngine requested', wants);
   const hbOk = await check(base, 'hb.wasm');
   const icuOk = (await check(base, 'icu4x_segmenter.wasm')) || (await check(base, 'icu4x_segmenter_wasm_bg.wasm'));
   const pdfiumOk =
@@ -72,19 +73,21 @@ export async function chooseEngine(base, requested) {
     (await check(base, 'mupdf-wasm.js')) &&
     ((await check(base, 'mupdf.wasm')) || (await check(base, 'mupdf-wasm.wasm')));
   const overlayOk = await check(base, 'pdf-lib.js');
+  console.log('DEBUG: engine assets', { hbOk, icuOk, pdfiumOk, mupdfOk, overlayOk });
 
   function pick() {
-    if (wants === 'mupdf') return 'mupdf';
-    if (wants === 'pdfium') return 'pdfium';
-    if (wants === 'overlay') return 'overlay';
+    if (wants === 'mupdf') return mupdfOk ? 'mupdf' : (pdfiumOk ? 'pdfium' : (overlayOk ? 'overlay' : 'simple'));
+    if (wants === 'pdfium') return pdfiumOk ? 'pdfium' : (mupdfOk ? 'mupdf' : (overlayOk ? 'overlay' : 'simple'));
+    if (wants === 'overlay') return overlayOk ? 'overlay' : (pdfiumOk ? 'pdfium' : (mupdfOk ? 'mupdf' : 'simple'));
     if (wants === 'simple') return 'simple';
-    // auto: prefer MuPDF if present; else PDFium; else Overlay; else Simple
+    // auto: prefer PDFium if present; then MuPDF; then Overlay; else Simple
     if (pdfiumOk) return 'pdfium';
     if (mupdfOk) return 'mupdf';
     if (overlayOk) return 'overlay';
     return 'simple';
   }
   const choice = pick();
+  console.log('DEBUG: chooseEngine selected', choice);
   return { choice, hbOk, icuOk, pdfiumOk, mupdfOk, overlayOk };
 }
 
@@ -107,11 +110,13 @@ export async function downloadWasmAssets(dir, downloader) {
 
 async function loadEngine(cfg) {
   if (_impl && cfg && (cfg.wasmEngine || 'auto') === _lastChoice) return _impl;
+  console.log('DEBUG: loadEngine start', cfg && cfg.wasmEngine);
   try {
     const base = new URL('./vendor/', import.meta.url).href;
     const requested = cfg && cfg.wasmEngine;
     const { choice, hbOk, icuOk, pdfiumOk, mupdfOk } = await chooseEngine(base, requested);
     if (!choice) { _lastChoice = 'auto'; }
+    console.log('DEBUG: loadEngine choice', choice);
     // Strict mode: if requested engine assets missing, do not fallback
     const strict = !!(cfg && cfg.wasmStrict);
     if (strict) {
@@ -127,13 +132,16 @@ async function loadEngine(cfg) {
     else if (choice === 'overlay') wrapper = 'overlay.engine.js';
     let engineMod;
     try {
+      console.log(`DEBUG: importing wrapper ${wrapper}`);
       engineMod = await import(/* @vite-ignore */ base + wrapper);
     } catch (e) {
+      console.error('DEBUG: wrapper import failed', e);
       available = false;
       _impl = { async rewritePdf() { throw new Error(`WASM ${choice} wrapper not wired. Implement rewrite() in src/wasm/vendor/${wrapper}`); } };
       return _impl;
     }
     const engine = await engineMod.init({ baseURL: base, hasHB: hbOk, hasICU: icuOk, hasPDF: choice === 'pdfium' ? pdfiumOk : mupdfOk });
+    console.log('DEBUG: engine module initialized');
     if (!engine || typeof engine.rewrite !== 'function') {
       available = false;
       _impl = { async rewritePdf() { throw new Error(`WASM ${choice} wrapper missing rewrite()`); } };
@@ -141,25 +149,33 @@ async function loadEngine(cfg) {
     }
     _impl = {
       async rewritePdf(buffer, cfg2, onProgress) {
+        console.log(`DEBUG: rewritePdf called size ${buffer.byteLength} bytes`);
         if (onProgress) onProgress({ phase: 'rewrite', page: 0, total: 1 });
-        return await engine.rewrite(buffer, cfg2, onProgress);
+        return await engine.rewrite(buffer, cfg2, p => {
+          console.log('DEBUG: engine progress', p);
+          if (onProgress) onProgress(p);
+        });
       },
     };
     available = true;
+    console.log('DEBUG: engine loaded', choice);
   } catch (e) {
     available = false;
+    console.error('DEBUG: loadEngine failed', e);
     _impl = { async rewritePdf() { throw new Error('WASM engine not available. Place vendor assets under src/wasm/vendor/.'); } };
   }
   return _impl;
 }
 
 export async function isWasmAvailable(cfg) {
+  console.log('DEBUG: isWasmAvailable check');
   if (_impl && (cfg?.wasmEngine || 'auto') === _lastChoice) return available;
   await loadEngine(cfg);
   return available;
 }
 
 export async function rewritePdf(buffer, cfg, onProgress) {
+  console.log(`DEBUG: rewritePdf entry size ${buffer.byteLength} bytes`);
   const impl = await loadEngine(cfg);
   return impl.rewritePdf(buffer, cfg, onProgress);
 }
diff --git a/src/wasm/pdfFetch.js b/src/wasm/pdfFetch.js
index e4d45ef..e1d485c 100644
--- a/src/wasm/pdfFetch.js
+++ b/src/wasm/pdfFetch.js
@@ -1,31 +1,44 @@
 export const MAX_PDF_BYTES = 32 * 1024 * 1024; // 32 MiB
 
 export function assertAllowedScheme(urlStr) {
+  console.log(`DEBUG: checking PDF URL scheme for ${urlStr}`);
   let u;
   try { u = new URL(urlStr); } catch { throw new Error('Invalid PDF URL'); }
   const ok = u.protocol === 'http:' || u.protocol === 'https:' || u.protocol === 'file:' || u.protocol === 'blob:';
-  if (!ok) throw new Error('Blocked PDF URL scheme');
+  if (!ok) {
+    console.log(`DEBUG: blocked scheme ${u.protocol}`);
+    throw new Error('Blocked PDF URL scheme');
+  }
+  console.log(`DEBUG: allowed scheme ${u.protocol}`);
   return u;
 }
 
 export async function safeFetchPdf(urlStr) {
+  console.log(`DEBUG: safeFetchPdf called for ${urlStr}`);
   const u = assertAllowedScheme(urlStr);
   if (u.protocol === 'http:' || u.protocol === 'https:') {
     try {
       const head = await fetch(urlStr, { method: 'HEAD' });
+      console.log(`DEBUG: HEAD status ${head.status}`);
       const len = Number(head.headers.get('content-length') || '0');
+      console.log(`DEBUG: content-length ${len}`);
       if (Number.isFinite(len) && len > 0 && len > MAX_PDF_BYTES) {
         throw new Error('PDF too large');
       }
       const ctype = (head.headers.get('content-type') || '').toLowerCase();
+      console.log(`DEBUG: content-type ${ctype}`);
       if (ctype && !ctype.includes('pdf')) {
         if (!u.pathname.toLowerCase().endsWith('.pdf')) throw new Error('Not a PDF content-type');
       }
-    } catch {}
+    } catch (e) {
+      console.log('DEBUG: HEAD request failed', e);
+    }
   }
   const resp = await fetch(urlStr);
+  console.log(`DEBUG: GET status ${resp.status}`);
   if (!resp.ok) throw new Error(`Failed to fetch PDF: ${resp.status}`);
   const buffer = await resp.arrayBuffer();
+  console.log(`DEBUG: fetched PDF size ${buffer.byteLength} bytes`);
   if (buffer.byteLength > MAX_PDF_BYTES) throw new Error('PDF too large');
   return buffer;
 }
diff --git a/src/wasm/pipeline.js b/src/wasm/pipeline.js
index c89de0b..23dfd60 100644
--- a/src/wasm/pipeline.js
+++ b/src/wasm/pipeline.js
@@ -1,11 +1,31 @@
-import { isWasmAvailable, rewritePdf } from './engine.js';
+import { isWasmAvailable, rewritePdf, WASM_ASSETS } from './engine.js';
 import { safeFetchPdf } from './pdfFetch.js';
 
 export async function regeneratePdfFromUrl(fileUrl, cfg, onProgress) {
+  console.log(`DEBUG: regeneratePdfFromUrl start ${fileUrl}`);
   const buffer = await safeFetchPdf(fileUrl);
-  if (!(cfg && cfg.useWasmEngine)) throw new Error('WASM engine disabled. Enable it in settings.');
+  console.log(`DEBUG: fetched original PDF size ${buffer.byteLength} bytes`);
+  if (!(cfg && cfg.useWasmEngine)) {
+    console.log('DEBUG: WASM engine disabled in config');
+    throw new Error('WASM engine disabled. Enable it in settings.');
+  }
   const available = await isWasmAvailable(cfg);
-  if (!available) throw new Error('WASM engine not available. Place vendor assets under src/wasm/vendor/.');
+  console.log(`DEBUG: WASM engine available ${available}`);
+  if (!available) {
+    console.log('DEBUG: WASM engine not available');
+    if (typeof chrome !== 'undefined' && chrome.downloads && chrome.downloads.download) {
+      for (const a of WASM_ASSETS) {
+        chrome.downloads.download({ url: a.url, filename: `wasm/vendor/${a.path}` });
+      }
+      if (typeof alert === 'function') {
+        alert('Downloading engine assets. Copy the "wasm" folder into the extension directory and reload.');
+      }
+    }
+    throw new Error('WASM engine not available. Place vendor assets under src/wasm/vendor/.');
+  }
   if (onProgress) onProgress({ phase: 'collect', page: 0, total: 1 });
-  return await rewritePdf(buffer, cfg, onProgress);
+  return await rewritePdf(buffer, cfg, p => {
+    console.log('DEBUG: rewrite progress', p);
+    if (onProgress) onProgress(p);
+  });
 }
diff --git a/src/wasm/vendor/simple.engine.js b/src/wasm/vendor/simple.engine.js
index ac35eb8..6e82022 100644
--- a/src/wasm/vendor/simple.engine.js
+++ b/src/wasm/vendor/simple.engine.js
@@ -41,7 +41,7 @@ function buildSimplePdf(pages, onProgress) {
       y -= leading;
     });
     stream += 'ET\n';
-    const content = `<< /Length ${stream.length} >>\nstream\n${stream}endstream`;
+    const content = `<< /Length ${stream.length} >>\nstream\n${stream}endstream\n`;
     contentObjs.push({ num: contentNum, body: content });
     if (onProgress) onProgress({ phase: 'render', page: i + 1, total: pages.length });
   });
@@ -50,10 +50,10 @@ function buildSimplePdf(pages, onProgress) {
   add('1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj');
   add(`2 0 obj << /Type /Pages /Count ${pages.length} /Kids [ ${kids.join(' ')} ] >> endobj`);
   add('3 0 obj << /Type /Font /Subtype /Type1 /BaseFont /Helvetica >> endobj');
-  pageObjs.forEach((p, idx) => {
+  pageObjs.forEach((p) => {
     add(`${p.num} 0 obj << /Type /Page /Parent 2 0 R /MediaBox [0 0 ${Math.round(p.w)} ${Math.round(p.h)}] /Resources << /Font << /F1 3 0 R >> >> /Contents ${p.content} >> endobj`);
   });
-  contentObjs.forEach((c) => add(`${c.num} 0 obj ${c.body} endobj`));
+  contentObjs.forEach((c) => add(`${c.num} 0 obj\n${c.body}endobj`));
 
   const xrefPos = buf.length;
   buf += 'xref\n';
@@ -63,7 +63,7 @@ function buildSimplePdf(pages, onProgress) {
     const off = String(offsets[i]).padStart(10, '0');
     buf += `${off} 00000 n \n`;
   }
-  buf += `trailer << /Size ${contentObjs.length + pageObjs.length + 3 + 1} /Root 1 0 R >>\nstartxref\n${xrefPos}\n%%EOF`; 
+  buf += `trailer << /Size ${contentObjs.length + pageObjs.length + 3 + 1} /Root 1 0 R >>\nstartxref\n${xrefPos}\n%%EOF\n`;
   return new Blob([new TextEncoder().encode(buf)], { type: 'application/pdf' });
 }
 
diff --git a/test/engine.test.js b/test/engine.test.js
index 14360da..48a97a1 100644
--- a/test/engine.test.js
+++ b/test/engine.test.js
@@ -39,6 +39,26 @@ describe('chooseEngine', () => {
     expect(choice).toBe('pdfium');
   });
 
+  it('downgrades requested mupdf when assets missing', async () => {
+    const { chooseEngine } = loadEngine();
+    const ok = new Set([
+      'base/pdfium.engine.js',
+      'base/pdfium.js',
+      'base/pdfium.wasm',
+      'base/hb.wasm',
+      'base/icu4x_segmenter.wasm',
+      'base/pdf-lib.js',
+    ]);
+    global.fetch = jest.fn(url => {
+      if (ok.has(url)) return Promise.resolve({ ok: true });
+      return Promise.reject(new Error('missing'));
+    });
+    const { choice, mupdfOk, pdfiumOk } = await chooseEngine('base/', 'mupdf');
+    expect(mupdfOk).toBe(false);
+    expect(pdfiumOk).toBe(true);
+    expect(choice).toBe('pdfium');
+  });
+
   it('loads engines after assets downloaded', async () => {
     const { chooseEngine, WASM_ASSETS, downloadWasmAssets } = loadEngine();
   const os = require('os');
diff --git a/test/pipeline.test.js b/test/pipeline.test.js
new file mode 100644
index 0000000..a2be49f
--- /dev/null
+++ b/test/pipeline.test.js
@@ -0,0 +1,47 @@
+const fs = require('fs');
+const path = require('path');
+
+function loadPipeline() {
+  const code = fs.readFileSync(path.join(__dirname, '../src/wasm/pipeline.js'), 'utf8');
+  const transformed = code
+    .replace("import { isWasmAvailable, rewritePdf, WASM_ASSETS } from './engine.js';", "const { isWasmAvailable, rewritePdf, WASM_ASSETS } = require('../src/wasm/engine.js');")
+    .replace("import { safeFetchPdf } from './pdfFetch.js';", "const { safeFetchPdf } = require('../src/wasm/pdfFetch.js');")
+    .replace(/export\s+/g, '');
+  const module = { exports: {} };
+  const fn = new Function('require', 'module', 'exports', transformed + '\nreturn { regeneratePdfFromUrl };');
+  return fn(require, module, module.exports);
+}
+
+jest.mock('../src/wasm/engine.js', () => ({
+  isWasmAvailable: jest.fn().mockResolvedValue(false),
+  rewritePdf: jest.fn(),
+  WASM_ASSETS: [
+    { path: 'engine.wasm', url: 'https://example.com/engine.wasm' },
+  ],
+}));
+
+jest.mock('../src/wasm/pdfFetch.js', () => ({
+  safeFetchPdf: jest.fn().mockResolvedValue(new ArrayBuffer(8)),
+}));
+
+describe('regeneratePdfFromUrl when engine missing', () => {
+  beforeEach(() => {
+    global.chrome = { downloads: { download: jest.fn() } };
+    global.alert = jest.fn();
+  });
+  afterEach(() => {
+    delete global.chrome;
+    delete global.alert;
+  });
+  it('triggers asset downloads before failing', async () => {
+    const { regeneratePdfFromUrl } = loadPipeline();
+    await expect(
+      regeneratePdfFromUrl('https://example.com/a.pdf', { useWasmEngine: true })
+    ).rejects.toThrow('WASM engine not available');
+    expect(global.chrome.downloads.download).toHaveBeenCalledWith({
+      url: 'https://example.com/engine.wasm',
+      filename: 'wasm/vendor/engine.wasm',
+    });
+    expect(global.alert).toHaveBeenCalled();
+  });
+});
diff --git a/test/simple.engine.test.js b/test/simple.engine.test.js
new file mode 100644
index 0000000..4437eea
--- /dev/null
+++ b/test/simple.engine.test.js
@@ -0,0 +1,33 @@
+const fs = require('fs');
+const path = require('path');
+const { TextEncoder } = require('util');
+
+global.TextEncoder = TextEncoder;
+if (typeof global.structuredClone !== 'function') {
+  global.structuredClone = obj => JSON.parse(JSON.stringify(obj));
+}
+class FakeBlob {
+  constructor(parts) { this.data = parts[0]; }
+  text() { return Promise.resolve(Buffer.from(this.data).toString()); }
+  arrayBuffer() { return Promise.resolve(this.data.buffer); }
+}
+global.Blob = FakeBlob;
+
+function loadBuilder() {
+  const code = fs.readFileSync(path.join(__dirname, '../src/wasm/vendor/simple.engine.js'), 'utf8');
+  const transformed = code.replace(/export\s+/g, '');
+  const fn = new Function(transformed + '\nreturn { buildSimplePdf };');
+  return fn().buildSimplePdf;
+}
+
+describe('buildSimplePdf', () => {
+  it('creates a PDF that can be parsed', async () => {
+    const buildSimplePdf = loadBuilder();
+    const blob = buildSimplePdf([{ width: 200, height: 200, lines: ['hello world'] }]);
+    const text = await blob.text();
+    expect(text.startsWith('%PDF-')).toBe(true);
+    const pdfjsLib = require('pdfjs-dist/legacy/build/pdf.js');
+    const pdf = await pdfjsLib.getDocument({ data: new Uint8Array(await blob.arrayBuffer()) }).promise;
+    expect(pdf.numPages).toBe(1);
+  });
+});
diff --git a/test/translator.test.js b/test/translator.test.js
index 1c70fa9..1f17083 100644
--- a/test/translator.test.js
+++ b/test/translator.test.js
@@ -17,6 +17,27 @@ test('translate success', async () => {
   expect(res.text).toBe('hello');
 });
 
+test('adds bearer prefix automatically', async () => {
+  fetch.mockResponseOnce(JSON.stringify({output:{text:'hello'}}));
+  await translate({endpoint:'https://e/', apiKey:'abc123', model:'m', text:'hi', source:'en', target:'es'});
+  const headers = fetch.mock.calls[0][1].headers;
+  expect(headers.Authorization).toBe('Bearer abc123');
+});
+
+test('uses existing bearer prefix after trimming', async () => {
+  fetch.mockResponseOnce(JSON.stringify({output:{text:'ok'}}));
+  await translate({endpoint:'https://e/', apiKey:'  Bearer xyz  ', model:'m', text:'hi', source:'en', target:'es'});
+  const headers = fetch.mock.calls[0][1].headers;
+  expect(headers.Authorization).toBe('Bearer xyz');
+});
+
+test('omits authorization header when api key missing', async () => {
+  fetch.mockResponseOnce(JSON.stringify({output:{text:'hi'}}));
+  await translate({endpoint:'https://e/', apiKey:'', model:'m', text:'hi', source:'en', target:'es'});
+  const headers = fetch.mock.calls[0][1].headers;
+  expect(headers.Authorization).toBeUndefined();
+});
+
 test('translate error', async () => {
   const spy = jest.spyOn(console, 'error').mockImplementation(() => {});
   fetch.mockResponseOnce(JSON.stringify({message:'bad'}), {status:400});
-- 
2.50.0

