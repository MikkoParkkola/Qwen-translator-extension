From c90b2241268a05dc34cc8a39e3554e08d6fba6ec Mon Sep 17 00:00:00 2001
From: MikkoParkkola <78788115+MikkoParkkola@users.noreply.github.com>
Date: Wed, 30 Jul 2025 23:06:53 +0200
Subject: [PATCH 19/34] Improve debug logging and fix message response

---
 package-lock.json    |   4 +-
 package.json         |   2 +-
 src/background.js    | 136 ++++++++++++++++++++++---------------------
 src/config.js        |   1 +
 src/contentScript.js |   7 ++-
 src/manifest.json    |   2 +-
 src/popup.html       |   2 +
 src/popup.js         |  15 +++++
 src/translator.js    |  16 ++---
 9 files changed, 107 insertions(+), 78 deletions(-)

diff --git a/package-lock.json b/package-lock.json
index ee76208..0b97b8b 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -1,12 +1,12 @@
 {
   "name": "qwen-translator-extension",
-  "version": "1.0.0",
+  "version": "1.2.0",
   "lockfileVersion": 3,
   "requires": true,
   "packages": {
     "": {
       "name": "qwen-translator-extension",
-      "version": "1.0.0",
+      "version": "1.2.0",
       "license": "ISC",
       "devDependencies": {
         "@types/jest": "^30.0.0",
diff --git a/package.json b/package.json
index f06bf9d..d5f069b 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "qwen-translator-extension",
-  "version": "1.0.0",
+  "version": "1.2.0",
   "description": "Extension to translate web pages using Qwen-MT-Turbo model",
   "main": "index.js",
   "scripts": {
diff --git a/src/background.js b/src/background.js
index 91c4d1a..1b28fc5 100644
--- a/src/background.js
+++ b/src/background.js
@@ -5,73 +5,79 @@ chrome.runtime.onInstalled.addListener(() => {
   console.log('Qwen Translator installed');
 });
 
-chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
-  if (msg.action === 'translate') {
-    const { endpoint, apiKey, model, text, source, target } = msg.opts;
-    const ep = endpoint.endsWith('/') ? endpoint : `${endpoint}/`;
-    const controller = new AbortController();
-    const timer = setTimeout(() => controller.abort(), 10000);
-    const url = `${ep}services/aigc/text-generation/generation`;
-    console.log('Background translating via', url);
+async function handleTranslate(opts) {
+  const { endpoint, apiKey, model, text, source, target, debug } = opts;
+  const ep = endpoint.endsWith('/') ? endpoint : `${endpoint}/`;
+  const controller = new AbortController();
+  const timer = setTimeout(() => controller.abort(), 10000);
+  const url = `${ep}services/aigc/text-generation/generation`;
+  if (debug) console.log('QTDEBUG: background translating via', url);
 
-    chrome.storage.sync.get({ requestLimit: 60, tokenLimit: 100000 }, cfg => {
-      configure({ requestLimit: cfg.requestLimit, tokenLimit: cfg.tokenLimit, windowMs: 60000 });
+  const cfg = await new Promise(resolve =>
+    chrome.storage.sync.get({ requestLimit: 60, tokenLimit: 100000 }, resolve)
+  );
+  configure({ requestLimit: cfg.requestLimit, tokenLimit: cfg.tokenLimit, windowMs: 60000 });
 
-      runWithRateLimit(() => fetch(url, {
-        method: 'POST',
-        headers: {
-          'Content-Type': 'application/json',
-          Authorization: apiKey,
-          'X-DashScope-SSE': 'enable',
+  try {
+    const resp = await runWithRateLimit(() => fetch(url, {
+      method: 'POST',
+      headers: {
+        'Content-Type': 'application/json',
+        Authorization: apiKey,
+        'X-DashScope-SSE': 'enable',
+      },
+      body: JSON.stringify({
+        model,
+        input: { messages: [{ role: 'user', content: text }] },
+        parameters: {
+          translation_options: { source_lang: source, target_lang: target },
         },
-        body: JSON.stringify({
-          model,
-          input: { messages: [{ role: 'user', content: text }] },
-          parameters: {
-            translation_options: { source_lang: source, target_lang: target },
-          },
-        }),
-        signal: controller.signal,
-      }), approxTokens(text))
-      .then(async resp => {
-        clearTimeout(timer);
-        if (!resp.ok) {
-          const err = await resp.json().catch(() => ({ message: resp.statusText }));
-          sendResponse({ error: `HTTP ${resp.status}: ${err.message}` });
-          return;
-        }
-        const reader = resp.body.getReader();
-        const decoder = new TextDecoder();
-        let buffer = '';
-        let result = '';
-        while (true) {
-          const { value, done } = await reader.read();
-          if (done) break;
-          buffer += decoder.decode(value, { stream: true });
-          const lines = buffer.split('\n');
-          buffer = lines.pop();
-          for (const line of lines) {
-            const trimmed = line.trim();
-            if (!trimmed.startsWith('data:')) continue;
-            const data = trimmed.slice(5).trim();
-            if (data === '[DONE]') { reader.cancel(); break; }
-            try {
-              const obj = JSON.parse(data);
-              const chunk =
-                obj.output?.text ||
-                obj.output?.choices?.[0]?.message?.content || '';
-              result += chunk;
-            } catch {}
-          }
-        }
-        sendResponse({ text: result });
-      })
-      .catch(err => {
-        clearTimeout(timer);
-        console.error('Background translation error:', err);
-        sendResponse({ error: err.message });
-      });
-    });
-    return true;
+      }),
+      signal: controller.signal,
+    }), approxTokens(text));
+
+    clearTimeout(timer);
+    if (!resp.ok) {
+      const err = await resp.json().catch(() => ({ message: resp.statusText }));
+      if (debug) console.log('QTDEBUG: background HTTP error', err);
+      return { error: `HTTP ${resp.status}: ${err.message}` };
+    }
+
+    const reader = resp.body.getReader();
+    const decoder = new TextDecoder();
+    let buffer = '';
+    let result = '';
+    while (true) {
+      const { value, done } = await reader.read();
+      if (done) break;
+      buffer += decoder.decode(value, { stream: true });
+      const lines = buffer.split('\n');
+      buffer = lines.pop();
+      for (const line of lines) {
+        const trimmed = line.trim();
+        if (!trimmed.startsWith('data:')) continue;
+        const data = trimmed.slice(5).trim();
+        if (data === '[DONE]') { reader.cancel(); break; }
+        try {
+          const obj = JSON.parse(data);
+          const chunk =
+            obj.output?.text ||
+            obj.output?.choices?.[0]?.message?.content || '';
+          result += chunk;
+        } catch {}
+      }
+    }
+    if (debug) console.log('QTDEBUG: background translation completed');
+    return { text: result };
+  } catch (err) {
+    clearTimeout(timer);
+    console.error('QTERROR: background translation error', err);
+    return { error: err.message };
+  }
+}
+
+chrome.runtime.onMessage.addListener((msg, sender) => {
+  if (msg.action === 'translate') {
+    return handleTranslate(msg.opts);
   }
 });
diff --git a/src/config.js b/src/config.js
index 14ace38..b6e8e62 100644
--- a/src/config.js
+++ b/src/config.js
@@ -7,6 +7,7 @@ const defaultCfg = {
   autoTranslate: false,
   requestLimit: 60,
   tokenLimit: 100000,
+  debug: false,
 };
 
 function qwenLoadConfig() {
diff --git a/src/contentScript.js b/src/contentScript.js
index d2c0951..f3351ab 100644
--- a/src/contentScript.js
+++ b/src/contentScript.js
@@ -33,6 +33,7 @@ async function translateNode(node) {
   const text = node.textContent.trim();
   if (!text) return;
   try {
+    if (currentConfig.debug) console.log('QTDEBUG: translating node', text.slice(0, 20));
     const controller = new AbortController();
     const timeout = setTimeout(() => controller.abort(), 10000);
     const { text: translated } = await window.qwenTranslate({
@@ -43,13 +44,14 @@ async function translateNode(node) {
       source: currentConfig.sourceLanguage,
       target: currentConfig.targetLanguage,
       signal: controller.signal,
+      debug: currentConfig.debug,
     });
     clearTimeout(timeout);
     node.textContent = translated;
     mark(node);
   } catch (e) {
     showError(`${e.message}. See console for details.`);
-    console.error('Translation error:', e);
+    console.error('QTERROR: translation error', e);
   }
 }
 
@@ -86,9 +88,10 @@ function observe() {
 async function start() {
   currentConfig = await window.qwenLoadConfig();
   if (!currentConfig.apiKey) {
-    console.warn('Qwen Translator: API key not configured.');
+    console.warn('QTWARN: API key not configured.');
     return;
   }
+  if (currentConfig.debug) console.log('QTDEBUG: starting automatic translation');
   scan();
   observe();
 }
diff --git a/src/manifest.json b/src/manifest.json
index 2742273..46c7484 100644
--- a/src/manifest.json
+++ b/src/manifest.json
@@ -2,7 +2,7 @@
   "manifest_version": 3,
   "name": "Qwen Translator",
   "description": "Translate pages using Qwen-MT-Turbo",
-  "version": "1.0",
+  "version": "1.2",
   "permissions": ["storage", "activeTab", "tabs", "scripting"],
   "host_permissions": [
     "https://dashscope-intl.aliyuncs.com/*"
diff --git a/src/popup.html b/src/popup.html
index 20883f7..07edd4a 100644
--- a/src/popup.html
+++ b/src/popup.html
@@ -20,9 +20,11 @@
   <label>Requests per minute <input type="number" id="requestLimit"></label>
   <label>Tokens per minute <input type="number" id="tokenLimit"></label>
   <label><input type="checkbox" id="auto"> Translate automatically</label>
+  <label><input type="checkbox" id="debug"> Debug logging</label>
   <button id="save">Save</button>
   <button id="test">Test Settings</button>
   <div id="status"></div>
+  <div id="version" style="font-size:11px;color:#777;margin-top:4px"></div>
   <script src="throttle.js"></script>
   <script src="translator.js"></script>
   <script src="config.js"></script>
diff --git a/src/popup.js b/src/popup.js
index c691f95..90586fc 100644
--- a/src/popup.js
+++ b/src/popup.js
@@ -6,7 +6,9 @@ const targetSelect = document.getElementById('target');
 const reqLimitInput = document.getElementById('requestLimit');
 const tokenLimitInput = document.getElementById('tokenLimit');
 const autoCheckbox = document.getElementById('auto');
+const debugCheckbox = document.getElementById('debug');
 const status = document.getElementById('status');
+const versionDiv = document.getElementById('version');
 
 function populateLanguages() {
   window.qwenLanguages.forEach(l => {
@@ -28,9 +30,12 @@ window.qwenLoadConfig().then(cfg => {
   reqLimitInput.value = cfg.requestLimit;
   tokenLimitInput.value = cfg.tokenLimit;
   autoCheckbox.checked = cfg.autoTranslate;
+  debugCheckbox.checked = !!cfg.debug;
   if (!cfg.apiKey) status.textContent = 'Set API key';
 });
 
+versionDiv.textContent = `v${chrome.runtime.getManifest().version}`;
+
 document.getElementById('translate').addEventListener('click', () => {
   chrome.tabs.query({active: true, currentWindow: true}, (tabs) => {
     chrome.tabs.sendMessage(tabs[0].id, {action: 'start'});
@@ -47,6 +52,7 @@ document.getElementById('save').addEventListener('click', () => {
     requestLimit: parseInt(reqLimitInput.value, 10) || 60,
     tokenLimit: parseInt(tokenLimitInput.value, 10) || 100000,
     autoTranslate: autoCheckbox.checked,
+    debug: debugCheckbox.checked,
   };
   window.qwenSaveConfig(cfg).then(() => {
     status.textContent = 'Saved';
@@ -56,6 +62,11 @@ document.getElementById('save').addEventListener('click', () => {
 
 document.getElementById('test').addEventListener('click', async () => {
   status.textContent = 'Testing...';
+  console.log('QTDEBUG: starting configuration test');
+  const timer = setTimeout(() => {
+    console.error('QTERROR: configuration test timed out');
+    status.textContent = 'Error: timeout';
+  }, 15000);
   try {
     await window.qwenTranslate({
       endpoint: endpointInput.value.trim(),
@@ -64,9 +75,13 @@ document.getElementById('test').addEventListener('click', async () => {
       source: sourceSelect.value,
       text: 'hello',
       target: targetSelect.value,
+      debug: debugCheckbox.checked,
     });
     status.textContent = 'Configuration OK';
+    console.log('QTDEBUG: configuration test successful');
   } catch (e) {
     status.textContent = `Error: ${e.message}`;
+    console.error('QTERROR: configuration test failed', e);
   }
+  clearTimeout(timer);
 });
diff --git a/src/translator.js b/src/translator.js
index cd99c15..4be85a0 100644
--- a/src/translator.js
+++ b/src/translator.js
@@ -22,9 +22,9 @@ function withSlash(url) {
   return url.endsWith('/') ? url : `${url}/`;
 }
 
-async function doFetch({ endpoint, apiKey, model, text, source, target, signal }) {
+async function doFetch({ endpoint, apiKey, model, text, source, target, signal, debug }) {
   const url = `${withSlash(endpoint)}services/aigc/text-generation/generation`;
-  console.log('Sending translation request to', url);
+  if (debug) console.log('QTDEBUG: sending translation request to', url);
   const body = {
     model,
     input: { messages: [{ role: 'user', content: text }] },
@@ -89,7 +89,7 @@ async function doFetch({ endpoint, apiKey, model, text, source, target, signal }
   return { text: result };
 }
 
-async function qwenTranslate({ endpoint, apiKey, model, text, source, target, signal }) {
+async function qwenTranslate({ endpoint, apiKey, model, text, source, target, signal, debug = false }) {
   const cacheKey = `${source}:${target}:${text}`;
   if (cache.has(cacheKey)) {
     return cache.get(cacheKey);
@@ -98,8 +98,8 @@ async function qwenTranslate({ endpoint, apiKey, model, text, source, target, si
   if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
     const ep = withSlash(endpoint);
     const result = await new Promise((resolve, reject) => {
-      console.log('Requesting translation via background script');
-      chrome.runtime.sendMessage({ action: 'translate', opts: { endpoint: ep, apiKey, model, text, source, target } }, res => {
+      if (debug) console.log('QTDEBUG: requesting translation via background script');
+      chrome.runtime.sendMessage({ action: 'translate', opts: { endpoint: ep, apiKey, model, text, source, target, debug } }, res => {
         if (chrome.runtime.lastError) {
           reject(new Error(chrome.runtime.lastError.message));
         } else if (res && res.error) {
@@ -109,19 +109,21 @@ async function qwenTranslate({ endpoint, apiKey, model, text, source, target, si
         }
       });
     });
+    if (debug) console.log('QTDEBUG: background response received');
     cache.set(cacheKey, result);
     return result;
   }
 
   try {
     const data = await runWithRateLimit(
-      () => doFetch({ endpoint, apiKey, model, text, source, target, signal }),
+      () => doFetch({ endpoint, apiKey, model, text, source, target, signal, debug }),
       approxTokens(text)
     );
     cache.set(cacheKey, data);
+    if (debug) console.log('QTDEBUG: translation successful');
     return data;
   } catch (e) {
-    console.error('Translation request failed:', e);
+    console.error('QTERROR: translation request failed', e);
     throw e;
   }
 }
-- 
2.50.0

