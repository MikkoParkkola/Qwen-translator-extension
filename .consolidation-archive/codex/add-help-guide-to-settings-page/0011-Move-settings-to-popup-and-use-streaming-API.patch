From f56d81e06a36cb2edd6176d0702cffec01fbe71b Mon Sep 17 00:00:00 2001
From: MikkoParkkola <78788115+MikkoParkkola@users.noreply.github.com>
Date: Wed, 30 Jul 2025 17:28:21 +0200
Subject: [PATCH 11/11] Move settings to popup and use streaming API

---
 README.md               |   9 ++--
 src/background.js       |  32 +++++++++---
 src/config.js           |   6 +--
 src/contentScript.js    |   6 +--
 src/manifest.json       |   1 -
 src/options.html        |  28 -----------
 src/options.js          | 107 ----------------------------------------
 src/popup.html          |  18 +++++--
 src/popup.js            |  63 ++++++++++++++++++++---
 src/translator.js       |  55 ++++++++++++++++-----
 test/translator.test.js |   8 +--
 11 files changed, 151 insertions(+), 182 deletions(-)
 delete mode 100644 src/options.html
 delete mode 100644 src/options.js

diff --git a/README.md b/README.md
index f1e0b00..1e309bd 100644
--- a/README.md
+++ b/README.md
@@ -15,13 +15,12 @@ Remove the extension from the browser's extension management page.
 Reload the unpacked extension after replacing the files with a newer version.
 
 ## Configuration
-Use the extension options page to set:
+Use the popup to configure:
 - API key and optional endpoint (keep your API key private)
-- Translation model (`qwen-mt-plus` or `qwen-mt-turbo`)
-  - Click **Refresh** to retrieve the model list from the `/models` API
-- Target language and ignored languages
+- Translation model name (defaults to `qwen-mt-turbo`)
+- Source and target languages
 - Automatic translation toggle
-The language and model lists include search boxes to make selection easier.
+Click **Test Settings** in the popup to verify the configuration. The extension uses the streaming API for responsive translations.
 
 ## Usage
 Click the extension icon and choose **Translate Page**. If automatic translation is enabled the page will be translated on load. Translations apply to dynamically added content.
diff --git a/src/background.js b/src/background.js
index 138ca87..2ac3283 100644
--- a/src/background.js
+++ b/src/background.js
@@ -4,11 +4,11 @@ chrome.runtime.onInstalled.addListener(() => {
 
 chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
   if (msg.action === 'translate') {
-    const { endpoint, apiKey, model, text, target } = msg.opts;
+    const { endpoint, apiKey, model, text, source, target } = msg.opts;
     const ep = endpoint.endsWith('/') ? endpoint : `${endpoint}/`;
     const controller = new AbortController();
     const timer = setTimeout(() => controller.abort(), 10000);
-    const url = `${ep}services/aigc/mt/text-translator/generation`;
+    const url = `${ep}services/aigc/mt/text-translator/generation-stream`;
     console.log('Background translating via', url);
     fetch(url, {
       method: 'POST',
@@ -18,7 +18,7 @@ chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
       },
       body: JSON.stringify({
         model,
-        input: { source_language: 'auto', target_language: target, text },
+        input: { source_language: source, target_language: target, text },
       }),
       signal: controller.signal,
     })
@@ -29,12 +29,28 @@ chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
           sendResponse({ error: `HTTP ${resp.status}: ${err.message}` });
           return;
         }
-        const data = await resp.json();
-        if (!data.output || !data.output.text) {
-          sendResponse({ error: 'Invalid API response' });
-          return;
+        const reader = resp.body.getReader();
+        const decoder = new TextDecoder();
+        let buffer = '';
+        let result = '';
+        while (true) {
+          const { value, done } = await reader.read();
+          if (done) break;
+          buffer += decoder.decode(value, { stream: true });
+          const lines = buffer.split('\n');
+          buffer = lines.pop();
+          for (const line of lines) {
+            const trimmed = line.trim();
+            if (!trimmed.startsWith('data:')) continue;
+            const data = trimmed.slice(5).trim();
+            if (data === '[DONE]') { reader.cancel(); break; }
+            try {
+              const obj = JSON.parse(data);
+              if (obj.output && obj.output.text) result += obj.output.text;
+            } catch {}
+          }
         }
-        sendResponse({ text: data.output.text, detected_language: data.output.detected_language });
+        sendResponse({ text: result });
       })
       .catch(err => {
         clearTimeout(timer);
diff --git a/src/config.js b/src/config.js
index d0a3033..31ddb49 100644
--- a/src/config.js
+++ b/src/config.js
@@ -1,10 +1,10 @@
 const defaultCfg = {
   apiKey: '',
-  apiEndpoint: 'https://dashscope-intl.aliyuncs.com/api/v1/',
+  apiEndpoint: 'https://dashscope-intl.aliyuncs.com/api/v1',
+  model: 'qwen-mt-turbo',
+  sourceLanguage: 'en',
   targetLanguage: 'en',
-  ignoredLanguages: [],
   autoTranslate: false,
-  model: 'qwen-mt-turbo',
 };
 
 function qwenLoadConfig() {
diff --git a/src/contentScript.js b/src/contentScript.js
index 3ee8dfb..d2c0951 100644
--- a/src/contentScript.js
+++ b/src/contentScript.js
@@ -35,18 +35,16 @@ async function translateNode(node) {
   try {
     const controller = new AbortController();
     const timeout = setTimeout(() => controller.abort(), 10000);
-    const { text: translated, detected_language } = await window.qwenTranslate({
+    const { text: translated } = await window.qwenTranslate({
       endpoint: currentConfig.apiEndpoint,
       apiKey: currentConfig.apiKey,
       model: currentConfig.model,
       text,
+      source: currentConfig.sourceLanguage,
       target: currentConfig.targetLanguage,
       signal: controller.signal,
     });
     clearTimeout(timeout);
-    if (currentConfig.ignoredLanguages.includes(detected_language) || detected_language === currentConfig.targetLanguage) {
-      return;
-    }
     node.textContent = translated;
     mark(node);
   } catch (e) {
diff --git a/src/manifest.json b/src/manifest.json
index c33b431..874efba 100644
--- a/src/manifest.json
+++ b/src/manifest.json
@@ -14,7 +14,6 @@
     "default_popup": "popup.html",
     "default_title": "Qwen Translator"
   },
-  "options_page": "options.html",
   "content_scripts": [
     {
       "matches": ["<all_urls>"],
diff --git a/src/options.html b/src/options.html
deleted file mode 100644
index 421b40c..0000000
--- a/src/options.html
+++ /dev/null
@@ -1,28 +0,0 @@
-<!DOCTYPE html>
-<html>
-<head>
-  <meta charset="utf-8">
-  <style>
-    body { font-family: Arial, sans-serif; width: 400px; padding: 10px; }
-    label { display: block; margin-top: 10px; }
-    input[type="text"], select { width: 100%; box-sizing: border-box; }
-    small { color: #555; }
-    button { margin-top: 5px; }
-    #msg { margin-top: 10px; font-size: 12px; color: #060; }
-  </style>
-</head>
-<body>
-  <h1>Qwen Translator Options</h1>
-  <label title="Your DashScope API key. Get it from the Alibaba Cloud console.">API Key <input type="text" id="apiKey" /></label>
-  <label title="Override the API URL if needed.">API Endpoint <input type="text" id="apiEndpoint" /></label>
-  <label title="Select the translation model. Use Refresh to retrieve the latest list from the API.">Model <input type="search" id="modelSearch" placeholder="Search" /> <select id="model"></select> <button id="refresh">Refresh</button></label>
-  <label title="Language to translate into.">Target Language <input type="search" id="targetSearch" placeholder="Search" /> <select id="target"></select></label>
-  <label title="Languages that should never be translated.">Ignored Languages <input type="search" id="ignoredSearch" placeholder="Search" /> <select id="ignored" multiple size="5"></select></label>
-  <label title="Automatically translate when the page loads."><input type="checkbox" id="auto"/> Translate automatically</label>
-  <button id="save">Save</button>
-  <div id="msg"></div>
-  <script src="config.js"></script>
-  <script src="languages.js"></script>
-  <script src="options.js"></script>
-</body>
-</html>
diff --git a/src/options.js b/src/options.js
deleted file mode 100644
index b42eef0..0000000
--- a/src/options.js
+++ /dev/null
@@ -1,107 +0,0 @@
-const apiKeyInput = document.getElementById('apiKey');
-const endpointInput = document.getElementById('apiEndpoint');
-const modelSelect = document.getElementById('model');
-const targetSelect = document.getElementById('target');
-const ignoredSelect = document.getElementById('ignored');
-const modelSearch = document.getElementById('modelSearch');
-const targetSearch = document.getElementById('targetSearch');
-const ignoredSearch = document.getElementById('ignoredSearch');
-const autoCheckbox = document.getElementById('auto');
-const msg = document.getElementById('msg');
-
-function populateLanguages() {
-  window.qwenLanguages.forEach(l => {
-    const opt = document.createElement('option');
-    opt.value = l.code; opt.textContent = l.name;
-    targetSelect.appendChild(opt.cloneNode(true));
-    ignoredSelect.appendChild(opt);
-  });
-}
-
-function attachSearch(select, input) {
-  input.addEventListener('input', () => {
-    const q = input.value.toLowerCase();
-    [...select.options].forEach(o => {
-      o.hidden = !o.textContent.toLowerCase().includes(q);
-    });
-  });
-}
-
-function withSlash(url) {
-  return url.endsWith('/') ? url : `${url}/`;
-}
-
-async function fetchModels() {
-  const endpoint = withSlash(endpointInput.value.trim());
-  const key = apiKeyInput.value.trim();
-  try {
-    // if the endpoint already points to the models path do not append again
-    const url = endpoint.endsWith('models/') ? endpoint : `${endpoint}models`;
-    console.log('Fetching models from', url);
-    const res = await fetch(url, {
-      headers: { 'Authorization': `Bearer ${key}` }
-    });
-    if (!res.ok) {
-      const errTxt = await res.text().catch(() => res.statusText);
-      throw new Error(`Model fetch failed (${res.status}): ${errTxt}`);
-    }
-    const data = await res.json();
-    modelSelect.innerHTML = '';
-    const list = Array.isArray(data.models)
-      ? data.models
-      : Array.isArray(data.data)
-        ? data.data
-        : Array.isArray(data)
-          ? data
-          : [];
-    list
-      .map(m => (typeof m === 'string' ? m : m.model || m.id))
-      .filter(n => typeof n === 'string' && n.includes('qwen-mt'))
-      .forEach(name => {
-        const opt = document.createElement('option');
-        opt.value = name;
-        opt.textContent = name;
-        modelSelect.appendChild(opt);
-      });
-    attachSearch(modelSelect, modelSearch);
-  } catch (e) {
-    console.error('Model fetch error:', e);
-    msg.textContent = e.message;
-    setTimeout(() => { msg.textContent = ''; }, 5000);
-  }
-}
-
-document.getElementById('refresh').addEventListener('click', fetchModels);
-
-populateLanguages();
-attachSearch(targetSelect, targetSearch);
-attachSearch(ignoredSelect, ignoredSearch);
-
-window.qwenLoadConfig().then(cfg => {
-  apiKeyInput.value = cfg.apiKey;
-  endpointInput.value = cfg.apiEndpoint;
-  autoCheckbox.checked = cfg.autoTranslate;
-  targetSelect.value = cfg.targetLanguage;
-  cfg.ignoredLanguages.forEach(l => {
-    const opt = [...ignoredSelect.options].find(o => o.value === l);
-    if (opt) opt.selected = true;
-  });
-  fetchModels().then(() => {
-    modelSelect.value = cfg.model;
-  });
-});
-
-document.getElementById('save').addEventListener('click', () => {
-  const cfg = {
-    apiKey: apiKeyInput.value.trim(),
-    apiEndpoint: withSlash(endpointInput.value.trim()),
-    model: modelSelect.value,
-    targetLanguage: targetSelect.value,
-    ignoredLanguages: [...ignoredSelect.selectedOptions].map(o => o.value),
-    autoTranslate: autoCheckbox.checked
-  };
-  window.qwenSaveConfig(cfg).then(() => {
-    msg.textContent = 'Saved';
-    setTimeout(() => { msg.textContent = ''; }, 2000);
-  });
-});
diff --git a/src/popup.html b/src/popup.html
index 1fc05c9..f6a79ac 100644
--- a/src/popup.html
+++ b/src/popup.html
@@ -3,16 +3,26 @@
 <head>
   <meta charset="utf-8">
   <style>
-    body { font-family: Arial, sans-serif; width: 220px; padding: 10px; }
-    button { width: 100%; margin-top: 5px; padding: 6px; }
-    #status { margin-top: 5px; font-size: 12px; color: #555; }
+    body { font-family: Arial, sans-serif; width: 240px; padding: 10px; }
+    label { display:block; margin-top:4px; font-size:12px; }
+    input[type=text], select { width:100%; box-sizing:border-box; margin-top:2px; }
+    button { width: 100%; margin-top:6px; padding:6px; }
+    #status { margin-top:5px; font-size:12px; color:#555; min-height:16px; }
   </style>
 </head>
 <body>
   <button id="translate" title="Translate the current tab">Translate Page</button>
-  <button id="options" title="Open settings">Options</button>
+  <label>API Key <input type="text" id="apiKey"></label>
+  <label>API Endpoint <input type="text" id="apiEndpoint"></label>
+  <label>Model <input type="text" id="model"></label>
+  <label>Source <select id="source"></select></label>
+  <label>Target <select id="target"></select></label>
+  <label><input type="checkbox" id="auto"> Translate automatically</label>
+  <button id="save">Save</button>
+  <button id="test">Test Settings</button>
   <div id="status"></div>
   <script src="config.js"></script>
+  <script src="languages.js"></script>
   <script src="popup.js"></script>
 </body>
 </html>
diff --git a/src/popup.js b/src/popup.js
index 253ee61..17225a6 100644
--- a/src/popup.js
+++ b/src/popup.js
@@ -1,17 +1,66 @@
+const apiKeyInput = document.getElementById('apiKey');
+const endpointInput = document.getElementById('apiEndpoint');
+const modelInput = document.getElementById('model');
+const sourceSelect = document.getElementById('source');
+const targetSelect = document.getElementById('target');
+const autoCheckbox = document.getElementById('auto');
+const status = document.getElementById('status');
+
+function populateLanguages() {
+  window.qwenLanguages.forEach(l => {
+    const opt = document.createElement('option');
+    opt.value = l.code; opt.textContent = l.name;
+    sourceSelect.appendChild(opt.cloneNode(true));
+    targetSelect.appendChild(opt);
+  });
+}
+
+populateLanguages();
+
 window.qwenLoadConfig().then(cfg => {
-  if (!cfg.apiKey) {
-    document.getElementById('status').textContent = 'Set API key in options';
-  }
+  apiKeyInput.value = cfg.apiKey;
+  endpointInput.value = cfg.apiEndpoint;
+  modelInput.value = cfg.model;
+  sourceSelect.value = cfg.sourceLanguage;
+  targetSelect.value = cfg.targetLanguage;
+  autoCheckbox.checked = cfg.autoTranslate;
+  if (!cfg.apiKey) status.textContent = 'Set API key';
 });
 
 document.getElementById('translate').addEventListener('click', () => {
   chrome.tabs.query({active: true, currentWindow: true}, (tabs) => {
     chrome.tabs.sendMessage(tabs[0].id, {action: 'start'});
   });
-  document.getElementById('status').textContent = 'Translation started';
-  console.log('Translate button clicked');
 });
 
-document.getElementById('options').addEventListener('click', () => {
-  chrome.runtime.openOptionsPage();
+document.getElementById('save').addEventListener('click', () => {
+  const cfg = {
+    apiKey: apiKeyInput.value.trim(),
+    apiEndpoint: endpointInput.value.trim(),
+    model: modelInput.value.trim(),
+    sourceLanguage: sourceSelect.value,
+    targetLanguage: targetSelect.value,
+    autoTranslate: autoCheckbox.checked,
+  };
+  window.qwenSaveConfig(cfg).then(() => {
+    status.textContent = 'Saved';
+    setTimeout(() => { status.textContent = ''; }, 2000);
+  });
+});
+
+document.getElementById('test').addEventListener('click', async () => {
+  status.textContent = 'Testing...';
+  try {
+    await window.qwenTranslate({
+      endpoint: endpointInput.value.trim(),
+      apiKey: apiKeyInput.value.trim(),
+      model: modelInput.value.trim(),
+      source: sourceSelect.value,
+      text: 'hello',
+      target: targetSelect.value,
+    });
+    status.textContent = 'Configuration OK';
+  } catch (e) {
+    status.textContent = `Error: ${e.message}`;
+  }
 });
diff --git a/src/translator.js b/src/translator.js
index 6f934f8..6485b36 100644
--- a/src/translator.js
+++ b/src/translator.js
@@ -9,12 +9,15 @@ function withSlash(url) {
   return url.endsWith('/') ? url : `${url}/`;
 }
 
-async function doFetch({ endpoint, apiKey, model, text, target, signal }) {
-  const url = `${withSlash(endpoint)}services/aigc/mt/text-translator/generation`;
+async function doFetch({ endpoint, apiKey, model, text, source, target, signal }) {
+  const streamPath = `${withSlash(endpoint)}services/aigc/mt/text-translator/generation-stream`;
+  const url = (typeof window === 'undefined')
+    ? `${withSlash(endpoint)}services/aigc/mt/text-translator/generation`
+    : streamPath;
   console.log('Sending translation request to', url);
   const body = {
     model,
-    input: { source_language: 'auto', target_language: target, text },
+    input: { source_language: source, target_language: target, text },
   };
   const resp = await fetchFn(url, {
     method: 'POST',
@@ -31,15 +34,45 @@ async function doFetch({ endpoint, apiKey, model, text, target, signal }) {
       .catch(() => ({ message: resp.statusText }));
     throw new Error(`HTTP ${resp.status}: ${err.message || 'Translation failed'}`);
   }
-  const data = await resp.json();
-  if (!data.output || !data.output.text) {
-    throw new Error('Invalid API response');
+  if (!resp.body || typeof resp.body.getReader !== 'function') {
+    const data = await resp.json();
+    if (!data.output || !data.output.text) {
+      throw new Error('Invalid API response');
+    }
+    return data.output;
   }
-  return data.output;
+
+  const reader = resp.body.getReader();
+  const decoder = new TextDecoder();
+  let buffer = '';
+  let result = '';
+  while (true) {
+    const { value, done } = await reader.read();
+    if (done) break;
+    buffer += decoder.decode(value, { stream: true });
+    const lines = buffer.split('\n');
+    buffer = lines.pop();
+    for (const line of lines) {
+      const trimmed = line.trim();
+      if (!trimmed.startsWith('data:')) continue;
+      const data = trimmed.slice(5).trim();
+      if (data === '[DONE]') {
+        reader.cancel();
+        break;
+      }
+      try {
+        const obj = JSON.parse(data);
+        if (obj.output && obj.output.text) {
+          result += obj.output.text;
+        }
+      } catch {}
+    }
+  }
+  return { text: result };
 }
 
-async function qwenTranslate({ endpoint, apiKey, model, text, target, signal }) {
-  const cacheKey = `${target}:${text}`;
+async function qwenTranslate({ endpoint, apiKey, model, text, source, target, signal }) {
+  const cacheKey = `${source}:${target}:${text}`;
   if (cache.has(cacheKey)) {
     return cache.get(cacheKey);
   }
@@ -48,7 +81,7 @@ async function qwenTranslate({ endpoint, apiKey, model, text, target, signal })
     const ep = withSlash(endpoint);
     const result = await new Promise((resolve, reject) => {
       console.log('Requesting translation via background script');
-      chrome.runtime.sendMessage({ action: 'translate', opts: { endpoint: ep, apiKey, model, text, target } }, res => {
+      chrome.runtime.sendMessage({ action: 'translate', opts: { endpoint: ep, apiKey, model, text, source, target } }, res => {
         if (chrome.runtime.lastError) {
           reject(new Error(chrome.runtime.lastError.message));
         } else if (res && res.error) {
@@ -63,7 +96,7 @@ async function qwenTranslate({ endpoint, apiKey, model, text, target, signal })
   }
 
   try {
-    const data = await doFetch({ endpoint, apiKey, model, text, target, signal });
+    const data = await doFetch({ endpoint, apiKey, model, text, source, target, signal });
     cache.set(cacheKey, data);
     return data;
   } catch (e) {
diff --git a/test/translator.test.js b/test/translator.test.js
index 5ab3d03..be9854f 100644
--- a/test/translator.test.js
+++ b/test/translator.test.js
@@ -10,20 +10,20 @@ beforeEach(() => {
 
 test('translate success', async () => {
   fetch.mockResponseOnce(JSON.stringify({output:{text:'hello'}}));
-  const res = await translate({endpoint:'https://example.com/', apiKey:'key', model:'m', text:'hola', target:'en'});
+  const res = await translate({endpoint:'https://example.com/', apiKey:'key', model:'m', text:'hola', source:'es', target:'en'});
   expect(res.text).toBe('hello');
 });
 
 test('translate error', async () => {
   fetch.mockResponseOnce(JSON.stringify({message:'bad'}), {status:400});
-  await expect(translate({endpoint:'https://e/', apiKey:'k', model:'m', text:'x', target:'en'})).rejects.toThrow('bad');
+  await expect(translate({endpoint:'https://e/', apiKey:'k', model:'m', text:'x', source:'es', target:'en'})).rejects.toThrow('bad');
 });
 
 test('translate caching', async () => {
   fetch.mockResponseOnce(JSON.stringify({output:{text:'hi'}}));
-  const first = await translate({endpoint:'https://e/', apiKey:'k', model:'m', text:'hola', target:'en'});
+  const first = await translate({endpoint:'https://e/', apiKey:'k', model:'m', text:'hola', source:'es', target:'en'});
   expect(first.text).toBe('hi');
-  const cached = await translate({endpoint:'https://e/', apiKey:'k', model:'m', text:'hola', target:'en'});
+  const cached = await translate({endpoint:'https://e/', apiKey:'k', model:'m', text:'hola', source:'es', target:'en'});
   expect(fetch).toHaveBeenCalledTimes(1);
   expect(cached.text).toBe('hi');
 });
-- 
2.50.0

