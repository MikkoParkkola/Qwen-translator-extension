From 3073a6123805e1f26a0da54ba93847a19cac9930 Mon Sep 17 00:00:00 2001
From: MikkoParkkola <78788115+MikkoParkkola@users.noreply.github.com>
Date: Mon, 18 Aug 2025 07:44:30 +0200
Subject: [PATCH] fix: guard offline HUD against stale timers

---
 package-lock.json          |  4 ++--
 package.json               |  2 +-
 src/background.js          | 26 +++++++++++++++++++++--
 src/contentScript.js       | 43 ++++++++++++++++++++++++++++++++------
 src/i18n/en.json           |  3 ++-
 src/i18n/zh.json           |  3 ++-
 test/contentScript.test.js | 41 ++++++++++++++++++++++++++++++++++++
 7 files changed, 109 insertions(+), 13 deletions(-)

diff --git a/package-lock.json b/package-lock.json
index c45bd02..1a4c756 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -1,12 +1,12 @@
 {
   "name": "qwen-translator-extension",
-  "version": "1.32.0",
+  "version": "1.33.1",
   "lockfileVersion": 3,
   "requires": true,
   "packages": {
     "": {
       "name": "qwen-translator-extension",
-      "version": "1.32.0",
+      "version": "1.33.1",
       "hasInstallScript": true,
       "license": "AGPL-3.0-or-later",
       "dependencies": {
diff --git a/package.json b/package.json
index b5c89ff..9ae5307 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "qwen-translator-extension",
-  "version": "1.32.0",
+  "version": "1.33.1",
   "description": "Extension to translate web pages using Qwen-MT-Turbo model",
   "main": "index.js",
   "scripts": {
diff --git a/src/background.js b/src/background.js
index 340dc5d..52d4952 100644
--- a/src/background.js
+++ b/src/background.js
@@ -61,6 +61,16 @@ function safeSendMessage(msg) {
   } catch {}
 }
 
+function isOfflineError(err) {
+  return (typeof navigator !== 'undefined' && navigator.onLine === false) ||
+    /network|fetch|offline/i.test((err && err.message) || '') ||
+    (err && err.code === 'ERR_NETWORK');
+}
+
+function notifyOffline() {
+  safeSendMessage({ action: 'offline' });
+}
+
 function calibrateLimits(force) {
   if (!self.qwenLimitDetector || !chrome?.storage?.sync) return;
   chrome.storage.sync.get({ apiEndpoint: '', model: '', requestLimit: 60, tokenLimit: 100000, calibratedAt: 0 }, async cfg => {
@@ -541,6 +551,10 @@ async function handleTranslate(opts) {
     logger.error('background translation error', err);
     logUsage(tokens, Date.now() - start);
     iconError = true;
+    if (isOfflineError(err)) {
+      notifyOffline();
+      return { error: 'offline' };
+    }
     return { error: err.message };
   } finally {
     clearTimeout(timeout);
@@ -554,7 +568,10 @@ chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
   if (msg.action === 'translate') {
     handleTranslate(msg.opts)
       .then(sendResponse)
-      .catch(err => sendResponse({ error: err.message }));
+      .catch(err => {
+        if (isOfflineError(err)) notifyOffline();
+        sendResponse({ error: err.message });
+      });
     return true;
   }
   if (msg.action === 'ping') {
@@ -815,7 +832,12 @@ chrome.runtime.onConnect.addListener(port => {
         logger.error('background port translation error', err);
         logUsage(tokens, Date.now() - start);
         iconError = true;
-        try { port.postMessage({ requestId, error: err.message }); } catch {}
+        if (isOfflineError(err)) {
+          notifyOffline();
+          try { port.postMessage({ requestId, error: 'offline' }); } catch {}
+        } else {
+          try { port.postMessage({ requestId, error: err.message }); } catch {}
+        }
       } finally {
         clearTimeout(timeout);
         inflight.delete(requestId);
diff --git a/src/contentScript.js b/src/contentScript.js
index 29141ad..01f86a1 100644
--- a/src/contentScript.js
+++ b/src/contentScript.js
@@ -12,6 +12,7 @@ if (typeof window !== 'undefined' && window.__qwenCSLoaded) {
   const batchQueue = [];
   let processing = false;
   let statusTimer;
+  let statusSeq = 0;
   const pending = new Set();
   let flushTimer;
   const controllers = new Set();
@@ -102,12 +103,16 @@ function setStatus(message, isError = false) {
     chrome.runtime.sendMessage({ action: 'popup-status', text: message, error: isError }, handleLastError());
   } catch {}
   if (statusTimer) clearTimeout(statusTimer);
-  if (isError) statusTimer = setTimeout(clearStatus, 5000);
+  const seq = ++statusSeq;
+  if (isError) statusTimer = setTimeout(() => {
+    if (seq === statusSeq) clearStatus();
+  }, 5000);
 }
 
 function clearStatus() {
   const el = document.getElementById('qwen-status');
   if (el) el.remove();
+  statusTimer = null;
 }
 
 function updateProgressHud() {
@@ -134,6 +139,18 @@ function showError(message) {
   setStatus(message, true);
 }
 
+function isOfflineError(err) {
+  return (typeof navigator !== 'undefined' && navigator.onLine === false) ||
+    /network|fetch|offline/i.test((err && err.message) || '') ||
+    (err && err.code === 'ERR_NETWORK');
+}
+
+function showOffline() {
+  const msg = (window.qwenI18n && window.qwenI18n.t) ? window.qwenI18n.t('status.offline') : 'Offline';
+  setStatus(msg, true);
+  try { chrome.runtime.sendMessage({ action: 'offline', text: msg }, handleLastError()); } catch {}
+}
+
 function setupPrefetchObserver() {
   if (prefetchObserver !== undefined) return;
   if (typeof IntersectionObserver === 'undefined') {
@@ -428,7 +445,11 @@ async function translateNode(node) {
     node.textContent = leading + translated + trailing;
     mark(node);
   } catch (e) {
-    showError(`${e.message}. See console for details.`);
+    if (isOfflineError(e)) {
+      showOffline();
+    } else {
+      showError(`${e.message}. See console for details.`);
+    }
     logger.error('QTERROR: translation error', e);
   } finally {
     controllers.delete(controller);
@@ -532,8 +553,12 @@ async function processQueue() {
     try {
       await translateBatch(item.nodes, stats);
     } catch (e) {
-      showError(`${e.message}. See console for details.`);
-      logger.error('QTERROR: batch translation error', e && e.message, e);
+      if (isOfflineError(e)) {
+        showOffline();
+      } else {
+        showError(`${e.message}. See console for details.`);
+        logger.error('QTERROR: batch translation error', e && e.message, e);
+      }
       item.enqueued = Date.now();
       batchQueue.push(item);
       await new Promise(r => setTimeout(r, 1000));
@@ -758,7 +783,12 @@ chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
         clearTimeout(timer);
         if (cfg.debug) logger.debug('QTDEBUG: test-e2e sending error', err);
         el.remove();
-        sendResponse({ error: err.message, stack: err.stack });
+        if (isOfflineError(err)) {
+          showOffline();
+          sendResponse({ error: 'offline' });
+        } else {
+          sendResponse({ error: err.message, stack: err.stack });
+        }
       });
     return true;
   }
@@ -791,7 +821,8 @@ chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
         addFeedbackUI(node, text, translated, res.confidence);
         sel.removeAllRanges();
       } catch (e) {
-        showError('Translation failed');
+        if (isOfflineError(e)) showOffline();
+        else showError('Translation failed');
       }
     })();
   }
diff --git a/src/i18n/en.json b/src/i18n/en.json
index d745afe..bcf306d 100644
--- a/src/i18n/en.json
+++ b/src/i18n/en.json
@@ -8,5 +8,6 @@
   "bubble.translate": "Translate",
   "bubble.pin": "Pin",
   "bubble.copy": "Copy",
-  "bubble.ariaLabel": "Translation result"
+  "bubble.ariaLabel": "Translation result",
+  "status.offline": "Offline. Please check your connection."
 }
diff --git a/src/i18n/zh.json b/src/i18n/zh.json
index d9dc3e6..0b60843 100644
--- a/src/i18n/zh.json
+++ b/src/i18n/zh.json
@@ -8,5 +8,6 @@
   "bubble.translate": "翻译",
   "bubble.pin": "固定",
   "bubble.copy": "复制",
-  "bubble.ariaLabel": "翻译结果"
+  "bubble.ariaLabel": "翻译结果",
+  "status.offline": "离线：请检查网络连接"
 }
diff --git a/test/contentScript.test.js b/test/contentScript.test.js
index 426dfb5..534801c 100644
--- a/test/contentScript.test.js
+++ b/test/contentScript.test.js
@@ -227,3 +227,44 @@ test('shows bubble on text selection and translates', async () => {
   expect(bubble.textContent).toBe('T:Hello');
 });
 
+test('emits offline status when translation fails', async () => {
+  sendMessage.mockClear();
+  const origOnline = navigator.onLine;
+  Object.defineProperty(navigator, 'onLine', { value: false, configurable: true });
+  const originalTranslate = window.qwenTranslate;
+  window.qwenTranslate = jest.fn().mockRejectedValue(new Error('Failed to fetch'));
+  setCurrentConfig({ apiEndpoint: 'https://e/', model: 'm', sourceLanguage: 'en', targetLanguage: 'es', debug: false });
+  document.body.innerHTML = '<p id="s">Hello</p>';
+  const range = document.createRange();
+  range.selectNodeContents(document.getElementById('s'));
+  const sel = window.getSelection();
+  sel.removeAllRanges();
+  sel.addRange(range);
+  messageListener({ action: 'translate-selection' });
+  await new Promise(r => setTimeout(r, 0));
+  const offlineCall = sendMessage.mock.calls.find(([msg]) => msg.action === 'offline');
+  expect(offlineCall && offlineCall[0].text).toContain('Offline');
+  const status = document.getElementById('qwen-status');
+  expect(status.textContent).toContain('Offline');
+  Object.defineProperty(navigator, 'onLine', { value: origOnline, configurable: true });
+  window.qwenTranslate = originalTranslate;
+});
+
+test('offline error detected by error code', async () => {
+  sendMessage.mockClear();
+  const originalTranslate = window.qwenTranslate;
+  window.qwenTranslate = jest.fn().mockRejectedValue({ code: 'ERR_NETWORK', message: 'network down' });
+  setCurrentConfig({ apiEndpoint: 'https://e/', model: 'm', sourceLanguage: 'en', targetLanguage: 'es', debug: false });
+  document.body.innerHTML = '<p id="s">Hi</p>';
+  const range = document.createRange();
+  range.selectNodeContents(document.getElementById('s'));
+  const sel = window.getSelection();
+  sel.removeAllRanges();
+  sel.addRange(range);
+  messageListener({ action: 'translate-selection' });
+  await new Promise(r => setTimeout(r, 0));
+  const offlineCall = sendMessage.mock.calls.find(([msg]) => msg.action === 'offline');
+  expect(offlineCall).toBeTruthy();
+  window.qwenTranslate = originalTranslate;
+});
+
-- 
2.50.0

