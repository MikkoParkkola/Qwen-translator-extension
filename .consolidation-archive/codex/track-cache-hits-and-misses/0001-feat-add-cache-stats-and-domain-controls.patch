From 2f3f8cf5be53ce5763eb8b05cdb86c823538a423 Mon Sep 17 00:00:00 2001
From: MikkoParkkola <78788115+MikkoParkkola@users.noreply.github.com>
Date: Wed, 13 Aug 2025 10:06:47 +0200
Subject: [PATCH] feat: add cache stats and domain controls

---
 src/background.js       |  10 +++
 src/batch.js            |  10 +--
 src/cache.js            |  49 ++++++++++-
 src/contentScript.js    |   9 ++
 src/popup.html          |   4 +
 src/popup.js            | 178 +++++++++++++++++++++++++++-------------
 src/translator.js       |  14 ++--
 test/popupCache.test.js |   6 ++
 test/popupCost.test.js  |   6 ++
 9 files changed, 214 insertions(+), 72 deletions(-)

diff --git a/src/background.js b/src/background.js
index 24eca58..0bec974 100644
--- a/src/background.js
+++ b/src/background.js
@@ -274,6 +274,16 @@ chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
     sendResponse({ ok: true });
     return true;
   }
+  if (msg.action === 'clear-cache-domain') {
+    if (self.qwenClearCacheDomain) self.qwenClearCacheDomain(msg.domain);
+    sendResponse({ ok: true });
+    return true;
+  }
+  if (msg.action === 'clear-cache-pair') {
+    if (self.qwenClearCacheLangPair) self.qwenClearCacheLangPair(msg.source, msg.target);
+    sendResponse({ ok: true });
+    return true;
+  }
   if (msg.action === 'config-changed') {
     throttleReady = null;
     chrome.storage.sync.get(
diff --git a/src/batch.js b/src/batch.js
index c8d87a6..fa7d49b 100644
--- a/src/batch.js
+++ b/src/batch.js
@@ -174,7 +174,7 @@
       const words = joinedText.replaceAll(SEP, ' ').trim().split(/\s+/).filter(Boolean).length;
       let res;
       try {
-        res = await qwenTranslate({ ...opts, text: joinedText, onRetry, retryDelay, force: opts.force });
+        res = await qwenTranslate({ ...opts, text: joinedText, onRetry, retryDelay, force: opts.force, domain: opts.domain });
       } catch (e) {
         if (/HTTP\s+400/i.test(e.message || '')) throw e;
         g.forEach(m => {
@@ -194,14 +194,14 @@
         for (const m of g) {
           let out;
           try {
-            const single = await qwenTranslate({ ...opts, text: m.text, onRetry, retryDelay, force: opts.force });
+            const single = await qwenTranslate({ ...opts, text: m.text, onRetry, retryDelay, force: opts.force, domain: opts.domain });
             out = single.text;
           } catch {
             out = m.text;
           }
           m.result = out;
           const key = `${provider}:${opts.source}:${opts.target}:${m.text}`;
-          setCache(key, { text: out });
+          setCache(key, { text: out }, opts.domain);
           stats.requests++;
           stats.tokens += approxTokens(m.text);
           stats.words += m.text.trim().split(/\s+/).filter(Boolean).length;
@@ -211,7 +211,7 @@
       for (let i = 0; i < g.length; i++) {
         g[i].result = translated[i] || g[i].text;
         const key = `${provider}:${opts.source}:${opts.target}:${g[i].text}`;
-        setCache(key, { text: g[i].result });
+        setCache(key, { text: g[i].result }, opts.domain);
       }
       const elapsedMs = Date.now() - stats.start;
       const avg = elapsedMs / stats.requests;
@@ -255,7 +255,7 @@
       retryIdx.forEach((idx, i) => {
         results[idx] = retr.texts[i];
         const key = `${provider}:${opts.source}:${opts.target}:${texts[idx]}`;
-        setCache(key, { text: results[idx] });
+        setCache(key, { text: results[idx] }, opts.domain);
       });
     }
 
diff --git a/src/cache.js b/src/cache.js
index f094dbb..2579d75 100644
--- a/src/cache.js
+++ b/src/cache.js
@@ -4,6 +4,8 @@ let CACHE_TTL_MS = 30 * 24 * 60 * 60 * 1000; // 30 days
 let cacheReady = Promise.resolve();
 let LZString;
 let compressionErrors = 0;
+let hitCount = 0;
+let missCount = 0;
 
 if (typeof window === 'undefined') {
   LZString = require('lz-string');
@@ -95,16 +97,21 @@ function persistCache(key, value) {
 
 function getCache(key) {
   const entry = cache.get(key);
-  if (!entry) return;
+  if (!entry) {
+    missCount++;
+    return;
+  }
   if (entry.ts && Date.now() - entry.ts > CACHE_TTL_MS) {
     removeCache(key);
+    missCount++;
     return;
   }
+  hitCount++;
   return entry;
 }
 
-function setCache(key, value) {
-  const entry = { ...value, ts: Date.now() };
+function setCache(key, value, origin) {
+  const entry = { ...value, origin, ts: Date.now() };
   cache.set(key, entry);
   if (cache.size > MAX_CACHE_ENTRIES) {
     const first = cache.keys().next().value;
@@ -133,6 +140,8 @@ function removeCache(key) {
 function qwenClearCache() {
   cache.clear();
   compressionErrors = 0;
+  hitCount = 0;
+  missCount = 0;
   if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local) {
     chrome.storage.local.remove('qwenCache');
   } else if (typeof localStorage !== 'undefined') {
@@ -148,6 +157,34 @@ function qwenGetCompressionErrors() {
   return compressionErrors;
 }
 
+function qwenGetCacheStats() {
+  const total = hitCount + missCount;
+  const hitRate = total ? hitCount / total : 0;
+  return { hits: hitCount, misses: missCount, hitRate };
+}
+
+function qwenGetDomainCounts() {
+  const counts = {};
+  cache.forEach(v => {
+    const d = v.origin || 'unknown';
+    counts[d] = (counts[d] || 0) + 1;
+  });
+  return counts;
+}
+
+function qwenClearCacheDomain(domain) {
+  Array.from(cache.entries()).forEach(([k, v]) => {
+    if (v.origin === domain) removeCache(k);
+  });
+}
+
+function qwenClearCacheLangPair(source, target) {
+  Array.from(cache.keys()).forEach(k => {
+    const parts = k.split(':');
+    if (parts[1] === source && parts[2] === target) removeCache(k);
+  });
+}
+
 function _setMaxCacheEntries(n) {
   MAX_CACHE_ENTRIES = n;
 }
@@ -180,6 +217,10 @@ const api = {
   qwenClearCache,
   qwenGetCacheSize,
   qwenGetCompressionErrors,
+   qwenGetCacheStats,
+   qwenGetDomainCounts,
+   qwenClearCacheDomain,
+   qwenClearCacheLangPair,
   qwenSetCacheLimit,
   qwenSetCacheTTL,
   _setMaxCacheEntries,
@@ -189,9 +230,11 @@ const api = {
 
 if (typeof window !== 'undefined') {
   window.qwenCache = api;
+  Object.assign(window, api);
 }
 if (typeof self !== 'undefined' && typeof window === 'undefined') {
   self.qwenCache = api;
+  Object.assign(self, api);
 }
 if (typeof module !== 'undefined') {
   module.exports = api;
diff --git a/src/contentScript.js b/src/contentScript.js
index 6c3cf41..c109471 100644
--- a/src/contentScript.js
+++ b/src/contentScript.js
@@ -172,6 +172,7 @@ async function translateBatch(elements, stats) {
       signal: controller.signal,
       debug: currentConfig.debug,
       force: forceTranslate,
+      domain: location.hostname,
     };
     if (currentConfig.dualMode) {
       opts.models = [
@@ -392,6 +393,12 @@ chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
   if (msg.action === 'clear-cache') {
     if (window.qwenClearCache) window.qwenClearCache();
   }
+  if (msg.action === 'clear-cache-domain') {
+    if (window.qwenClearCacheDomain) window.qwenClearCacheDomain(msg.domain);
+  }
+  if (msg.action === 'clear-cache-pair') {
+    if (window.qwenClearCacheLangPair) window.qwenClearCacheLangPair(msg.source, msg.target);
+  }
   if (msg.action === 'test-read') {
     sendResponse({ title: document.title });
   }
@@ -417,6 +424,7 @@ chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
         debug: cfg.debug,
         stream: false,
         signal: controller.signal,
+        domain: location.hostname,
       })
       .then(res => {
         clearTimeout(timer);
@@ -453,6 +461,7 @@ chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
           source: cfg.sourceLanguage,
           target: cfg.targetLanguage,
           debug: cfg.debug,
+          domain: location.hostname,
           force: true,
         });
         const range = sel.getRangeAt(0);
diff --git a/src/popup.html b/src/popup.html
index 7f5bc25..53508a0 100644
--- a/src/popup.html
+++ b/src/popup.html
@@ -131,10 +131,14 @@
       </div>
       <div class="main-actions">
         <button id="clearCache" title="Remove saved translations">Clear Cache</button>
+        <button id="clearDomain" title="Clear cache for current domain">Clear Domain</button>
+        <button id="clearPair" title="Clear cache for selected languages">Clear Pair</button>
         <span id="cacheSize" style="font-size:0.875rem"></span>
+        <span id="hitRate" style="font-size:0.875rem"></span>
         <span id="compressionErrors" style="font-size:0.875rem"></span>
         <label class="force-toggle"><input type="checkbox" id="force"> Force</label>
       </div>
+      <div id="domainCounts" style="font-size:0.75rem"></div>
 
       <div class="usage-section">
         <div class="usage-item">
diff --git a/src/popup.js b/src/popup.js
index 6bb2061..7f8a9d8 100644
--- a/src/popup.js
+++ b/src/popup.js
@@ -36,11 +36,15 @@ const translateBtn = document.getElementById('translate');
 const testBtn = document.getElementById('test');
 const progressBar = document.getElementById('progress');
 const clearCacheBtn = document.getElementById('clearCache');
+const clearDomainBtn = document.getElementById('clearDomain');
+const clearPairBtn = document.getElementById('clearPair');
 const forceCheckbox = document.getElementById('force');
 const cacheSizeLabel = document.getElementById('cacheSize');
+const hitRateLabel = document.getElementById('hitRate');
 const compressionErrorsLabel = document.getElementById('compressionErrors');
 const cacheLimitInput = document.getElementById('cacheSizeLimit');
 const cacheTTLInput = document.getElementById('cacheTTL');
+const domainCountsDiv = document.getElementById('domainCounts');
 
 const applyProviderConfig =
   (window.qwenProviderConfig && window.qwenProviderConfig.applyProviderConfig) ||
@@ -113,6 +117,7 @@ function syncInputs(from, to) {
 }
 
 function updateView(cfg) {
+  if (!viewContainer) return;
   if (cfg.apiKey && cfg.apiEndpoint && cfg.model) {
     viewContainer.classList.remove('show-setup');
     viewContainer.classList.add('show-main');
@@ -164,8 +169,9 @@ function setWorking(w) {
 }
 
 function updateThrottleInputs() {
-  const manual = !smartThrottleInput.checked;
+  const manual = !(smartThrottleInput && smartThrottleInput.checked);
   [reqLimitInput, tokenLimitInput, tokensPerReqInput, retryDelayInput].forEach(el => {
+    if (!el) return;
     el.disabled = !manual;
     if (!manual) {
       el.placeholder = el.dataset.auto || '';
@@ -266,28 +272,29 @@ chrome.runtime.sendMessage({ action: 'get-status' }, s => {
 window.qwenLoadConfig().then(cfg => {
   currentCfg = cfg;
   // Populate main view
-  apiKeyInput.value = cfg.apiKey || '';
-  endpointInput.value = cfg.apiEndpoint || '';
-  modelInput.value = cfg.model || '';
-  providerSelect.value = cfg.provider || 'qwen';
-  sourceSelect.value = cfg.sourceLanguage;
-  targetSelect.value = cfg.targetLanguage;
-  reqLimitInput.value = cfg.requestLimit;
-  tokenLimitInput.value = cfg.tokenLimit;
-  tokenBudgetInput.value = cfg.tokenBudget || '';
-  autoCheckbox.checked = cfg.autoTranslate;
-  debugCheckbox.checked = !!cfg.debug;
-  smartThrottleInput.checked = cfg.smartThrottle !== false;
-  tokensPerReqInput.value = cfg.tokensPerReq || '';
-  retryDelayInput.value = cfg.retryDelay || '';
-  cacheLimitInput.value = cfg.cacheMaxEntries || '';
-  cacheTTLInput.value = Math.floor((cfg.cacheTTL || 30 * 24 * 60 * 60 * 1000) / (24 * 60 * 60 * 1000));
+  if (apiKeyInput) apiKeyInput.value = cfg.apiKey || '';
+  if (endpointInput) endpointInput.value = cfg.apiEndpoint || '';
+  if (modelInput) modelInput.value = cfg.model || '';
+  if (providerSelect) providerSelect.value = cfg.provider || 'qwen';
+  if (sourceSelect) sourceSelect.value = cfg.sourceLanguage;
+  if (targetSelect) targetSelect.value = cfg.targetLanguage;
+  if (reqLimitInput) reqLimitInput.value = cfg.requestLimit;
+  if (tokenLimitInput) tokenLimitInput.value = cfg.tokenLimit;
+  if (tokenBudgetInput) tokenBudgetInput.value = cfg.tokenBudget || '';
+  if (autoCheckbox) autoCheckbox.checked = cfg.autoTranslate;
+  if (debugCheckbox) debugCheckbox.checked = !!cfg.debug;
+  if (smartThrottleInput) smartThrottleInput.checked = cfg.smartThrottle !== false;
+  if (tokensPerReqInput) tokensPerReqInput.value = cfg.tokensPerReq || '';
+  if (retryDelayInput) retryDelayInput.value = cfg.retryDelay || '';
+  if (cacheLimitInput) cacheLimitInput.value = cfg.cacheMaxEntries || '';
+  if (cacheTTLInput)
+    cacheTTLInput.value = Math.floor((cfg.cacheTTL || 30 * 24 * 60 * 60 * 1000) / (24 * 60 * 60 * 1000));
 
   // Populate setup view
-  setupApiKeyInput.value = cfg.apiKey || '';
-  setupApiEndpointInput.value = cfg.apiEndpoint || '';
-  setupModelInput.value = cfg.model || '';
-  setupProviderInput.value = cfg.provider || 'qwen';
+  if (setupApiKeyInput) setupApiKeyInput.value = cfg.apiKey || '';
+  if (setupApiEndpointInput) setupApiEndpointInput.value = cfg.apiEndpoint || '';
+  if (setupModelInput) setupModelInput.value = cfg.model || '';
+  if (setupProviderInput) setupProviderInput.value = cfg.provider || 'qwen';
 
   updateView(cfg);
   updateProviderFields();
@@ -300,31 +307,39 @@ window.qwenLoadConfig().then(cfg => {
     { main: providerSelect, setup: setupProviderInput, event: 'change' },
   ];
 
-  allInputs.forEach(({main, setup, event}) => {
-    main.addEventListener(event, () => {
-      syncInputs(main, setup);
-      saveConfig();
-      if (event === 'change') refreshUsage();
-    });
-    setup.addEventListener(event, () => {
-      syncInputs(setup, main);
-      saveConfig();
-      if (event === 'change') refreshUsage();
-    });
+  allInputs.forEach(({ main, setup, event }) => {
+    if (main) {
+      main.addEventListener(event, () => {
+        syncInputs(main, setup);
+        saveConfig();
+        if (event === 'change') refreshUsage();
+      });
+    }
+    if (setup) {
+      setup.addEventListener(event, () => {
+        syncInputs(setup, main);
+        saveConfig();
+        if (event === 'change') refreshUsage();
+      });
+    }
   });
 
-  providerSelect.addEventListener('change', updateProviderFields);
-  setupProviderInput.addEventListener('change', updateProviderFields);
+  if (providerSelect) providerSelect.addEventListener('change', updateProviderFields);
+  if (setupProviderInput) setupProviderInput.addEventListener('change', updateProviderFields);
 
   updateThrottleInputs();
-  [reqLimitInput, tokenLimitInput, tokenBudgetInput, tokensPerReqInput, retryDelayInput, cacheLimitInput, cacheTTLInput].forEach(el => el.addEventListener('input', saveConfig));
-  [sourceSelect, targetSelect, autoCheckbox, debugCheckbox, smartThrottleInput].forEach(el => el.addEventListener('change', () => { updateThrottleInputs(); saveConfig(); }));
+  [reqLimitInput, tokenLimitInput, tokenBudgetInput, tokensPerReqInput, retryDelayInput, cacheLimitInput, cacheTTLInput].forEach(el => {
+    if (el) el.addEventListener('input', saveConfig);
+  });
+  [sourceSelect, targetSelect, autoCheckbox, debugCheckbox, smartThrottleInput].forEach(el => {
+    if (el) el.addEventListener('change', () => { updateThrottleInputs(); saveConfig(); });
+  });
   if (window.qwenSetCacheLimit) window.qwenSetCacheLimit(cfg.cacheMaxEntries || 1000);
   if (window.qwenSetCacheTTL) window.qwenSetCacheTTL(cfg.cacheTTL || 30 * 24 * 60 * 60 * 1000);
   updateCacheSize();
 });
 
-versionDiv.textContent = `v${chrome.runtime.getManifest().version}`;
+if (versionDiv) versionDiv.textContent = `v${chrome.runtime.getManifest().version}`;
 
 function setBar(el, ratio) {
   const r = Math.max(0, Math.min(1, ratio));
@@ -340,29 +355,40 @@ function updateCacheSize() {
     const n = window.qwenGetCompressionErrors();
     compressionErrorsLabel.textContent = n ? `Errors: ${n}` : '';
   }
+  if (hitRateLabel && window.qwenGetCacheStats) {
+    const { hits, misses, hitRate } = window.qwenGetCacheStats();
+    const total = hits + misses;
+    const pct = total ? Math.round(hitRate * 100) : 0;
+    hitRateLabel.textContent = `Hit Rate: ${pct}% (${hits}/${total})`;
+  }
+  if (domainCountsDiv && window.qwenGetDomainCounts) {
+    const counts = window.qwenGetDomainCounts();
+    const parts = Object.entries(counts).map(([d, c]) => `${d}: ${c}`);
+    domainCountsDiv.textContent = parts.join(', ');
+  }
 }
 
 function refreshUsage() {
   chrome.runtime.sendMessage({ action: 'usage' }, res => {
     if (chrome.runtime.lastError || !res) return;
-    reqCount.textContent = `${res.requests}/${res.requestLimit}`;
-    tokenCount.textContent = `${res.tokens}/${res.tokenLimit}`;
-    setBar(reqBar, res.requests / res.requestLimit);
-    setBar(tokenBar, res.tokens / res.tokenLimit);
-    totalReq.textContent = res.totalRequests;
-    totalTok.textContent = res.totalTokens;
-    queueLen.textContent = res.queue;
-    failedReq.textContent = res.failedTotalRequests;
-    failedTok.textContent = res.failedTotalTokens;
-    if (res.models) {
+    if (reqCount) reqCount.textContent = `${res.requests}/${res.requestLimit}`;
+    if (tokenCount) tokenCount.textContent = `${res.tokens}/${res.tokenLimit}`;
+    if (reqBar) setBar(reqBar, res.requests / res.requestLimit);
+    if (tokenBar) setBar(tokenBar, res.tokens / res.tokenLimit);
+    if (totalReq) totalReq.textContent = res.totalRequests;
+    if (totalTok) totalTok.textContent = res.totalTokens;
+    if (queueLen) queueLen.textContent = res.queue;
+    if (failedReq) failedReq.textContent = res.failedTotalRequests;
+    if (failedTok) failedTok.textContent = res.failedTotalTokens;
+    if (res.models && turboReq && plusReq) {
       const turbo = res.models['qwen-mt-turbo'] || { requests: 0, requestLimit: 0 };
       const plus = res.models['qwen-mt-plus'] || { requests: 0, requestLimit: 0 };
       turboReq.textContent = `${turbo.requests}/${turbo.requestLimit}`;
       plusReq.textContent = `${plus.requests}/${plus.requestLimit}`;
-      setBar(turboReqBar, turbo.requestLimit ? turbo.requests / turbo.requestLimit : 0);
-      setBar(plusReqBar, plus.requestLimit ? plus.requests / plus.requestLimit : 0);
+      if (turboReqBar) setBar(turboReqBar, turbo.requestLimit ? turbo.requests / turbo.requestLimit : 0);
+      if (plusReqBar) setBar(plusReqBar, plus.requestLimit ? plus.requests / plus.requestLimit : 0);
     }
-    if (res.costs) {
+    if (res.costs && costTurbo24h) {
       const turbo = res.costs['qwen-mt-turbo'];
       const plus = res.costs['qwen-mt-plus'];
       const total = res.costs.total;
@@ -384,13 +410,13 @@ function refreshUsage() {
         });
       }
     }
-    reqLimitInput.dataset.auto = res.requestLimit;
-    tokenLimitInput.dataset.auto = res.tokenLimit;
-    tokensPerReqInput.dataset.auto = Math.floor(res.tokenLimit / res.requestLimit || 0);
-    if (smartThrottleInput.checked) {
-      reqLimitInput.placeholder = reqLimitInput.dataset.auto;
-      tokenLimitInput.placeholder = tokenLimitInput.dataset.auto;
-      tokensPerReqInput.placeholder = tokensPerReqInput.dataset.auto;
+    if (reqLimitInput) reqLimitInput.dataset.auto = res.requestLimit;
+    if (tokenLimitInput) tokenLimitInput.dataset.auto = res.tokenLimit;
+    if (tokensPerReqInput) tokensPerReqInput.dataset.auto = Math.floor(res.tokenLimit / res.requestLimit || 0);
+    if (smartThrottleInput && smartThrottleInput.checked) {
+      if (reqLimitInput) reqLimitInput.placeholder = reqLimitInput.dataset.auto;
+      if (tokenLimitInput) tokenLimitInput.placeholder = tokenLimitInput.dataset.auto;
+      if (tokensPerReqInput) tokensPerReqInput.placeholder = tokensPerReqInput.dataset.auto;
     }
   });
 
@@ -469,6 +495,44 @@ if (clearCacheBtn) {
   });
 }
 
+if (clearPairBtn) {
+  clearPairBtn.addEventListener('click', () => {
+    const source = sourceSelect.value;
+    const target = targetSelect.value;
+    if (window.qwenClearCacheLangPair) window.qwenClearCacheLangPair(source, target);
+    chrome.runtime.sendMessage({ action: 'clear-cache-pair', source, target }, () => {});
+    chrome.tabs.query({}, tabs => {
+      tabs.forEach(t => chrome.tabs.sendMessage(t.id, { action: 'clear-cache-pair', source, target }, () => {}));
+    });
+    status.textContent = `Cleared ${source}->${target} cache.`;
+    updateCacheSize();
+    setTimeout(() => {
+      if (status.textContent.startsWith('Cleared')) status.textContent = '';
+    }, 2000);
+  });
+}
+
+if (clearDomainBtn) {
+  clearDomainBtn.addEventListener('click', () => {
+    chrome.tabs.query({ active: true, currentWindow: true }, tabs => {
+      const url = tabs[0] && tabs[0].url;
+      if (!url) return;
+      let domain;
+      try { domain = new URL(url).hostname; } catch { return; }
+      if (window.qwenClearCacheDomain) window.qwenClearCacheDomain(domain);
+      chrome.runtime.sendMessage({ action: 'clear-cache-domain', domain }, () => {});
+      chrome.tabs.query({}, allTabs => {
+        allTabs.forEach(t => chrome.tabs.sendMessage(t.id, { action: 'clear-cache-domain', domain }, () => {}));
+      });
+      status.textContent = `Cleared cache for ${domain}.`;
+      updateCacheSize();
+      setTimeout(() => {
+        if (status.textContent.startsWith('Cleared cache for')) status.textContent = '';
+      }, 2000);
+    });
+  });
+}
+
 testBtn.addEventListener('click', async () => {
   status.textContent = 'Testing...';
   if (!window.qwenTranslate || !window.qwenTranslateStream) {
diff --git a/src/translator.js b/src/translator.js
index 7e2f5c2..d273df5 100644
--- a/src/translator.js
+++ b/src/translator.js
@@ -69,10 +69,10 @@ if (typeof window === 'undefined') {
   }
 }
 
-async function qwenTranslate({ provider = 'qwen', endpoint, apiKey, model, text, source, target, signal, debug = false, stream = false, noProxy = false, onRetry, retryDelay, force = false }) {
+async function qwenTranslate({ provider = 'qwen', endpoint, apiKey, model, text, source, target, signal, debug = false, stream = false, noProxy = false, onRetry, retryDelay, force = false, domain }) {
   await cacheReady;
+  const modelList = Array.isArray(models) ? models : models ? [models] : [model];
   if (debug) {
-    const modelList = Array.isArray(models) ? models : models ? [models] : [model];
     console.log('QTDEBUG: qwenTranslate called with', {
       provider,
       endpoint,
@@ -124,7 +124,7 @@ async function qwenTranslate({ provider = 'qwen', endpoint, apiKey, model, text,
       throw new Error(result.error);
     }
     if (debug) console.log('QTDEBUG: background response received');
-    setCache(cacheKey, result);
+    setCache(cacheKey, result, domain);
     return result;
   }
 
@@ -139,7 +139,7 @@ async function qwenTranslate({ provider = 'qwen', endpoint, apiKey, model, text,
       approxTokens(text),
       { attempts, debug, onRetry, retryDelay }
     );
-    setCache(cacheKey, data);
+    setCache(cacheKey, data, domain);
     if (debug) {
       console.log('QTDEBUG: translation successful');
       console.log('QTDEBUG: final text', data.text);
@@ -164,7 +164,7 @@ async function qwenTranslate({ provider = 'qwen', endpoint, apiKey, model, text,
           retryDelay,
           attempts,
         });
-        setCache(cacheKey, data);
+        setCache(cacheKey, data, domain);
         return data;
       } catch (err) {
         console.error('QTERROR: translation request failed', err);
@@ -176,7 +176,7 @@ async function qwenTranslate({ provider = 'qwen', endpoint, apiKey, model, text,
   }
 }
 
-async function qwenTranslateStream({ provider = 'qwen', endpoint, apiKey, model, text, source, target, signal, debug = false, stream = true, noProxy = false, onRetry, retryDelay, force = false }, onData) {
+async function qwenTranslateStream({ provider = 'qwen', endpoint, apiKey, model, text, source, target, signal, debug = false, stream = true, noProxy = false, onRetry, retryDelay, force = false, domain }, onData) {
   await cacheReady;
   if (debug) {
     const modelList = Array.isArray(models) ? models : models ? [models] : [model];
@@ -208,7 +208,7 @@ async function qwenTranslateStream({ provider = 'qwen', endpoint, apiKey, model,
       approxTokens(text),
       { attempts, debug, onRetry, retryDelay }
     );
-    setCache(cacheKey, data);
+    setCache(cacheKey, data, domain);
     if (debug) {
       console.log('QTDEBUG: translation successful');
       console.log('QTDEBUG: final text', data.text);
diff --git a/test/popupCache.test.js b/test/popupCache.test.js
index a86c98d..29ac999 100644
--- a/test/popupCache.test.js
+++ b/test/popupCache.test.js
@@ -21,6 +21,12 @@ describe('popup cache controls', () => {
       document.body.appendChild(e);
       global[id] = e;
     });
+    const srcOpt = document.createElement('option');
+    srcOpt.value = 'en';
+    source.appendChild(srcOpt);
+    const tgtOpt = document.createElement('option');
+    tgtOpt.value = 'fr';
+    target.appendChild(tgtOpt);
     global.chrome = {
       runtime: {
         sendMessage: jest.fn(),
diff --git a/test/popupCost.test.js b/test/popupCost.test.js
index 1840b11..2b3fede 100644
--- a/test/popupCost.test.js
+++ b/test/popupCost.test.js
@@ -23,6 +23,12 @@ describe('popup cost display', () => {
       document.body.appendChild(e);
       global[id] = e;
     });
+    const srcOpt = document.createElement('option');
+    srcOpt.value = 'en';
+    source.appendChild(srcOpt);
+    const tgtOpt = document.createElement('option');
+    tgtOpt.value = 'fr';
+    target.appendChild(tgtOpt);
     global.chrome = {
       runtime: {
         sendMessage: jest.fn(),
-- 
2.50.0

