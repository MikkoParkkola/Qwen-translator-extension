From 59c7521ff5b12573e8a28a10890e721675660f1c Mon Sep 17 00:00:00 2001
From: MikkoParkkola <78788115+MikkoParkkola@users.noreply.github.com>
Date: Sat, 16 Aug 2025 21:18:26 +0200
Subject: [PATCH] chore: remove unused attempts var

---
 src/translator.js          | 79 ++++++++++++++++++++++++++++++++++----
 test/cache.test.js         | 11 ++++++
 test/contentScript.test.js | 28 +++++++++++++-
 test/translator.test.js    |  7 +++-
 4 files changed, 113 insertions(+), 12 deletions(-)

diff --git a/src/translator.js b/src/translator.js
index 4d7cc28..0b8d31f 100644
--- a/src/translator.js
+++ b/src/translator.js
@@ -12,7 +12,6 @@ var _setMaxCacheEntries;
 var _setCacheTTL;
 var _setCacheEntryTimestamp;
 var LZString;
-var attempts = 6;
 var runWithRateLimit;
 var approxTokens;
 var getUsage;
@@ -63,10 +62,43 @@ if (typeof translateRequest !== 'function') {
   streamRequest = mod.streamRequest || mod.translate;
 }
 
-async function qwenTranslate({ provider = 'qwen', endpoint, apiKey, model, text, source, target, signal, debug = false, stream = false, noProxy = false, onRetry, retryDelay, force = false, domain }) {
+async function qwenTranslate({
+  provider = 'qwen',
+  endpoint,
+  apiKey,
+  model,
+  models,
+  text,
+  source,
+  target,
+  signal,
+  debug = false,
+  stream = false,
+  noProxy = false,
+  onRetry,
+  retryDelay,
+  force = false,
+  domain,
+}) {
   await cacheReady;
-  const modelList = Array.isArray(model) ? model : [model];
-  const selectedModel = modelList[0];
+  const modelList =
+    typeof models === 'undefined'
+      ? Array.isArray(model)
+        ? model
+        : [model]
+      : Array.isArray(models)
+      ? models
+      : [models];
+  let selectedModel = modelList[0];
+  if (modelList.length > 1 && typeof getUsage === 'function') {
+    try {
+      const usage = getUsage() || {};
+      if (usage.requestLimit && usage.requests && usage.requests > usage.requestLimit * 0.5) {
+        selectedModel = modelList[1];
+      }
+    } catch {}
+  }
+  model = selectedModel;
   if (debug) {
     console.log('QTDEBUG: qwenTranslate called with', {
       provider,
@@ -98,7 +130,7 @@ async function qwenTranslate({ provider = 'qwen', endpoint, apiKey, model, text,
         chrome.runtime.sendMessage(
           {
             action: 'translate',
-      opts: { provider, endpoint: ep, apiKey, model: selectedModel, models: modelList, text, source, target, debug },
+      opts: { provider, endpoint: ep, apiKey, model, models: modelList, text, source, target, debug },
           },
           res => {
             if (chrome.runtime.lastError) {
@@ -177,16 +209,47 @@ async function qwenTranslate({ provider = 'qwen', endpoint, apiKey, model, text,
   }
 }
 
-async function qwenTranslateStream({ provider = 'qwen', endpoint, apiKey, model, text, source, target, signal, debug = false, stream = true, noProxy = false, onRetry, retryDelay, force = false, domain }, onData) {
+async function qwenTranslateStream(
+  {
+    provider = 'qwen',
+    endpoint,
+    apiKey,
+    model,
+    models,
+    text,
+    source,
+    target,
+    signal,
+    debug = false,
+    stream = true,
+    noProxy = false,
+    onRetry,
+    retryDelay,
+    force = false,
+    domain,
+  },
+  onData
+) {
   await cacheReady;
   const modelList =
     typeof models === 'undefined'
-      ? [model]
+      ? Array.isArray(model)
+        ? model
+        : [model]
       : Array.isArray(models)
       ? models
       : [models];
+  let selectedModel = modelList[0];
+  if (modelList.length > 1 && typeof getUsage === 'function') {
+    try {
+      const usage = getUsage() || {};
+      if (usage.requestLimit && usage.requests && usage.requests > usage.requestLimit * 0.5) {
+        selectedModel = modelList[1];
+      }
+    } catch {}
+  }
+  model = selectedModel;
   if (debug) {
-    const modelList = Array.isArray(model) ? model : [model];
     console.log('QTDEBUG: qwenTranslateStream called with', {
       endpoint,
       apiKeySet: Boolean(apiKey),
diff --git a/test/cache.test.js b/test/cache.test.js
index 90572bc..8cc3e0b 100644
--- a/test/cache.test.js
+++ b/test/cache.test.js
@@ -94,3 +94,14 @@ test('clear cache by domain and language pair', async () => {
   qwenClearCacheLangPair('en', 'es');
   expect(getCache('qwen:en:es:hola')).toBeUndefined();
 });
+
+test('removeCache deletes entry from memory and storage', async () => {
+  const { cacheReady, setCache, getCache, removeCache } = require('../src/cache');
+  await cacheReady;
+  setCache('k1', { text: 'x' });
+  expect(getCache('k1').text).toBe('x');
+  removeCache('k1');
+  expect(getCache('k1')).toBeUndefined();
+  const stored = JSON.parse(localStorage.getItem('qwenCache') || '{}');
+  expect(stored.k1).toBeUndefined();
+});
diff --git a/test/contentScript.test.js b/test/contentScript.test.js
index a122849..66e8b35 100644
--- a/test/contentScript.test.js
+++ b/test/contentScript.test.js
@@ -104,9 +104,11 @@ test('batches DOM nodes when exceeding token limit', async () => {
   const calls = jest.fn(async ({ texts }) => ({ texts }));
   window.qwenTranslateBatch = calls;
   document.body.innerHTML = '<p>A</p><p>B</p><p>C</p>';
+  jest.useFakeTimers();
   messageListener({ action: 'start' });
-  await new Promise(r => setTimeout(r, 50));
+  await jest.runOnlyPendingTimersAsync();
   expect(calls).toHaveBeenCalledTimes(4);
+  jest.useRealTimers();
   window.qwenTranslateBatch = original;
   delete window.qwenThrottle;
 });
@@ -140,8 +142,30 @@ test('force translation bypasses cache', async () => {
   await translateBatch(nodes);
   expect(network).toHaveBeenCalledTimes(1);
   document.body.innerHTML = '<p><span>Hello</span></p>';
+  jest.useFakeTimers();
   messageListener({ action: 'start', force: true });
-  await new Promise(r => setTimeout(r, 20));
+  await jest.runOnlyPendingTimersAsync();
   expect(network.mock.calls.length).toBeGreaterThan(1);
+  jest.useRealTimers();
   window.qwenTranslateBatch = original;
 });
+
+test('groups DOM nodes into batches by token budget', async () => {
+  const original = window.qwenTranslateBatch;
+  window.qwenThrottle = { approxTokens: () => 3000, getUsage: () => null };
+  const calls = [];
+  window.qwenTranslateBatch = jest.fn(async ({ texts }) => {
+    calls.push(texts);
+    return { texts };
+  });
+  document.body.innerHTML = '<p>A</p><p>B</p><p>C</p><p>D</p>';
+  jest.useFakeTimers();
+  messageListener({ action: 'start' });
+  await jest.runOnlyPendingTimersAsync();
+  expect(calls.length).toBeGreaterThanOrEqual(2);
+  expect(calls[0]).toEqual(['A', 'B']);
+  expect(calls[1]).toEqual(['C', 'D']);
+  jest.useRealTimers();
+  window.qwenTranslateBatch = original;
+  delete window.qwenThrottle;
+});
diff --git a/test/translator.test.js b/test/translator.test.js
index a107177..bec2511 100644
--- a/test/translator.test.js
+++ b/test/translator.test.js
@@ -29,6 +29,10 @@ beforeEach(() => {
   _setGetUsage(() => getUsage());
 });
 
+afterEach(() => {
+  jest.useRealTimers();
+});
+
 test('translate success', async () => {
   fetch.mockResponseOnce(JSON.stringify({output:{text:'hello'}}));
   const res = await translate({endpoint:'https://example.com/', apiKey:'key', model:'m', text:'hola', source:'es', target:'en'});
@@ -170,11 +174,10 @@ test('rate limiting queues requests', async () => {
   const p2 = translate({ endpoint: 'https://e/', apiKey: 'k', model: 'm', text: '2', source: 'es', target: 'en' });
   const p3 = translate({ endpoint: 'https://e/', apiKey: 'k', model: 'm', text: '3', source: 'es', target: 'en' });
 
-  jest.advanceTimersByTime(1000);
+  await jest.advanceTimersByTimeAsync(1000);
   const res = await Promise.all([p1, p2, p3]);
   expect(res[2].text).toBe('c');
   expect(fetch).toHaveBeenCalledTimes(3);
-  jest.useRealTimers();
 });
 
 test('batch splits requests by token budget', async () => {
-- 
2.50.0

