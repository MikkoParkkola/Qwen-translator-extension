From b1a451b9c2d51fd65a4824ca37e1cd64afab0de0 Mon Sep 17 00:00:00 2001
From: Your Name <you@example.com>
Date: Tue, 19 Aug 2025 03:23:57 +0200
Subject: [PATCH] feat(diagnostics): show latency avg/P50/P95; draw simple
 chart; chore(tests): add provider error normalization tests;
 feat(background): add percentiles to metrics-v1; providers: normalized errors

---
 src/background.js                         | 41 ++++++++++++++++++++++-
 src/popup/diagnostics.html                |  4 +--
 src/popup/diagnostics.js                  | 15 +++++++--
 test/providers.errorNormalization.test.js | 37 ++++++++++++++++++++
 4 files changed, 92 insertions(+), 5 deletions(-)
 create mode 100644 test/providers.errorNormalization.test.js

diff --git a/src/background.js b/src/background.js
index 33d2178..d30cb33 100644
--- a/src/background.js
+++ b/src/background.js
@@ -358,7 +358,10 @@ function getAggregatedStats() {
   const avgThroughput = totalLatency ? totalLoggedTokens / totalLatency : 0; // tokens per ms
   const eta = avgThroughput ? (remaining / avgThroughput) / 1000 : 0; // seconds
   const avgLatency = usageLog.length ? totalLatency / usageLog.length : 0;
-  return { requests: totalRequests, tokens: totalTokens, eta, avgLatency, quality: lastQuality };
+  const lat = usageLog.map(e => e.latency || 0).filter(n => Number.isFinite(n) && n >= 0).slice(-200).sort((a,b)=>a-b);
+  function pct(p){ if (!lat.length) return 0; const idx = Math.min(lat.length-1, Math.max(0, Math.floor(p*(lat.length-1)))); return lat[idx]; }
+  const p50 = pct(0.5), p95 = pct(0.95);
+  return { requests: totalRequests, tokens: totalTokens, eta, avgLatency, p50, p95, quality: lastQuality };
 }
 
 function broadcastStats() {
@@ -785,6 +788,42 @@ chrome.runtime.onMessage.addListener((raw, sender, sendResponse) => {
     });
     return true;
   }
+  if (msg.action === 'metrics-v1') {
+    ensureThrottle().then(() => {
+      const usage = self.qwenThrottle.getUsage();
+      const cache = {
+        size: cacheStats.size != null ? cacheStats.size : (self.qwenGetCacheSize ? self.qwenGetCacheSize() : 0),
+        max: cacheStats.max != null ? cacheStats.max : ((self.qwenConfig && self.qwenConfig.memCacheMax) || 0),
+        hits: cacheStats.hits || 0,
+        misses: cacheStats.misses || 0,
+        hitRate: cacheStats.hitRate || 0,
+      };
+      const tm = Object.keys(tmStats).length ? tmStats : ((self.qwenTM && self.qwenTM.stats) ? self.qwenTM.stats() : {});
+      const providers = {};
+      const now = Date.now();
+      for (const [name, pu] of providersUsage.entries()) {
+        const rt = (pu.reqTimes || []).filter(t => now - t < 60000);
+        const tt = (pu.tokTimes || []).filter(t => now - t.time < 60000);
+        providers[name] = {
+          window: { requests: rt.length, tokens: tt.reduce((s, t) => s + (t.tokens || 0), 0) },
+          totals: { requests: pu.totalReq || 0, tokens: pu.totalTok || 0 },
+          saved: { requests: pu.avoidedReq || 0, tokens: pu.avoidedTok || 0 },
+        };
+      }
+      const agg = getAggregatedStats();
+      sendResponse({
+        version: 1,
+        usage,
+        providers,
+        cache,
+        tm,
+        quality: { last: agg.quality, avgLatencyMs: agg.avgLatency, p50Ms: agg.p50, p95Ms: agg.p95, etaSeconds: Math.round(agg.eta || 0) },
+        errors: {},
+        status: translationStatus,
+      });
+    });
+    return true;
+  }
   if (msg.action === 'tm-cache-metrics') {
     const tmMetrics = (self.qwenTM && self.qwenTM.stats) ? self.qwenTM.stats() : {};
     const cacheStats = self.qwenGetCacheStats ? self.qwenGetCacheStats() : {};
diff --git a/src/popup/diagnostics.html b/src/popup/diagnostics.html
index 6310501..a4eec36 100644
--- a/src/popup/diagnostics.html
+++ b/src/popup/diagnostics.html
@@ -16,8 +16,9 @@
   <h3>Diagnostics</h3>
   <div class="section" id="status"></div>
   <div class="section" id="usage"></div>
+  <div class="section" id="quality"></div>
   <div class="section" id="usageSummary"></div>
-  <canvas id="usageChart"></canvas>
+  <canvas id="usageChart" width="320" height="80" style="background: var(--qwen-secondary-bg, rgba(118,118,128,0.2)); border:1px solid var(--qwen-border, rgba(255,255,255,0.2)); border-radius:4px;"></canvas>
   <div class="section" id="cache"></div>
   <ul id="providers"></ul>
   <button id="back" class="secondary">Back</button>
@@ -25,4 +26,3 @@
   <script src="diagnostics.js"></script>
 </body>
 </html>
-
diff --git a/src/popup/diagnostics.js b/src/popup/diagnostics.js
index fb88862..cf16c62 100644
--- a/src/popup/diagnostics.js
+++ b/src/popup/diagnostics.js
@@ -2,6 +2,7 @@
   const statusEl = document.getElementById('status');
   const usageEl = document.getElementById('usage');
   const cacheEl = document.getElementById('cache');
+  const qualityEl = document.getElementById('quality');
   const providersEl = document.getElementById('providers');
   const backBtn = document.getElementById('back');
   const summaryEl = document.getElementById('usageSummary');
@@ -87,6 +88,14 @@
   function render() {
     const u = metrics.usage || {};
     usageEl.textContent = `Requests ${u.requests || 0}/${u.requestLimit || 0} | Tokens ${u.tokens || 0}/${u.tokenLimit || 0}`;
+    const q = metrics.quality || {};
+    if (qualityEl) {
+      const avg = Math.round(q.avgLatencyMs || 0);
+      const p50 = Math.round(q.p50Ms || 0);
+      const p95 = Math.round(q.p95Ms || 0);
+      const eta = Math.round(q.etaSeconds || 0);
+      qualityEl.textContent = `Latency avg ${avg}ms | P50 ${p50}ms | P95 ${p95}ms | ETA ${eta}s`;
+    }
     const c = metrics.cache || {};
     const tm = metrics.tm || {};
     cacheEl.textContent = `Cache ${c.size || 0}/${c.max || 0} | TM hits ${tm.hits || 0} misses ${tm.misses || 0}`;
@@ -100,7 +109,10 @@
 
   async function load() {
     if (typeof chrome === 'undefined' || !chrome.runtime?.sendMessage) return;
-    metrics = await new Promise(resolve => chrome.runtime.sendMessage({ action: 'metrics' }, handleLastError(resolve)));
+    metrics = await new Promise(resolve => chrome.runtime.sendMessage({ action: 'metrics-v1' }, handleLastError(m => {
+      if (m && m.version === 1) return resolve(m);
+      chrome.runtime.sendMessage({ action: 'metrics' }, handleLastError(resolve));
+    })));
     status = await new Promise(resolve => chrome.runtime.sendMessage({ action: 'get-status' }, handleLastError(resolve)));
     render();
     updateStatus();
@@ -122,4 +134,3 @@
     } catch {}
   });
 })();
-
diff --git a/test/providers.errorNormalization.test.js b/test/providers.errorNormalization.test.js
new file mode 100644
index 0000000..5af9e39
--- /dev/null
+++ b/test/providers.errorNormalization.test.js
@@ -0,0 +1,37 @@
+// @jest-environment node
+
+describe('provider error normalization', () => {
+  beforeEach(() => {
+    jest.resetModules();
+    fetch.resetMocks();
+  });
+
+  function mockResp(status, body = { error: { message: 'x' } }, headers = {}) {
+    const h = new Headers(headers);
+    fetch.mockResponseOnce(JSON.stringify(body), { status, headers: h });
+  }
+
+  test('openai: 401 sets retryable=false', async () => {
+    const openai = require('../src/providers/openai.js');
+    mockResp(401, { error: { message: 'unauthorized' } });
+    await expect(openai.translate({ endpoint: 'https://api.openai.com/v1', apiKey: 'bad', model: 'gpt', text: 't', source: 'en', target: 'es', stream: false }))
+      .rejects.toMatchObject({ status: 401, retryable: false });
+  });
+
+  test('openai: 429 sets retryable=true and parses Retry-After', async () => {
+    const openai = require('../src/providers/openai.js');
+    mockResp(429, { error: { message: 'too many' } }, { 'retry-after': '2' });
+    const p = openai.translate({ endpoint: 'https://api.openai.com/v1', apiKey: 'k', model: 'gpt', text: 't', source: 'en', target: 'es', stream: false });
+    await expect(p).rejects.toMatchObject({ status: 429, retryable: true, retryAfter: expect.any(Number) });
+  });
+
+  test('deepl: 403 retryable=false; 500 retryable=true', async () => {
+    const deepl = require('../src/providers/deepl.js');
+    mockResp(403, { message: 'forbidden' });
+    await expect(deepl.translate({ apiKey: 'bad', text: 't', source: 'en', target: 'es' })).rejects.toMatchObject({ status: 403, retryable: false });
+    fetch.resetMocks();
+    mockResp(500, { message: 'server' });
+    await expect(deepl.translate({ apiKey: 'k', text: 't', source: 'en', target: 'es' })).rejects.toMatchObject({ status: 500, retryable: true });
+  });
+});
+
-- 
2.50.0

