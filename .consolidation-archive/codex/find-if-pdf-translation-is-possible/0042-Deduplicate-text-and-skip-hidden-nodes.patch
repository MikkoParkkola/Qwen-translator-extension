From 3ed568b8a269cbe0777e93d671383aa593d679ca Mon Sep 17 00:00:00 2001
From: MikkoParkkola <78788115+MikkoParkkola@users.noreply.github.com>
Date: Sat, 2 Aug 2025 18:22:19 +0200
Subject: [PATCH 42/45] Deduplicate text and skip hidden nodes

---
 README.md            |  27 ++++--
 src/background.js    |  63 +++++++++++--
 src/contentScript.js | 211 ++++++++++++++++++++++++++++++++++++++-----
 src/manifest.json    |   4 +-
 src/popup.html       |  12 +++
 src/popup.js         |  66 +++++++++++++-
 src/throttle.js      |  91 ++++++++++++++-----
 src/translator.js    |  86 +++++++++++++++---
 8 files changed, 478 insertions(+), 82 deletions(-)

diff --git a/README.md b/README.md
index 4a0f05a..d6fe394 100644
--- a/README.md
+++ b/README.md
@@ -9,6 +9,10 @@ This Chrome extension translates the content of the active tab using Alibaba Clo
 4. Choose "Load unpacked" and select the folder containing the extension files.
    The extension requests the "tabs" permission so the popup can send
    messages to the active tab for translation.
+   If Chrome reports **Service worker registration failed. Status code: 15**,
+   ensure the selected folder contains `manifest.json`, `background.js` and the
+   other files from the `src` directory. Loading the repository root without the
+   bundled files will cause the worker to fail.
 
 ## Uninstallation
 Remove the extension from the browser's extension management page.
@@ -26,28 +30,37 @@ Click **Test Settings** in the popup to run a short diagnostic. The extension pe
 1. Connect to the configured API endpoint
 2. Send an OPTIONS preflight request to the translation URL
 3. Perform a direct non-stream translation
-4. Perform the same translation via the background service worker
-5. Send a streaming translation request
-6. Read the contents of the active tab
-7. Translate a short string inside the active tab
-8. Verify that extension settings can be saved
+4. Verify that the background service worker responds
+5. Perform the same translation via the background service worker
+6. Send a streaming translation request
+7. Read the contents of the active tab
+8. Translate a short string inside the active tab
+9. Verify that extension settings can be saved
 Each step displays a pass or fail result and honours the debug logging preference.
 The active tab check may fail on browser-internal pages (such as the Chrome Web Store or settings). Open a regular web page before running the test.
 The final end-to-end tab translation aborts after about 10 seconds if no response is received.
+The sample phrase is chosen based on the configured source language so the translated text differs from the original.
 
 ## Usage
-Click the extension icon and choose **Translate Page**. If automatic translation is enabled the page will be translated on load. Translations apply to dynamically added content.
-If translation fails, an error message appears at the bottom-right of the page. Translations are cached for the current session to minimise API calls.
+Click the extension icon and choose **Translate Page**. If automatic translation is enabled the page will be translated on load. Translations apply to dynamically added content as well as embedded frames or third-party widgets whenever the browser grants access. If translation fails the affected text is kept in a queue and retried until the API succeeds. When the translated text matches the original the node is marked as untranslatable and skipped. Translations are cached for the current session to minimise API calls.
+Identical strings are translated only once and reused across matching nodes, and hidden or off-screen elements are ignored so tokens are spent only on visible text.
+Translated nodes keep their original leading and trailing whitespace and the navigation menu is processed before the rest of the page so key controls appear quickly. While translations are running the extension's toolbar icon shows an activity badge and a temporary status box in the bottom-right corner of the page reports current work or errors. The box disappears automatically when the extension is idle.
 
 ### Rate Limiting
 The extension and CLI queue translation requests to stay within the provider limits.
+The background worker maintains a single queue so multiple page nodes are translated sequentially rather than all at once, preventing bursts that would trigger HTTP 429 errors. Nodes are batched into combined translation requests to reduce the overall query count. If the provider still returns a 429 response the request is retried automatically.
 You can adjust the limits under **Requests per minute** and **Tokens per minute** in the extension popup or via `--requests` and `--tokens` on the CLI. Defaults are 60 requests and 100,000 tokens every 60 seconds.
+The popup displays live usage for the last minute and colour-coded bars turn yellow or red as limits are approached. Usage statistics refresh every second and also show total requests, total tokens and the current queue length.
 
 ### Troubleshooting
 Both model refreshes and translation requests write trace logs to the browser console. Copy any on-page error and check the console for a matching entry to diagnose problems.
 If the **Test Settings** button reports a timeout, the network request may be blocked by Content Security Policy or CORS restrictions. The extension automatically falls back to `XMLHttpRequest` when `fetch` fails, but some environments may still prevent the call entirely.
 If the **Read active tab** check fails, make sure the currently focused tab is a normal web page; the extension cannot access Chrome or extension pages.
 If the tab translation step fails, the page may block script execution or DOM updates.
+Some sites impose strict Content Security Policies that prevent the test element from executing or restrict network requests. Open a simple page such as `https://example.com` before running the tests. Console errors from third-party resources do not affect the translation check.
+Enable **Debug logging** in the popup to see details about the active tab and any error stack returned by the content script.
+If a translated page appears unchanged, verify that the source and target languages are configured correctly. With debug logging enabled the console warns when the translation result matches the original text.
+Shadow DOM content and same-origin iframes are scanned and translated automatically. Cross-origin frames may be translated when host permissions allow access, otherwise they are skipped.
 
 ## Development
 Run the unit tests with:
diff --git a/src/background.js b/src/background.js
index 137db07..13b7772 100644
--- a/src/background.js
+++ b/src/background.js
@@ -1,26 +1,54 @@
 importScripts('throttle.js', 'translator.js');
-const { configure } = self.qwenThrottle;
-const { qwenTranslate } = self;
 
 chrome.runtime.onInstalled.addListener(() => {
   console.log('Qwen Translator installed');
 });
 
+let throttleReady;
+let activeTranslations = 0;
+
+function updateBadge() {
+  if (activeTranslations > 0) {
+    chrome.action.setBadgeText({ text: '...' });
+    chrome.action.setBadgeBackgroundColor({ color: '#0d6efd' });
+  } else {
+    chrome.action.setBadgeText({ text: '' });
+  }
+}
+updateBadge();
+function ensureThrottle() {
+  if (!throttleReady) {
+    throttleReady = new Promise(resolve => {
+      chrome.storage.sync.get(
+        { requestLimit: 60, tokenLimit: 100000 },
+        cfg => {
+          self.qwenThrottle.configure({
+            requestLimit: cfg.requestLimit,
+            tokenLimit: cfg.tokenLimit,
+            windowMs: 60000,
+          });
+          resolve();
+        }
+      );
+    });
+  }
+  return throttleReady;
+}
+
 async function handleTranslate(opts) {
   const { endpoint, apiKey, model, text, source, target, debug } = opts;
   const ep = endpoint.endsWith('/') ? endpoint : `${endpoint}/`;
   if (debug) console.log('QTDEBUG: background translating via', ep);
 
-  const cfg = await new Promise(resolve =>
-    chrome.storage.sync.get({ requestLimit: 60, tokenLimit: 100000 }, resolve)
-  );
-  configure({ requestLimit: cfg.requestLimit, tokenLimit: cfg.tokenLimit, windowMs: 60000 });
+  await ensureThrottle();
 
   const controller = new AbortController();
   const timeout = setTimeout(() => controller.abort(), 20000);
+  activeTranslations++;
+  updateBadge();
 
   try {
-    const result = await qwenTranslate({
+    const result = await self.qwenTranslate({
       endpoint: ep,
       apiKey,
       model,
@@ -38,11 +66,28 @@ async function handleTranslate(opts) {
     return { error: err.message };
   } finally {
     clearTimeout(timeout);
+    activeTranslations--;
+    updateBadge();
   }
 }
 
-chrome.runtime.onMessage.addListener((msg, sender) => {
+chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
   if (msg.action === 'translate') {
-    return handleTranslate(msg.opts);
+    handleTranslate(msg.opts)
+      .then(sendResponse)
+      .catch(err => sendResponse({ error: err.message }));
+    return true;
+  }
+  if (msg.action === 'ping') {
+    if (msg.debug) console.log('QTDEBUG: ping received');
+    sendResponse({ ok: true });
+    return true;
+  }
+  if (msg.action === 'usage') {
+    ensureThrottle().then(() => {
+      const stats = self.qwenThrottle.getUsage();
+      sendResponse(stats);
+    });
+    return true;
   }
 });
diff --git a/src/contentScript.js b/src/contentScript.js
index 97d3159..82495c5 100644
--- a/src/contentScript.js
+++ b/src/contentScript.js
@@ -1,16 +1,19 @@
-let observer;
+let observers = [];
 let currentConfig;
+const batchQueue = [];
+let processing = false;
+let statusTimer;
 
-function showError(message) {
-  let el = document.getElementById('qwen-error');
+function setStatus(message, isError = false) {
+  let el = document.getElementById('qwen-status');
   if (!el) {
     el = document.createElement('div');
-    el.id = 'qwen-error';
+    el.id = 'qwen-status';
     Object.assign(el.style, {
       position: 'fixed',
       bottom: '10px',
       right: '10px',
-      background: 'rgba(255,0,0,0.8)',
+      background: 'rgba(0,0,0,0.6)',
       color: '#fff',
       padding: '5px 10px',
       zIndex: 2147483647,
@@ -18,19 +21,56 @@ function showError(message) {
     });
     document.body.appendChild(el);
   }
+  el.style.background = isError ? 'rgba(255,0,0,0.8)' : 'rgba(0,0,0,0.6)';
   el.textContent = `Qwen Translator: ${message}`;
+  if (statusTimer) clearTimeout(statusTimer);
+  if (isError) statusTimer = setTimeout(clearStatus, 5000);
+}
+
+function clearStatus() {
+  const el = document.getElementById('qwen-status');
+  if (el) el.remove();
+}
+
+function showError(message) {
+  setStatus(message, true);
 }
 
 function mark(node) {
   node.dataset.qwenTranslated = 'true';
 }
 
+function markUntranslatable(node) {
+  node.dataset.qwenUntranslatable = 'true';
+}
+
 function isMarked(node) {
-  return node.dataset && node.dataset.qwenTranslated === 'true';
+  return (
+    node.dataset &&
+    (node.dataset.qwenTranslated === 'true' || node.dataset.qwenUntranslatable === 'true')
+  );
+}
+
+const SKIP_TAGS = new Set(['SCRIPT', 'STYLE', 'NOSCRIPT', 'TEMPLATE']);
+
+function isVisible(el) {
+  if (!el) return false;
+  if (el.closest('[hidden],[aria-hidden="true"]')) return false;
+  const style = window.getComputedStyle(el);
+  if (style.visibility === 'hidden' || style.display === 'none') return false;
+  if (!el.getClientRects().length) return false;
+  return true;
+}
+
+function shouldTranslate(el) {
+  return !isMarked(el) && !SKIP_TAGS.has(el.tagName) && isVisible(el);
 }
 
 async function translateNode(node) {
-  const text = node.textContent.trim();
+  const original = node.textContent || '';
+  const leading = original.match(/^\s*/)[0];
+  const trailing = original.match(/\s*$/)[0];
+  const text = original.trim();
   if (!text) return;
   try {
     if (currentConfig.debug) console.log('QTDEBUG: translating node', text.slice(0, 20));
@@ -47,7 +87,13 @@ async function translateNode(node) {
       debug: currentConfig.debug,
     });
     clearTimeout(timeout);
-    node.textContent = translated;
+    if (currentConfig.debug) {
+      console.log('QTDEBUG: node translation result', { original: text.slice(0, 50), translated: translated.slice(0, 50) });
+      if (translated.trim().toLowerCase() === text.trim().toLowerCase()) {
+        console.warn('QTWARN: translated text is identical to source; check language configuration');
+      }
+    }
+    node.textContent = leading + translated + trailing;
     mark(node);
   } catch (e) {
     showError(`${e.message}. See console for details.`);
@@ -55,34 +101,139 @@ async function translateNode(node) {
   }
 }
 
-function scan() {
-  const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null);
+async function translateBatch(elements) {
+  const originals = elements.map(el => el.textContent || '');
+  const texts = originals.map(t => t.trim());
+  const controller = new AbortController();
+  const timeout = setTimeout(() => controller.abort(), 10000);
+  let res;
+  try {
+    res = await window.qwenTranslateBatch({
+      endpoint: currentConfig.apiEndpoint,
+      apiKey: currentConfig.apiKey,
+      model: currentConfig.model,
+      texts,
+      source: currentConfig.sourceLanguage,
+      target: currentConfig.targetLanguage,
+      signal: controller.signal,
+      debug: currentConfig.debug,
+    });
+  } finally {
+    clearTimeout(timeout);
+  }
+  res.texts.forEach((t, i) => {
+    const el = elements[i];
+    const orig = originals[i];
+    const leading = orig.match(/^\s*/)[0];
+    const trailing = orig.match(/\s*$/)[0];
+    if (currentConfig.debug) {
+      console.log('QTDEBUG: node translation result', { original: texts[i].slice(0, 50), translated: t.slice(0, 50) });
+    }
+    if (t.trim().toLowerCase() === texts[i].trim().toLowerCase()) {
+      markUntranslatable(el);
+      if (currentConfig.debug) {
+        console.warn('QTWARN: translated text is identical to source; marking as untranslatable');
+      }
+    } else {
+      el.textContent = leading + t + trailing;
+      mark(el);
+    }
+  });
+}
+
+function enqueueBatch(batch) {
+  batchQueue.push(batch);
+  if (!processing) processQueue();
+}
+
+async function processQueue() {
+  processing = true;
+  setStatus('Translating...');
+  while (batchQueue.length) {
+    setStatus(`Translating (${batchQueue.length} left)...`);
+    const batch = batchQueue.shift();
+    try {
+      await translateBatch(batch);
+    } catch (e) {
+      showError(`${e.message}. See console for details.`);
+      console.error('QTERROR: batch translation error', e);
+      batchQueue.push(batch);
+      await new Promise(r => setTimeout(r, 1000));
+    }
+  }
+  processing = false;
+  clearStatus();
+}
+
+function batchNodes(nodes) {
+  const maxTokens = 1000;
+  const batches = [];
+  let current = [];
+  let tokens = 0;
+  const approx = window.qwenThrottle ? window.qwenThrottle.approxTokens : t => Math.ceil(t.length / 4);
+  const seen = new Set();
+  nodes.forEach(el => {
+    const text = el.textContent.trim();
+    const tok = approx(text);
+    const unique = !seen.has(text);
+    if (current.length && tokens + (unique ? tok : 0) > maxTokens) {
+      batches.push(current);
+      current = [];
+      tokens = 0;
+      seen.clear();
+    }
+    current.push(el);
+    if (unique) {
+      tokens += tok;
+      seen.add(text);
+    }
+  });
+  if (current.length) batches.push(current);
+  batches.forEach(b => enqueueBatch(b));
+}
+
+function scan(root = document.body) {
+  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
   const nodes = [];
   let node;
   while ((node = walker.nextNode())) {
     const parent = node.parentElement;
-    if (parent && !isMarked(parent) && node.textContent.trim()) {
-      nodes.push(node);
+    if (parent && node.textContent.trim() && shouldTranslate(parent)) {
+      nodes.push(parent);
     }
   }
-  nodes.forEach(n => translateNode(n.parentElement));
+  if (nodes.length) batchNodes(nodes);
+  if (root.querySelectorAll) {
+    root.querySelectorAll('iframe,object,embed').forEach(el => {
+      try {
+        const doc = el.contentDocument || el.getSVGDocument?.();
+        if (doc) scan(doc);
+      } catch {}
+    });
+    root.querySelectorAll('*').forEach(el => {
+      if (el.shadowRoot) scan(el.shadowRoot);
+    });
+  }
 }
 
-function observe() {
-  observer = new MutationObserver((mutations) => {
+function observe(root = document.body) {
+  const obs = new MutationObserver((mutations) => {
     for (const m of mutations) {
       m.addedNodes.forEach(n => {
         if (n.nodeType === Node.ELEMENT_NODE) {
-          const walker = document.createTreeWalker(n, NodeFilter.SHOW_TEXT, null);
-          let node;
-          while ((node = walker.nextNode())) {
-            translateNode(node.parentElement);
-          }
+          scan(n);
         }
+        if (n.shadowRoot) observe(n.shadowRoot);
       });
     }
   });
-  observer.observe(document.body, {childList: true, subtree: true});
+  obs.observe(root, { childList: true, subtree: true });
+  observers.push(obs);
+  if (root.querySelectorAll) {
+    root.querySelectorAll('*').forEach(el => {
+      if (el.shadowRoot) observe(el.shadowRoot);
+    });
+  }
 }
 
 async function start() {
@@ -92,8 +243,14 @@ async function start() {
     return;
   }
   if (currentConfig.debug) console.log('QTDEBUG: starting automatic translation');
-  scan();
+  setStatus('Scanning page...');
+  const nav = document.querySelector('nav');
+  if (nav) scan(nav);
+  const main = document.querySelector('main');
+  if (main && main !== nav) scan(main);
+  scan(document.body);
   observe();
+  if (!batchQueue.length) clearStatus();
 }
 
 chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
@@ -106,7 +263,7 @@ chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
   }
   if (msg.action === 'test-e2e') {
     const cfg = msg.cfg || {};
-    const original = 'Hello world';
+    const original = msg.original || 'Hello world';
     const el = document.createElement('span');
     el.id = 'qwen-test-element';
     el.textContent = original;
@@ -128,14 +285,20 @@ chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
       })
       .then(res => {
         clearTimeout(timer);
+        if (cfg.debug) console.log('QTDEBUG: test-e2e translation result', res);
+        if (!res || typeof res.text !== 'string') {
+          throw new Error('invalid response');
+        }
         el.textContent = res.text;
+        if (cfg.debug) console.log('QTDEBUG: test-e2e sending response');
         sendResponse({ text: res.text });
         setTimeout(() => el.remove(), 1000);
       })
       .catch(err => {
         clearTimeout(timer);
+        if (cfg.debug) console.log('QTDEBUG: test-e2e sending error', err);
         el.remove();
-        sendResponse({ error: err.message });
+        sendResponse({ error: err.message, stack: err.stack });
       });
     return true;
   }
diff --git a/src/manifest.json b/src/manifest.json
index 032103b..8bbf583 100644
--- a/src/manifest.json
+++ b/src/manifest.json
@@ -5,6 +5,7 @@
   "version": "1.3.1",
   "permissions": ["storage", "activeTab", "tabs", "scripting"],
   "host_permissions": [
+    "<all_urls>",
     "https://dashscope-intl.aliyuncs.com/*"
   ],
   "background": {
@@ -24,7 +25,8 @@
     {
       "matches": ["<all_urls>"],
       "js": ["config.js", "throttle.js", "translator.js", "contentScript.js"],
-      "run_at": "document_idle"
+      "run_at": "document_idle",
+      "all_frames": true
     }
   ]
 }
diff --git a/src/popup.html b/src/popup.html
index 07edd4a..c6f502d 100644
--- a/src/popup.html
+++ b/src/popup.html
@@ -8,6 +8,9 @@
     input[type=text], select { width:100%; box-sizing:border-box; margin-top:2px; }
     button { width: 100%; margin-top:6px; padding:6px; }
     #status { margin-top:5px; font-size:12px; color:#555; min-height:16px; }
+    #usage { margin-top:6px; font-size:11px; }
+    .bar { height:6px; background:#ddd; margin-top:2px; }
+    .bar > div { height:100%; width:0%; background:green; }
   </style>
 </head>
 <body>
@@ -21,6 +24,15 @@
   <label>Tokens per minute <input type="number" id="tokenLimit"></label>
   <label><input type="checkbox" id="auto"> Translate automatically</label>
   <label><input type="checkbox" id="debug"> Debug logging</label>
+  <div id="usage">
+    <div>Requests <span id="reqCount">0/0</span></div>
+    <div class="bar"><div id="reqBar"></div></div>
+    <div>Tokens <span id="tokenCount">0/0</span></div>
+    <div class="bar"><div id="tokenBar"></div></div>
+    <div>Total Requests <span id="totalReq">0</span></div>
+    <div>Total Tokens <span id="totalTok">0</span></div>
+    <div>Queue <span id="queueLen">0</span></div>
+  </div>
   <button id="save">Save</button>
   <button id="test">Test Settings</button>
   <div id="status"></div>
diff --git a/src/popup.js b/src/popup.js
index 34a5a4c..2bf4774 100644
--- a/src/popup.js
+++ b/src/popup.js
@@ -9,6 +9,13 @@ const autoCheckbox = document.getElementById('auto');
 const debugCheckbox = document.getElementById('debug');
 const status = document.getElementById('status');
 const versionDiv = document.getElementById('version');
+const reqCount = document.getElementById('reqCount');
+const tokenCount = document.getElementById('tokenCount');
+const reqBar = document.getElementById('reqBar');
+const tokenBar = document.getElementById('tokenBar');
+const totalReq = document.getElementById('totalReq');
+const totalTok = document.getElementById('totalTok');
+const queueLen = document.getElementById('queueLen');
 
 function populateLanguages() {
   window.qwenLanguages.forEach(l => {
@@ -36,6 +43,27 @@ window.qwenLoadConfig().then(cfg => {
 
 versionDiv.textContent = `v${chrome.runtime.getManifest().version}`;
 
+function setBar(el, ratio) {
+  el.style.width = Math.min(100, ratio * 100) + '%';
+  el.style.background = ratio < 0.5 ? 'green' : ratio < 0.8 ? 'gold' : 'red';
+}
+
+function refreshUsage() {
+  chrome.runtime.sendMessage({ action: 'usage' }, res => {
+    if (chrome.runtime.lastError || !res) return;
+    reqCount.textContent = `${res.requests}/${res.requestLimit}`;
+    tokenCount.textContent = `${res.tokens}/${res.tokenLimit}`;
+    setBar(reqBar, res.requests / res.requestLimit);
+    setBar(tokenBar, res.tokens / res.tokenLimit);
+    totalReq.textContent = res.totalRequests;
+    totalTok.textContent = res.totalTokens;
+    queueLen.textContent = res.queue;
+  });
+}
+
+setInterval(refreshUsage, 1000);
+refreshUsage();
+
 document.getElementById('translate').addEventListener('click', () => {
   const debug = debugCheckbox.checked;
   chrome.tabs.query({active: true, currentWindow: true}, (tabs) => {
@@ -124,6 +152,19 @@ document.getElementById('test').addEventListener('click', async () => {
     if (!res.text) throw new Error('empty response');
   })) && allOk;
 
+  allOk = (await run('Background ping', async () => {
+    const resp = await new Promise((resolve, reject) => {
+      chrome.runtime.sendMessage({ action: 'ping', debug: cfg.debug }, res => {
+        if (chrome.runtime.lastError) {
+          reject(new Error(chrome.runtime.lastError.message));
+        } else {
+          resolve(res);
+        }
+      });
+    });
+    if (!resp || !resp.ok) throw new Error('no response');
+  })) && allOk;
+
   allOk = (await run('Background translation', async () => {
     const res = await window.qwenTranslate({ ...cfg, text: 'hello', stream: false });
     if (!res.text) throw new Error('empty response');
@@ -158,12 +199,21 @@ document.getElementById('test').addEventListener('click', async () => {
   allOk = (await run('Tab translation', async () => {
     const tabs = await new Promise(r => chrome.tabs.query({ active: true, currentWindow: true }, r));
     if (!tabs[0]) throw new Error('no tab');
+    const tab = tabs[0];
+    log('QTDEBUG: active tab for tab translation test', { id: tab.id, url: tab.url });
+    const sample = cfg.source && cfg.source.toLowerCase().startsWith('fi')
+      ? 'Hei maailma'
+      : 'Hello world';
     const resp = await new Promise((resolve, reject) => {
-      const timer = setTimeout(() => reject(new Error('timeout waiting for tab response')), 15000);
-      log('QTDEBUG: sending test-e2e request to tab', tabs[0].id);
-      chrome.tabs.sendMessage(tabs[0].id, { action: 'test-e2e', cfg }, res => {
+      const timer = setTimeout(() => {
+        log('QTERROR: tab translation timed out', { id: tab.id, url: tab.url });
+        reject(new Error('timeout waiting for tab response'));
+      }, 15000);
+      log('QTDEBUG: sending test-e2e request to tab', tab.id);
+      chrome.tabs.sendMessage(tab.id, { action: 'test-e2e', cfg, original: sample }, res => {
         clearTimeout(timer);
         if (chrome.runtime.lastError) {
+          log('QTERROR: tab message failed', chrome.runtime.lastError.message);
           reject(new Error(chrome.runtime.lastError.message));
         } else {
           log('QTDEBUG: tab responded', res);
@@ -171,10 +221,16 @@ document.getElementById('test').addEventListener('click', async () => {
         }
       });
     });
-    if (!resp || resp.error) throw new Error(resp ? resp.error : 'no response');
-    if (!resp.text || resp.text.toLowerCase() === 'hello world') {
+    if (!resp || resp.error) {
+      const err = new Error(resp ? resp.error : 'no response');
+      if (resp && resp.stack) err.stack = resp.stack;
+      log('QTERROR: tab returned error', err.message);
+      throw err;
+    }
+    if (!resp.text || resp.text.toLowerCase() === sample.toLowerCase()) {
       throw new Error('translation failed');
     }
+    log('QTDEBUG: tab translation succeeded', resp.text);
   })) && allOk;
 
   allOk = (await run('Storage access', async () => {
diff --git a/src/throttle.js b/src/throttle.js
index a1fbdbe..5c08ac2 100644
--- a/src/throttle.js
+++ b/src/throttle.js
@@ -1,22 +1,29 @@
-const queue = [];
-let config = {
-  requestLimit: 60,
-  tokenLimit: 100000,
-  windowMs: 60000,
-};
-let availableRequests = config.requestLimit;
-let availableTokens = config.tokenLimit;
-let interval = setInterval(() => {
-  availableRequests = config.requestLimit;
-  availableTokens = config.tokenLimit;
-  processQueue();
-}, config.windowMs);
+;(function (root) {
+  if (root.qwenThrottle) return
+
+  const queue = []
+  let config = {
+    requestLimit: 60,
+    tokenLimit: 100000,
+    windowMs: 60000,
+  }
+  let availableRequests = config.requestLimit
+  let availableTokens = config.tokenLimit
+  const requestTimes = []
+  const tokenTimes = []
+  let totalRequests = 0
+  let totalTokens = 0
+  let interval = setInterval(() => {
+    availableRequests = config.requestLimit
+    availableTokens = config.tokenLimit
+    processQueue()
+  }, config.windowMs)
 
 function approxTokens(text) {
   return Math.max(1, Math.ceil(text.length / 4));
 }
 
-function configure(opts = {}) {
+function throttleConfigure(opts = {}) {
   Object.assign(config, opts);
   availableRequests = config.requestLimit;
   availableTokens = config.tokenLimit;
@@ -28,11 +35,26 @@ function configure(opts = {}) {
   }, config.windowMs);
 }
 
+function recordUsage(tokens) {
+  const now = Date.now();
+  requestTimes.push(now);
+  tokenTimes.push({ time: now, tokens });
+  totalRequests++
+  totalTokens += tokens
+  prune(now);
+}
+
+function prune(now = Date.now()) {
+  while (requestTimes.length && now - requestTimes[0] > config.windowMs) requestTimes.shift();
+  while (tokenTimes.length && now - tokenTimes[0].time > config.windowMs) tokenTimes.shift();
+}
+
 function processQueue() {
   while (queue.length && availableRequests > 0 && availableTokens >= queue[0].tokens) {
     const item = queue.shift();
     availableRequests--;
     availableTokens -= item.tokens;
+    recordUsage(item.tokens);
     item.fn().then(item.resolve, item.reject);
   }
 }
@@ -65,12 +87,39 @@ async function runWithRetry(fn, text, attempts = 3, debug = false) {
   }
 }
 
-if (typeof module !== 'undefined') {
-  module.exports = { runWithRateLimit, runWithRetry, configure, approxTokens };
+function getUsage() {
+  prune();
+  const tokensUsed = tokenTimes.reduce((s, t) => s + t.tokens, 0);
+  return {
+    requests: requestTimes.length,
+    tokens: tokensUsed,
+    requestLimit: config.requestLimit,
+    tokenLimit: config.tokenLimit,
+    totalRequests,
+    totalTokens,
+    queue: queue.length,
+  };
 }
 
-if (typeof window !== 'undefined') {
-  window.qwenThrottle = { runWithRateLimit, runWithRetry, configure, approxTokens };
-} else if (typeof self !== 'undefined') {
-  self.qwenThrottle = { runWithRateLimit, runWithRetry, configure, approxTokens };
-}
+  if (typeof module !== 'undefined') {
+    module.exports = { runWithRateLimit, runWithRetry, configure: throttleConfigure, approxTokens, getUsage }
+  }
+
+  if (typeof window !== 'undefined') {
+    root.qwenThrottle = {
+      runWithRateLimit,
+      runWithRetry,
+      configure: throttleConfigure,
+      approxTokens,
+      getUsage,
+    }
+  } else if (typeof self !== 'undefined') {
+    root.qwenThrottle = {
+      runWithRateLimit,
+      runWithRetry,
+      configure: throttleConfigure,
+      approxTokens,
+      getUsage,
+    }
+  }
+})(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : globalThis)
diff --git a/src/translator.js b/src/translator.js
index f460e1d..494ed5d 100644
--- a/src/translator.js
+++ b/src/translator.js
@@ -112,15 +112,15 @@ async function doFetch({ endpoint, apiKey, model, text, source, target, signal,
       throw e;
     }
   }
-  if (!resp.ok) {
-    const err = await resp
-      .json()
-      .catch(() => ({ message: resp.statusText }));
-    const error = new Error(`HTTP ${resp.status}: ${err.message || 'Translation failed'}`);
-    if (debug) console.log('QTDEBUG: HTTP error response', error.message);
-    if (resp.status >= 500) error.retryable = true;
-    throw error;
-  }
+    if (!resp.ok) {
+      const err = await resp
+        .json()
+        .catch(() => ({ message: resp.statusText }));
+      const error = new Error(`HTTP ${resp.status}: ${err.message || 'Translation failed'}`);
+      if (debug) console.log('QTDEBUG: HTTP error response', error.message);
+      if (resp.status >= 500 || resp.status === 429) error.retryable = true;
+      throw error;
+    }
   if (!stream || !resp.body || typeof resp.body.getReader !== 'function') {
     if (debug) console.log('QTDEBUG: received non-streaming response');
     const data = await resp.json();
@@ -184,13 +184,38 @@ async function qwenTranslate({ endpoint, apiKey, model, text, source, target, si
     return cache.get(cacheKey);
   }
 
-  if (!noProxy && typeof window !== 'undefined' && typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
+  if (
+    !noProxy &&
+    typeof window !== 'undefined' &&
+    typeof chrome !== 'undefined' &&
+    chrome.runtime &&
+    chrome.runtime.sendMessage
+  ) {
     const ep = withSlash(endpoint);
     if (debug) console.log('QTDEBUG: requesting translation via background script');
-    const result = await chrome.runtime
-      .sendMessage({ action: 'translate', opts: { endpoint: ep, apiKey, model, text, source, target, debug } })
-      .catch(err => { throw new Error(err.message || err); });
-    if (result && result.error) {
+    const result = await new Promise((resolve, reject) => {
+      try {
+        chrome.runtime.sendMessage(
+          {
+            action: 'translate',
+            opts: { endpoint: ep, apiKey, model, text, source, target, debug },
+          },
+          res => {
+            if (chrome.runtime.lastError) {
+              reject(new Error(chrome.runtime.lastError.message));
+            } else {
+              resolve(res);
+            }
+          }
+        );
+      } catch (err) {
+        reject(err);
+      }
+    });
+    if (!result) {
+      throw new Error('No response from background');
+    }
+    if (result.error) {
       throw new Error(result.error);
     }
     if (debug) console.log('QTDEBUG: background response received');
@@ -252,19 +277,50 @@ async function qwenTranslateStream({ endpoint, apiKey, model, text, source, targ
     throw e;
   }
 }
+
+async function qwenTranslateBatch({ texts = [], ...opts }) {
+  const results = new Array(texts.length);
+  const indexMap = new Map();
+  texts.forEach((t, i) => {
+    const key = `${opts.source}:${opts.target}:${t}`;
+    if (cache.has(key)) {
+      results[i] = cache.get(key).text;
+    } else {
+      if (!indexMap.has(t)) indexMap.set(t, []);
+      indexMap.get(t).push(i);
+    }
+  });
+  const unique = Array.from(indexMap.keys());
+  if (unique.length) {
+    const joined = unique.join('\n');
+    const res = await qwenTranslate({ ...opts, text: joined });
+    const translated = res.text.split('\n');
+    translated.forEach((tr, idx) => {
+      const orig = unique[idx];
+      const key = `${opts.source}:${opts.target}:${orig}`;
+      cache.set(key, { text: tr });
+      indexMap.get(orig).forEach(i => {
+        results[i] = tr;
+      });
+    });
+  }
+  return { texts: results };
+}
 function qwenClearCache() {
   cache.clear();
 }
 if (typeof window !== 'undefined') {
   window.qwenTranslate = qwenTranslate;
   window.qwenTranslateStream = qwenTranslateStream;
+  window.qwenTranslateBatch = qwenTranslateBatch;
   window.qwenClearCache = qwenClearCache;
 }
 if (typeof self !== 'undefined' && typeof window === 'undefined') {
   self.qwenTranslate = qwenTranslate;
   self.qwenTranslateStream = qwenTranslateStream;
+  self.qwenTranslateBatch = qwenTranslateBatch;
   self.qwenClearCache = qwenClearCache;
 }
 if (typeof module !== 'undefined') {
-  module.exports = { qwenTranslate, qwenTranslateStream, qwenClearCache };
+  module.exports = { qwenTranslate, qwenTranslateStream, qwenTranslateBatch, qwenClearCache };
 }
-- 
2.50.0

