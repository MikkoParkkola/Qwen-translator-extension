From 08ba55b47fe8a6ee7a8f73689700986d840d26b4 Mon Sep 17 00:00:00 2001
From: Your Name <you@example.com>
Date: Tue, 19 Aug 2025 14:27:41 +0200
Subject: [PATCH 7/8] feat(pdf-wasm): add sha256 for packaged assets; warn on
 mismatch; add IDB cache + update tool

---
 src/wasm/engine.js             | 111 ++++++++++++++++++++++++++++-----
 test/wasm.engine.cache.test.js |  44 +++++++++++++
 tools/update-wasm-sha256.js    |  74 ++++++++++++++++++++++
 3 files changed, 215 insertions(+), 14 deletions(-)
 create mode 100644 test/wasm.engine.cache.test.js
 create mode 100644 tools/update-wasm-sha256.js

diff --git a/src/wasm/engine.js b/src/wasm/engine.js
index 0c3ae7f..375f4b4 100644
--- a/src/wasm/engine.js
+++ b/src/wasm/engine.js
@@ -2,28 +2,30 @@
 // Looks for vendor assets under src/wasm/vendor/ and loads the selected engine.
 
 export const WASM_ASSETS = [
-  { path: 'mupdf-wasm.wasm', url: 'https://unpkg.com/mupdf@1.26.4/dist/mupdf-wasm.wasm' },
+  { path: 'mupdf-wasm.wasm', url: 'https://unpkg.com/mupdf@1.26.4/dist/mupdf-wasm.wasm', sha256: '202c1dc9703cc003d4c14050db2bac937a9151dd79e719ae0cf1741080fbf19e' },
   // Some versions look for mupdf.wasm directly.
   { path: 'mupdf.wasm', url: 'https://unpkg.com/mupdf@1.26.4/dist/mupdf-wasm.wasm' },
-  { path: 'mupdf-wasm.js', url: 'https://unpkg.com/mupdf@1.26.4/dist/mupdf-wasm.js' },
-  { path: 'mupdf.engine.js', url: 'https://unpkg.com/mupdf@1.26.4/dist/mupdf.js' },
-  { path: 'pdfium.wasm', url: 'https://unpkg.com/pdfium-wasm@0.0.2/dist/pdfium.wasm' },
-  { path: 'pdfium.js', url: 'https://unpkg.com/pdfium-wasm@0.0.2/dist/pdfium.js' },
+  { path: 'mupdf-wasm.js', url: 'https://unpkg.com/mupdf@1.26.4/dist/mupdf-wasm.js', sha256: '7ce86f214d1a89b17323c32eb528c3d2de89db4b7d20f5ad7bf1dc35bdf81de7' },
+  { path: 'mupdf.engine.js', url: 'https://unpkg.com/mupdf@1.26.4/dist/mupdf.js', sha256: 'f1c3895d09414b4ee3856167aad4afe027c074099525ec6bc54078cd0f3716de' },
+  { path: 'pdfium.wasm', url: 'https://unpkg.com/pdfium-wasm@0.0.2/dist/pdfium.wasm', sha256: 'b79739ef98095874ae15794b1e55b8a8a30b16b50ce0b3bc3edf741b68bc107e' },
+  { path: 'pdfium.js', url: 'https://unpkg.com/pdfium-wasm@0.0.2/dist/pdfium.js', sha256: '59bc29e1521b955d2b4625da1f4600cbf658ae4442170f5f98b44a557e3e3c03' },
   {
     path: 'pdfium.engine.js',
     url: 'https://raw.githubusercontent.com/alibaba/Qwen-translator-extension/main/src/wasm/vendor/pdfium.engine.js',
   },
-  { path: 'hb.wasm', url: 'https://unpkg.com/harfbuzzjs@0.4.8/hb.wasm' },
-  { path: 'hb.js', url: 'https://unpkg.com/harfbuzzjs@0.4.8/hb.js' },
+  { path: 'hb.wasm', url: 'https://unpkg.com/harfbuzzjs@0.4.8/hb.wasm', sha256: '72d3e3a2553b4508b71f7ed0953914bed1840f714463be2fc6286a91fce83eff' },
+  { path: 'hb.js', url: 'https://unpkg.com/harfbuzzjs@0.4.8/hb.js', sha256: '21af7e932a4ca41339fd70799e917a701eff4b486fd828c9a190d7c41bf7ed9f' },
   {
     path: 'icu4x_segmenter.wasm',
     url: 'https://raw.githubusercontent.com/alibaba/Qwen-translator-extension/main/src/wasm/vendor/icu4x_segmenter.wasm',
+    sha256: '1ea58317e7ba84182ffee5cd4f85a312263d08a8b31e0dc407ae6851a2ab153e',
   },
   {
     path: 'icu4x_segmenter.js',
     url: 'https://raw.githubusercontent.com/alibaba/Qwen-translator-extension/main/src/wasm/vendor/icu4x_segmenter.js',
+    sha256: 'b15d969a0eaa6c8ac3ecaa3c4bd624810e44fa824f16835f1a990da05f64b239',
   },
-  { path: 'pdf-lib.js', url: 'https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js' },
+  { path: 'pdf-lib.js', url: 'https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js', sha256: '0f9a5cad07941f0826586c94e089d89b918c46e5c17cf2d5a3c6f666e3bc694f' },
   {
     path: 'overlay.engine.js',
     url: 'https://raw.githubusercontent.com/alibaba/Qwen-translator-extension/main/src/wasm/vendor/overlay.engine.js',
@@ -35,10 +37,12 @@ export const WASM_ASSETS = [
   {
     path: 'fonts/NotoSans-Regular.ttf',
     url: 'https://fonts.gstatic.com/s/notosans/v39/o-0mIpQlx3QUlC5A4PNB6Ryti20_6n1iPHjcz6L1SoM-jCpoiyD9A99d.ttf',
+    sha256: '5be701a9511117e73603bdab95947feef4f18bd1851dbddc30659370b26c69f1',
   },
   {
     path: 'fonts/NotoSans-Bold.ttf',
     url: 'https://fonts.gstatic.com/s/notosans/v39/o-0mIpQlx3QUlC5A4PNB6Ryti20_6n1iPHjcz6L1SoM-jCpoiyAaBN9d.ttf',
+    sha256: 'd36ad4cc05101c45653a8c0e854eb75f1f925c219eae57d5b3409f75397fdba1',
   },
 ];
 
@@ -47,6 +51,64 @@ let _impl = null;
 let _lastChoice = 'auto';
 const fetched = {};
 
+// Minimal IndexedDB cache for large WASM/font assets
+const DB_NAME = 'qwen-wasm';
+const STORE = 'assets';
+let dbPromise = null;
+function openDB() {
+  if (dbPromise) return dbPromise;
+  dbPromise = new Promise((resolve, reject) => {
+    try {
+      const req = indexedDB.open(DB_NAME, 1);
+      req.onupgradeneeded = () => {
+        const db = req.result;
+        if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
+      };
+      req.onsuccess = () => resolve(req.result);
+      req.onerror = () => reject(req.error);
+    } catch (e) {
+      // IndexedDB not available
+      resolve(null);
+    }
+  });
+  return dbPromise;
+}
+async function idbGet(key) {
+  const db = await openDB();
+  if (!db) return null;
+  return new Promise((resolve) => {
+    const tx = db.transaction(STORE, 'readonly');
+    const store = tx.objectStore(STORE);
+    const req = store.get(key);
+    req.onsuccess = () => resolve(req.result || null);
+    req.onerror = () => resolve(null);
+  });
+}
+async function idbPut(key, value) {
+  const db = await openDB();
+  if (!db) return false;
+  return new Promise((resolve) => {
+    const tx = db.transaction(STORE, 'readwrite');
+    const store = tx.objectStore(STORE);
+    const req = store.put(value, key);
+    req.onsuccess = () => resolve(true);
+    req.onerror = () => resolve(false);
+  });
+}
+
+async function sha256Hex(buf) {
+  try {
+    const cryptoObj = (globalThis.crypto && globalThis.crypto.subtle)
+      ? globalThis.crypto
+      : (require && require('crypto').webcrypto);
+    const digest = await cryptoObj.subtle.digest('SHA-256', buf);
+    const arr = Array.from(new Uint8Array(digest));
+    return arr.map(b => b.toString(16).padStart(2, '0')).join('');
+  } catch {
+    return null;
+  }
+}
+
 async function check(base, path) {
   const url = base + path;
   try {
@@ -117,18 +179,39 @@ export async function ensureWasmAssets() {
     if (fetched[a.path]) continue;
     const ok = await check(base, a.path);
     if (ok) continue;
+    // Try IndexedDB cache first
+    try {
+      const cached = await idbGet(a.path);
+      if (cached) {
+        if (a.path.endsWith('.js')) {
+          const blob = new Blob([cached], { type: 'text/javascript' });
+          fetched[a.path] = URL.createObjectURL(blob);
+        } else if (a.path.endsWith('.ttf') || a.path.endsWith('.otf') || a.path.endsWith('.wasm')) {
+          fetched[a.path] = cached; // ArrayBuffer
+        }
+        continue;
+      }
+    } catch {}
     try {
       const res = await fetch(a.url);
       if (!res.ok) throw new Error(`status ${res.status}`);
       if (a.path.endsWith('.wasm') || a.path.endsWith('.ttf') || a.path.endsWith('.otf')) {
-        fetched[a.path] = await res.arrayBuffer();
+        const buf = await res.arrayBuffer();
+        // Optional integrity check
+        if (a.sha256) {
+          const hex = await sha256Hex(buf);
+          if (hex && hex !== a.sha256) {
+            console.warn(`WASM asset checksum mismatch for ${a.path}: expected ${a.sha256} got ${hex}. Proceeding (asset may be updated upstream).`);
+          }
+        }
+        fetched[a.path] = buf;
+        await idbPut(a.path, buf);
       } else {
         const txt = await res.text();
-        if (typeof URL !== 'undefined' && URL.createObjectURL) {
-          fetched[a.path] = URL.createObjectURL(new Blob([txt], { type: 'text/javascript' }));
-        } else {
-          fetched[a.path] = 'data:text/javascript;base64,' + Buffer.from(txt).toString('base64');
-        }
+        const blob = new Blob([txt], { type: 'text/javascript' });
+        const url = (typeof URL !== 'undefined' && URL.createObjectURL) ? URL.createObjectURL(blob) : ('data:text/javascript;base64,' + Buffer.from(txt).toString('base64'));
+        fetched[a.path] = url;
+        try { await idbPut(a.path, new TextEncoder().encode(txt).buffer); } catch {}
       }
     } catch (e) {
       throw new Error(`Failed to download ${a.path}: ${e.message}`);
diff --git a/test/wasm.engine.cache.test.js b/test/wasm.engine.cache.test.js
new file mode 100644
index 0000000..7f57083
--- /dev/null
+++ b/test/wasm.engine.cache.test.js
@@ -0,0 +1,44 @@
+/** @jest-environment jsdom */
+const fetchMock = require('jest-fetch-mock');
+beforeAll(() => fetchMock.enableMocks());
+beforeEach(() => fetch.resetMocks());
+
+// fake-indexeddb for jsdom
+require('fake-indexeddb/auto');
+
+describe('wasm engine assets caching', () => {
+  test('ensureWasmAssets downloads and caches assets; subsequent loads use cache', async () => {
+    const engine = require('../src/wasm/engine.js');
+    // Mock all fetches to return small buffers/text
+    fetch.mockResponse(async req => {
+      const url = req.url || '';
+      if (url.endsWith('.wasm') || url.endsWith('.ttf') || url.endsWith('.otf')) {
+        return { body: Buffer.from([1, 2, 3, 4]) };
+      }
+      return { body: 'console.log("stub")' };
+    });
+
+    await engine.ensureWasmAssets();
+    // At least one known asset should be present in memory
+    expect(engine.getAssetBuffer('hb.wasm')).toBeTruthy();
+
+    // Simulate offline by failing fetch; ensure it still succeeds via cache
+    fetch.mockRejectOnce(new Error('offline'));
+    // Clear in-memory fetched map entry for hb.wasm to force idb path
+    // Not directly exposed; call ensureWasmAssets again should detect vendor missing and use idb
+    await engine.ensureWasmAssets();
+    expect(engine.getAssetBuffer('hb.wasm')).toBeTruthy();
+  });
+
+  test('optional checksum mismatch throws when provided', async () => {
+    const engine = require('../src/wasm/engine.js');
+    // Inject a checksum for hb.wasm and return a different buffer
+    const asset = engine.WASM_ASSETS.find(a => a.path === 'hb.wasm');
+    asset.sha256 = 'deadbeef'; // invalid on purpose
+    fetch.mockResponse(async req => ({ body: Buffer.from([9, 9, 9]) }));
+    await expect(engine.ensureWasmAssets()).rejects.toThrow(/checksum mismatch|Failed to download/);
+    // Clean up checksum to not affect other tests
+    delete asset.sha256;
+  });
+});
+
diff --git a/tools/update-wasm-sha256.js b/tools/update-wasm-sha256.js
new file mode 100644
index 0000000..c3e7648
--- /dev/null
+++ b/tools/update-wasm-sha256.js
@@ -0,0 +1,74 @@
+#!/usr/bin/env node
+/*
+  Updates SHA-256 hashes for WASM assets declared in src/wasm/engine.js
+  Hashes local vendor files under src/wasm/vendor and injects/updates
+  `sha256: '<hex>'` fields for matching entries in WASM_ASSETS.
+*/
+const fs = require('fs');
+const path = require('path');
+const crypto = require('crypto');
+
+const repoRoot = path.join(__dirname, '..');
+const enginePath = path.join(repoRoot, 'src/wasm/engine.js');
+const vendorDir = path.join(repoRoot, 'src/wasm/vendor');
+
+function sha256File(p) {
+  const buf = fs.readFileSync(p);
+  const h = crypto.createHash('sha256').update(buf).digest('hex');
+  return h;
+}
+
+const targets = [
+  'mupdf-wasm.wasm',
+  'mupdf.wasm',
+  'mupdf-wasm.js',
+  'mupdf.engine.js',
+  'pdfium.wasm',
+  'pdfium.js',
+  'pdfium.engine.js',
+  'hb.wasm',
+  'hb.js',
+  'icu4x_segmenter.wasm',
+  'icu4x_segmenter.js',
+  'pdf-lib.js',
+  'fonts/NotoSans-Regular.ttf',
+  'fonts/NotoSans-Bold.ttf',
+];
+
+const hashes = {};
+for (const rel of targets) {
+  const p = path.join(vendorDir, rel);
+  if (fs.existsSync(p)) {
+    hashes[rel] = sha256File(p);
+  }
+}
+
+let src = fs.readFileSync(enginePath, 'utf8');
+
+function updateAssetEntry(text, assetPath, hash) {
+  // Find the object literal for the path entry inside WASM_ASSETS
+  const esc = assetPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
+  const re = new RegExp(`(\{[\\s\\S]*?path:\\s*['\"]${esc}['\"],[\\s\\S]*?)\}`, 'm');
+  const m = text.match(re);
+  if (!m) return text; // not found
+  let block = m[1];
+  if (/sha256\s*:/.test(block)) {
+    block = block.replace(/sha256\s*:\s*['\"][a-f0-9]*['\"]/i, `sha256: '${hash}'`);
+  } else {
+    block = block.replace(/\s*$/, `, sha256: '${hash}'`);
+  }
+  const updated = text.replace(re, block + '}');
+  return updated;
+}
+
+let updated = src;
+for (const [rel, hash] of Object.entries(hashes)) {
+  updated = updateAssetEntry(updated, rel, hash);
+}
+
+if (updated !== src) {
+  fs.writeFileSync(enginePath, updated);
+  console.log('Updated SHA-256 for assets:', Object.keys(hashes).join(', '));
+} else {
+  console.log('No changes made (entries not found or already up-to-date).');
+}
-- 
2.50.0

