From cb14cba2d7077a0fb152257d953e08ffbd40c21a Mon Sep 17 00:00:00 2001
From: MikkoParkkola <78788115+MikkoParkkola@users.noreply.github.com>
Date: Thu, 31 Jul 2025 03:38:00 +0200
Subject: [PATCH 24/46] Add non-streaming option

---
 README.md         |  6 +++---
 cli/translate.js  | 26 +++++++++++++++++---------
 src/background.js | 31 +++++--------------------------
 src/translator.js | 23 ++++++++++++-----------
 4 files changed, 37 insertions(+), 49 deletions(-)

diff --git a/README.md b/README.md
index 3ab2649..506a3d0 100644
--- a/README.md
+++ b/README.md
@@ -22,7 +22,7 @@ Use the popup to configure:
 - Translation model name (defaults to `qwen-mt-turbo`)
 - Source and target languages
 - Automatic translation toggle
-Click **Test Settings** in the popup to verify the configuration. The extension uses the streaming API for responsive translations.
+Click **Test Settings** in the popup to verify the configuration. The extension uses the non-streaming API for simpler throttling.
 
 ## Usage
 Click the extension icon and choose **Translate Page**. If automatic translation is enabled the page will be translated on load. Translations apply to dynamically added content.
@@ -43,11 +43,11 @@ npm test
 ```
 
 ## Command Line Utility
-A simple translator CLI is included in `cli/translate.js`. It streams translations as you type.
+A simple translator CLI is included in `cli/translate.js`. It streams translations as you type by default. Use `--no-stream` for request/response mode.
 
 ### Usage
 ```sh
-node cli/translate.js -k <API_KEY> [-e endpoint] [-m model] [--requests N] [--tokens M] [-d] -s <source_lang> -t <target_lang>
+node cli/translate.js -k <API_KEY> [-e endpoint] [-m model] [--requests N] [--tokens M] [-d] [--no-stream] -s <source_lang> -t <target_lang>
 ```
 If no endpoint is specified the tool defaults to `https://dashscope-intl.aliyuncs.com/api/v1`.
 Use `-d` to print detailed request and response logs.
diff --git a/cli/translate.js b/cli/translate.js
index 8bf743f..756709a 100755
--- a/cli/translate.js
+++ b/cli/translate.js
@@ -2,7 +2,7 @@
 
 const readline = require('readline');
 const { configure } = require('../src/throttle');
-const { qwenTranslateStream } = require('../src/translator');
+const { qwenTranslateStream, qwenTranslate } = require('../src/translator');
 
 function parseArgs() {
   const args = process.argv.slice(2);
@@ -17,6 +17,7 @@ function parseArgs() {
     else if (a === '--requests') opts.requestLimit = parseInt(args[++i], 10);
     else if (a === '--tokens') opts.tokenLimit = parseInt(args[++i], 10);
     else if (a === '-d' || a === '--debug') opts.debug = true;
+    else if (a === '--no-stream') opts.stream = false;
     else if (a === '-h' || a === '--help') opts.help = true;
   }
   return opts;
@@ -27,8 +28,10 @@ async function main() {
   const DEFAULT_MODEL = 'qwen-mt-turbo';
   const opts = parseArgs();
 
+  if (opts.stream !== false) opts.stream = true;
+
   if (opts.help || !opts.apiKey || !opts.source || !opts.target) {
-    console.log('Usage: node translate.js -k <apiKey> [-e endpoint] [-m model] [-\-requests N] [-\-tokens M] [-d] -s <source> -t <target>');
+    console.log('Usage: node translate.js -k <apiKey> [-e endpoint] [-m model] [--requests N] [--tokens M] [-d] [--no-stream] -s <source> -t <target>');
     process.exit(opts.help ? 0 : 1);
   }
 
@@ -36,12 +39,12 @@ async function main() {
   opts.model = opts.model || DEFAULT_MODEL;
 
   if (opts.debug) {
-    console.log('QTDEBUG: starting CLI with options', {
+    console.error('\x1b[36mQTDEBUG: starting CLI with options', {
       endpoint: opts.endpoint,
       model: opts.model,
       source: opts.source,
       target: opts.target,
-    });
+    }, '\x1b[0m');
   }
 
   configure({
@@ -56,11 +59,16 @@ async function main() {
     line = line.trim();
     if (!line) { rl.prompt(); return; }
     try {
-      await qwenTranslateStream({ ...opts, text: line, debug: opts.debug }, chunk => {
-        if (opts.debug) console.log('QTDEBUG: chunk received', chunk);
-        process.stdout.write(chunk);
-      });
-      process.stdout.write('\n');
+      if (opts.stream) {
+        await qwenTranslateStream({ ...opts, text: line, debug: opts.debug, stream: true }, chunk => {
+          if (opts.debug) console.error('\x1b[36mQTDEBUG: chunk received', chunk, '\x1b[0m');
+          process.stdout.write(chunk);
+        });
+        process.stdout.write('\n');
+      } else {
+        const res = await qwenTranslate({ ...opts, text: line, debug: opts.debug, stream: false });
+        process.stdout.write(res.text + '\n');
+      }
     } catch (err) {
       console.error(err.stack || err.toString());
       process.exit(1);
diff --git a/src/background.js b/src/background.js
index 766b223..396580e 100644
--- a/src/background.js
+++ b/src/background.js
@@ -26,7 +26,6 @@ async function handleTranslate(opts) {
         headers: {
           'Content-Type': 'application/json',
           Authorization: apiKey,
-          'X-DashScope-SSE': 'enable',
         },
         body: JSON.stringify({
           model,
@@ -57,32 +56,12 @@ async function handleTranslate(opts) {
       return { error: `HTTP ${resp.status}: ${err.message}` };
     }
 
-    const reader = resp.body.getReader();
-    const decoder = new TextDecoder();
-    let buffer = '';
-    let result = '';
-    while (true) {
-      const { value, done } = await reader.read();
-      if (done) break;
-      buffer += decoder.decode(value, { stream: true });
-      const lines = buffer.split('\n');
-      buffer = lines.pop();
-      for (const line of lines) {
-        const trimmed = line.trim();
-        if (!trimmed.startsWith('data:')) continue;
-        const data = trimmed.slice(5).trim();
-        if (data === '[DONE]') { reader.cancel(); break; }
-        try {
-          const obj = JSON.parse(data);
-          const chunk =
-            obj.output?.text ||
-            obj.output?.choices?.[0]?.message?.content || '';
-          result += chunk;
-        } catch {}
-      }
-    }
+    const data = await resp.json();
+    const text =
+      data.output?.text ||
+      data.output?.choices?.[0]?.message?.content || '';
     if (debug) console.log('QTDEBUG: background translation completed');
-    return { text: result };
+    return { text };
   } catch (err) {
     console.error('QTERROR: background translation error', err);
     return { error: err.message };
diff --git a/src/translator.js b/src/translator.js
index 929e789..d04ed81 100644
--- a/src/translator.js
+++ b/src/translator.js
@@ -25,7 +25,7 @@ function withSlash(url) {
   return url.endsWith('/') ? url : `${url}/`;
 }
 
-async function doFetch({ endpoint, apiKey, model, text, source, target, signal, debug, onData }) {
+async function doFetch({ endpoint, apiKey, model, text, source, target, signal, debug, onData, stream = true }) {
   const url = `${withSlash(endpoint)}services/aigc/text-generation/generation`;
   if (debug) {
     console.log('QTDEBUG: sending translation request to', url);
@@ -41,13 +41,14 @@ async function doFetch({ endpoint, apiKey, model, text, source, target, signal,
   if (debug) console.log('QTDEBUG: request body', body);
   let resp;
   try {
+    const headers = {
+      'Content-Type': 'application/json',
+      Authorization: apiKey,
+    };
+    if (stream) headers['X-DashScope-SSE'] = 'enable';
     resp = await fetchFn(url, {
       method: 'POST',
-      headers: {
-        'Content-Type': 'application/json',
-        Authorization: apiKey,
-        'X-DashScope-SSE': 'enable',
-      },
+      headers,
       body: JSON.stringify(body),
       signal,
     });
@@ -68,7 +69,7 @@ async function doFetch({ endpoint, apiKey, model, text, source, target, signal,
     if (resp.status >= 500) error.retryable = true;
     throw error;
   }
-  if (!resp.body || typeof resp.body.getReader !== 'function') {
+  if (!stream || !resp.body || typeof resp.body.getReader !== 'function') {
     if (debug) console.log('QTDEBUG: received non-streaming response');
     const data = await resp.json();
     const text =
@@ -115,7 +116,7 @@ async function doFetch({ endpoint, apiKey, model, text, source, target, signal,
   return { text: result };
 }
 
-async function qwenTranslate({ endpoint, apiKey, model, text, source, target, signal, debug = false }) {
+async function qwenTranslate({ endpoint, apiKey, model, text, source, target, signal, debug = false, stream = false }) {
   if (debug) {
     console.log('QTDEBUG: qwenTranslate called with', {
       endpoint,
@@ -147,7 +148,7 @@ async function qwenTranslate({ endpoint, apiKey, model, text, source, target, si
 
   try {
     const data = await runWithRetry(
-      () => doFetch({ endpoint, apiKey, model, text, source, target, signal, debug }),
+      () => doFetch({ endpoint, apiKey, model, text, source, target, signal, debug, stream }),
       approxTokens(text),
       3,
       debug
@@ -164,7 +165,7 @@ async function qwenTranslate({ endpoint, apiKey, model, text, source, target, si
   }
 }
 
-async function qwenTranslateStream({ endpoint, apiKey, model, text, source, target, signal, debug = false }, onData) {
+async function qwenTranslateStream({ endpoint, apiKey, model, text, source, target, signal, debug = false, stream = true }, onData) {
   if (debug) {
     console.log('QTDEBUG: qwenTranslateStream called with', {
       endpoint,
@@ -183,7 +184,7 @@ async function qwenTranslateStream({ endpoint, apiKey, model, text, source, targ
   }
   try {
     const data = await runWithRetry(
-      () => doFetch({ endpoint, apiKey, model, text, source, target, signal, debug, onData }),
+      () => doFetch({ endpoint, apiKey, model, text, source, target, signal, debug, onData, stream }),
       approxTokens(text),
       3,
       debug
-- 
2.50.0

