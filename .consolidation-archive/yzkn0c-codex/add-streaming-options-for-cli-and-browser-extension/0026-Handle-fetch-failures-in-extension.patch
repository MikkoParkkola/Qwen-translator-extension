From 3ac27adbb7eb180ddcedbf4dd7ef5f88c7a3ed11 Mon Sep 17 00:00:00 2001
From: MikkoParkkola <78788115+MikkoParkkola@users.noreply.github.com>
Date: Thu, 31 Jul 2025 04:03:16 +0200
Subject: [PATCH 26/30] Handle fetch failures in extension

---
 README.md         |  7 ++--
 cli/translate.js  | 26 +++++++++-----
 src/background.js | 90 +++++++++++-----------------------------------
 src/translator.js | 92 ++++++++++++++++++++++++++++++++++++++---------
 4 files changed, 117 insertions(+), 98 deletions(-)

diff --git a/README.md b/README.md
index 3ab2649..3b71328 100644
--- a/README.md
+++ b/README.md
@@ -22,7 +22,7 @@ Use the popup to configure:
 - Translation model name (defaults to `qwen-mt-turbo`)
 - Source and target languages
 - Automatic translation toggle
-Click **Test Settings** in the popup to verify the configuration. The extension uses the streaming API for responsive translations.
+Click **Test Settings** in the popup to verify the configuration. The extension uses the same non-streaming API implementation as the CLI and aborts the request if no response is received within 20 seconds.
 
 ## Usage
 Click the extension icon and choose **Translate Page**. If automatic translation is enabled the page will be translated on load. Translations apply to dynamically added content.
@@ -34,6 +34,7 @@ You can adjust the limits under **Requests per minute** and **Tokens per minute*
 
 ### Troubleshooting
 Both model refreshes and translation requests write trace logs to the browser console. Copy any on-page error and check the console for a matching entry to diagnose problems.
+If the **Test Settings** button reports a timeout, the network request may be blocked by Content Security Policy or CORS restrictions. The extension automatically falls back to `XMLHttpRequest` when `fetch` fails, but some environments may still prevent the call entirely.
 
 ## Development
 Run the unit tests with:
@@ -43,11 +44,11 @@ npm test
 ```
 
 ## Command Line Utility
-A simple translator CLI is included in `cli/translate.js`. It streams translations as you type.
+A simple translator CLI is included in `cli/translate.js`. It streams translations as you type by default. Use `--no-stream` for request/response mode.
 
 ### Usage
 ```sh
-node cli/translate.js -k <API_KEY> [-e endpoint] [-m model] [--requests N] [--tokens M] [-d] -s <source_lang> -t <target_lang>
+node cli/translate.js -k <API_KEY> [-e endpoint] [-m model] [--requests N] [--tokens M] [-d] [--no-stream] -s <source_lang> -t <target_lang>
 ```
 If no endpoint is specified the tool defaults to `https://dashscope-intl.aliyuncs.com/api/v1`.
 Use `-d` to print detailed request and response logs.
diff --git a/cli/translate.js b/cli/translate.js
index 8bf743f..756709a 100755
--- a/cli/translate.js
+++ b/cli/translate.js
@@ -2,7 +2,7 @@
 
 const readline = require('readline');
 const { configure } = require('../src/throttle');
-const { qwenTranslateStream } = require('../src/translator');
+const { qwenTranslateStream, qwenTranslate } = require('../src/translator');
 
 function parseArgs() {
   const args = process.argv.slice(2);
@@ -17,6 +17,7 @@ function parseArgs() {
     else if (a === '--requests') opts.requestLimit = parseInt(args[++i], 10);
     else if (a === '--tokens') opts.tokenLimit = parseInt(args[++i], 10);
     else if (a === '-d' || a === '--debug') opts.debug = true;
+    else if (a === '--no-stream') opts.stream = false;
     else if (a === '-h' || a === '--help') opts.help = true;
   }
   return opts;
@@ -27,8 +28,10 @@ async function main() {
   const DEFAULT_MODEL = 'qwen-mt-turbo';
   const opts = parseArgs();
 
+  if (opts.stream !== false) opts.stream = true;
+
   if (opts.help || !opts.apiKey || !opts.source || !opts.target) {
-    console.log('Usage: node translate.js -k <apiKey> [-e endpoint] [-m model] [-\-requests N] [-\-tokens M] [-d] -s <source> -t <target>');
+    console.log('Usage: node translate.js -k <apiKey> [-e endpoint] [-m model] [--requests N] [--tokens M] [-d] [--no-stream] -s <source> -t <target>');
     process.exit(opts.help ? 0 : 1);
   }
 
@@ -36,12 +39,12 @@ async function main() {
   opts.model = opts.model || DEFAULT_MODEL;
 
   if (opts.debug) {
-    console.log('QTDEBUG: starting CLI with options', {
+    console.error('\x1b[36mQTDEBUG: starting CLI with options', {
       endpoint: opts.endpoint,
       model: opts.model,
       source: opts.source,
       target: opts.target,
-    });
+    }, '\x1b[0m');
   }
 
   configure({
@@ -56,11 +59,16 @@ async function main() {
     line = line.trim();
     if (!line) { rl.prompt(); return; }
     try {
-      await qwenTranslateStream({ ...opts, text: line, debug: opts.debug }, chunk => {
-        if (opts.debug) console.log('QTDEBUG: chunk received', chunk);
-        process.stdout.write(chunk);
-      });
-      process.stdout.write('\n');
+      if (opts.stream) {
+        await qwenTranslateStream({ ...opts, text: line, debug: opts.debug, stream: true }, chunk => {
+          if (opts.debug) console.error('\x1b[36mQTDEBUG: chunk received', chunk, '\x1b[0m');
+          process.stdout.write(chunk);
+        });
+        process.stdout.write('\n');
+      } else {
+        const res = await qwenTranslate({ ...opts, text: line, debug: opts.debug, stream: false });
+        process.stdout.write(res.text + '\n');
+      }
     } catch (err) {
       console.error(err.stack || err.toString());
       process.exit(1);
diff --git a/src/background.js b/src/background.js
index 766b223..137db07 100644
--- a/src/background.js
+++ b/src/background.js
@@ -1,5 +1,6 @@
-importScripts('throttle.js');
-const { runWithRetry, approxTokens, configure } = self.qwenThrottle;
+importScripts('throttle.js', 'translator.js');
+const { configure } = self.qwenThrottle;
+const { qwenTranslate } = self;
 
 chrome.runtime.onInstalled.addListener(() => {
   console.log('Qwen Translator installed');
@@ -8,84 +9,35 @@ chrome.runtime.onInstalled.addListener(() => {
 async function handleTranslate(opts) {
   const { endpoint, apiKey, model, text, source, target, debug } = opts;
   const ep = endpoint.endsWith('/') ? endpoint : `${endpoint}/`;
-  const url = `${ep}services/aigc/text-generation/generation`;
-  if (debug) console.log('QTDEBUG: background translating via', url);
+  if (debug) console.log('QTDEBUG: background translating via', ep);
 
   const cfg = await new Promise(resolve =>
     chrome.storage.sync.get({ requestLimit: 60, tokenLimit: 100000 }, resolve)
   );
   configure({ requestLimit: cfg.requestLimit, tokenLimit: cfg.tokenLimit, windowMs: 60000 });
 
-  try {
-    const attempt = async () => {
-      const controller = new AbortController();
-      const t = setTimeout(() => controller.abort(), 10000);
-      try {
-        const r = await fetch(url, {
-        method: 'POST',
-        headers: {
-          'Content-Type': 'application/json',
-          Authorization: apiKey,
-          'X-DashScope-SSE': 'enable',
-        },
-        body: JSON.stringify({
-          model,
-          input: { messages: [{ role: 'user', content: text }] },
-          parameters: { translation_options: { source_lang: source, target_lang: target } },
-        }),
-        signal: controller.signal,
-      });
-        if (!r.ok && r.status >= 500) {
-          const err = new Error(`HTTP ${r.status}`);
-          err.retryable = true;
-          throw err;
-        }
-        return r;
-      } catch (e) {
-        e.retryable = true;
-        throw e;
-      } finally {
-        clearTimeout(t);
-      }
-    };
-
-    const resp = await runWithRetry(attempt, approxTokens(text), 3, debug);
+  const controller = new AbortController();
+  const timeout = setTimeout(() => controller.abort(), 20000);
 
-    if (!resp.ok) {
-      const err = await resp.json().catch(() => ({ message: resp.statusText }));
-      if (debug) console.log('QTDEBUG: background HTTP error', err);
-      return { error: `HTTP ${resp.status}: ${err.message}` };
-    }
-
-    const reader = resp.body.getReader();
-    const decoder = new TextDecoder();
-    let buffer = '';
-    let result = '';
-    while (true) {
-      const { value, done } = await reader.read();
-      if (done) break;
-      buffer += decoder.decode(value, { stream: true });
-      const lines = buffer.split('\n');
-      buffer = lines.pop();
-      for (const line of lines) {
-        const trimmed = line.trim();
-        if (!trimmed.startsWith('data:')) continue;
-        const data = trimmed.slice(5).trim();
-        if (data === '[DONE]') { reader.cancel(); break; }
-        try {
-          const obj = JSON.parse(data);
-          const chunk =
-            obj.output?.text ||
-            obj.output?.choices?.[0]?.message?.content || '';
-          result += chunk;
-        } catch {}
-      }
-    }
+  try {
+    const result = await qwenTranslate({
+      endpoint: ep,
+      apiKey,
+      model,
+      text,
+      source,
+      target,
+      debug,
+      signal: controller.signal,
+      stream: false,
+    });
     if (debug) console.log('QTDEBUG: background translation completed');
-    return { text: result };
+    return result;
   } catch (err) {
     console.error('QTERROR: background translation error', err);
     return { error: err.message };
+  } finally {
+    clearTimeout(timeout);
   }
 }
 
diff --git a/src/translator.js b/src/translator.js
index 929e789..dba63d6 100644
--- a/src/translator.js
+++ b/src/translator.js
@@ -4,9 +4,13 @@ var runWithRetry;
 var approxTokens;
 
 if (typeof window === 'undefined') {
-  // Node 18+ provides a global fetch implementation
-  fetchFn = typeof fetch !== 'undefined' ? fetch : require('cross-fetch');
-  ({ runWithRateLimit, runWithRetry, approxTokens } = require('./throttle'));
+  if (typeof self !== 'undefined' && self.qwenThrottle) {
+    ({ runWithRateLimit, runWithRetry, approxTokens } = self.qwenThrottle);
+  } else {
+    // Node 18+ provides a global fetch implementation
+    fetchFn = typeof fetch !== 'undefined' ? fetch : require('cross-fetch');
+    ({ runWithRateLimit, runWithRetry, approxTokens } = require('./throttle'));
+  }
 } else {
   if (window.qwenThrottle) {
     ({ runWithRateLimit, runWithRetry, approxTokens } = window.qwenThrottle);
@@ -21,11 +25,42 @@ if (typeof window === 'undefined') {
 
 const cache = new Map();
 
+function fetchViaXHR(url, { method = 'GET', headers = {}, body, signal }, debug) {
+  return new Promise((resolve, reject) => {
+    const xhr = new XMLHttpRequest();
+    xhr.open(method, url, true);
+    Object.entries(headers).forEach(([k, v]) => xhr.setRequestHeader(k, v));
+    xhr.responseType = 'text';
+    if (signal) {
+      if (signal.aborted) return reject(new DOMException('Aborted', 'AbortError'));
+      const onAbort = () => {
+        xhr.abort();
+        reject(new DOMException('Aborted', 'AbortError'));
+      };
+      signal.addEventListener('abort', onAbort, { once: true });
+      xhr.addEventListener('loadend', () => signal.removeEventListener('abort', onAbort));
+    }
+    xhr.onload = () => {
+      const resp = {
+        ok: xhr.status >= 200 && xhr.status < 300,
+        status: xhr.status,
+        json: async () => JSON.parse(xhr.responseText || 'null'),
+        text: async () => xhr.responseText,
+        headers: new Headers(),
+      };
+      if (debug) console.log('QTDEBUG: XHR status', xhr.status);
+      resolve(resp);
+    };
+    xhr.onerror = () => reject(new Error('Network error'));
+    xhr.send(body);
+  });
+}
+
 function withSlash(url) {
   return url.endsWith('/') ? url : `${url}/`;
 }
 
-async function doFetch({ endpoint, apiKey, model, text, source, target, signal, debug, onData }) {
+async function doFetch({ endpoint, apiKey, model, text, source, target, signal, debug, onData, stream = true }) {
   const url = `${withSlash(endpoint)}services/aigc/text-generation/generation`;
   if (debug) {
     console.log('QTDEBUG: sending translation request to', url);
@@ -41,13 +76,14 @@ async function doFetch({ endpoint, apiKey, model, text, source, target, signal,
   if (debug) console.log('QTDEBUG: request body', body);
   let resp;
   try {
+    const headers = {
+      'Content-Type': 'application/json',
+      Authorization: apiKey,
+    };
+    if (stream) headers['X-DashScope-SSE'] = 'enable';
     resp = await fetchFn(url, {
       method: 'POST',
-      headers: {
-        'Content-Type': 'application/json',
-        Authorization: apiKey,
-        'X-DashScope-SSE': 'enable',
-      },
+      headers,
       body: JSON.stringify(body),
       signal,
     });
@@ -56,8 +92,25 @@ async function doFetch({ endpoint, apiKey, model, text, source, target, signal,
       console.log('QTDEBUG: response headers', Object.fromEntries(resp.headers.entries()));
     }
   } catch (e) {
-    e.retryable = true;
-    throw e;
+    if (!stream && typeof XMLHttpRequest !== 'undefined') {
+      if (debug) console.log('QTDEBUG: fetch failed, falling back to XHR');
+      resp = await fetchViaXHR(
+        url,
+        {
+          method: 'POST',
+          headers: {
+            'Content-Type': 'application/json',
+            Authorization: apiKey,
+          },
+          body: JSON.stringify(body),
+          signal,
+        },
+        debug
+      );
+    } else {
+      e.retryable = true;
+      throw e;
+    }
   }
   if (!resp.ok) {
     const err = await resp
@@ -68,7 +121,7 @@ async function doFetch({ endpoint, apiKey, model, text, source, target, signal,
     if (resp.status >= 500) error.retryable = true;
     throw error;
   }
-  if (!resp.body || typeof resp.body.getReader !== 'function') {
+  if (!stream || !resp.body || typeof resp.body.getReader !== 'function') {
     if (debug) console.log('QTDEBUG: received non-streaming response');
     const data = await resp.json();
     const text =
@@ -115,7 +168,7 @@ async function doFetch({ endpoint, apiKey, model, text, source, target, signal,
   return { text: result };
 }
 
-async function qwenTranslate({ endpoint, apiKey, model, text, source, target, signal, debug = false }) {
+async function qwenTranslate({ endpoint, apiKey, model, text, source, target, signal, debug = false, stream = false }) {
   if (debug) {
     console.log('QTDEBUG: qwenTranslate called with', {
       endpoint,
@@ -131,7 +184,7 @@ async function qwenTranslate({ endpoint, apiKey, model, text, source, target, si
     return cache.get(cacheKey);
   }
 
-  if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
+  if (typeof window !== 'undefined' && typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
     const ep = withSlash(endpoint);
     if (debug) console.log('QTDEBUG: requesting translation via background script');
     const result = await chrome.runtime
@@ -147,7 +200,7 @@ async function qwenTranslate({ endpoint, apiKey, model, text, source, target, si
 
   try {
     const data = await runWithRetry(
-      () => doFetch({ endpoint, apiKey, model, text, source, target, signal, debug }),
+      () => doFetch({ endpoint, apiKey, model, text, source, target, signal, debug, stream }),
       approxTokens(text),
       3,
       debug
@@ -164,7 +217,7 @@ async function qwenTranslate({ endpoint, apiKey, model, text, source, target, si
   }
 }
 
-async function qwenTranslateStream({ endpoint, apiKey, model, text, source, target, signal, debug = false }, onData) {
+async function qwenTranslateStream({ endpoint, apiKey, model, text, source, target, signal, debug = false, stream = true }, onData) {
   if (debug) {
     console.log('QTDEBUG: qwenTranslateStream called with', {
       endpoint,
@@ -183,7 +236,7 @@ async function qwenTranslateStream({ endpoint, apiKey, model, text, source, targ
   }
   try {
     const data = await runWithRetry(
-      () => doFetch({ endpoint, apiKey, model, text, source, target, signal, debug, onData }),
+      () => doFetch({ endpoint, apiKey, model, text, source, target, signal, debug, onData, stream }),
       approxTokens(text),
       3,
       debug
@@ -207,6 +260,11 @@ if (typeof window !== 'undefined') {
   window.qwenTranslateStream = qwenTranslateStream;
   window.qwenClearCache = qwenClearCache;
 }
+if (typeof self !== 'undefined' && typeof window === 'undefined') {
+  self.qwenTranslate = qwenTranslate;
+  self.qwenTranslateStream = qwenTranslateStream;
+  self.qwenClearCache = qwenClearCache;
+}
 if (typeof module !== 'undefined') {
   module.exports = { qwenTranslate, qwenTranslateStream, qwenClearCache };
 }
-- 
2.50.0

